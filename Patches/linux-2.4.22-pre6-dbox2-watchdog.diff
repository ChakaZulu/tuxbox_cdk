diff -Naur linux-2.4.22-pre6/arch/ppc/kernel/m8xx_setup.c linux-2.4.22-pre6-dbox2/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.22-pre6/arch/ppc/kernel/m8xx_setup.c	2003-06-13 16:51:31.000000000 +0200
+++ linux-2.4.22-pre6-dbox2/arch/ppc/kernel/m8xx_setup.c	2003-07-15 09:16:34.000000000 +0200
@@ -117,6 +117,22 @@
 	printk ("timebase_interrupt()\n");
 }
 
+#ifdef CONFIG_DBOX2
+void m8xx_reset_watchdog(void)
+{
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0x556c; /* write magic1 */
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0xaa39; /* write magic2 */
+}
+
+void pit_interrupt(int irq, void * dev, struct pt_regs * regs)
+{
+	m8xx_reset_watchdog();
+
+	/* clear irq */
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr |= PISCR_PS;
+}
+#endif
+
 /* The decrementer counts at the system (internal) clock frequency divided by
  * sixteen, or external oscillator divided by four.  We force the processor
  * to use system clock divided by sixteen.
@@ -125,6 +141,10 @@
 {
 	bd_t	*binfo = (bd_t *)__res;
 	int freq, fp, divisor;
+#ifdef CONFIG_DBOX2
+	unsigned long sypcr;
+	unsigned short pitc, swtc, swp;
+#endif	
 
 	/* Unlock the SCCR. */
 	((volatile immap_t *)IMAP_ADDR)->im_clkrstk.cark_sccrk = ~KAPWR_KEY;
@@ -184,6 +204,42 @@
 	if (request_irq(DEC_INTERRUPT, timebase_interrupt, 0, "tbint",
 				NULL) != 0)
 		panic("Could not allocate timer IRQ!");
+
+#ifdef CONFIG_DBOX2
+	sypcr = ((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_sypcr;
+
+	if ((sypcr >> 2) & 0x1) {
+	    m8xx_reset_watchdog();
+
+	    if (sypcr >> 16)
+		swtc = sypcr >> 16;
+	    else
+		swtc = 0xFFFF;
+
+	    if (sypcr & 0x1)
+		swp = 2048;
+	    else
+		swp = 1;
+
+#define PITRTCLK 8192
+
+	    /* Fire trigger if half of the wdt ticked down */
+	    if ((swp * swtc) > (UINT_MAX / PITRTCLK))
+		pitc = swtc * swp / binfo->bi_intfreq * PITRTCLK / 2;
+	    else
+		pitc = PITRTCLK * swtc * swp / binfo->bi_intfreq / 2;
+
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_pitc = pitc << 16;
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr = (mk_int_int_mask(PIT_INTERRUPT) << 8) | PISCR_PIE | PISCR_PTE;
+
+	    if (request_8xxirq(PIT_INTERRUPT, pit_interrupt, 0, "pit", NULL) != 0)
+		    panic("mpc8xx-wdt: could not allocate pit irq!");
+
+	    printk(KERN_INFO "mpc8xx-wdt: active wdt found (SWTC: 0x%04X, SWP: 0x%01X)\n", sypcr >> 16, sypcr & 0x1);
+	    printk(KERN_INFO "mpc8xx-wdt: keep-alive trigger activated (PITC: 0x%04X)\n", pitc);
+	}
+#endif
+
 }
 
 /* The RTC on the MPC8xx is an internal register.
diff -Naur linux-2.4.22-pre6/arch/ppc/kernel/time.c linux-2.4.22-pre6-dbox2/arch/ppc/kernel/time.c
--- linux-2.4.22-pre6/arch/ppc/kernel/time.c	2003-06-13 16:51:31.000000000 +0200
+++ linux-2.4.22-pre6-dbox2/arch/ppc/kernel/time.c	2003-07-15 09:16:34.000000000 +0200
@@ -71,6 +71,10 @@
 
 extern int do_sys_settimeofday(struct timeval *tv, struct timezone *tz);
 
+#ifdef CONFIG_DBOX2
+extern void m8xx_reset_watchdog(void);
+#endif
+
 /* keep track of when we need to update the rtc */
 time_t last_rtc_update;
 extern rwlock_t xtime_lock;
@@ -320,6 +324,9 @@
 		sec = ppc_md.get_rtc_time();
 		elapsed = 0;
 		do {
+#ifdef CONFIG_DBOX2
+			m8xx_reset_watchdog();
+#endif
 			old_stamp = stamp; 
 			old_sec = sec;
 			stamp = get_native_tbl();
