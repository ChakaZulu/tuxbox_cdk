diff -Naur archive/linux-2.6.17/Makefile linux-2.6.17/Makefile
--- archive/linux-2.6.17/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/Makefile	2007-08-30 09:04:04.000000000 +0200
@@ -172,8 +172,9 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= ppc
+#CROSS_COMPILE	?= powerpc-405-linux-gnu-
+CROSS_COMPILE	?= powerpc-tuxbox-linux-gnu-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
diff -Naur archive/linux-2.6.17/arch/ppc/configs/mutant200s_defconfig linux-2.6.17/arch/ppc/configs/mutant200s_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/mutant200s_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/mutant200s_defconfig	2008-03-16 12:45:02.000000000 +0100
@@ -0,0 +1,1006 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17
+# Sat Aug  4 09:32:31 2007
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-mutant200s"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+# CONFIG_WANT_EARLY_SERIAL is not set
+
+#
+# IBM 4xx options
+#
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_RELOOK100S=y
+# CONFIG_RELOOK200S is not set
+# CONFIG_RELOOK210 is not set
+# CONFIG_RELOOK300 is not set
+# CONFIG_RELOOK400 is not set
+# CONFIG_RELOOK400C is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_XILINX_ML403 is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_PPC_GEN550=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+CONFIG_SECCOMP=y
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK100S=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+# CONFIG_WINDFARM is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_DM9000=y
+# CONFIG_DM9000X is not set
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=m
+
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_V4L2=y
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_FIRMWARE_EDID is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_STB2500FB=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_SPI=m
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZMA=y
+CONFIG_SQUASHFS_LZMA_LC=3
+CONFIG_SQUASHFS_LZMA_LP=0
+CONFIG_SQUASHFS_LZMA_PB=2
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_FS is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
diff -Naur archive/linux-2.6.17/arch/ppc/configs/relook200_defconfig linux-2.6.17/arch/ppc/configs/relook200_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/relook200_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/relook200_defconfig	2007-08-30 09:04:17.000000000 +0200
@@ -0,0 +1,1058 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17
+# Sat Aug  4 08:44:14 2007
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-cubecafe"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+# CONFIG_WANT_EARLY_SERIAL is not set
+
+#
+# IBM 4xx options
+#
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+# CONFIG_RELOOK100S is not set
+CONFIG_RELOOK200S=y
+# CONFIG_RELOOK210 is not set
+# CONFIG_RELOOK300 is not set
+# CONFIG_RELOOK400 is not set
+# CONFIG_RELOOK400C is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_XILINX_ML403 is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_PPC_GEN550=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+CONFIG_SECCOMP=y
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK200S=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDE_STB04xxx is not set
+# CONFIG_BLK_DEV_IDE_DMVULCAN is not set
+CONFIG_BLK_DEV_IDE_STB2500=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+# CONFIG_WINDFARM is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_DM9000=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=m
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_V4L2 is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_FIRMWARE_EDID is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_STB2500FB=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_SPI=m
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZMA=y
+CONFIG_SQUASHFS_LZMA_LC=3
+CONFIG_SQUASHFS_LZMA_LP=0
+CONFIG_SQUASHFS_LZMA_PB=2
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+CONFIG_NLS_ISO8859_5=y
+# CONFIG_NLS_ISO8859_6 is not set
+CONFIG_NLS_ISO8859_7=y
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
diff -Naur archive/linux-2.6.17/arch/ppc/configs/relook210_defconfig linux-2.6.17/arch/ppc/configs/relook210_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/relook210_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/relook210_defconfig	2007-09-10 21:59:56.000000000 +0200
@@ -0,0 +1,1238 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17
+# Sat Aug  4 08:36:13 2007
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-cubecafe-prime"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+# CONFIG_WANT_EARLY_SERIAL is not set
+
+#
+# IBM 4xx options
+#
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+# CONFIG_RELOOK100S is not set
+# CONFIG_RELOOK200S is not set
+CONFIG_RELOOK210=y
+# CONFIG_RELOOK300 is not set
+# CONFIG_RELOOK400 is not set
+# CONFIG_RELOOK400C is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_XILINX_ML403 is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_PPC_GEN550=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+CONFIG_SECCOMP=y
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK210=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDE_STB04xxx is not set
+# CONFIG_BLK_DEV_IDE_DMVULCAN is not set
+CONFIG_BLK_DEV_IDE_STB2500=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+# CONFIG_WINDFARM is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_DM9000=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_V4L2 is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_FIRMWARE_EDID is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_STB2500FB=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_ISP116X_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+# CONFIG_USB_HIDINPUT is not set
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ANYDATA is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP2101=m
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_SPI=m
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZMA=y
+CONFIG_SQUASHFS_LZMA_LC=3
+CONFIG_SQUASHFS_LZMA_LP=0
+CONFIG_SQUASHFS_LZMA_PB=2
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+CONFIG_NLS_ISO8859_5=y
+# CONFIG_NLS_ISO8859_6 is not set
+CONFIG_NLS_ISO8859_7=y
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
diff -Naur archive/linux-2.6.17/arch/ppc/configs/relook300_defconfig linux-2.6.17/arch/ppc/configs/relook300_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/relook300_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/relook300_defconfig	2007-08-30 09:04:17.000000000 +0200
@@ -0,0 +1,621 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Fri Mar  4 15:32:48 2005
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-relook300"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_RELOOK300=y
+# CONFIG_RELOOK400 is not set
+# CONFIG_RELOOK500 is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_OPENBIOS=y
+# CONFIG_PPC4xx_DMA is not set
+# CONFIG_PM is not set
+# CONFIG_UART0_TTYS0 is not set
+CONFIG_UART0_TTYS1=y
+CONFIG_SERIAL_SICC=y
+CONFIG_UART1_DFLT_CONSOLE=y
+CONFIG_SERIAL_SICC_CONSOLE=y
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+CONFIG_PREEMPT=y
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK300=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_LBD=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_STBxxxxx=y
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_NET2270 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+CONFIG_USB_GADGET_PDIUSBD12=y
+CONFIG_USB_PDIUSBD12=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur archive/linux-2.6.17/arch/ppc/configs/relook300s_defconfig linux-2.6.17/arch/ppc/configs/relook300s_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/relook300s_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/relook300s_defconfig	2007-08-30 09:04:17.000000000 +0200
@@ -0,0 +1,632 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Wed Apr 12 18:16:06 2006
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-relook300"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+# CONFIG_RELOOK100S is not set
+CONFIG_RELOOK300=y
+# CONFIG_RELOOK400 is not set
+# CONFIG_RELOOK400C is not set
+# CONFIG_RELOOK500S is not set
+# CONFIG_RELOOK500T is not set
+# CONFIG_RELOOK510S is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+# CONFIG_PPC4xx_DMA is not set
+# CONFIG_PM is not set
+# CONFIG_UART0_TTYS0 is not set
+CONFIG_UART0_TTYS1=y
+CONFIG_SERIAL_SICC=y
+CONFIG_UART1_DFLT_CONSOLE=y
+CONFIG_SERIAL_SICC_CONSOLE=y
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+CONFIG_PREEMPT=y
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK300=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_LBD=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_STBxxxxx=y
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+#CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_NET2270 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+CONFIG_USB_GADGET_PDIUSBD12=y
+CONFIG_USB_PDIUSBD12=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZMA=y
+CONFIG_SQUASHFS_LZMA_LC=3
+CONFIG_SQUASHFS_LZMA_LP=0
+CONFIG_SQUASHFS_LZMA_PB=2
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur archive/linux-2.6.17/arch/ppc/configs/relook400_defconfig linux-2.6.17/arch/ppc/configs/relook400_defconfig
--- archive/linux-2.6.17/arch/ppc/configs/relook400_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/configs/relook400_defconfig	2007-09-09 05:14:39.000000000 +0200
@@ -0,0 +1,1055 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17
+# Sat Aug  4 08:56:38 2007
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-relook400"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+# CONFIG_E500 is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+# CONFIG_WANT_EARLY_SERIAL is not set
+
+#
+# IBM 4xx options
+#
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+# CONFIG_RELOOK100S is not set
+# CONFIG_RELOOK200S is not set
+# CONFIG_RELOOK210 is not set
+# CONFIG_RELOOK300 is not set
+CONFIG_RELOOK400=y
+# CONFIG_RELOOK400C is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_XILINX_ML403 is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_PPC_GEN550=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+CONFIG_SECCOMP=y
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_RELOOK400=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDE_STB04xxx is not set
+# CONFIG_BLK_DEV_IDE_DMVULCAN is not set
+CONFIG_BLK_DEV_IDE_STB2500=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+# CONFIG_WINDFARM is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_DM9000=y
+# CONFIG_DM9000X is not set
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+CONFIG_IBM_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_V4L2=y
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_FIRMWARE_EDID is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_STB2500FB=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZMA=y
+CONFIG_SQUASHFS_LZMA_LC=3
+CONFIG_SQUASHFS_LZMA_LP=0
+CONFIG_SQUASHFS_LZMA_PB=2
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
diff -Naur archive/linux-2.6.17/arch/ppc/kernel/dma-mapping.c linux-2.6.17/arch/ppc/kernel/dma-mapping.c
--- archive/linux-2.6.17/arch/ppc/kernel/dma-mapping.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/kernel/dma-mapping.c	2007-08-30 09:04:17.000000000 +0200
@@ -372,6 +372,22 @@
 	case DMA_NONE:
 		BUG();
 	case DMA_FROM_DEVICE:	/* invalidate only */
+#if defined(CONFIG_40x)
+			/* Handle cases where the buffer start and/or end
+			 * are not L1 cache line aligned.
+			 * Some drivers/subsystems (e.g. USB, SCSI) do DMA
+			 * from stack allocated buffers. To prevent
+			 * corruption of other stack variables located
+			 * near the buffer, we flush (instead of invalidate)
+			 * these "dangerous" areas.
+			 * patch from Eugene Surovegin <ebs@ebshome.net>
+			 */
+			if( unlikely(start & (L1_CACHE_BYTES - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (start));
+
+			if( unlikely(end & (L1_CACHE_BYTES - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (end));
+#endif
 		invalidate_dcache_range(start, end);
 		break;
 	case DMA_TO_DEVICE:		/* writeback only */
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/Kconfig linux-2.6.17/arch/ppc/platforms/4xx/Kconfig
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/platforms/4xx/Kconfig	2007-08-30 09:04:17.000000000 +0200
@@ -52,6 +52,36 @@
 	help
 	  This option enables support for the IBM PPC405GP evaluation board.
 
+config RELOOK100S
+        bool "relook100s"
+        help
+          This option enables support for the DGStation relook100s board.
+
+config RELOOK200S
+        bool "relook200s"
+        help
+          This option enables support for the DGStation relook200s (CubeCaFe) board.
+
+config RELOOK210
+        bool "relook210"
+        help
+          This option enables support for the DGStation relook210 (CubeCaFe-prime) board.
+		  
+config RELOOK300
+        bool "relook300"
+        help
+          This option enables support for the DGStation relook300 board.
+
+config RELOOK400
+        bool "relook400"
+        help
+          This option enables support for the DGStation relook400 board.
+
+config RELOOK400C
+        bool "relook400c"
+        help
+          This option enables support for the DGStation relook400c board.
+
 config XILINX_ML300
 	bool "Xilinx-ML300"
 	help
@@ -173,7 +203,7 @@
 
 config IBM_OCP
 	bool
-	depends on ASH || BAMBOO || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || YUCCA || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+ 	depends on ASH || BUBINGA || CPCI405 || EBONY || EP405 || OCOTEA || RELOOK100S || RELOOK200S || RELOOK210 || RELOOK300 || RELOOK400 || RELOOK400C || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config IBM_EMAC4
@@ -224,7 +254,7 @@
 
 config STB03xxx
 	bool
-	depends on REDWOOD_5 || REDWOOD_6
+	depends on RELOOK300 || REDWOOD_5 || REDWOOD_6
 	default y
 
 config EMBEDDEDBOOT
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/Makefile linux-2.6.17/arch/ppc/platforms/4xx/Makefile
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/platforms/4xx/Makefile	2007-08-30 09:04:17.000000000 +0200
@@ -13,10 +13,22 @@
 obj-$(CONFIG_REDWOOD_6)		+= redwood6.o
 obj-$(CONFIG_SYCAMORE)		+= sycamore.o
 obj-$(CONFIG_WALNUT)		+= walnut.o
+obj-$(CONFIG_RELOOK100S)	+= relook100s.o
+obj-$(CONFIG_RELOOK200S)	+= relook200s.o
+obj-$(CONFIG_RELOOK210)		+= relook210.o
+obj-$(CONFIG_RELOOK300)		+= relook300.o
+obj-$(CONFIG_RELOOK400)		+= relook400.o
+obj-$(CONFIG_RELOOK400C)	+= relook400c.o
 obj-$(CONFIG_XILINX_ML300)	+= xilinx_ml300.o
 obj-$(CONFIG_XILINX_ML403)	+= xilinx_ml403.o
 
 obj-$(CONFIG_405GP)		+= ibm405gp.o
+obj-$(CONFIG_RELOOK300)		+= ibmstb3.o
+obj-$(CONFIG_RELOOK100S)	+= ibmstbx25.o
+obj-$(CONFIG_RELOOK200S)	+= ibmstbx25.o
+obj-$(CONFIG_RELOOK210)		+= ibmstbx25.o
+obj-$(CONFIG_RELOOK400)		+= ibmstbx25.o
+obj-$(CONFIG_RELOOK400C)	+= ibmstbx25.o
 obj-$(CONFIG_REDWOOD_5)		+= ibmstb4.o
 obj-$(CONFIG_NP405H)		+= ibmnp405h.o
 obj-$(CONFIG_REDWOOD_6)		+= ibmstbx25.o
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.c linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.c	2007-08-30 09:04:17.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ * arch/ppc/platforms/4xx/ibmstb4.c
+ *
+ * Author: Armin Kuster <akuster@mvista.com>
+ *
+ * 2000-2001 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/init.h>
+#include <asm/ocp.h>
+#include <platforms/4xx/ibmstb3.h>
+
+static struct ocp_func_iic_data ibmstb3_iic0_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+
+static struct ocp_func_iic_data ibmstb3_iic1_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+OCP_SYSFS_IIC_DATA()
+
+struct ocp_def core_ocp[] __initdata = {
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 0,
+	  .paddr	= UART0_IO_BASE,
+	  .irq		= UART0_INT,
+	  .pm		= IBM_CPM_UART0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .paddr	= IIC0_BASE,
+	  .irq		= IIC0_IRQ,
+	  .pm		= IBM_CPM_IIC0,
+	  .additions	= &ibmstb3_iic0_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .paddr	= IIC1_BASE,
+	  .irq		= IIC1_IRQ,
+	  .pm		= IBM_CPM_IIC1,
+	  .additions	= &ibmstb3_iic1_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_GPIO,
+	  .paddr	= GPIO0_BASE,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= IBM_CPM_GPIO0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IDE,
+	  .paddr	= 0x00000000,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_FB,
+	  .paddr	= 0xa0400000,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_INVALID,
+	}
+};
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.h linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/ibmstb3.h	2007-08-30 09:04:17.000000000 +0200
@@ -0,0 +1,306 @@
+/*
+ * ibmstbx.h
+ *
+ *	This was dirived from the ppc4xx.h and all stbx specific definitions
+ *	are located here.
+ *
+ *      Armin Kuster <akuster@mvista.com>
+ *      Tom Rini <trini@mvista.com>
+ *      Oct, 2001
+ *
+ *
+ *
+ * Copyright 2001 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *	Version 1.0 Oct 10, 2001 - A. Kuster
+ *	Initial version	 - moved stbx  specific out of ibm4xx.h
+ *
+ *	Version 1.1 Oct 25, 2001 - T. Rini
+ *	Lots of cleanups, and we get included by the board-specific file.
+ *
+ *	Version 1.2 Jan 16, 2002 - A. Kuster
+ *	Removed common dcr offests that are now in ibm405.h 
+ *
+ *	Version 1.3 Feb 22, 2002 - Armin & David Gibson
+ *	Added early serial boot #define support
+ *	added UIC define 
+ *
+ *	Version 1.3 03/29/02 - Armin
+ *	 Changed i2c support to ocp standard
+ *
+ *	Version 1.4 05/06/02 - Armin
+ *	 removed IIC_IRQ now using core_ocp[];
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_IBMSTB3_H__
+#define __ASM_IBMSTB3_H__
+
+#include <linux/config.h>
+//#include <platforms/ibm_ocp.h>
+
+/* ibm405.h at bottom of this file */
+
+/*
+ * Memory map for the IBM "Redwood-4" STB03xxx evaluation board.
+ *
+ * The  STB03xxx internal i/o addresses don't work for us 1:1,
+ * so we need to map them at a well know virtual address.
+ *
+ * 4000 000x   uart1           -> 0xe000 000x
+ * 4001 00xx   ppu
+ * 4002 00xx   smart card
+ * 4003 000x   iic
+ * 4004 000x   uart0
+ * 4005 0xxx   timer
+ * 4006 00xx   gpio
+ * 4007 00xx   smart card
+ * 400b 000x   iic
+ * 400c 000x   scp
+ * 400d 000x   modem
+ */
+
+#define STB03xxx_IO_BASE	((uint)0xe0000000)
+#define PPC4xx_ONB_IO_PADDR	((uint)0x40000000)
+#define PPC4xx_ONB_IO_VADDR	STB03xxx_IO_BASE
+#define PPC4xx_ONB_IO_SIZE	((uint)14*64*1024)
+
+/* Since we're into address mapping hacks, at least try to hide
+ * it under a macro.....
+ */
+#define STB03xxx_MAP_IO_ADDR(a)	(((uint)(a) & 0x000fffff) + PPC4xx_ONB_IO_VADDR)
+
+#define RS_TABLE_SIZE		1
+#define UART0_INT		20
+#ifdef __BOOTER__
+#define UART0_IO_BASE		0x40040000
+#else
+#define UART0_IO_BASE		0xe0040000
+#endif
+
+ /* UART 0 is duped here so when the SICC is the default console
+  * then ttys1 is configured properly - armin 
+  */
+
+#define UART1_INT		20
+#ifdef __BOOTER__
+#define UART1_IO_BASE		0x40040000
+#else
+#define UART1_IO_BASE		0xe0040000
+#endif
+
+/* need to make this work in scheme - armin */
+
+#define SICC0_INTRX		21
+#define SICC0_INTTX		22
+#define SICC0_IO_BASE		((uint* )0x40000000)
+
+#define IIC0_BASE	0x40030000
+#define IIC1_BASE	0x400b0000
+#define OPB0_BASE	0x40010000
+#define GPIO0_BASE	0x40060000
+#define IIC0_IRQ	9
+#define IIC1_IRQ	10
+#define IIC_OWN		0x55
+#define IIC_CLOCK	50
+
+#define BD_EMAC_ADDR(e,i) bi_enetaddr[i]
+
+#define STD_UART_OP(num)					\
+	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
+		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
+		iomem_base: (u8 *)UART##num##_IO_BASE,		\
+		io_type: SERIAL_IO_MEM},
+
+#if defined(CONFIG_UART0_TTYS0)
+#define SERIAL_DEBUG_IO_BASE	UART0_IO_BASE
+#define SERIAL_PORT_DFNS	\
+	STD_UART_OP(0)
+#endif
+
+#if defined(CONFIG_UART0_TTYS1)
+#define SERIAL_DEBUG_IO_BASE	UART1_IO_BASE
+#define SERIAL_PORT_DFNS	\
+	STD_UART_OP(1)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#define DCRN_DCRX_BASE		0x020
+#define DCRN_CIC_BASE 		0x030
+#define DCRN_UIC0_BASE		0x040
+#define DCRN_PLB0_BASE		0x054
+#define DCRN_PLB1_BASE		0x064
+#define DCRN_EBIMC_BASE		0x070
+#define DCRN_POB0_BASE		0x0B0
+
+#define DCRN_BE_BASE		0x090
+#define DCRN_DMA0_BASE		0x0C0
+#define DCRN_DMA1_BASE		0x0C8
+#define DCRN_DMA2_BASE		0x0D0
+#define DCRN_DMA3_BASE		0x0D8
+#define DCRNCAP_DMA_CC		1	/* have DMA chained count capability */
+#define DCRN_DMASR_BASE		0x0E0
+
+#define DCRN_CPMFR_BASE		0x102
+#define DCRN_SCCR_BASE		0x120
+#define UIC0 DCRN_UIC0_BASE
+
+#define IBM_CPM_IIC0	0x80000000	/* IIC 0 interface */
+#define IBM_CPM_I1284	0x40000000	/* IEEE-1284 */
+#define IBM_CPM_IIC1	0x20000000	/* IIC 1 interface */
+#define IBM_CPM_CPU	0x10000000	/* PPC405B3 clock control */
+#define IBM_CPM_AUD	0x08000000	/* Audio Decoder */
+#define IBM_CPM_EBIU	0x04000000	/* External Bus Interface Unit */
+#define IBM_CPM_SDRAM1	0x02000000	/* SDRAM 1 memory controller */
+#define IBM_CPM_DMA	0x01000000	/* DMA controller */
+#define IBM_CPM_RES_1	0x00800000	/* reserved */
+#define IBM_CPM_RES_2	0x00400000	/* reserved */
+#define IBM_CPM_RES_3	0x00200000	/* reserved */
+#define IBM_CPM_UART1	0x00100000	/* Serial 1 / Infrared */
+#define IBM_CPM_UART0	0x00080000	/* Serial 0 / 16550 */
+#define IBM_CPM_DCRX	0x00040000	/* DCR Extension */
+#define IBM_CPM_SC0	0x00020000	/* Smart Card 0 */
+#define IBM_CPM_RES_4	0x00010000	/* reserved */
+#define IBM_CPM_SC1	0x00008000	/* Smart Card 1 */
+#define IBM_CPM_SDRAM0	0x00004000	/* SDRAM 0 memory controller */
+#define IBM_CPM_XPT54	0x00002000	/* Transport - 54 Mhz */
+#define IBM_CPM_CBS	0x00001000	/* Cross Bar Switch */
+#define IBM_CPM_GPT	0x00000800	/* GPTPWM */
+#define IBM_CPM_GPIO0	0x00000400	/* General Purpose IO 0 */
+#define IBM_CPM_DENC	0x00000200	/* Digital video Encoder */
+#define IBM_CPM_TMRCLK	0x00000100	/* CPU timers */
+#define IBM_CPM_XPT27	0x00000080	/* Transport - 27 Mhz */
+#define IBM_CPM_UIC	0x00000040	/* Universal Interrupt Controller */
+#define IBM_CPM_RES_5	0x00000020	/* reserved */
+#define IBM_CPM_MSI	0x00000010	/* Modem Serial Interface (SSP) */
+#define IBM_CPM_UART2	0x00000008	/* Serial Control Port */
+#define IBM_CPM_DSCR	0x00000004	/* Descrambler */
+#define IBM_CPM_VID2	0x00000002	/* Video Decoder clock domain 2 */
+#define IBM_CPM_RES_6	0x00000001	/* reserved */
+
+/*			0x80000000 */
+#define UIC_XPORT	0x40000000	/* 1 Transport */
+#define UIC_AUDIO	0x20000000	/* 2 Audio Decoder */
+#define UIC_VIDEO	0x10000000	/* 3 Video Decoder */
+#define UIC_D0		0x08000000	/* 4 DMA Channel 0 */
+#define UIC_D1		0x04000000	/* 5 DMA Channel 1 */
+#define UIC_D2		0x02000000	/* 6 DMA Channel 2 */
+#define UIC_D3		0x01000000	/* 7 DMA Channel 3 */
+#define UIC_SC0		0x00800000	/* 8 SmartCard 0 Controller */
+#define UIC_IIC0	0x00400000	/* 9 IIC 0 */
+#define UIC_IIC1	0x00200000	/* 10 IIC 1 */
+#define UIC_PWM0	0x00100000	/* 11 GPT_PWM 0: Capture Timers */
+#define UIC_PWM1	0x00080000	/* 12 GPT_PWM 1: Compare Timers */
+#define UIC_SCP		0x00040000	/* 13 Serial Control Port */
+#define UIC_SSP		0x00020000	/* 14 Soft Modem/Synchronous Serial Port */
+#define UIC_PWM2	0x00010000	/* 15 GPT_PWM 2: Down Counters */
+#define UIC_SC1		0x00008000	/* 16 SmartCard 1 Controller */
+#define UIC_EIR7	0x00004000	/* 17 External IRQ 7 */
+#define UIC_EIR8	0x00002000	/* 18 External IRQ 8 */
+#define UIC_EIR9	0x00001000	/* 19 External IRQ 9 */
+#define UIC_U0		0x00000800	/* 20 UART0 */
+#define UIC_IR_RCV	0x00000400	/* 21 Serial 1 / Infrared UART Receive */
+#define UIC_IR_XMIT	0x00000200	/* 22 Serial 1 / Infrared UART Transmit */
+#define UIC_IEEE1284	0x00000100	/* 23 IEEE-1284 / PPU */
+#define UIC_DCRX	0x00000080	/* 24 DCRX */
+#define UIC_EIR0	0x00000040	/* 25 External IRQ 0 */
+#define UIC_EIR1	0x00000020	/* 26 External IRQ 1 */
+#define UIC_EIR2	0x00000010	/* 27 External IRQ 2 */
+#define UIC_EIR3	0x00000008	/* 28 External IRQ 3 */
+#define UIC_EIR4	0x00000004	/* 29 External IRQ 4 */
+#define UIC_EIR5	0x00000002	/* 30 External IRQ 5 */
+#define UIC_EIR6	0x00000001	/* 31 External IRQ 6 */
+
+#ifdef DCRN_CIC_BASE
+#define DCRN_CICCR	(DCRN_CIC_BASE + 0x0)	/* CIC Control Register */
+#define DCRN_DMAS1	(DCRN_CIC_BASE + 0x1)	/* DMA Select1 Register */
+#define DCRN_DMAS2	(DCRN_CIC_BASE + 0x2)	/* DMA Select2 Register */
+#define DCRN_CICVCR	(DCRN_CIC_BASE + 0x3)	/* CIC Video COntro Register */
+#define DCRN_CICSEL3	(DCRN_CIC_BASE + 0x5)	/* CIC Select 3 Register */
+#define DCRN_SGPO	(DCRN_CIC_BASE + 0x6)	/* CIC GPIO Output Register */
+#define DCRN_SGPOD	(DCRN_CIC_BASE + 0x7)	/* CIC GPIO OD Register */
+#define DCRN_SGPTC	(DCRN_CIC_BASE + 0x8)	/* CIC GPIO Tristate Ctrl Reg */
+#define DCRN_SGPI	(DCRN_CIC_BASE + 0x9)	/* CIC GPIO Input Reg */
+#endif
+
+#ifdef DCRN_DCRX_BASE
+#define DCRN_DCRXICR	(DCRN_DCRX_BASE + 0x0)	/* Internal Control Register */
+#define DCRN_DCRXISR	(DCRN_DCRX_BASE + 0x1)	/* Internal Status Register */
+#define DCRN_DCRXECR	(DCRN_DCRX_BASE + 0x2)	/* External Control Register */
+#define DCRN_DCRXESR	(DCRN_DCRX_BASE + 0x3)	/* External Status Register */
+#define DCRN_DCRXTAR	(DCRN_DCRX_BASE + 0x4)	/* Target Address Register */
+#define DCRN_DCRXTDR	(DCRN_DCRX_BASE + 0x5)	/* Target Data Register */
+#define DCRN_DCRXIGR	(DCRN_DCRX_BASE + 0x6)	/* Interrupt Generation Register */
+#define DCRN_DCRXBCR	(DCRN_DCRX_BASE + 0x7)	/* Line Buffer Control Register */
+#endif
+
+#ifdef DCRN_EBC_BASE
+#define DCRN_EBCCFGADR	(DCRN_EBC_BASE + 0x0)	/* Peripheral Controller Address */
+#define DCRN_EBCCFGDATA	(DCRN_EBC_BASE + 0x1)	/* Peripheral Controller Data */
+#endif
+
+#ifdef DCRN_EBIMC_BASE
+#define DCRN_BRCRH0	(DCRN_EBIMC_BASE + 0x0)	/* Bus Region Config High 0 */
+#define DCRN_BRCRH1	(DCRN_EBIMC_BASE + 0x1)	/* Bus Region Config High 1 */
+#define DCRN_BRCRH2	(DCRN_EBIMC_BASE + 0x2)	/* Bus Region Config High 2 */
+#define DCRN_BRCRH3	(DCRN_EBIMC_BASE + 0x3)	/* Bus Region Config High 3 */
+#define DCRN_BRCRH4	(DCRN_EBIMC_BASE + 0x4)	/* Bus Region Config High 4 */
+#define DCRN_BRCRH5	(DCRN_EBIMC_BASE + 0x5)	/* Bus Region Config High 5 */
+#define DCRN_BRCRH6	(DCRN_EBIMC_BASE + 0x6)	/* Bus Region Config High 6 */
+#define DCRN_BRCRH7	(DCRN_EBIMC_BASE + 0x7)	/* Bus Region Config High 7 */
+#define DCRN_BRCR0	(DCRN_EBIMC_BASE + 0x10)	/* BRC 0 */
+#define DCRN_BRCR1	(DCRN_EBIMC_BASE + 0x11)	/* BRC 1 */
+#define DCRN_BRCR2	(DCRN_EBIMC_BASE + 0x12)	/* BRC 2 */
+#define DCRN_BRCR3	(DCRN_EBIMC_BASE + 0x13)	/* BRC 3 */
+#define DCRN_BRCR4	(DCRN_EBIMC_BASE + 0x14)	/* BRC 4 */
+#define DCRN_BRCR5	(DCRN_EBIMC_BASE + 0x15)	/* BRC 5 */
+#define DCRN_BRCR6	(DCRN_EBIMC_BASE + 0x16)	/* BRC 6 */
+#define DCRN_BRCR7	(DCRN_EBIMC_BASE + 0x17)	/* BRC 7 */
+#define DCRN_BEAR0	(DCRN_EBIMC_BASE + 0x20)	/* Bus Error Address Register */
+#define DCRN_BESR0	(DCRN_EBIMC_BASE + 0x21)	/* Bus Error Status Register */
+#define DCRN_BIUCR	(DCRN_EBIMC_BASE + 0x2A)	/* Bus Interfac Unit Ctrl Reg */
+#endif
+
+#ifdef DCRN_SCCR_BASE
+#define DCRN_SCCR	(DCRN_SCCR_BASE + 0x0)
+#endif
+
+#ifdef DCRN_SDRAM0_BASE
+#define DCRN_SDRAM0_CFGADDR	(DCRN_SDRAM0_BASE + 0x0)	/* Memory Controller Address */
+#define DCRN_SDRAM0_CFGDATA	(DCRN_SDRAM0_BASE + 0x1)	/* Memory Controller Data */
+#endif
+
+#ifdef DCRN_OCM0_BASE
+#define DCRN_OCMISARC	(DCRN_OCM0_BASE + 0x0)	/* OCM Instr Side Addr Range Compare */
+#define DCRN_OCMISCR	(DCRN_OCM0_BASE + 0x1)	/* OCM Instr Side Control */
+#define DCRN_OCMDSARC	(DCRN_OCM0_BASE + 0x2)	/* OCM Data Side Addr Range Compare */
+#define DCRN_OCMDSCR	(DCRN_OCM0_BASE + 0x3)	/* OCM Data Side Control */
+#endif
+
+#include <asm/ibm405.h>
+
+#endif				/* __ASM_IBMSTB3_H__ */
+#endif				/* __KERNEL__ */
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb4.c linux-2.6.17/arch/ppc/platforms/4xx/ibmstb4.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstb4.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/platforms/4xx/ibmstb4.c	2007-08-30 09:04:17.000000000 +0200
@@ -47,6 +47,7 @@
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
 	  .paddr	= IIC0_BASE,
+	  .index	= 0,
 	  .irq		= IIC0_IRQ,
 	  .pm		= IBM_CPM_IIC0,
 	  .additions	= &ibmstb4_iic0_def,
@@ -55,6 +56,7 @@
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
 	  .paddr	= IIC1_BASE,
+	  .index	= 1,
 	  .irq		= IIC1_IRQ,
 	  .pm		= IBM_CPM_IIC1,
 	  .additions	= &ibmstb4_iic1_def,
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.c linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.c	2007-08-30 09:04:17.000000000 +0200
@@ -53,6 +53,12 @@
 	  .irq		= OCP_IRQ_NA,
 	  .pm		= IBM_CPM_GPIO0,
 	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IDE,
+	  .paddr	= IDE0_BASE,
+	  .irq		= IDE0_IRQ,
+	  .pm		= OCP_CPM_NA,
+	},
 	{ .vendor	= OCP_VENDOR_INVALID
 	}
 };
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.h linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/platforms/4xx/ibmstbx25.h	2007-08-30 09:04:17.000000000 +0200
@@ -92,7 +92,7 @@
 #define XPTDMA_IRQ	23
 #define DCRIDE_IRQ	24
 /* IRQ 25 - 30 external */
-#define IDE0_IRQ	26
+#define IDE0_IRQ	25
 
 #define IIC_NUMS	1
 #define UART_NUMS	3
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook100s.c linux-2.6.17/arch/ppc/platforms/4xx/relook100s.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook100s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook100s.c	2008-03-14 16:42:41.000000000 +0100
@@ -0,0 +1,323 @@
+/*
+ * arch/ppc/platforms/4xx/relook100s.c
+ *
+ * Support for the DGStation relook100s board.
+ *
+ * Author: Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+#include <linux/delay.h>
+#include <asm/machdep.h>
+#include <linux/dm9000.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+/*
+ * Define all of the IRQ senses and polarities.
+ */
+
+unsigned char ppc4xx_uic_ext_irq_cfg[] __initdata = {
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 17: Ext Int 7 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 18: Ext Int 8 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 19: Ext Int 9 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 25: Ext Int 0 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 26: Ext Int 1 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 27: Ext Int 2 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 28: Ext Int 3 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 29: Ext Int 4 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 30: Ext Int 5 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 31: Ext Int 6 */
+};
+
+/* system devices*/
+static struct resource stb2500soc_resources[] ={
+	[0] = {
+		.start	= SOC_DRV_MEM_BASE,
+		.end	= SOC_DRV_MEM_END,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device stb2500soc_device =
+{
+	.name		= "stb2500soc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(stb2500soc_resources),
+	.resource	= stb2500soc_resources,
+};
+
+/* network device */
+static struct resource dm9000_resources[] ={
+	[0] = {
+		.start	= DM9000_MEM_START,
+		.end	= DM9000_MEM_START + DM9000_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= DM9000_IRQ,
+		.end	= DM9000_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*
+static struct dm9000_plat_data dgs_dm9k_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY,
+};
+*/
+
+static struct platform_device dm9000_device ={
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource	= dm9000_resources,
+	/*
+	.dev		= {
+		.platform_data = &dgs_dm9k_platdata,
+	}
+	*/
+};
+
+
+/*
+Spi device
+*/
+
+#define GPIO10 10
+#define GPIO11 11
+#define GPIO12 12
+
+#define	spi_sck_bit		GPIO12
+#define	spi_mosi_bit	GPIO10
+#define	spi_miso_bit	GPIO11
+
+#ifdef PLAT_HAS_M25P80
+
+static struct mtd_partition cr_spi_flash_partitions[] = {
+#ifdef DATAFLASH_MULTIPART
+        {
+                .name = "bootloader",
+                .size = 0x00020000,
+                .offset = 0,
+                .mask_flags = MTD_CAP_ROM
+        },{
+                .name = "kernel",
+                .size = 0xe0000,
+                .offset = 0x20000
+        },{
+                .name = "file system",
+                .size = 0x700000,
+                .offset = 0x00100000,
+        }
+#else
+		{
+                .name = "CR dataflash",
+                .size = 0x800000,
+                .offset = 0,
+        }
+#endif
+};
+
+
+static struct flash_platform_data cr_spi_flash_data = {
+         .name = "m25p80",
+         .parts = cr_spi_flash_partitions,
+         .nr_parts = ARRAY_SIZE(cr_spi_flash_partitions),
+         .type = "m25p64",
+};
+
+#endif
+
+#ifdef PLAT_HAS_MMC
+int spimmc_get_ro (struct device * spi_dev)
+{
+	printk("spimmc_get_ro\n");
+	return 0;
+}
+
+int spimmc_init (struct device * spi_dev , irqreturn_t (*handler)(int, void *) , void *mmc)
+{
+	printk("spimmc_init\n");
+	return 0;
+}
+
+void spimmc_exit(struct device * spi_dev, void * data)
+{
+	printk ("spimmc_exit\n");
+}
+
+void spimmc_setpower (struct device * spi_dev, unsigned int value)
+{
+	printk("spimmc_setpower %d\n", value);
+
+}
+
+static struct mmc_spi_platform_data hackport_mmc_spi_pdata = {
+	.detect_delay		= 10,
+	.init				= spimmc_init,
+	.exit				= spimmc_exit,
+	.get_ro				= spimmc_get_ro,
+	.ocr_mask			= MMC_VDD_32_33|MMC_VDD_33_34,
+	.setpower			= spimmc_setpower,
+};
+#endif
+
+
+struct stb2500_spigpio_info {
+        unsigned long            pin_clk;
+        unsigned long            pin_mosi;
+        unsigned long            pin_miso;
+
+        unsigned long            board_size;
+        struct spi_board_info   *board_info;
+
+        void (*chip_select)(struct stb2500_spigpio_info *spi, int cs);
+};
+
+static struct spi_board_info stb2500_spi_board_info[] /*__initdata*/ = {
+#ifdef PLAT_HAS_M25P80
+	{
+		/* the modalias must be the same as spi device driver name */
+		.modalias = "m25p80",       /* Name of spi_driver for this device */
+		.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+		.bus_num = 1,               /* Framework bus number */
+		.chip_select = M25P80_CS,           /* Framework chip select. */
+		.platform_data = &cr_spi_flash_data,
+		/*.mode = SPI_MODE_3,*/
+	},
+#endif
+#ifdef PLAT_HAS_MMC
+	{
+			.modalias = "mmc_spi", /* Name of spi_driver for this device */
+			.max_speed_hz = 6250000,     /* max spi clock (SCK) speed in HZ */
+			.bus_num = 1,               /* Framework bus number */
+			.chip_select = MMC_CS,           /* Framework chip select. */
+			.platform_data = NULL,      /* No spi_driver specific config */
+			.controller_data = &hackport_mmc_spi_pdata
+	},
+#endif
+#ifdef PLAT_HAS_MAX3421
+	{
+			.modalias = "max3421e-spi",
+			.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+			.bus_num = 1,
+			.chip_select = MAX3421E_CS,           /* Framework chip select. */
+	},
+#endif
+};
+
+
+static struct stb2500_spigpio_info spi_gpio_cfg = {
+	.pin_clk	= spi_sck_bit,
+	.pin_mosi	= spi_mosi_bit,
+	.pin_miso	= spi_miso_bit,
+	.board_size	= ARRAY_SIZE(stb2500_spi_board_info),
+	.board_info	= stb2500_spi_board_info,
+};
+
+static void spidevs_platform_release (struct device *dev) {}
+
+static struct platform_device spi_gpio_dev = {
+		.name		  = "stb2500-spi-gpio",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+static struct platform_device spi_scp_dev = {
+		.name		  = "stb2500-spi-scp",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+static struct platform_device *relook100s_devs[] __initdata ={
+	&stb2500soc_device,
+	&dm9000_device,
+	&spi_gpio_dev,
+	&spi_scp_dev,
+};
+
+#define SDRAM0CR1 0x1E8
+#define SDRAM0BR1 0x1E7
+
+static
+int relook100s_get_br1_mem_size(void)
+{
+	if (((mfdcr(SDRAM0BR1) >> 12) & 0x7 )==0)
+		return 0;
+
+	return ((mfdcr(SDRAM0CR1) >> 20) &  0x1f)+1;
+}
+
+
+static int __init
+relook100s_platform_add_devices(void)
+{
+	//if (mfdcr(SDRAM0BR1)!=0)
+	if (relook100s_get_br1_mem_size()==32)
+	{
+		printk("Mutant200s with 64 Megabytes detected\n");
+		stb2500soc_resources->start  = SOC_DRV_MEM_BASE_H;
+		stb2500soc_resources->end	= SOC_DRV_MEM_END_H;
+	}
+	return platform_add_devices(relook100s_devs, ARRAY_SIZE(relook100s_devs));
+}
+
+
+
+
+void __init
+relook100s_setup_arch(void)
+{
+	printk(KERN_INFO "relook100s (mutant) DGStation Co. http://www.dgstation.co.kr\n");
+	ppc4xx_setup_arch();
+}
+
+device_initcall(relook100s_platform_add_devices);
+
+void __init
+relook100s_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++)
+	{
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STBx25xx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	}
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = relook100s_setup_arch;
+	ppc_md.setup_io_mappings = relook100s_map_io;
+}
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook100s.h linux-2.6.17/arch/ppc/platforms/4xx/relook100s.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook100s.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook100s.h	2008-03-13 16:17:45.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * arch/ppc/platforms/4xx/relook100s.h
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RELOOK100S_H__
+#define __ASM_RELOOK100S_H__
+
+#define PLATFORM_DGS_RELOOK100S
+
+/* relook100s has an STBx25xx core */
+#include <platforms/4xx/ibmstbx25.h>
+
+#ifndef __ASSEMBLY__
+typedef struct ppc_board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+
+/*Driver will seek for theese values */
+#define SOC_DRV_MEM_START	0x00000000
+#define SOC_DRV_MEM_BASE	0x018A0000
+#define SOC_DRV_MEM_END		0x02000000
+
+/*super Mutant with 64 megs*/
+#define SOC_DRV_MEM_START_H	0x00000000
+#define SOC_DRV_MEM_BASE_H	0x038A0000
+#define SOC_DRV_MEM_END_H	0x04000000
+
+
+/*Spi device */
+#define PLAT_HAS_MMC
+#define PLAT_HAS_MAX3421
+#define PLAT_HAS_M25P80
+
+#define M25P80_CS     3
+#define MAX3421E_CS  24
+#define MAX3421E_IRQ  2
+#define MMC_CS		  0
+
+/* network device */
+#define DM9000_MEM_START	0xfee00000
+#define DM9000_MEM_SIZE		0x00001000
+#define DM9000_IRQ		26
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox compatible rel00k100s"
+
+#endif				/* __ASM_RELOOK100S_H__ */
+#endif				/* __KERNEL__ */
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook200s.c linux-2.6.17/arch/ppc/platforms/4xx/relook200s.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook200s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook200s.c	2008-03-03 19:45:04.000000000 +0100
@@ -0,0 +1,304 @@
+/*
+ * arch/ppc/platforms/4xx/relook200s.c
+ *
+ * Support for the DGStation relook200s board.
+ *
+ * Author: Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+#include <linux/delay.h>
+#include <asm/machdep.h>
+#include <linux/dm9000.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+/*
+ * Define all of the IRQ senses and polarities.
+ */
+
+unsigned char ppc4xx_uic_ext_irq_cfg[] __initdata = {
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 17: Ext Int 7 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 18: Ext Int 8 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 19: Ext Int 9 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 25: Ext Int 0 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 26: Ext Int 1 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 27: Ext Int 2 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 28: Ext Int 3 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 29: Ext Int 4 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 30: Ext Int 5 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 31: Ext Int 6 */
+};
+
+/* system devices*/
+static struct resource stb2500soc_resources[] ={
+	[0] = {
+		.start	= SOC_DRV_MEM_BASE,
+		.end	= SOC_DRV_MEM_END,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device stb2500soc_device =
+{
+	.name		= "stb2500soc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(stb2500soc_resources),
+	.resource	= stb2500soc_resources,
+};
+
+/* network device */
+static struct resource dm9000_resources[] ={
+	[0] = {
+		.start	= DM9000_MEM_START,
+		.end	= DM9000_MEM_START + DM9000_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= DM9000_IRQ,
+		.end	= DM9000_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*
+static struct dm9000_plat_data dgs_dm9k_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY,
+};
+*/
+
+static struct platform_device dm9000_device =
+{
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource	= dm9000_resources,
+	/*
+	.dev		= {
+		.platform_data = &dgs_dm9k_platdata,
+	}
+	*/
+};
+
+
+/*
+Spi device
+*/
+
+#define GPIO10 10
+#define GPIO11 11
+#define GPIO12 12
+
+#define	spi_sck_bit		GPIO12
+#define	spi_mosi_bit	GPIO10
+#define	spi_miso_bit	GPIO11
+
+#ifdef PLAT_HAS_M25P80
+
+static struct mtd_partition cr_spi_flash_partitions[] = {
+#ifdef DATAFLASH_MULTIPART
+        {
+                .name = "bootloader",
+                .size = 0x00020000,
+                .offset = 0,
+                .mask_flags = MTD_CAP_ROM
+        },{
+                .name = "kernel",
+                .size = 0xe0000,
+                .offset = 0x20000
+        },{
+                .name = "file system",
+                .size = 0x700000,
+                .offset = 0x00100000,
+        }
+#else
+		{
+                .name = "CR dataflash",
+                .size = 0x800000,
+                .offset = 0,
+        }
+#endif
+};
+
+
+static struct flash_platform_data cr_spi_flash_data = {
+         .name = "m25p80",
+         .parts = cr_spi_flash_partitions,
+         .nr_parts = ARRAY_SIZE(cr_spi_flash_partitions),
+         .type = "m25p64",
+};
+
+#endif
+
+#ifdef PLAT_HAS_MMC
+int spimmc_get_ro (struct device * spi_dev)
+{
+	printk("spimmc_get_ro\n");
+	return 0;
+}
+
+int spimmc_init (struct device * spi_dev , irqreturn_t (*handler)(int, void *) , void *mmc)
+{
+	printk("spimmc_init\n");
+	return 0;
+}
+
+void spimmc_exit(struct device * spi_dev, void * data)
+{
+	printk ("spimmc_exit\n");
+}
+
+void spimmc_setpower (struct device * spi_dev, unsigned int value)
+{
+	printk("spimmc_setpower %d\n", value);
+
+}
+
+static struct mmc_spi_platform_data hackport_mmc_spi_pdata = {
+	.detect_delay		= 10,
+	.init				= spimmc_init,
+	.exit				= spimmc_exit,
+	.get_ro				= spimmc_get_ro,
+	.ocr_mask			= MMC_VDD_32_33|MMC_VDD_33_34,
+	.setpower			= spimmc_setpower,
+};
+#endif
+
+
+struct stb2500_spigpio_info {
+        unsigned long            pin_clk;
+        unsigned long            pin_mosi;
+        unsigned long            pin_miso;
+
+        unsigned long            board_size;
+        struct spi_board_info   *board_info;
+
+        void (*chip_select)(struct stb2500_spigpio_info *spi, int cs);
+};
+
+static struct spi_board_info stb2500_spi_board_info[] /*__initdata*/ = {
+#ifdef PLAT_HAS_M25P80
+	{
+		/* the modalias must be the same as spi device driver name */
+		.modalias = "m25p80",       /* Name of spi_driver for this device */
+		.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+		.bus_num = 1,               /* Framework bus number */
+		.chip_select = M25P80_CS,           /* Framework chip select. */
+		.platform_data = &cr_spi_flash_data,
+		/*.mode = SPI_MODE_3,*/
+	},
+#endif
+#ifdef PLAT_HAS_MMC
+	{
+			.modalias = "mmc_spi", /* Name of spi_driver for this device */
+			.max_speed_hz = 6250000,     /* max spi clock (SCK) speed in HZ */
+			.bus_num = 1,               /* Framework bus number */
+			.chip_select = MMC_CS,           /* Framework chip select. */
+			.platform_data = NULL,      /* No spi_driver specific config */
+			.controller_data = &hackport_mmc_spi_pdata
+	},
+#endif
+#ifdef PLAT_HAS_MAX3421
+	{
+			.modalias = "max3421e-spi",
+			.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+			.bus_num = 1,
+			.chip_select = MAX3421E_CS,           /* Framework chip select. */
+	},
+#endif
+};
+
+
+static struct stb2500_spigpio_info spi_gpio_cfg = {
+	.pin_clk	= spi_sck_bit,
+	.pin_mosi	= spi_mosi_bit,
+	.pin_miso	= spi_miso_bit,
+	.board_size	= ARRAY_SIZE(stb2500_spi_board_info),
+	.board_info	= stb2500_spi_board_info,
+};
+
+static void spidevs_platform_release (struct device *dev) {}
+
+static struct platform_device spi_gpio_dev = {
+		.name		  = "stb2500-spi-gpio",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+static struct platform_device spi_scp_dev = {
+		.name		  = "stb2500-spi-scp",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+
+/* platform device list */
+static struct platform_device *relook200s_devs[] __initdata =
+{
+	&stb2500soc_device,
+	&dm9000_device,
+	&spi_gpio_dev,
+	&spi_scp_dev,
+
+};
+
+static int __init
+relook200s_platform_add_devices(void)
+{
+	return platform_add_devices(relook200s_devs, ARRAY_SIZE(relook200s_devs));
+}
+
+void __init
+relook200s_setup_arch(void)
+{
+	printk(KERN_INFO "relook200s (cubeCaFe) DGStation Co. http://www.dgstation.co.kr\n");
+	ppc4xx_setup_arch();
+}
+device_initcall(relook200s_platform_add_devices);
+
+void __init
+relook200s_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++)
+	{
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STBx25xx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	}
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = relook200s_setup_arch;
+	ppc_md.setup_io_mappings = relook200s_map_io;
+}
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook200s.h linux-2.6.17/arch/ppc/platforms/4xx/relook200s.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook200s.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook200s.h	2008-03-03 19:45:42.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+ * arch/ppc/platforms/4xx/relook200s.h
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RELOOK200S_H__
+#define __ASM_RELOOK200S_H__
+
+#define PLATFORM_DGS_RELOOK200S
+
+/* relook200s has an STBx25xx core */
+#include <platforms/4xx/ibmstbx25.h>
+
+#ifndef __ASSEMBLY__
+typedef struct ppc_board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+/*Driver will seek for theese values */
+#define SOC_DRV_MEM_START	0xA0000000
+#define SOC_DRV_MEM_BASE	0xA18A0000
+#define SOC_DRV_MEM_END		0xA2000000
+
+/*Spi device */
+#define PLAT_HAS_MMC
+#define PLAT_HAS_MAX3421
+#define PLAT_HAS_M25P80
+
+#define M25P80_CS     3
+
+#define MAX3421E_CS   27
+#define MAX3421E_IRQ  2
+
+#define MMC_CS		  9
+
+/* network device */
+#define DM9000_MEM_START	0xfee00000
+#define DM9000_MEM_SIZE		0x00001000
+#define DM9000_IRQ		26
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox compatible rel00k200s"
+
+#endif				/* __ASM_RELOOK200S_H__ */
+#endif				/* __KERNEL__ */
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook210.c linux-2.6.17/arch/ppc/platforms/4xx/relook210.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook210.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook210.c	2008-03-03 19:45:04.000000000 +0100
@@ -0,0 +1,342 @@
+/*
+ * arch/ppc/platforms/4xx/relook210.c
+ *
+ * Support for the DGStation relook210 board.
+ *
+ * Author: sandali
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+#include <linux/delay.h>
+#include <asm/machdep.h>
+#include <linux/dm9000.h>
+#include <linux/usb_isp116x.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+
+/*
+ * Define all of the IRQ senses and polarities.
+ */
+
+unsigned char ppc4xx_uic_ext_irq_cfg[] __initdata = {
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 17: Ext Int 7 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 18: Ext Int 8 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 19: Ext Int 9 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 25: Ext Int 0 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 26: Ext Int 1 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 27: Ext Int 2 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 28: Ext Int 3 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 29: Ext Int 4 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 30: Ext Int 5 */
+        (IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* 31: Ext Int 6 */
+};
+
+/* system devices*/
+static struct resource stb2500soc_resources[] ={
+	[0] = {
+		.start	= SOC_DRV_MEM_BASE,
+		.end	= SOC_DRV_MEM_END,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device stb2500soc_device =
+{
+	.name		= "stb2500soc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(stb2500soc_resources),
+	.resource	= stb2500soc_resources,
+};
+
+/* isp1161 usb host device */
+static struct resource isp116x_resources[] = {
+	[0] = {			/// data (A0 = 0)
+	       .start = ISP1161_MEM_START,
+	       .end = ISP1161_MEM_START + 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {			/// addr (A0 = 1)
+	       .start = ISP1161_MEM_START + 2,
+	       .end = ISP1161_MEM_START + 3,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[2] = {
+	       .start = ISP1161_IRQ,
+	       .end = ISP1161_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static void isp116x_delay(struct device *dev, int delay)
+{
+	/* ugly and poor */
+	ndelay(delay);
+}
+
+static struct isp116x_platform_data isp116x_data = {
+	.sel15Kres = 0,
+	.oc_enable = 0,
+	.remote_wakeup_enable = 0,
+	.int_act_high=1,
+	.int_edge_triggered = 0,
+	.delay = isp116x_delay,
+};
+
+static struct platform_device		isp1161_device = {
+	.name		=  "isp116x-hcd",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &isp116x_data,
+		.parent = &platform_bus,
+	},
+	.resource               = isp116x_resources,
+	.num_resources          = ARRAY_SIZE(isp116x_resources),
+};
+
+/* network device */
+static struct resource dm9000_resources[] ={
+	[0] = {
+		.start	= DM9000_MEM_START,
+		.end	= DM9000_MEM_START + DM9000_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= DM9000_IRQ,
+		.end	= DM9000_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+
+/*
+static struct dm9000_plat_data dgs_dm9k_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY,
+};
+*/
+
+static struct platform_device dm9000_device =
+{
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource	= dm9000_resources,
+	/*
+	.dev		= {
+		.platform_data = &dgs_dm9k_platdata,
+	}
+	*/
+};
+
+/*
+Spi device
+*/
+
+#define GPIO10 10
+#define GPIO11 11
+#define GPIO12 12
+
+#define	spi_sck_bit		GPIO12
+#define	spi_mosi_bit	GPIO10
+#define	spi_miso_bit	GPIO11
+
+#ifdef PLAT_HAS_M25P80
+
+static struct mtd_partition cr_spi_flash_partitions[] = {
+#ifdef DATAFLASH_MULTIPART
+        {
+                .name = "bootloader",
+                .size = 0x00020000,
+                .offset = 0,
+                .mask_flags = MTD_CAP_ROM
+        },{
+                .name = "kernel",
+                .size = 0xe0000,
+                .offset = 0x20000
+        },{
+                .name = "file system",
+                .size = 0x700000,
+                .offset = 0x00100000,
+        }
+#else
+		{
+                .name = "CR dataflash",
+                .size = 0x800000,
+                .offset = 0,
+        }
+#endif
+};
+
+
+static struct flash_platform_data cr_spi_flash_data = {
+         .name = "m25p80",
+         .parts = cr_spi_flash_partitions,
+         .nr_parts = ARRAY_SIZE(cr_spi_flash_partitions),
+         .type = "m25p64",
+};
+
+#endif
+
+#ifdef PLAT_HAS_MMC
+int spimmc_get_ro (struct device * spi_dev)
+{
+	printk("spimmc_get_ro\n");
+	return 0;
+}
+
+int spimmc_init (struct device * spi_dev , irqreturn_t (*handler)(int, void *) , void *mmc)
+{
+	printk("spimmc_init\n");
+	return 0;
+}
+
+void spimmc_exit(struct device * spi_dev, void * data)
+{
+	printk ("spimmc_exit\n");
+}
+
+void spimmc_setpower (struct device * spi_dev, unsigned int value)
+{
+	printk("spimmc_setpower %d\n", value);
+
+}
+
+static struct mmc_spi_platform_data hackport_mmc_spi_pdata = {
+	.detect_delay		= 10,
+	.init				= spimmc_init,
+	.exit				= spimmc_exit,
+	.get_ro				= spimmc_get_ro,
+	.ocr_mask			= MMC_VDD_32_33|MMC_VDD_33_34,
+	.setpower			= spimmc_setpower,
+};
+#endif
+
+
+struct stb2500_spigpio_info {
+        unsigned long            pin_clk;
+        unsigned long            pin_mosi;
+        unsigned long            pin_miso;
+
+        unsigned long            board_size;
+        struct spi_board_info   *board_info;
+
+        void (*chip_select)(struct stb2500_spigpio_info *spi, int cs);
+};
+
+static struct spi_board_info stb2500_spi_board_info[] /*__initdata*/ = {
+#ifdef PLAT_HAS_M25P80
+	{
+		/* the modalias must be the same as spi device driver name */
+		.modalias = "m25p80",       /* Name of spi_driver for this device */
+		.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+		.bus_num = 1,               /* Framework bus number */
+		.chip_select = M25P80_CS,           /* Framework chip select. */
+		.platform_data = &cr_spi_flash_data,
+		/*.mode = SPI_MODE_3,*/
+	},
+#endif
+#ifdef PLAT_HAS_MMC
+	{
+			.modalias = "mmc_spi", /* Name of spi_driver for this device */
+			.max_speed_hz = 6250000,     /* max spi clock (SCK) speed in HZ */
+			.bus_num = 1,               /* Framework bus number */
+			.chip_select = MMC_CS,           /* Framework chip select. */
+			.platform_data = NULL,      /* No spi_driver specific config */
+			.controller_data = &hackport_mmc_spi_pdata
+	},
+#endif
+};
+
+
+static struct stb2500_spigpio_info spi_gpio_cfg = {
+	.pin_clk	= spi_sck_bit,
+	.pin_mosi	= spi_mosi_bit,
+	.pin_miso	= spi_miso_bit,
+	.board_size	= ARRAY_SIZE(stb2500_spi_board_info),
+	.board_info	= stb2500_spi_board_info,
+};
+
+static void spidevs_platform_release (struct device *dev) {}
+
+static struct platform_device spi_gpio_dev = {
+		.name		  = "stb2500-spi-gpio",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+static struct platform_device spi_scp_dev = {
+		.name		  = "stb2500-spi-scp",
+        .id                     = -1,
+        .dev = {
+				.release	   = &spidevs_platform_release,
+                .platform_data = &spi_gpio_cfg,
+        },
+};
+
+/* platform device list */
+static struct platform_device *relook210_devs[] __initdata =
+{
+	&stb2500soc_device,
+	&dm9000_device,
+	&isp1161_device,
+	&spi_gpio_dev,
+	&spi_scp_dev,
+};
+
+static int __init
+relook210_platform_add_devices(void)
+{
+	return platform_add_devices(relook210_devs, ARRAY_SIZE(relook210_devs));
+}
+
+void __init
+relook210_setup_arch(void)
+{
+	printk(KERN_INFO "relook210 (CubeCaFe-prime) DGStation Co. http://www.dgstation.co.kr\n");
+	ppc4xx_setup_arch();
+}
+device_initcall(relook210_platform_add_devices);
+
+void __init
+relook210_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++)
+	{
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STBx25xx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	}
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = relook210_setup_arch;
+	ppc_md.setup_io_mappings = relook210_map_io;
+}
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook210.h linux-2.6.17/arch/ppc/platforms/4xx/relook210.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook210.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook210.h	2008-03-03 19:46:01.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * arch/ppc/platforms/4xx/relook210.h
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RELOOK210_H__
+#define __ASM_RELOOK210_H__
+
+#define PLATFORM_DGS_RELOOK210
+
+/* relook210 has an STBx25xx core */
+#include <platforms/4xx/ibmstbx25.h>
+
+#ifndef __ASSEMBLY__
+typedef struct ppc_board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+/*Driver will seek for theese values */
+#define SOC_DRV_MEM_START	0xA0000000
+#define SOC_DRV_MEM_BASE	0xA18A0000
+#define SOC_DRV_MEM_END		0xA2000000
+
+/*Spi device */
+#define PLAT_HAS_M25P80
+#define PLAT_HAS_MMC
+
+#define M25P80_CS   0
+#define MMC_CS		1
+
+/* isp 1161 usb host device  */
+#define ISP1161_MEM_START	0xfa000002
+#define ISP1161_IRQ			27
+
+/* network device */
+#define DM9000_MEM_START	0xfee00000
+#define DM9000_MEM_SIZE		0x00001000
+#define DM9000_IRQ		26
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox compatible rel00k210"
+
+#endif				/* __ASM_RELOOK210_H__ */
+#endif				/* __KERNEL__ */
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook300.c linux-2.6.17/arch/ppc/platforms/4xx/relook300.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook300.c	2008-03-03 19:45:04.000000000 +0100
@@ -0,0 +1,88 @@
+/*
+ * arch/ppc/platforms/4xx/relook300.c
+ *
+ * Support for the DGStation relook300 board.
+ *
+ * Author: Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+#include <linux/delay.h>
+#include <asm/machdep.h>
+
+static struct resource pdiusbd12_resources[] =
+{
+	{
+		.start	= PDIUSBD12_MEM_START,
+		.end	= PDIUSBD12_MEM_START+PDIUSBD12_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= PDIUSBD12_IRQ,
+		.end	= PDIUSBD12_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pdiusbd12_device = {
+	.name		= "pdiusbd12_udc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(pdiusbd12_resources),
+	.resource	= pdiusbd12_resources,
+};
+
+static struct platform_device *relook300_devs[] __initdata = {
+	&pdiusbd12_device,
+};
+
+static int __init
+relook300_platform_add_devices(void)
+{
+	return platform_add_devices(relook300_devs, ARRAY_SIZE(relook300_devs));
+}
+
+device_initcall(relook300_platform_add_devices);
+
+void __init
+relook300_setup_arch(void)
+{
+	printk(KERN_INFO "relook300 DGStation Co. http://www.dgstation.co.kr\n");
+
+	ppc4xx_setup_arch();
+}
+
+void __init
+relook300_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++) {
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STB03xxx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	
+	}
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = relook300_setup_arch;
+	ppc_md.setup_io_mappings = relook300_map_io;
+}
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook300.h linux-2.6.17/arch/ppc/platforms/4xx/relook300.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook300.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook300.h	2008-03-03 19:45:04.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * arch/ppc/platforms/4xx/relook300.h
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RELOOK300_H__
+#define __ASM_RELOOK300_H__
+
+/* relook300 has an STB034xx core */
+#include <platforms/4xx/ibmstb3.h>
+
+#ifndef __ASSEMBLY__
+typedef struct board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+#define PDIUSBD12_MEM_START	0xff500000
+#define PDIUSBD12_MEM_SIZE	0x00001000
+#define PDIUSBD12_IRQ		26
+
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(324000000 / 16 / 16)
+
+#define PPC4xx_MACHINE_NAME	"DGStation relook300"
+
+#endif				/* __ASM_RELOOK300_H__ */
+#endif				/* __KERNEL__ */
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook400.c linux-2.6.17/arch/ppc/platforms/4xx/relook400.c
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook400.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook400.c	2008-03-03 19:45:04.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+ * arch/ppc/platforms/4xx/relook400.c
+ *
+ * Support for the DGStation relook400 board.
+ *
+ * Author: Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+#include <linux/delay.h>
+#include <asm/machdep.h>
+#include <linux/dm9000.h>
+
+
+/*
+ * Define all of the IRQ senses and polarities.
+ */
+
+unsigned char ppc4xx_uic_ext_irq_cfg[] __initdata = {
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 17: Ext Int 7 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 18: Ext Int 8 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 19: Ext Int 9 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 25: Ext Int 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 26: Ext Int 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 27: Ext Int 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 28: Ext Int 3 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 29: Ext Int 4 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 30: Ext Int 5 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 31: Ext Int 6 */
+};
+
+/* system devices*/
+static struct resource stb2500soc_resources[] ={
+	[0] = {
+		.start	= SOC_DRV_MEM_BASE,
+		.end	= SOC_DRV_MEM_END,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device stb2500soc_device =
+{
+	.name		= "stb2500soc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(stb2500soc_resources),
+	.resource	= stb2500soc_resources,
+};
+
+/* client usb device */
+static struct resource pdiusbd12_resources[] =
+{
+	{
+		.start	= PDIUSBD12_MEM_START,
+		.end	= PDIUSBD12_MEM_START+PDIUSBD12_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= PDIUSBD12_IRQ,
+		.end	= PDIUSBD12_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pdiusbd12_device =
+{
+	.name		= "pdiusbd12_udc",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(pdiusbd12_resources),
+	.resource	= pdiusbd12_resources,
+};
+
+/* nand flash memory */
+static struct resource nandmem_resources[] =
+{
+	{
+		.start	= NANDMEM_MEM_START,
+		.end	= NANDMEM_MEM_START + NANDMEM_MEM_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device nandmem_device =
+{
+	.name		= "nand",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(nandmem_resources),
+	.resource	= nandmem_resources,
+};
+
+/* network device */
+static struct resource dm9000_resources[] ={
+	[0] = {
+		.start	= DM9000_MEM_START,
+		.end	= DM9000_MEM_START+DM9000_MEM_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= DM9000_IRQ,
+		.end	= DM9000_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*
+static struct dm9000_plat_data dgs_dm9k_platdata = {
+	.flags		= DM9000_PLATF_16BITONLY,
+};
+*/
+
+static struct platform_device dm9000_device =
+{
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource	= dm9000_resources,
+	/*
+	.dev		= {
+		.platform_data = &dgs_dm9k_platdata,
+	}
+	*/
+};
+
+/* platform device list */
+static struct platform_device *relook400_devs[] __initdata =
+{
+	&stb2500soc_device,
+	&dm9000_device,
+	&pdiusbd12_device,
+	&nandmem_device,
+};
+
+static int __init
+relook400_platform_add_devices(void)
+{
+	return platform_add_devices(relook400_devs, ARRAY_SIZE(relook400_devs));
+}
+
+void __init
+relook400_setup_arch(void)
+{
+	printk(KERN_INFO "relook400 DGStation Co. http://www.dgstation.co.kr\n");
+	ppc4xx_setup_arch();
+}
+device_initcall(relook400_platform_add_devices);
+
+void __init
+relook400_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++)
+	{
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STBx25xx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	}
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = relook400_setup_arch;
+	ppc_md.setup_io_mappings = relook400_map_io;
+}
+
diff -Naur archive/linux-2.6.17/arch/ppc/platforms/4xx/relook400.h linux-2.6.17/arch/ppc/platforms/4xx/relook400.h
--- archive/linux-2.6.17/arch/ppc/platforms/4xx/relook400.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/arch/ppc/platforms/4xx/relook400.h	2008-03-16 23:32:34.000000000 +0100
@@ -0,0 +1,66 @@
+/*
+ * arch/ppc/platforms/4xx/relook400.h
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RELOOK400_H__
+#define __ASM_RELOOK400_H__
+
+#define PLATFORM_DGS_RELOOK400S
+
+/* relook400 has an STBx25xx core */
+#include <platforms/4xx/ibmstbx25.h>
+
+#ifndef __ASSEMBLY__
+typedef struct ppc_board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+/*Driver will seek for theese values */
+#define SOC_DRV_MEM_START	0xA0000000
+#define SOC_DRV_MEM_BASE	0xA18A0000
+#define SOC_DRV_MEM_END		0xA2000000
+
+/* network device */
+#define DM9000_MEM_START	0xfee00000
+#define DM9000_MEM_SIZE		0x00001000
+#define DM9000_IRQ		29
+
+/* usb client device */
+#define PDIUSBD12_MEM_START	0xfef00000
+#define PDIUSBD12_MEM_SIZE	0x00001000
+#define PDIUSBD12_IRQ		26
+
+/* nand flash memory */
+#define NANDMEM_MEM_START	0xfed00000
+#define NANDMEM_MEM_SIZE	0x00000100
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox compatible rel00k400s"
+
+#endif				/* __ASM_RELOOK400_H__ */
+#endif				/* __KERNEL__ */
diff -Naur archive/linux-2.6.17/arch/ppc/syslib/ppc4xx_dma.c linux-2.6.17/arch/ppc/syslib/ppc4xx_dma.c
--- archive/linux-2.6.17/arch/ppc/syslib/ppc4xx_dma.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/syslib/ppc4xx_dma.c	2007-08-30 09:04:18.000000000 +0200
@@ -451,7 +451,7 @@
 		return DMA_STATUS_BAD_CHANNEL;
 	}
 
-#if DCRN_POL > 0
+#ifdef DCRN_POL
 	polarity = mfdcr(DCRN_POL);
 #else
 	polarity = 0;
@@ -466,7 +466,7 @@
 	/* clear all polarity signals and then "or" in new signal levels */
 	polarity &= ~GET_DMA_POLARITY(dmanr);
 	polarity |= p_init->polarity;
-#if DCRN_POL > 0
+#ifdef DCRN_POL
 	mtdcr(DCRN_POL, polarity);
 #endif
 	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
@@ -513,7 +513,7 @@
 
 	memcpy(p_dma_ch, &dma_channels[dmanr], sizeof (ppc_dma_ch_t));
 
-#if DCRN_POL > 0
+#ifdef DCRN_POL 
 	polarity = mfdcr(DCRN_POL);
 #else
 	polarity = 0;
diff -Naur archive/linux-2.6.17/arch/ppc/syslib/ppc4xx_setup.c linux-2.6.17/arch/ppc/syslib/ppc4xx_setup.c
--- archive/linux-2.6.17/arch/ppc/syslib/ppc4xx_setup.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/arch/ppc/syslib/ppc4xx_setup.c	2007-08-30 09:04:18.000000000 +0200
@@ -47,6 +47,7 @@
 extern void abort(void);
 extern void ppc4xx_find_bridges(void);
 
+ 
 /* Global Variables */
 bd_t __res;
 
@@ -272,7 +273,6 @@
 #ifdef CONFIG_SERIAL_TEXT_DEBUG
 	ppc_md.progress = gen550_progress;
 #endif
-
 #if defined(CONFIG_PCI) && defined(CONFIG_IDE)
 	ppc_ide_md.ide_init_hwif = ppc4xx_ide_init_hwif_ports;
 #endif /* defined(CONFIG_PCI) && defined(CONFIG_IDE) */
diff -Naur archive/linux-2.6.17/drivers/base/power/shutdown.c linux-2.6.17/drivers/base/power/shutdown.c
--- archive/linux-2.6.17/drivers/base/power/shutdown.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/base/power/shutdown.c	2007-08-30 09:04:22.000000000 +0200
@@ -35,10 +35,12 @@
  */
 void device_shutdown(void)
 {
-	struct device * dev, *devn;
-
+	struct device * dev;
+	//struct device * devn;
 	down_write(&devices_subsys.rwsem);
-	list_for_each_entry_safe_reverse(dev, devn, &devices_subsys.kset.list,
+	//Safe is commented as it seems to hang the systems
+	//list_for_each_entry_safe_reverse(dev, devn, &devices_subsys.kset.list,
+	list_for_each_entry_reverse(dev, &devices_subsys.kset.list,
 				kobj.entry) {
 		if (dev->bus && dev->bus->shutdown) {
 			dev_dbg(dev, "shutdown\n");
diff -Naur archive/linux-2.6.17/drivers/char/Kconfig linux-2.6.17/drivers/char/Kconfig
--- archive/linux-2.6.17/drivers/char/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/char/Kconfig	2007-08-30 09:04:23.000000000 +0200
@@ -569,7 +569,6 @@
 	  It will automatically be selected if one of the back-end console drivers
 	  is selected.
 
-
 config HVC_CONSOLE
 	bool "pSeries Hypervisor Virtual Console support"
 	depends on PPC_PSERIES
@@ -862,6 +861,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called sonypi.
 
+config IBM_GPIO
+	tristate "IBM GPIO"
+	depends on IBM_OCP
+
 config TANBAC_TB0219
 	tristate "TANBAC TB0219 base board support"
 	depends TANBAC_TB022X
diff -Naur archive/linux-2.6.17/drivers/char/Makefile linux-2.6.17/drivers/char/Makefile
--- archive/linux-2.6.17/drivers/char/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/char/Makefile	2007-08-30 09:04:23.000000000 +0200
@@ -58,6 +58,7 @@
 obj-$(CONFIG_DTLK)		+= dtlk.o
 obj-$(CONFIG_R3964)		+= n_r3964.o
 obj-$(CONFIG_APPLICOM)		+= applicom.o
+obj-$(CONFIG_IBM_GPIO)		+= ibm_gpio.o
 obj-$(CONFIG_SONYPI)		+= sonypi.o
 obj-$(CONFIG_RTC)		+= rtc.o
 obj-$(CONFIG_HPET)		+= hpet.o
diff -Naur archive/linux-2.6.17/drivers/char/ibm_gpio.c linux-2.6.17/drivers/char/ibm_gpio.c
--- archive/linux-2.6.17/drivers/char/ibm_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/char/ibm_gpio.c	2007-08-30 09:04:24.000000000 +0200
@@ -0,0 +1,391 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *	TODO: devfs
+ *
+ *	Version: 02/01/12 - Armin
+ *			 converted to ocp and using ioremap
+ *
+ *	1.2 02/21/01 - Armin
+ *		minor compiler warning fixes
+ *
+ *	1.3 02/22/01 - Armin
+ *		added apm
+ *
+ *	1.4 05/07/02 - Armin/David Mueller
+ *		coverted to core_ocp[];
+ *
+ *	1.5 05/25/02 - Armin
+ *	 name change from *_driver to *_dev
+ *
+ *	1.6 06/04/02 - Matt Porter
+ *	ioremap paddr. Comment as 4xx generic driver.
+ *	Fix header to be userland safe and locate in
+ *	an accessible area.  Add ioctl to configure
+ *	multiplexed GPIO pins.
+ *
+ *	1.7 07/25/02 - Armin
+ *	added CPM to enable/disable in init/exit
+ *
+ */
+
+#define VUFX "07.25.02"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <linux/ibm_gpio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+
+struct miscdevice ibm_gpio_miscdev;
+static struct gpio_regs *gpiop;
+static struct ocp_driver ibm_gpio_driver;
+
+#ifdef CONFIG_PM
+static struct pm_dev *pm_gpio;
+
+static int
+gpio_save_state(u32 state)
+{
+	return 0;
+}
+
+static int
+gpio_suspend(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | state);
+	return 0;
+}
+
+static int
+gpio_resume(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~state);
+	return 0;
+}
+#endif
+
+int
+ibm_gpio_config(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+
+#ifdef CONFIG_40x
+#ifdef DCRN_CHCR0
+	{
+		u32 cfg_reg;
+
+		/*
+		 * PPC405 uses CPC0_CR0 to select multiplexed GPIO pins.
+		 */
+		cfg_reg = mfdcr(DCRN_CHCR0);
+		cfg_reg = (cfg_reg & ~mask) | (data & mask);
+		mtdcr(DCRN_CHCR0, cfg_reg);
+	}
+#endif
+#elif CONFIG_440GP
+	{
+		u32 cfg_reg;
+
+		/*
+		 * PPC440GP uses CPC0_GPIO to select multiplexed GPIO pins.
+		 */
+		cfg_reg = mfdcr(DCRN_CPC0_GPIO);
+		cfg_reg = (cfg_reg & ~mask) | (data & mask);
+		mtdcr(DCRN_CPC0_GPIO, cfg_reg);
+	}
+#elif CONFIG_440GX
+	{
+		u32 cfg_reg;
+
+		/*
+		 * PPC440GX uses SDR0_PFC0 to select multiplexed GPIO pins
+		 */
+		cfg_reg = SDR_READ(DCRN_SDR_PFC0);
+		cfg_reg = (cfg_reg & ~mask) | (data & mask);
+		SDR_WRITE(DCRN_SDR_PFC0, cfg_reg);
+	}
+#else
+#error This driver is only supported on PPC40x and PPC440 CPUs
+#endif
+
+	return 0;
+}
+
+int
+ibm_gpio_tristate(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = (gpiop->tcr & ~mask) | (data & mask);
+	return 0;
+}
+
+int
+ibm_gpio_open_drain(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->odr = (gpiop->odr & ~mask) | (data & mask);
+
+	return 0;
+}
+
+int
+ibm_gpio_in(__u32 device, __u32 mask, volatile __u32 * data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = gpiop->tcr & ~mask;
+	eieio();
+
+	/*
+	   ** If the previous state was OUT, and gpiop->ir is read once, then the
+	   ** data that was being OUTput will be read.  One way to get the right
+	   ** data is to read gpiop->ir twice.
+	 */
+
+	*data = gpiop->ir;
+	*data = gpiop->ir & mask;
+	eieio();
+	return 0;
+}
+
+int
+ibm_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->or = (gpiop->or & ~mask) | (data & mask);
+	eieio();
+	gpiop->tcr = gpiop->tcr | mask;
+	eieio();
+	return 0;
+}
+
+static int
+ibm_gpio_open(struct inode *inode, struct file *file)
+{
+	//MOD_INC_USE_COUNT;
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int
+ibm_gpio_release(struct inode *inode, struct file *file)
+{
+	//MOD_DEC_USE_COUNT;
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static int
+ibm_gpio_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	static struct ibm_gpio_ioctl_data ioctl_data;
+	int status;
+
+	switch (cmd) {
+	case IBMGPIO_IN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		status = ibm_gpio_in(ioctl_data.device,
+				     ioctl_data.mask, &ioctl_data.data);
+		if (status != 0)
+			return status;
+
+		if (copy_to_user((struct ibm_gpio_ioctl_data *) arg,
+				 &ioctl_data, sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		break;
+
+	case IBMGPIO_OUT:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_out(ioctl_data.device,
+				    ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_OPEN_DRAIN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_open_drain(ioctl_data.device,
+					   ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_TRISTATE:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_tristate(ioctl_data.device,
+					 ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_CFG:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_config(ioctl_data.device,
+				ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+	return 0;
+}
+
+static struct file_operations ibm_gpio_fops = {
+	owner:THIS_MODULE,
+	ioctl:ibm_gpio_ioctl,
+	open:ibm_gpio_open,
+	release:ibm_gpio_release,
+};
+
+static int __init
+ibm_gpio_probe(struct ocp_device *ocp)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+
+	ibm_gpio_miscdev.minor = 185;
+	ibm_gpio_miscdev.name = ibm_gpio_driver.name;
+	ibm_gpio_miscdev.fops = &ibm_gpio_fops;
+	misc_register(&ibm_gpio_miscdev);
+
+	gpiop = (struct gpio_regs *) ioremap(ocp->def->paddr,
+			sizeof(struct gpio_regs));
+	printk("GPIO #%d at 0x%lx\n", ocp->def->index,
+			(unsigned long) gpiop);
+
+
+	return 0;
+}
+
+static void __exit
+ibm_gpio_remove(struct ocp_device *ocp)
+{
+	misc_deregister(&ibm_gpio_miscdev);
+}
+
+static struct ocp_device_id ibm_gpio_ids[] __devinitdata =
+{
+	{ .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_GPIO },
+	{ .vendor = OCP_VENDOR_INVALID }
+};
+
+static struct ocp_driver ibm_gpio_driver =
+{
+	.name           = "ibm_gpio",
+	.id_table       = ibm_gpio_ids,
+	.probe          = ibm_gpio_probe,
+	.remove         = __devexit_p(ibm_gpio_remove),
+#if defined(CONFIG_PM)
+	.suspend        = NULL,
+	.resume         = NULL,
+#endif
+};
+
+static int __init
+ibm_gpio_init(void)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+	return ocp_register_driver(&ibm_gpio_driver);
+}
+
+static void __exit
+ibm_gpio_exit(void)
+{
+	ocp_unregister_driver(&ibm_gpio_driver);
+}
+
+module_init(ibm_gpio_init);
+module_exit(ibm_gpio_exit);
+
+EXPORT_SYMBOL(ibm_gpio_tristate);
+EXPORT_SYMBOL(ibm_gpio_open_drain);
+EXPORT_SYMBOL(ibm_gpio_in);
+EXPORT_SYMBOL(ibm_gpio_out);
+
+MODULE_LICENSE("GPL");
diff -Naur archive/linux-2.6.17/drivers/i2c/busses/i2c-ibm_iic.c linux-2.6.17/drivers/i2c/busses/i2c-ibm_iic.c
--- archive/linux-2.6.17/drivers/i2c/busses/i2c-ibm_iic.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/i2c/busses/i2c-ibm_iic.c	2007-08-30 09:04:25.000000000 +0200
@@ -58,6 +58,10 @@
 module_param(iic_force_fast, bool, 0);
 MODULE_PARM_DESC(iic_fast_poll, "Force fast mode (400 kHz)");
 
+#if defined(CONFIG_RELOOK100S)|| defined(CONFIG_RELOOK200S) || defined(CONFIG_RELOOK210) || defined(CONFIG_RELOOK300) || defined(CONFIG_RELOOK400) || defined(CONFIG_RELOOK500S) || defined(CONFIG_RELOOK500T) || defined(CONFIG_RELOOK510S)
+#define NO_DIRECTCTL
+#endif
+
 #define DBG_LEVEL 0
 
 #ifdef DBG
@@ -89,13 +93,20 @@
 	       KERN_DEBUG "  xtcntlss = 0x%02x, directcntl = 0x%02x\n",
 		in_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts), 
 		in_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt), 
-		in_8(&iic->xtcntlss), in_8(&iic->directcntl));
+		in_8(&iic->xtcntlss),
+#ifndef NO_DIRECTCTL
+	       	in_8(&iic->directcntl)
+#else
+		0xff
+#endif		
+		);
 }
 #  define DUMP_REGS(h,dev)	dump_iic_regs((h),(dev))
 #else
 #  define DUMP_REGS(h,dev)	((void)0)
 #endif
 
+#ifndef NO_DIRECTCTL
 /* Bus timings (in ns) for bit-banging */
 static struct i2c_timings {
 	unsigned int hd_sta;
@@ -120,6 +131,7 @@
 	.high 	= 600,
 	.buf	= 1300,
 }};
+#endif 
 
 /* Enable/disable interrupt generation */
 static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)
@@ -178,40 +190,45 @@
 static void iic_dev_reset(struct ibm_iic_private* dev)
 {
 	volatile struct iic_regs __iomem *iic = dev->vaddr;
-	int i;
-	u8 dc;
 	
 	DBG("%d: soft reset\n", dev->idx);
 	DUMP_REGS("reset", dev);
 	
     	/* Place chip in the reset state */
 	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
-	
-	/* Check if bus is free */
-	dc = in_8(&iic->directcntl);	
-	if (!DIRCTNL_FREE(dc)){
-		DBG("%d: trying to regain bus control\n", dev->idx);
-	
-		/* Try to set bus free state */
-		out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);	
-	
-		/* Wait until we regain bus control */
-		for (i = 0; i < 100; ++i){
-			dc = in_8(&iic->directcntl);
-			if (DIRCTNL_FREE(dc))
-				break;
-			
-			/* Toggle SCL line */
-			dc ^= DIRCNTL_SCC;
-			out_8(&iic->directcntl, dc);
-			udelay(10);
-			dc ^= DIRCNTL_SCC;
-			out_8(&iic->directcntl, dc);
-			
-			/* be nice */
-			cond_resched();
+
+#ifndef NO_DIRECTCTL
+	{
+		int i;
+		u8 dc;
+	
+		/* Check if bus is free */
+		dc = in_8(&iic->directcntl);	
+		if (!DIRCTNL_FREE(dc)){
+			DBG("%d: trying to regain bus control\n", dev->idx);
+		
+			/* Try to set bus free state */
+			out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);	
+		
+			/* Wait until we regain bus control */
+			for (i = 0; i < 100; ++i){
+				dc = in_8(&iic->directcntl);
+				if (DIRCTNL_FREE(dc))
+					break;
+				
+				/* Toggle SCL line */
+				dc ^= DIRCNTL_SCC;
+				out_8(&iic->directcntl, dc);
+				udelay(10);
+				dc ^= DIRCNTL_SCC;
+				out_8(&iic->directcntl, dc);
+				
+				/* be nice */
+				cond_resched();
+			}
 		}
 	}
+#endif
 	
 	/* Remove reset */
 	out_8(&iic->xtcntlss, 0);
@@ -220,6 +237,7 @@
 	iic_dev_init(dev);
 }
 
+#ifndef NO_DIRECTCTL
 /*
  * Do 0-length transaction using bit-banging through IIC_DIRECTCNTL register.
  */
@@ -317,6 +335,7 @@
 	res = -EREMOTEIO;
 	goto out;
 }
+#endif
 
 /*
  * IIC interrupt handler
@@ -570,6 +589,7 @@
 	}		
 	for (i = 0; i < num; ++i){
 		if (unlikely(msgs[i].len <= 0)){
+#ifndef NO_DIRECTCTL
 			if (num == 1 && !msgs[0].len){
 				/* Special case for I2C_SMBUS_QUICK emulation.
 				 * IBM IIC doesn't support 0-length transactions
@@ -577,6 +597,7 @@
 				 */
 				return iic_smbus_quick(dev, &msgs[0]);
 			}
+#endif
 			DBG("%d: invalid len %d in msg[%d]\n", dev->idx, 
 				msgs[i].len, i);
 			return -EINVAL;
@@ -631,6 +652,7 @@
 	.functionality	= iic_func
 };
 
+#if !defined(CONFIG_RELOOK100S) && !defined(CONFIG_RELOOK200S) && !defined(CONFIG_RELOOK210) && !defined(CONFIG_RELOOK300) && !defined(CONFIG_RELOOK400) && !defined(CONFIG_RELOOK500S) && !defined(CONFIG_RELOOK500T) && !defined(CONFIG_RELOOK510S)
 /*
  * Calculates IICx_CLCKDIV value for a specific OPB clock frequency
  */
@@ -657,6 +679,7 @@
 	}
 	return (u8)((opb + 9) / 10 - 1);
 }
+#endif
 
 /*
  * Register single IIC interface
@@ -714,7 +737,11 @@
 	/* clckdiv is the same for *all* IIC interfaces, 
 	 * but I'd rather make a copy than introduce another global. --ebs
 	 */
+#if !defined(CONFIG_RELOOK100S) && !defined(CONFIG_RELOOK200S) && !defined(CONFIG_RELOOK210) && !defined(CONFIG_RELOOK300) && !defined(CONFIG_RELOOK400) && !defined(CONFIG_RELOOK500S) && !defined(CONFIG_RELOOK500T) && !defined(CONFIG_RELOOK510S)	 
 	dev->clckdiv = iic_clckdiv(ocp_sys_info.opb_bus_freq);
+#else
+	dev->clckdiv = 0x05;
+#endif
 	DBG("%d: clckdiv = %d\n", dev->idx, dev->clckdiv);
 	
 	/* Initialize IIC interface */
diff -Naur archive/linux-2.6.17/drivers/i2c/i2c-dev.c linux-2.6.17/drivers/i2c/i2c-dev.c
--- archive/linux-2.6.17/drivers/i2c/i2c-dev.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/i2c/i2c-dev.c	2007-08-30 09:04:25.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/init.h>
 #include <linux/i2c.h>
 #include <linux/i2c-dev.h>
@@ -421,6 +422,8 @@
 	if (IS_ERR(i2c_dev))
 		return PTR_ERR(i2c_dev);
 
+		devfs_mk_cdev(MKDEV(I2C_MAJOR, i2c_dev->minor),
+			S_IFCHR|S_IRUSR|S_IWUSR, "i2c/%d", i2c_dev->minor);
 	pr_debug("i2c-dev: adapter [%s] registered as minor %d\n",
 		 adap->name, i2c_dev->minor);
 
@@ -451,6 +454,7 @@
 	if (!i2c_dev)
 		return -ENODEV;
 
+	devfs_remove("i2c/%d", i2c_dev->minor);
 	return_i2c_dev(i2c_dev);
 	class_device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, i2c_dev->minor));
 	kfree(i2c_dev);
@@ -498,6 +502,8 @@
 	if (res)
 		goto out_unreg_class;
 
+	devfs_mk_dir("i2c");
+	
 	return 0;
 
 out_unreg_class:
@@ -513,6 +519,7 @@
 {
 	i2c_del_driver(&i2cdev_driver);
 	class_destroy(i2c_dev_class);
+	devfs_remove("i2c");
 	unregister_chrdev(I2C_MAJOR,"i2c");
 }
 
diff -Naur archive/linux-2.6.17/drivers/ide/Kconfig linux-2.6.17/drivers/ide/Kconfig
--- archive/linux-2.6.17/drivers/ide/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/ide/Kconfig	2007-08-30 09:04:25.000000000 +0200
@@ -962,6 +962,35 @@
 
 endchoice
 
+config BLK_DEV_IDE_STB04xxx
+	tristate "STB04xxx (Redwood-5) IDE support"
+	depends on BLK_DEV_IDE 
+	help
+	  This option provides support for IDE on IBM STB04xxx Redwood-5
+	  systems.
+
+	  If unsure, say N.
+
+config BLK_DEV_IDE_DMVULCAN
+	tristate "VULCAN (Redwood-6) IDE support"
+	depends on BLK_DEV_IDE 
+	select BLK_DEV_IDEDMA
+	help
+	  This option provides support for IDE on IBM Vulcan Redwood-6
+	  systems.
+
+	  If unsure, say N.
+
+config BLK_DEV_IDE_STB2500
+	tristate "VULCAN (Redwood-6) IDE support"
+	depends on BLK_DEV_IDE 
+	select BLK_DEV_IDEDMA
+	help
+	  This option provides support for IDE on IBM Vulcan Redwood-6
+	  systems.
+
+	  If unsure, say N.
+
 # no isa -> no vlb
 config IDE_CHIPSETS
 	bool "Other IDE chipset support"
diff -Naur archive/linux-2.6.17/drivers/ide/Makefile linux-2.6.17/drivers/ide/Makefile
--- archive/linux-2.6.17/drivers/ide/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/ide/Makefile	2007-08-30 09:04:25.000000000 +0200
@@ -36,6 +36,9 @@
 # built-in only drivers from ppc/
 ide-core-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+= ppc/mpc8xx.o
 ide-core-$(CONFIG_BLK_DEV_IDE_PMAC)	+= ppc/pmac.o
+ide-core-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ppc/ibm_ocp_ide.o
+ide-core-$(CONFIG_BLK_DEV_IDE_DMVULCAN)	+= ppc/vulcan.o
+ide-core-$(CONFIG_BLK_DEV_IDE_STB2500)	+= ppc/stbxxxxx.o
 
 # built-in only drivers from h8300/
 ide-core-$(CONFIG_H8300)		+= h8300/ide-h8300.o
diff -Naur archive/linux-2.6.17/drivers/ide/ide-disk.c linux-2.6.17/drivers/ide/ide-disk.c
--- archive/linux-2.6.17/drivers/ide/ide-disk.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/ide/ide-disk.c	2007-08-30 09:04:25.000000000 +0200
@@ -487,7 +487,7 @@
 {
 	unsigned long long capacity, set_max;
 	int lba48 = idedisk_supports_lba48(drive->id);
-
+	
 	capacity = drive->capacity64;
 	if (lba48)
 		set_max = idedisk_read_native_max_address_ext(drive);
diff -Naur archive/linux-2.6.17/drivers/ide/ide.c linux-2.6.17/drivers/ide/ide.c
--- archive/linux-2.6.17/drivers/ide/ide.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/ide/ide.c	2007-08-30 09:04:25.000000000 +0200
@@ -1487,6 +1487,15 @@
 static int __initdata probe_qd65xx;
 extern int qd65xx_init(void);
 #endif
+#ifdef CONFIG_BLK_DEV_IDE_STB04xxx
+extern int stb04xxx_ide_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_IDE_DMVULCAN
+extern int vulcan_ide_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_IDE_STB2500
+extern int stbxxxx_ide_init(void);
+#endif
 
 static int __initdata is_chipset_set[MAX_HWIFS];
 
@@ -2027,6 +2036,15 @@
 	if (probe_qd65xx)
 		(void)qd65xx_init();
 #endif
+#ifdef CONFIG_BLK_DEV_IDE_STB04xxx
+	(void)stb04xxx_ide_init();
+#endif
+#ifdef CONFIG_BLK_DEV_IDE_DMVULCAN
+	(void)vulcan_ide_init();
+#endif
+#ifdef CONFIG_BLK_DEV_IDE_STB2500
+	(void)stbxxxx_ide_init();
+#endif
 
 	initializing = 1;
 	/* Probe for special PCI and other "known" interface chipsets. */
diff -Naur archive/linux-2.6.17/drivers/ide/ppc/ibm_ocp_ide.c linux-2.6.17/drivers/ide/ppc/ibm_ocp_ide.c
--- archive/linux-2.6.17/drivers/ide/ppc/ibm_ocp_ide.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/ide/ppc/ibm_ocp_ide.c	2007-08-30 09:04:25.000000000 +0200
@@ -0,0 +1,911 @@
+	/*
+ * IDE driver for IBM On-chip IDE contollers
+ *    Copyright 2001 - 2002 MontaVista Software Inc.
+ *    Dan Malek.
+ *
+ *    Version 1.2 (01/30/12) Armin
+ *    Converted to ocp
+ *    merger up to new ide-timing.h
+ *
+ *    Version 2.0 (05/02/15) - armin
+ *    converted to new core_ocp and only supports one interface for now.
+ *
+ *    Version 2.1 (05/25/02) - armin
+ *      name change from *_driver to *_dev
+ *    Version 2.2 06/13/02 - Armin
+ *      changed irq_resource array to just irq
+ *
+ *    Version 2.3 (Feb 2005) - andre
+ *      - big rewrite to fix some serious bugs
+ *      - bring up to date with ide in 2.6.11-rc3
+ *      - DMA works correctly now, even with non-hard-disks
+ *        I snagged bits and pieces from a variety of drivers, primarily
+ *        ide-pmac.c and ide-dma.c .....thanks to previous authors!
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <ide-timing.h>
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/dma-mapping.h>
+
+#define OCPVR	"2.3"
+
+#ifdef CONFIG_DREAMBOX_DUAL_IDE
+#define NR_HWIF 2
+
+#ifdef CONFIG_DM7020
+static void dreambox_set_ide_bus(int bus)
+{
+#define MUXO 0x36
+#define MUXOD 0x37
+#define MUXTC 0x38
+	unsigned long temp = mfdcr(MUXO);
+	if (!bus)
+		temp |=  0x80000000 >> 25;
+	else
+		temp &=~(0x80000000 >> 25);
+	mtdcr(MUXO, temp);
+}
+#endif
+
+#else
+#define NR_HWIF 1
+#endif
+
+#define MK_TIMING(AS, DIOP, DIOY, DH) \
+	((FIT((AS),    0, 0x0f) << 27) | \
+	 (FIT((DIOP),  0, 0x3f) << 20) | \
+	 (FIT((DIOY),  0, 0x3f) << 13) | \
+	 (FIT((DH),    0, 0x07) <<  9))
+
+#define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+
+#define MK_UTIMING(CYC, RP) \
+	((FIT(UTIMING_SETHLD, 0, 0x0f) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 0x0f) << 22) | \
+	 (FIT((CYC),          0, 0x0f) << 17) | \
+	 (FIT((RP),           0, 0x3f) << 10) | \
+	 (FIT(UTIMING_SS,     0, 0x0f) <<  5) | \
+	 1 /* Turn on Ultra DMA */)
+
+/* Define the period of the STB clock used to generate the
+ * IDE bus timing.  The clock is actually 63 MHz, but it
+ * gets rounded in a favorable direction.
+ */
+#define IDE_SYS_FREQ	63	/* MHz */
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)   /* 1takt == SYS_CLOCK_NS nanosekunden */
+
+struct whold_timing {
+	short mode;
+	short whold;
+};
+
+static const struct whold_timing whold_timing[] = {
+
+	{XFER_UDMA_5, 0},
+	{XFER_UDMA_4, 0},
+	{XFER_UDMA_3, 0},
+
+	{XFER_UDMA_2, 0},
+	{XFER_UDMA_1, 0},
+	{XFER_UDMA_0, 0},
+
+	{XFER_UDMA_SLOW, 0},
+
+	{XFER_MW_DMA_2, 0},
+	{XFER_MW_DMA_1, 0},
+	{XFER_MW_DMA_0, 0},
+
+	{XFER_SW_DMA_2, 0},
+	{XFER_SW_DMA_1, 0},
+	{XFER_SW_DMA_0, 10},
+
+	{XFER_PIO_5, 10},
+	{XFER_PIO_4, 10},
+	{XFER_PIO_3, 15},
+
+	{XFER_PIO_2, 20},
+	{XFER_PIO_1, 30},
+	{XFER_PIO_0, 50},
+
+	{XFER_PIO_SLOW,},
+
+	{-1}
+};
+
+/* The interface doesn't have register/PIO timing for each device,
+ * but rather "fast" and "slow" timing.  We have to determeine
+ * which is the "fast" device based upon their capability.
+ */
+static int pio_mode[2] = { -1, -1 };
+
+
+/* structure of the memory mapped IDE control */
+typedef struct ide_regs {
+	unsigned int si_stat;	/* IDE status */
+	unsigned int si_intenable;	/* IDE interrupt enable */
+	unsigned int si_control;	/* IDE control */
+	unsigned int pad0[0x3d];
+	unsigned int si_c0rt;	/* Chan 0 Register transfer timing */
+	unsigned int si_c0fpt;	/* Chan 0 Fast PIO transfer timing */
+	unsigned int si_c0timo;	/* Chan 0 timeout */
+	unsigned int pad1[2];
+	unsigned int si_c0d0u;	/* Chan 0 dev 0 UDMA timing */
+#define si_c0d0m si_c0d0u	/* Chan 0 dev 0 Multiword DMA timing */
+	unsigned int pad2;
+	unsigned int si_c0d1u;	/* Chan 0 dev 1 UDMA timing */
+#define si_c0d1m si_c0d1u	/* Chan 0 dev 1 Multiword DMA timing */
+	unsigned int si_c0c;	/* Chan 0 Control */
+	unsigned int si_c0s0;	/* Chan 0 Status 0 */
+	unsigned int si_c0ie;	/* Chan 0 Interrupt Enable */
+	unsigned int si_c0s1;	/* Chan 0 Status 0 */
+	unsigned int pad4[4];
+	unsigned int si_c0dcm;	/* Chan 0 DMA Command */
+	unsigned int si_c0tb;	/* Chan 0 PRD Table base address */
+	unsigned int si_c0dct;	/* Chan 0 DMA Count */
+	unsigned int si_c0da;	/* Chan 0 DMA Address */
+	unsigned int si_c0sr;	/* Chan 0 Slew Rate Output Control */
+	unsigned char pad5[0xa2];
+	unsigned short si_c0adc;	/* Chan 0 Alt status/control */
+	unsigned char si_c0d;	/* Chan 0 data */
+	unsigned char si_c0ef;	/* Chan 0 error/features */
+	unsigned char si_c0sct;	/* Chan 0 sector count */
+	unsigned char si_c0sn;	/* Chan 0 sector number */
+	unsigned char si_c0cl;	/* Chan 0 cylinder low */
+	unsigned char si_c0ch;	/* Chan 0 cylinder high */
+	unsigned char si_c0dh;	/* Chan 0 device/head */
+	unsigned char si_c0scm;	/* Chan 0 status/command */
+} ide_t;
+
+#if NR_HWIF == 2
+static int shadow_valid;
+static ide_t shadow_regs;
+static int current_bus = -1;
+static void dreambox_ide_selectproc(ide_drive_t *drive)
+{
+	volatile ide_t __iomem * const idp = HWIF (drive)->hwif_data;
+	int newbus = drive->hwif->index;
+	if (current_bus != newbus)
+	{
+//		printk("select %d\n", newbus);
+		if (current_bus != -1)
+		{
+			if (!shadow_valid)
+			{
+				printk("initializing!\n");
+#define SWAP(x) shadow_regs.si_##x = idp->si_##x;
+				SWAP(c0rt);
+				SWAP(c0fpt);
+				SWAP(c0timo);
+				SWAP(c0d0u);
+				SWAP(c0d1u);
+				SWAP(c0c);
+#undef SWAP
+				shadow_valid = 1;
+			} else
+			{
+				u32 tmp;
+#define SWAP(x) tmp = idp->si_##x; idp->si_##x = shadow_regs.si_##x; shadow_regs.si_##x = tmp;
+				SWAP(c0rt);
+				SWAP(c0fpt);
+				SWAP(c0timo);
+				SWAP(c0d0u);
+				SWAP(c0d1u);
+				SWAP(c0c);
+#undef SWAP
+			}
+		}
+		dreambox_set_ide_bus(newbus);
+		current_bus = newbus;
+	}
+}
+#endif
+
+/* The structure of the PRD entry.  The address must be word aligned,
+ * and the count must be an even number of bytes.
+ */
+typedef struct {
+	unsigned int prd_physptr;
+	unsigned int prd_count;	/* Count only in lower 16 bits */
+} prd_entry_t;
+#define PRD_EOT		0x80000000lu	/* Set in prd_count */
+
+/* The number of PRDs required in a single transfer from the upper IDE
+ * functions. The maximum number is 128 (ide.h), but most seem to code to
+ * 256 (because of having two IDE channels). must be less than one page.
+ */
+#define NUM_PRD 256
+
+
+
+/* this is borrowed from ide_timing_find_mode so we can find the proper
+ * whold parameter
+ */
+static short
+whold_timing_find_mode(short speed)
+{
+	const struct whold_timing *t;
+
+	for (t = whold_timing; likely (t->mode >= 0); t++)
+		if (t->mode == speed)
+			return t->whold;
+
+	return 0;
+}
+
+/* The STB04 has a fixed number of cycles that get added in
+ * regardless.  Adjust an ide_timing struct to accommodate that.
+ */
+static void
+stb04xxx_ide_adjust_timing(struct ide_timing * const t)
+{
+	t->setup   -= 2;
+	t->act8b   -= 1;
+	t->rec8b   -= 1;
+	t->active  -= 1;
+	t->recover -= 1;
+}
+
+static int
+stb04xxx_ide_tune_chipset (ide_drive_t * const drive,
+			   u8           speed)
+{
+	volatile ide_t __iomem * const ide_regs  = HWIF (drive)->hwif_data;
+	ide_drive_t       *peer        = HWIF (drive)->drives + (~drive->dn & 1);
+	struct ide_timing  t, p, merge, *fast;
+	int                fast_device;
+	unsigned int       ctl;
+
+	if (speed != XFER_PIO_SLOW && speed != drive->current_speed)
+		if (ide_config_drive_speed(drive, speed))
+			printk (KERN_WARNING
+				"ide%d: Drive %d didn't accept speed setting. "
+				"Oh, well.\n",
+				HWIF(drive)->index, drive->dn & 1);
+
+	ide_timing_compute(drive, speed, &t, SYS_CLOCK_NS, SYS_CLOCK_NS);
+	stb04xxx_ide_adjust_timing(&t);
+
+	/* peer is the other, i.e. not current, drive */
+	if (peer->present) {
+		ide_timing_compute(peer, peer->current_speed, &p,
+				   SYS_CLOCK_NS, SYS_CLOCK_NS);
+		stb04xxx_ide_adjust_timing(&p);
+		ide_timing_merge(&p, &t, &merge,
+				 IDE_TIMING_8BIT | IDE_TIMING_SETUP);
+	}
+	else
+		merge = t;
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	drive->current_speed = speed;
+
+	/* Now determine which drive is faster, and set up the
+	 * interface timing.  It would sure be nice if they would
+	 * have just had the timing registers for each device......
+	 */
+	/* change pio_mode of current drive */
+	pio_mode[(drive->dn & 1)] = (int) speed;
+
+	/* Now determine which of the drives
+	 * the first call we only know one device, and on subsequent
+	 * calls the user may manually change drive parameters.
+	 * Make timing[0] the fast device and timing[1] the slow.
+	 */
+
+	/* compare pio_mode of both drives, one of them is
+	   faster than the other */
+	if (pio_mode[0] >= pio_mode[1])
+		fast_device = 0;
+	else
+		fast_device = 1;
+
+	if (fast_device == (drive->dn & 1))
+		/* if fast drive == current drive */
+		fast = &t;
+	else
+		/* if fast drive == peer (other) drive */
+		fast = &p;
+
+	/* Now we know which device is the fast one and which is
+	 * the slow one.  The merged timing goes into the "regular"
+	 * timing registers and represents the slower of both times.
+	 */
+	ide_regs->si_c0rt = MK_TIMING(merge.setup, merge.act8b,
+				      merge.rec8b,
+				      whold_timing_find_mode(merge.mode));
+
+	ide_regs->si_c0fpt = MK_TIMING(fast->setup, fast->act8b,
+				       fast->rec8b,
+				       whold_timing_find_mode(fast->mode));
+
+	/* tell the interface which drive is the fast one. 	 */
+	ctl = ide_regs->si_c0c; /* Chan 0 Control */
+	ctl &= ~0x10000000ul;
+	ctl |= fast_device << 28;
+	ide_regs->si_c0c = ctl;
+
+	/* Set up DMA timing. */
+	if ((speed & XFER_MODE) != XFER_PIO) {
+		/* NOTE: si_c0d0m and si_c0d0u are two different names
+		 * for the same register.  Whether it is used for
+		 * Multi-word DMA timings or Ultra DMA timings is
+		 * determined by the LSB written into it.  This is also
+		 * true for si_c0d1m and si_c0d1u.  */
+		volatile unsigned int __iomem *dtiming;
+		if (drive->dn & 1)
+			dtiming = &(ide_regs->si_c0d1u);
+		else
+			dtiming = &(ide_regs->si_c0d0u);
+
+		if ((speed & XFER_MODE) == XFER_UDMA) {
+			static const int tRP[] = {
+				EZ(160, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(125, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ( 85, SYS_CLOCK_NS) - 2 /*fixed cycles */
+			};
+			static const int NUMtRP =
+			    (sizeof (tRP) / sizeof (tRP[0]));
+			*dtiming =
+			    MK_UTIMING(t.udma,
+				       tRP[FIT(speed & 0xf, 0, NUMtRP - 1)]);
+		} else {
+			/* Multi-word DMA.  Note that t.recover/2 is an
+			 * approximation of MAX(tH, MAX(tJ, tN)) */
+			*dtiming = MK_TIMING(t.setup, t.active,
+					     t.recover, t.recover / 2);
+		}
+		drive->using_dma = 1;
+	}
+
+	return 0;
+}
+
+
+/**
+ *	stb04xxx_ide_tune_drive - tune a drive attached to a stb04
+ *	@drive: drive to tune
+ *	@pio: desired PIO mode (255 for "best possible")
+ *
+ *	Set the interface PIO mode.
+ */
+static void
+stb04xxx_ide_tune_drive (ide_drive_t * const drive,
+			 u8           pio)
+{
+	pio = ide_get_best_pio_mode (drive, pio, 4, NULL);
+	stb04xxx_ide_tune_chipset(drive, XFER_PIO_0 + pio);
+}
+
+static int
+stb04xxx_ide_dma_host_off (ide_drive_t * const drive)
+{
+	return 0;
+}
+static int stb04xxx_ide_dma_host_on (ide_drive_t * const drive) __attribute__((alias("stb04xxx_ide_dma_host_off")));
+
+static int
+stb04xxx_ide_dma_off_quietly (ide_drive_t * const drive)
+{
+	drive->using_dma = 0;
+	return stb04xxx_ide_dma_host_off (drive);
+}
+
+/**
+ *	stb04xxx_ide_dma_check - set up for DMA if possible
+ *	@drive: IDE drive to set up
+ *
+ *	Set up the drive for the highest supported speed considering the
+ *	driver, controller and cable
+ */
+static int
+stb04xxx_ide_dma_check (ide_drive_t * const drive)
+{
+	/* Allow UDMA_66 only if an 80 conductor cable is connected. */
+	u16 w80 = HWIF (drive)->udma_four;
+
+	/* Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
+	 * Datasheet says the following modes are supported:
+	 *   PIO modes 0 to 4
+	 *   Multiword DMA modes 0 to 2
+	 *   UltraDMA modes 0 to 4
+	 */
+	int modes = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA
+		    | (w80 ? XFER_UDMA_66 : 0);
+	int mode;
+
+	/* XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
+	 * valid for the STB04, so mask it out of consideration just
+	 * in case some drive sets it...
+	 */
+	drive->id->eide_pio_modes &= ~4;
+
+	mode = ide_find_best_mode (drive, modes);
+
+	drive->using_dma = 0;
+	stb04xxx_ide_tune_chipset (drive, mode);
+	if (HWIF (drive)->autodma
+	    && (((mode & XFER_MODE) == XFER_PIO)
+		|| ((mode & XFER_MODE) == XFER_EPIO)))
+		drive->using_dma = 0;
+
+	return 0;
+}
+
+static int
+stb04xxx_ide_dma_on (ide_drive_t * const drive)
+{
+	drive->using_dma = 1;
+	return stb04xxx_ide_dma_host_on (drive);
+}
+
+
+/* fill in the next PRD entry
+   note that one PRD entry can transfer at most 65536 bytes */
+static int
+build_prd_entry (prd_entry_t **table,
+		 u32           paddr,
+		 u32           size,
+		 int          *count)
+{
+	while (size) {
+		u16 tc = size & 0xffff;
+
+		if (unlikely (*count >= NUM_PRD)) {
+//			printk (KERN_WARNING "%s: DMA table too small\n",
+//					     __FUNCTION__);
+			return 0;	/* revert to PIO for this request */
+		}
+
+		/* data must be 16 byte aligned */
+		if (unlikely (paddr & 0xf)) {
+//			printk (KERN_WARNING
+//				"%s: DMA buffer not 16 byte aligned.\n",
+//				__FUNCTION__);
+			return 0;	/* revert to PIO for this request */
+		}
+
+		/* transfer count must be a multiple of 16 */
+		if (unlikely (tc & 0x0f)) {
+//			printk (KERN_WARNING
+//				"%s: invalid DMA transfer count.\n",
+//				__FUNCTION__);
+			return 0;	/* revert to PIO for this request */
+		}
+		
+		(*table)->prd_physptr = paddr;
+		(*table)->prd_count   = tc;
+
+		paddr += (tc ? : 65536);
+		size  -= (tc ? : 65536);
+
+		++(*table);
+		++(*count);
+	}
+
+	return 1;
+}
+
+static int
+stb04xxx_ide_build_sglist (ide_drive_t        * const drive,
+			   ide_hwif_t         * const hwif,
+			   struct request     * const rq,
+			   struct scatterlist *sg)
+{
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
+	hwif->sg_dma_direction = (rq_data_dir (rq) == READ) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	
+	return dma_map_sg(/* hwif->pci_dev */ NULL, sg, hwif->sg_nents,
+			  hwif->sg_dma_direction);
+}
+
+static int
+stb04xxx_ide_build_dmatable (ide_drive_t    * const drive,
+			     ide_hwif_t     * const hwif,
+			     struct request * const rq)
+{
+	prd_entry_t  *table = (prd_entry_t *) hwif->dmatable_cpu;
+	unsigned int  count = 0;
+	int i;
+	struct scatterlist *sg = hwif->sg_table;
+
+	hwif->sg_nents = i = stb04xxx_ide_build_sglist (drive, hwif, rq, sg);
+
+	if (unlikely (!i))
+		goto use_pio_instead;
+	
+	++i;
+	while (--i) {
+		if (unlikely (!build_prd_entry (&table,
+						sg_dma_address (sg),
+						sg_dma_len (sg),
+						&count)))
+			goto use_pio_instead;
+
+		++sg;
+	}
+
+	if (likely (count)) {
+		--table;
+		table->prd_count |= PRD_EOT;
+		return count;
+	}
+
+	printk (KERN_ERR "%s: empty DMA table?\n", drive->name);
+
+use_pio_instead:
+	dma_unmap_sg (NULL,
+		      hwif->sg_table, hwif->sg_nents, hwif->sg_dma_direction);
+	
+	return 0; /* revert to PIO for this request */
+}
+	
+
+static void
+stb04xxx_ide_destroy_dmatable (ide_drive_t * const drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	int nents = hwif->sg_nents;
+	
+	if (nents) {
+		dma_unmap_sg (NULL, hwif->sg_table, nents,
+			      hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
+	}
+}
+
+
+static int
+stb04xxx_dma_setup (ide_drive_t * const drive)
+{
+	ide_hwif_t             * const hwif = HWIF (drive);
+	volatile ide_t __iomem * const ide_regs = (ide_t *) hwif->hwif_data;
+	struct request         * const rq = HWGROUP (drive)->rq;
+
+	/* PRD table */
+	if (unlikely (!stb04xxx_ide_build_dmatable (drive, hwif, rq))) {
+		/* try PIO instead of DMA */
+		ide_map_sg (drive, rq);
+		return 1;
+	}
+
+	ide_regs->si_c0tb = hwif->dmatable_dma; /* address of sg list */
+	ide_regs->si_c0s0 = 0xdc800000ul;       /* clear all status */
+	ide_regs->si_c0ie = 0x90000000ul;       /* enable all intr */
+	/* specify r/w */
+	ide_regs->si_c0dcm = (rq_data_dir (rq) == READ) ? 0x00000000ul : 0x08000000ul;
+
+	drive->waiting_for_dma = 1;
+	return 0;
+}
+
+static void
+stb04xxx_dma_exec_cmd (ide_drive_t * const drive,
+		       u8           command)
+{
+//	ide_execute_command (drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
+}
+
+static void
+stb04xxx_dma_start (ide_drive_t * const drive)
+{
+	volatile ide_t __iomem * const ide_regs  = (ide_t *) HWIF (drive)->hwif_data;
+
+	/* start DMA */
+	mb ();
+	ide_regs->si_c0dcm |= 0x01000000ul; /* kick it */
+}
+
+static int
+stb04xxx_ide_dma_end (ide_drive_t * const drive)
+{
+	volatile ide_t __iomem * const ide_regs = (ide_t *) HWIF (drive)->hwif_data;
+	unsigned int    dstat;
+
+	drive->waiting_for_dma = 0;
+	/* stop DMA */
+	ide_regs->si_c0dcm &= ~0x01000000ul;
+	/* get DMA status */
+	dstat = ide_regs->si_c0s1;
+	/* clear all status bits */
+	ide_regs->si_c0s0 = 0xdc800000ul;
+	wmb ();
+	stb04xxx_ide_destroy_dmatable (drive);
+	/* verify good dma status */
+	return (dstat & 0x10000000ul) ? 0 : 1; /* return true if DMA still active */
+}
+
+static int
+stb04xxx_ide_dma_test_irq (ide_drive_t * const drive)
+{
+	/* return 1 if dma irq issued, 0 otherwise */
+	volatile ide_t __iomem * const ide = (ide_t *) HWIF (drive)->hwif_data;
+
+#if NR_HWIF == 2
+	if (HWIF(drive)->index != current_bus)
+		return 0;
+#endif
+
+	if (ide->si_c0s0 & 0x10000000ul)
+		return 1;
+	if (!drive->waiting_for_dma) {
+		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
+				    drive->name, __FUNCTION__);
+	}
+
+	return 0;
+}
+
+static int
+stb04xxx_ide_dma_lostirq (ide_drive_t * const drive)
+{
+	printk ("%s: DMA interrupt recovery neccessary\n", drive->name);
+	return 1;
+}
+
+static int
+stb04xxx_ide_dma_timeout (ide_drive_t * const drive)
+{
+	printk (KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+	if (stb04xxx_ide_dma_test_irq (drive))
+		return 0;
+	return stb04xxx_ide_dma_end (drive);
+}
+
+static void
+stb04xxx_ide_setup_dma (ide_hwif_t * const hwif)
+{
+#ifdef CONFIG_DM7020
+	if ( !hwif->index )
+		hwif->udma_four = 1; //(ide_regs->si_c0s1 & 0x20000000ul) != 0;
+#endif
+	if ( hwif->index )
+		hwif->autodma = 0;
+	else
+	{
+		hwif->autodma = 1;
+		hwif->atapi_dma  = 1;
+		hwif->ultra_mask = hwif->udma_four ? 0x1f : 0x07;
+		hwif->mwdma_mask = 0x07;
+	}
+
+	hwif->drives[0].autotune = hwif->drives[1].autotune = IDE_TUNE_AUTO;
+	hwif->drives[0].autodma  = hwif->drives[1].autodma  = hwif->autodma;
+
+	/* set everything to something != NULL */
+	hwif->ide_dma_host_off = &stb04xxx_ide_dma_host_off;
+	hwif->ide_dma_host_on  = &stb04xxx_ide_dma_host_on;
+
+	hwif->ide_dma_check = &stb04xxx_ide_dma_check;
+	hwif->ide_dma_off_quietly = &stb04xxx_ide_dma_off_quietly;
+	hwif->ide_dma_on          = &stb04xxx_ide_dma_on;
+
+	hwif->dma_setup    = &stb04xxx_dma_setup;
+	hwif->dma_exec_cmd = &stb04xxx_dma_exec_cmd;
+	hwif->dma_start    = &stb04xxx_dma_start;
+	hwif->ide_dma_end  = &stb04xxx_ide_dma_end;
+
+	hwif->ide_dma_test_irq = &stb04xxx_ide_dma_test_irq;
+
+	hwif->ide_dma_lostirq = &stb04xxx_ide_dma_lostirq;
+	hwif->ide_dma_timeout = &stb04xxx_ide_dma_timeout;
+}
+
+static int __init
+stb04xxx_ide_probe (struct ocp_device * const ocp)
+{
+	int                     err;
+	unsigned int            uicdcr;
+	volatile ide_t __iomem *ide_regs;
+	unsigned long           flags;
+	unsigned char          * ip;
+	int                     i, index;
+	
+	printk ("IBM STB04xxx OCP IDE driver version %s\n", OCPVR);
+
+	if (!request_region (ocp->def->paddr, sizeof (ide_t), "ide"))
+		return -ENOMEM;
+
+	ocp_force_power_on (ocp);
+
+	ide_regs = ioremap (ocp->def->paddr, sizeof (ide_t));
+	if (unlikely (!ide_regs)) {
+		err = -ENOMEM;
+		goto error1;
+	}
+
+	/* Enable the interface. */
+	ide_regs->si_control = 0x80000000ul;
+	ide_regs->si_c0s0 = 0xdc800000ul;       /* Clear all status */
+	ide_regs->si_intenable = 0x80000000ul;
+	/* Per the STB04 data sheet:
+	 *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
+	 * and:
+	 *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
+	 * Solving the first equation for RDYT:
+	 *             (tTO/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------
+	 *                     8
+	 * Substituting equation 2) for tTO in equation 3:
+	 *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------------------------------
+	 *                                8
+	 * It's just the timeout so having it too long isn't too
+	 * significant, so we'll just assume t2 is zero.  All this math
+	 * is handled by the compiler and RDYT ends up being 11 assuming
+	 * that SYS_CLOCK_NS is 15.
+	 */
+	ide_regs->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
+
+	/* stuff some slow default PIO timing */
+	ide_regs->si_c0rt = MK_TIMING(6, 19, 15, 2);
+	ide_regs->si_c0fpt = MK_TIMING(6, 19, 15, 2);
+
+	/* enable 32bit access on both devices */
+	ide_regs->si_c0c |= 0x00008040ul;
+
+	/* we should probably have UIC functions to set external
+	   interrupt level/edge */
+	local_irq_save (flags);
+	uicdcr = mfdcr (DCRN_UIC_PR (UIC0));
+	uicdcr &= ~(0x80000000ul >> IDE0_IRQ);
+	mtdcr (DCRN_UIC_PR(UIC0), uicdcr);
+	mtdcr (DCRN_UIC_TR(UIC0),
+	       mfdcr (DCRN_UIC_TR (UIC0)) | (0x80000000ul >> IDE0_IRQ));
+	local_irq_restore (flags);
+
+	/* initialize */
+	ocp_set_drvdata (ocp, &ide_hwifs[0]);
+
+	for (index=0; index < NR_HWIF; ++index)
+	{
+		ide_hwifs[index].gendev.parent = &ocp->dev;
+		/* setup MMIO ops */
+		default_hwif_mmiops (&ide_hwifs[index]);
+
+		/* tell common code _not_q to mess with resources */
+		ide_hwifs[index].mmio = 2;
+		ide_set_hwifdata (&ide_hwifs[index], (void *) ide_regs);
+
+		ip = (unsigned char *) (&(ide_regs->si_c0d));    /* Chan 0 data */
+		for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+			ide_hwifs[index].hw.io_ports[i] = (int) (ip++);
+		ide_hwifs[index].hw.io_ports[IDE_CONTROL_OFFSET] = (int) (&(ide_regs->si_c0adc));
+		memcpy (ide_hwifs[index].io_ports, ide_hwifs[index].hw.io_ports, sizeof (ide_hwifs[index].hw.io_ports));
+		ide_hwifs[index].chipset = ide_generic;
+		ide_hwifs[index].irq     = ocp->def->irq;
+		ide_hwifs[index].noprobe = 0;
+		ide_hwifs[index].hold    = 1;
+		ide_hwifs[index].index   = index;
+		/* Figure out if an 80 conductor cable is connected */
+
+		ide_hwifs[index].tuneproc  = &stb04xxx_ide_tune_drive;
+		ide_hwifs[index].speedproc = &stb04xxx_ide_tune_chipset;
+		ide_hwifs[index].drives[0].io_32bit = ide_hwifs[index].drives[1].io_32bit = 1;
+		ide_hwifs[index].drives[0].unmask   = ide_hwifs[index].drives[1].unmask   = 1;
+		pio_mode[0] = pio_mode[1] = -1;
+
+		stb04xxx_ide_setup_dma (&ide_hwifs[index]);
+	
+		ide_hwifs[index].sg_max_nents = NUM_PRD;
+#if NR_HWIF == 2
+		ide_hwifs[index].mate = &ide_hwifs[index^1];
+		ide_hwifs[index].serialized = 1;
+		ide_hwifs[index].selectproc = &dreambox_ide_selectproc;
+#endif
+	}
+
+	/* grab a page for the PRD table. this is save with respect to not
+	   crossing a 64k border because returned memory is page aligned
+	   and NUM_PRD*sizeof(prd_entry_t) end up being 2048 bytes, i.e.
+	   less than one page. */
+	ide_hwifs[0].dmatable_cpu = dma_alloc_coherent (NULL,
+		 NUM_PRD * sizeof (prd_entry_t),
+		 &ide_hwifs[0].dmatable_dma,
+		 GFP_KERNEL | GFP_DMA);
+	if (unlikely (!ide_hwifs[0].dmatable_cpu)) {
+		err = -ENOMEM;
+		goto error2;
+	}
+
+	for (index=0; index < NR_HWIF; ++index)
+		probe_hwif_init (&ide_hwifs[index]);
+
+	return 0;
+
+error2:
+	ide_set_hwifdata (&ide_hwifs[index], NULL);
+	ide_hwifs[index].noprobe = 1;
+	ide_hwifs[index].chipset = ide_unknown;
+	ocp_set_drvdata (ocp, NULL);
+	iounmap (ide_regs);
+error1:
+	ocp_force_power_off (ocp);
+	release_region (ocp->def->paddr, sizeof (ide_t));
+	return err;
+}
+
+static void
+stb04xxx_ide_remove (struct ocp_device * const ocp)
+{
+	ide_hwif_t             * const hwif = ocp_get_drvdata (ocp);
+	volatile ide_t __iomem * const ide_regs = ide_get_hwifdata (hwif);
+
+	/* ide_unregister () can't ever handle these correctly for us */
+	dma_free_coherent (NULL, NUM_PRD * sizeof (prd_entry_t),
+		hwif->dmatable_cpu, hwif->dmatable_dma);
+
+	hwif->dmatable_cpu = NULL;
+	hwif->dmatable_dma = 0;
+	ide_unregister (hwif->index);
+
+	iounmap (ide_regs);
+	release_region (ocp->def->paddr, sizeof (ide_t));
+
+	ocp_force_power_off (ocp);
+}
+
+
+static struct ocp_device_id stb04xxx_ide_ids[] __devinitdata =
+{
+        { .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IDE},
+        { .vendor = OCP_VENDOR_INVALID }
+};
+
+MODULE_DEVICE_TABLE (ocp, stb04xxx_ide_ids);
+
+static struct ocp_driver stb04xxx_ide_driver = {
+	.name     = "ide",
+	.id_table = stb04xxx_ide_ids,
+	.probe    = stb04xxx_ide_probe,
+	.remove   = __devexit_p (stb04xxx_ide_remove),
+#if defined(CONFIG_PM)
+	.suspend  = NULL,
+	.resume   = NULL,
+#endif
+};
+
+
+int __init
+stb04xxx_ide_init (void)
+{
+	return ocp_register_driver (&stb04xxx_ide_driver);
+}
+
+static void __exit
+stb04xxx_ide_exit (void)
+{
+	ocp_unregister_driver (&stb04xxx_ide_driver);
+}
+
+#if 0
+/* needs to be called after ide has been initialized */
+late_initcall (stb04xxx_ide_init);
+#endif
+// sorry..but late_initcall isn't working properly 
+// some entries in /proc/ide/hdX/ are missing ( e.g. capacity )
+// so we call stb04xxx_ide_init from within ide.c probe_for_hwifs
+
+
+module_exit (stb04xxx_ide_exit);
+
+MODULE_LICENSE ("GPL");
+MODULE_AUTHOR ("André Draszik <andid@gmx.net>");
+MODULE_DESCRIPTION ("driver for IBM OCP IDE on STB04xxx");
diff -Naur archive/linux-2.6.17/drivers/ide/ppc/stbxxxxx.c linux-2.6.17/drivers/ide/ppc/stbxxxxx.c
--- archive/linux-2.6.17/drivers/ide/ppc/stbxxxxx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/ide/ppc/stbxxxxx.c	2007-08-30 09:04:25.000000000 +0200
@@ -0,0 +1,616 @@
+/*
+ *    Copyright 2001 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *		Hai-Pao Fan <hpfan@mvista.com>
+ *
+ *    Module name: stbxxxxx.c
+ *
+ *    Description:
+ *	This option provides support for IDE on IBM STB034xx Redwood-4,
+ *	IBM STBx25xx Redwood-6, DGStation relook300, DGStation relook400
+ *	system.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <asm/ocp.h>
+#include "../ide-timing.h"
+
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+#ifdef IDE0_IRQ
+#undef IDE0_IRQ
+#endif
+
+#define IDE_VER			"2.1 S"
+
+
+
+//#define WAIT_WHILE_DMA
+#define SUPPORT_LBA48
+
+#define DCRN_IDELMCR		0x27
+#define IDELMCR_MDMA2		0xC0000000
+#define IDELMCR_WRITE		0x20000000
+#define IDELMCR_ACTIVE		0x10000000
+
+#define IDE0_IRQ 	25		/* interrupt level(int0) */
+
+/* use DMA channel 2 for IDE DMA operations */
+
+#define IDE_DMA_INT	6		/* IDE dma channel 2 interrupt */
+
+/* DMACR2 */
+#define IDE_DMACR_CE	0x80000000	/* 00 channel enable */
+#define IDE_DMACR_CIE	0x40000000	/* 01 channel interrupt enable */
+#define IDE_DMACR_TD	0x20000000	/* 02 transfer direction */
+					/* 0 = write 1 = read */
+#define IDE_DMACR_PL	0x10000000	/* 03 peripheral location */
+
+#define IDE_DMACR_PWM2M	0x0C000000	/* 04-05 peripheral width */
+#define IDE_DMACR_PWHW  0x04000000  /* 04-05 peripheral HALFWORD */
+#define IDE_DMACR_PWW   0x08000000  /* 04-05 peripheral WORD */
+
+
+#define IDE_DMACR_DAI	0x02000000	/* 06 destination address increment */
+#define IDE_DMACR_SAI	0x01000000	/* 07 source address increment */
+#define IDE_DMACR_CP	0x00800000	/* 08 high order channel priority bit*/
+#define IDE_DMACR_TMSW	0x00400000	/* 09-10 transfer mode */
+#define IDE_DMACR_TMHW	0x00600000	/* 09-10 transfer mode */
+#define IDE_DMACR_PSC	0x00180000	/* 11-12 peripheral setup cycles */
+#define IDE_DMACR_PWC	0x0007E000	/* 13-18 peripheral wait cycles */
+#define IDE_DMACR_PHC	0x00001C00	/* 19-21 peripheral hold cycles */
+#define IDE_DMACR_ETD	0x00000200	/* 22 EOT/TC */
+#define IDE_DMACR_TCE	0x00000100	/* 23 TC Enable */
+#define IDE_DMACR_CH	0x00000080	/* 24 chaining enable */
+#define IDE_DMACR_ECE	0x00000020	/* 26 EOT chain mode enable */
+#define IDE_DMACR_TCD	0x00000010	/* 27 TC chain mode enable */
+#define IDE_DMACR_DEC	0x00000004	/* 29 destination address decrement */
+#define IDE_DMACR_CP1	0x00000001	/* 31 low order channel priority bit */
+
+#define IDE_DMASR_TC	0x20000000
+#define IDE_DMASR_EOT	0x02000000
+#define IDE_DMASR_ERR	0x00200000
+#define IDE_DMASR_CB	0x00000100
+#define IDE_DMASR_CT	0x00000020
+
+static unsigned long dmacr_def = 0x0000AB02;	/* pwc=101 phc=10, res:30=1 */
+static unsigned long dma_address;
+
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static int ocp_ide_dma_on(ide_drive_t * drive);
+static int ocp_ide_dma_check(ide_drive_t *drive);
+static int ocp_ide_dma_end(ide_drive_t *drive);
+static int ocp_dma_setup( ide_drive_t *drive );
+static void ocp_dma_start( ide_drive_t *drive );
+static int ocp_ide_dma_end(ide_drive_t *drive);
+
+#define WMODE	0		/* default to DMA line mode */
+
+#ifdef WAIT_WHILE_DMA
+static volatile unsigned long dmastat;
+#endif
+
+/* Function Prototypes */
+static byte ocp_ide_dma_2_pio(byte);
+static int ocp_ide_check_dma(ide_drive_t * drive);
+#define MK_TIMING(AS, DIOP, DIOY, DH) \
+	((FIT((AS),    0, 15) << 27) | \
+	 (FIT((DIOP),  0, 63) << 20) | \
+	 (FIT((DIOY),  0, 63) << 13) | \
+	 (FIT((DH),    0,  7) << 9))
+
+#define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+#define MK_UTIMING(CYC, RP) \
+	((FIT(UTIMING_SETHLD, 0, 15) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 15) << 22) | \
+	 (FIT((CYC),          0, 15) << 17) | \
+	 (FIT((RP),           0, 63) << 10) | \
+	 (FIT(UTIMING_SS,     0, 15) << 5)  | \
+	 1 /* Turn on Ultra DMA */)
+
+/* Define the period of the STB clock used to generate the
+ * IDE bus timing.  The clock is actually 63 MHz, but it
+ * get rounded in a favorable direction.
+ */
+#define IDE_SYS_FREQ	50	/* MHz */
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)
+
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+
+static byte ocp_ide_dma_2_pio(byte xfer_rate)
+{
+	switch(xfer_rate) {
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+#if 0
+static irqreturn_t ocp_ide_dma_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+	int dmastat = mfdcr(DCRN_DMASR);
+
+	mtdcr(DCRN_DMASR,
+		IDE_DMASR_TC | IDE_DMASR_EOT | IDE_DMASR_ERR | IDE_DMASR_CT);
+
+	/* clear UIC bit */
+	mtdcr(DCRN_UIC_SR(UIC0), (0x80000000 >> IDE_DMA_INT));
+
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static ide_startstop_t redwood_ide_intr (ide_drive_t *drive)
+{
+	int dma_stat;
+	unsigned char stat;
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+	sector_t rest;
+
+	//printk( "ide interrupt\n" );
+
+	dma_stat = ocp_ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);
+
+	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT))
+	{
+		if (!dma_stat)
+		{
+			ide_driver_t *drv;
+			rest = rq->nr_sectors - rq->current_nr_sectors;
+
+			drv = *(ide_driver_t **)rq->rq_disk->private_data;
+			drv->end_request(drive, 1, rq->current_nr_sectors);
+
+			//printk( "Ok.\n" );
+
+			if( rest )
+				return 0;//__ide_do_rw_disk( drive, rq, rq->sector );
+			else
+				return ide_stopped;
+		}
+
+		printk( KERN_WARNING "%s: redwood_ide_intr: bad DMA status (dma_stat %08x)\n",
+				drive->name, dma_stat );
+	}
+
+	printk( "Error.\n" );
+	return ide_error(drive, __FUNCTION__, stat);
+}
+
+
+static int redwood_dma_timer_expiry(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+	printk(KERN_WARNING "%s: dma_timer_expiry: dma status == 0x%02x\n",
+		drive->name, dma_stat);
+
+	if ((dma_stat & 0x18) == 0x18)	/* BUSY Stupid Early Timer !! */
+		return WAIT_CMD;
+
+	HWGROUP(drive)->expiry = NULL;	/* one free ride for now */
+
+	/* 1 dmaing, 2 error, 4 intr */
+
+	if (dma_stat & 2) {	/* ERROR */
+		(void) hwif->ide_dma_end(drive);
+		return ide_error(drive,
+			"dma_timer_expiry", hwif->INB(IDE_STATUS_REG));
+	}
+	if (dma_stat & 1)	/* DMAing */
+		return WAIT_CMD;
+
+	if (dma_stat & 4)	/* Got an Interrupt */
+		HWGROUP(drive)->handler(drive);
+
+	return 0;
+}
+
+static int ocp_ide_dma_set(ide_drive_t *drive, int write)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long length;
+	sector_t sectors;
+
+	if (drive->media != ide_disk)
+		return 0;
+
+	if (mfdcr(DCRN_DMACR2) & IDE_DMACR_CE)	/* DMA is busy? */
+	{
+		printk("ocp_ide_dma_set :dma is working now.\n");
+		return -1;
+	}
+
+	sectors = rq->current_nr_sectors;
+	//printk( "sectors %lld\n", sectors );
+
+	if (write)
+	{
+		dma_cache_wback_inv((unsigned long) rq->buffer,
+				sectors * SECTOR_SIZE);
+
+		mtdcr(DCRN_DMASA2, virt_to_bus(rq->buffer));
+#if WMODE
+		mtdcr(DCRN_DMADA2,0);
+#else
+		mtdcr(DCRN_DMADA2,dma_address);
+#endif
+	}
+	else
+	{
+		dma_cache_inv((unsigned long) rq->buffer,
+				sectors * SECTOR_SIZE);
+
+#if WMODE
+		mtdcr(DCRN_DMASA2,0);
+#else
+		mtdcr(DCRN_DMASA2,dma_address);
+#endif
+		mtdcr(DCRN_DMADA2, virt_to_bus(rq->buffer));
+	}
+
+#ifdef SUPPORT_LBA48
+	if( drive->addressing )
+	{
+		ata_nsector_t nsectors;
+
+		nsectors.all = (u16)sectors;
+		HWIF(drive)->OUTB(nsectors.b.high, IDE_NSECTOR_REG);
+		HWIF(drive)->OUTB(nsectors.b.low , IDE_NSECTOR_REG);
+	}
+	else
+#endif
+	{
+		HWIF(drive)->OUTB(sectors, IDE_NSECTOR_REG);
+	}
+	length = sectors * SECTOR_SIZE;
+	//printk( "length %ld\n", length );
+
+	/* set_dma_count doesn't do M2M line xfer sizes right. */
+#if WMODE
+	mtdcr(DCRN_DMACT2, length >> 2);	//2
+#else
+	mtdcr(DCRN_DMACT2, length >> 4);
+#endif
+
+	if (write)
+	{
+#if WMODE
+		mtdcr(DCRN_DMACR2, IDE_DMACR_CIE| IDE_DMACR_PWHW | IDE_DMACR_DAI | dmacr_def);			//0x46000000
+#else
+		mtdcr(DCRN_IDELMCR, IDELMCR_MDMA2 |IDELMCR_WRITE | IDELMCR_ACTIVE);	//IDELMCR ide mode   RES| WRITEOP|DMA_ACTIVE
+		mtdcr(DCRN_DMACR2, IDE_DMACR_CIE| IDE_DMACR_PWM2M| IDE_DMACR_SAI | IDE_DMACR_TMHW | dmacr_def);	//0x4D600000
+#endif
+	}
+	else
+	{
+#if WMODE
+		mtdcr(DCRN_DMACR2, IDE_DMACR_CIE |IDE_DMACR_TD | IDE_DMACR_PWHW | IDE_DMACR_DAI| dmacr_def);				//0x66000000
+#else
+		mtdcr(DCRN_IDELMCR, IDELMCR_MDMA2 |IDELMCR_ACTIVE);		//IDELMCR ide mode   RES| READOP|DMA_ACTIVE
+		mtdcr(DCRN_DMACR2, IDE_DMACR_CIE |IDE_DMACR_TD | IDE_DMACR_PWM2M | IDE_DMACR_DAI| IDE_DMACR_TMHW |dmacr_def);			//0x6E600000
+#endif
+	}
+
+	drive->waiting_for_dma = 1;
+
+	return 0;
+}
+
+
+static int ocp_dma_setup( ide_drive_t *drive )
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+
+	return ocp_ide_dma_set(drive, rq_data_dir(rq));
+}
+
+static void ocp_dma_exec_cmd( ide_drive_t *drive, u8 cmd )
+{
+	/* issue cmd to drive */
+	ide_execute_command(drive, cmd, &redwood_ide_intr, WAIT_CMD, NULL);
+	//ide_execute_command(drive, cmd, &ide_dma_intr, WAIT_CMD, NULL);
+
+}
+static int ocp_ide_dma_timeout(ide_drive_t *drive)
+{
+	printk(KERN_INFO "%s: chipset supported \n", __FUNCTION__);
+	return redwood_dma_timer_expiry( drive );
+}
+
+static void ocp_dma_start( ide_drive_t *drive )
+{
+	/* enable DMA */
+	mtdcr(DCRN_DMACR2,mfdcr(DCRN_DMACR2) | IDE_DMACR_CE);
+}
+
+
+static int ocp_ide_dma_end(ide_drive_t *drive)
+{
+	unsigned long cr;
+	int ret = 0;
+
+	/* check if dma is working */
+	cr = mfdcr(DCRN_DMACR2);
+	if(cr & IDE_DMACR_CE)
+	{
+		printk(KERN_WARNING "dma is working.(status %08lx)\n", cr );
+		printk(KERN_WARNING "%d bytes left\n", mfdcr(DCRN_DMACT2));
+		printk(KERN_WARNING "DA is %08x\n", mfdcr(DCRN_DMADA2));
+		ret = (int)cr;
+	}
+
+	/* disable DMA */
+	mtdcr(DCRN_DMACR2, cr & ~IDE_DMACR_CE);	//Clear ChannelEnable
+	mtdcr(DCRN_IDELMCR,0);					//IDELMCR ide mode   RES| READOP|DMA_NONACTIVE
+
+	drive->waiting_for_dma = 0;
+
+	return ret;
+}
+
+/*
+ * Check what is the best DMA timing setting for the drive and
+ * call appropriate functions to apply it.
+ */
+static int ocp_ide_dma_check(ide_drive_t *drive)
+{
+	return ocp_ide_dma_on(drive);
+}
+
+static int ocp_ide_dma_on(ide_drive_t * drive)
+{
+	return ocp_ide_check_dma(drive);
+}
+
+static int ocp_ide_tune_chipset(ide_drive_t * drive, byte speed)
+{
+	int err = 0;
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	err = ide_config_drive_speed(drive, speed);
+	drive->current_speed = speed;
+	return err;
+}
+
+static int ocp_ide_check_dma(ide_drive_t * drive)
+{
+	mtdcr(DCRN_DMACR2, 0);
+	mtdcr(DCRN_DMASR, IDE_DMASR_TC | IDE_DMASR_EOT | IDE_DMASR_ERR
+			| IDE_DMASR_CT);
+
+
+#if WMODE
+	mtdcr(DCRN_IDELMCR, 0);			//IDELMCR ide mode   RES| READOP|DMA_NONACTIVE
+	mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) | 0x00000400);
+#else
+	/* Configure CIC reg for line mode dma */
+	mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) & ~0x00000400);
+#endif
+
+	drive->using_dma = 1;
+
+	return 0;
+}
+
+static int ocp_ide_dma_off_quietly(ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	return ocp_ide_dma_end(drive);
+}
+
+static int ocp_ide_dma_lostirq(ide_drive_t *drive)
+{
+	printk("---| 44: %08x\n", mfdcr(0x44) & (0x80000000 >> IDE0_IRQ));
+	printk("---| 45: %08x\n", mfdcr(0x45) & (0x80000000 >> IDE0_IRQ));
+	printk("DCR: %08x\n", mfdcr(0xd1));
+	printk(KERN_INFO "%s: chipset supported \n", __FUNCTION__);
+	return 1;
+
+}
+
+static void ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+	printk( "%s: use pio mode %d\n", drive->name, pio );
+}
+
+
+/*
+ * Check out that the interrupt we got was for us.
+ */
+static int ocp_ide_dma_test_irq(ide_drive_t *drive)
+{
+	return 1;
+}
+
+static int __init
+stbxxxx_ide_probe (struct ocp_device * const ocp)
+{
+	unsigned long reg ;
+	ide_hwif_t *hwif;
+	hw_regs_t *hw;
+	unsigned long ioaddr;
+	int i, index;
+
+	printk("IBM Redwood 4/6 IDE driver version %s\n", IDE_VER);
+
+ 	ocp_force_power_on (ocp);
+
+	index = 0;
+	hwif = &ide_hwifs[index];
+	hw = &hwif->hw;
+	ocp_set_drvdata(ocp, hwif);
+
+	memset(hw, 0, sizeof(*hw));
+
+	//mtdcr(DCRN_DCRXICR, 0x40000000);	/* set dcrx internal arbiter */	//Hey This is not existing in 2500..
+
+	/* reconstruct phys addrs from EBIU config regs for CS2# */
+	reg = ((mfdcr(DCRN_BRCR2) & 0xff000000) >> 4) | 0xf0000000;
+	ioaddr = (unsigned long)ioremap(reg, 0x10);
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+	{
+		hw->io_ports[i] = ioaddr;
+		ioaddr += 2;
+	}
+
+	/* reconstruct phys addrs from EBIU config regs for CS3# */
+	reg = ((mfdcr(DCRN_BRCR3) & 0xff000000) >> 4) | 0xf0000000;
+	ioaddr = (unsigned long)ioremap(reg, 0x02);
+	hw->io_ports[IDE_CONTROL_OFFSET] = ioaddr;
+	dma_address =  ((mfdcr(DCRN_BRCR7) & 0xff000000) >> 4) | 0xf0000000;
+
+	printk("detected IOADDR: %08x/%08x\n", ((mfdcr(DCRN_BRCR2) & 0xff000000) >> 4) | 0xf0000000, ((mfdcr(DCRN_BRCR3) & 0xff000000) >> 4) | 0xf0000000);
+	printk("DMA addr: %08lx\n", dma_address);
+
+	hw->irq = IDE0_IRQ;
+	printk("using irq %d\n", hw->irq);
+
+
+
+	/* init CIC control reg to enable IDE interface PIO mode */
+	mtdcr(DCRN_CICCR, (mfdcr(DCRN_CICCR) & 0xffff7bff) | 0x0003);
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = 2;
+
+	mtdcr(DCRN_DMACR2, IDE_DMACR_CIE| IDE_DMACR_PWM2M| IDE_DMACR_SAI|IDE_DMACR_TMHW | dmacr_def);
+	mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
+
+	/* init CIC select2 reg to connect external DMA port 3 to internal
+	 * DMA channel 2
+	 */
+	mtdcr(DCRN_DMAS2, (mfdcr(DCRN_DMAS2) & 0xfffffff0) | 0x00000002);
+
+	index = 0;
+	hwif = &ide_hwifs[0];
+	hwif->tuneproc 				= &ocp_ide_tune_drive;
+	hwif->drives[0].autotune 	= 1;
+	hwif->autodma 				= 1;
+
+	hwif->dma_setup 			= &ocp_dma_setup;
+	hwif->dma_exec_cmd 			= &ocp_dma_exec_cmd;
+	hwif->dma_start 			= &ocp_dma_start;
+
+	hwif->ide_dma_end 			= &ocp_ide_dma_end;
+	hwif->ide_dma_check 		= &ocp_ide_dma_check;
+	hwif->ide_dma_on 			= &ocp_ide_dma_on;
+	hwif->ide_dma_off_quietly 	= &ocp_ide_dma_off_quietly;
+	hwif->ide_dma_host_off 		= &ocp_ide_dma_off_quietly;
+	hwif->ide_dma_test_irq 		= &ocp_ide_dma_test_irq;
+	hwif->ide_dma_host_on 		= &ocp_ide_dma_on;
+
+	hwif->ide_dma_lostirq 		= &ocp_ide_dma_lostirq;
+	hwif->ide_dma_timeout 		= &ocp_ide_dma_timeout;
+	hwif->speedproc 			= &ocp_ide_tune_chipset;
+	hwif->noprobe 				= 0;
+
+	/* dma count register is 16 bits. */
+#if WMODE
+	hwif->rqsize 				= 64*1024/SECTOR_SIZE*4;
+#else
+	hwif->rqsize 				= 64*1024/SECTOR_SIZE*16;
+#endif
+
+#ifndef SUPPORT_LBA48
+	hwif->no_lba48 				= 1;
+	hwif->no_lba48_dma 			= 1;
+#endif
+
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hw->io_ports));
+	hwif->irq 					= IDE0_IRQ;
+
+	//request_irq(IDE_DMA_INT, ocp_ide_dma_irq, 0, "ocp-ide-dma", hwif);
+
+	return probe_hwif_init(hwif);
+}
+
+
+static void
+stbxxxx_ide_remove (struct ocp_device * const ocp)
+{
+	return;
+}
+
+static struct ocp_device_id stbxxxx_ide_ids[] __devinitdata =
+{
+        { .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IDE},
+        { .vendor = OCP_VENDOR_INVALID }
+};
+
+MODULE_DEVICE_TABLE (ocp, stbxxxx_ide_ids);
+
+static struct ocp_driver vulcan_ide_driver = {
+	.name     = "ide",
+	.id_table = stbxxxx_ide_ids,
+	.probe    = stbxxxx_ide_probe,
+	.remove   = stbxxxx_ide_remove,
+#if defined(CONFIG_PM)
+	.suspend  = NULL,
+	.resume   = NULL,
+#endif
+};
+
+
+int __init
+stbxxxx_ide_init (void)
+{
+	return ocp_register_driver (&vulcan_ide_driver);
+}
+
+static void __exit
+stbxxxx_ide_exit (void)
+{
+	ocp_unregister_driver (&vulcan_ide_driver);
+}
+
+/* late_initcall (vulcan_ide_init); */
+
+/* unfortunately, late_initcall doesn't work: some entries in
+   /proc/ide/hdX/ will be missing.
+   so we call vulcan_ide_init from within ide.c probe_for_hwifs.
+*/
+
+module_exit (stbxxxx_ide_exit);
diff -Naur archive/linux-2.6.17/drivers/ide/ppc/vulcan.c linux-2.6.17/drivers/ide/ppc/vulcan.c
--- archive/linux-2.6.17/drivers/ide/ppc/vulcan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/ide/ppc/vulcan.c	2007-08-30 09:04:25.000000000 +0200
@@ -0,0 +1,516 @@
+/*
+ *    Copyright 2001 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *		Hai-Pao Fan <hpfan@mvista.com>
+ *
+ *    Module name: stbxxxxx.c
+ *
+ *    Description:
+ *	This option provides support for IDE on IBM STB034xx Redwood-4,
+ *	IBM STBx25xx Redwood-6, DGStation relook300, DGStation relook400
+ *	system.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <asm/ocp.h>
+#include "../ide-timing.h"
+
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+#define IDE_VER			"2.0 DMM"
+
+#define DRIVER(x) x->drv
+
+//#define WAIT_WHILE_DMA
+#define SUPPORT_LBA48
+
+#define DCRXBCR_WRITE		0x20000000
+#define DCRXBCR_MDMA2		0xC0000000
+
+/* use DMA channel 2 for IDE DMA operations */
+
+#define IDE_DMA_INT	6		/* IDE dma channel 2 interrupt */
+
+/* DMACR2 */
+#define IDE_DMACR_CE	0x80000000	/* 00 channel enable */
+#define IDE_DMACR_CIE	0x40000000	/* 01 channel interrupt enable */
+#define IDE_DMACR_TD	0x20000000	/* 02 transfer direction */
+					/* 0 = write 1 = read */
+#define IDE_DMACR_PL	0x10000000	/* 03 peripheral location */
+#define IDE_DMACR_PW	0x0C000000	/* 04-05 peripheral width */
+#define IDE_DMACR_DAI	0x02000000	/* 06 destination address increment */
+#define IDE_DMACR_SAI	0x01000000	/* 07 source address increment */
+#define IDE_DMACR_CP	0x00800000	/* 08 high order channel priority bit*/
+#define IDE_DMACR_TM	0x00600000	/* 09-10 transfer mode */
+#define IDE_DMACR_PSC	0x00180000	/* 11-12 peripheral setup cycles */
+#define IDE_DMACR_PWC	0x0007E000	/* 13-18 peripheral wait cycles */
+#define IDE_DMACR_PHC	0x00001C00	/* 19-21 peripheral hold cycles */
+#define IDE_DMACR_ETD	0x00000200	/* 22 EOT/TC */
+#define IDE_DMACR_TCE	0x00000100	/* 23 TC Enable */
+#define IDE_DMACR_CH	0x00000080	/* 24 chaining enable */
+#define IDE_DMACR_ECE	0x00000020	/* 26 EOT chain mode enable */
+#define IDE_DMACR_TCD	0x00000010	/* 27 TC chain mode enable */
+#define IDE_DMACR_DEC	0x00000004	/* 29 destination address decrement */
+#define IDE_DMACR_CP1	0x00000001	/* 31 low order channel priority bit */
+
+#define IDE_DMASR_TC	0x20000000
+#define IDE_DMASR_EOT	0x02000000
+#define IDE_DMASR_ERR	0x00200000
+#define IDE_DMASR_CB	0x00000100
+#define IDE_DMASR_CT	0x00000020
+#define DCRXBCR_ACTIVATE	0x10000000
+
+static unsigned long dmacr_def = 0x0000AB02;	/* pwc=101 phc=10, res:30=1 */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static int ocp_ide_dma_on(ide_drive_t * drive);
+static int ocp_ide_dma_check(ide_drive_t *drive);
+static int ocp_ide_dma_end(ide_drive_t *drive);
+
+#define WMODE	0		/* default to DMA line mode */
+
+#ifdef WAIT_WHILE_DMA
+static volatile unsigned long dmastat;
+#endif
+
+/* Function Prototypes */
+static byte ocp_ide_dma_2_pio(byte);
+static int ocp_ide_check_dma(ide_drive_t * drive);
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+
+static byte ocp_ide_dma_2_pio(byte xfer_rate)
+{
+	switch(xfer_rate) {
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+static ide_drive_t *my_drive;
+
+static int ocp_ide_dma_set(ide_drive_t *drive, int write)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long length;
+	sector_t sectors;
+	
+	my_drive = drive;
+
+	if (drive->media != ide_disk)
+		return 0;
+
+	mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
+
+	if (mfdcr(DCRN_DMACR2) & IDE_DMACR_CE)	/* DMA is busy? */
+	{
+		printk("ocp_ide_dma_set :dma is working now.\n");
+		return -1;
+	}
+
+	sectors = rq->current_nr_sectors;
+
+	if (write)
+	{
+		dma_cache_wback_inv((unsigned long) rq->buffer,
+				sectors * SECTOR_SIZE);
+
+#if WMODE
+		mtdcr(DCRN_DMADA2, virt_to_bus(rq->buffer));
+#else
+		mtdcr(DCRN_DMASA2, virt_to_bus(rq->buffer));
+		mtdcr(DCRN_DMADA2,0x7ce00000);
+#endif
+	}
+	else
+	{
+		dma_cache_inv((unsigned long) rq->buffer,
+				sectors * SECTOR_SIZE);
+
+#if WMODE
+		mtdcr(DCRN_DMADA2, virt_to_bus(rq->buffer));
+#else
+		mtdcr(DCRN_DMADA2, virt_to_bus(rq->buffer));
+		mtdcr(DCRN_DMASA2,0x7ce00000);
+#endif
+	}
+	
+	length = sectors * SECTOR_SIZE;
+
+	/* set_dma_count doesn't do M2M line xfer sizes right. */
+#if WMODE
+	mtdcr(DCRN_DMACT2, (length >> 1));
+#else
+	mtdcr(DCRN_DMACT2, (length >> 4));
+#endif
+
+	if (sectors != rq->nr_sectors)
+	{
+//		printk("not last sector (%d / %d)\n", (int)sectors, (int)rq->nr_sectors);
+		dmacr_def |= IDE_DMACR_CIE;
+	} else
+	{
+//		printk("last sector (%d / %d)\n", (int)sectors, (int)rq->nr_sectors);
+		dmacr_def &=~IDE_DMACR_CIE;
+	}
+
+	if (write)
+	{
+#if WMODE
+		mtdcr(DCRN_DMACR2, 0x06000000 | dmacr_def);
+#else
+		mtdcr(DCRN_DCRXBCR, 0xF0000000);
+		mtdcr(DCRN_DMACR2, 0x0D600000 | dmacr_def);
+#endif
+	}
+	else
+	{
+#if WMODE
+		mtdcr(DCRN_DMACR2, 0x26000000 | dmacr_def);
+#else
+		mtdcr(DCRN_DCRXBCR,0xD0000000);
+		mtdcr(DCRN_DMACR2, 0x2E600000 | dmacr_def);
+#endif
+	}
+	
+	drive->waiting_for_dma = 1;
+
+	return 0;
+}
+
+static int ocp_dma_setup( ide_drive_t *drive )
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+
+	return ocp_ide_dma_set(drive, rq_data_dir(rq));
+}
+
+static void ocp_dma_exec_cmd( ide_drive_t *drive, u8 cmd )
+{
+	/* issue cmd to drive */
+//	ide_execute_command(drive, cmd, &redwood_ide_intr, WAIT_CMD, NULL);
+	ide_execute_command(drive, cmd, &ide_dma_intr, WAIT_CMD, NULL);
+}
+
+static void ocp_dma_start( ide_drive_t *drive )
+{
+	/* enable DMA */
+	mtdcr(DCRN_DMACR2,mfdcr(DCRN_DMACR2) | IDE_DMACR_CE);
+}
+
+static int ocp_ide_dma_end(ide_drive_t *drive)
+{
+	unsigned long cr;
+	int ret = 0;
+
+	/* check if dma is working */
+	cr = mfdcr(DCRN_DMACR2);
+	if(cr & IDE_DMACR_CE)
+	{
+		printk(KERN_WARNING "dma is working.(status %08lx)\n", cr );
+		printk(KERN_WARNING "%d bytes left\n", mfdcr(DCRN_DMACT2));
+		printk(KERN_WARNING "DA is %08x\n", mfdcr(DCRN_DMADA2));
+		ret = (int)cr;
+	}
+	/* disable DMA */
+	mtdcr(DCRN_DMACR2, cr & ~0x80000000);
+	mtdcr(DCRN_DCRXBCR,0);
+
+	drive->waiting_for_dma = 0;
+
+	return ret;
+}
+
+static irqreturn_t ocp_ide_dma_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int dma_stat;
+	ide_drive_t *drive = my_drive;
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+	sector_t rest;
+
+	mtdcr(DCRN_DMASR, IDE_DMASR_TC | IDE_DMASR_EOT | IDE_DMASR_ERR
+			| IDE_DMASR_CT);
+
+	dma_stat = ocp_ide_dma_end(drive);
+
+	if (!dma_stat)
+	{
+		if (!rq)
+			return IRQ_HANDLED;
+
+		rest = rq->nr_sectors - rq->current_nr_sectors;
+		
+		//printk( "Ok.\n" );
+
+		if (rest)
+		{
+			ide_end_request(drive, 1, rq->current_nr_sectors);
+
+			ocp_dma_setup(drive);
+			ocp_dma_start(drive);
+			return IRQ_HANDLED;
+		} else
+		{
+			return IRQ_HANDLED;
+		}
+	}
+
+	printk( KERN_WARNING "%s: redwood_ide_intr: bad DMA status (dma_stat %08x)\n",
+			drive->name, dma_stat );
+	printk( "Error.\n" );
+
+	return IRQ_HANDLED;
+}
+
+static int ocp_ide_dma_check(ide_drive_t *drive)
+{
+	return ocp_ide_dma_on(drive);
+}
+
+static int ocp_ide_dma_on(ide_drive_t * drive)
+{
+	return ocp_ide_check_dma(drive);
+}
+
+static int ocp_ide_tune_chipset(ide_drive_t * drive, byte speed)
+{
+	int err = 0;
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	err = ide_config_drive_speed(drive, speed);
+	drive->current_speed = speed;
+	return err;
+}
+
+static int ocp_ide_check_dma(ide_drive_t * drive)
+{
+	mtdcr(DCRN_DMACR2, 0);
+	mtdcr(DCRN_DMASR, IDE_DMASR_TC | IDE_DMASR_EOT | IDE_DMASR_ERR
+			| IDE_DMASR_CT);
+
+
+#if WMODE
+	mtdcr(DCRN_DCRXBCR, 0);
+	mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) | 0x00000400);
+#else
+	/* Configure CIC reg for line mode dma */
+	mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) & ~0x00000400);
+#endif
+
+	drive->using_dma = 1;
+
+	return 0;
+}
+
+static int ocp_ide_dma_off_quietly(ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	return ocp_ide_dma_end(drive);
+}
+
+static int ocp_ide_dma_lostirq(ide_drive_t *drive)
+{
+	printk("---| 44: %08x\n", mfdcr(0x44) & (0x80000000 >> 26));
+	printk("---| 45: %08x\n", mfdcr(0x45) & (0x80000000 >> 26));
+	printk("DCR: %08x\n", mfdcr(0xd1));
+	printk(KERN_INFO "%s: chipset supported \n", __FUNCTION__);
+	return 1;
+}
+
+static int ocp_ide_dma_timeout(ide_drive_t *drive)
+{
+	printk(KERN_INFO "%s: chipset supported \n", __FUNCTION__);
+	return 1;
+//	return redwood_dma_timer_expiry( drive );
+}
+
+static void ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+	printk( "%s: use pio mode %d\n", drive->name, pio );
+}
+
+static int ocp_ide_dma_test_irq(ide_drive_t *drive)
+{
+	return 1;
+}
+
+static int __init
+vulcan_ide_probe (struct ocp_device * const ocp)
+{
+	unsigned long reg;
+	ide_hwif_t *hwif;
+	hw_regs_t *hw;
+	unsigned long ioaddr;
+	int i, index;
+	
+	printk("IBM Redwood 4/6 IDE driver version %s\n", IDE_VER);
+	
+	ocp_force_power_on (ocp);
+
+	index = 0;
+	hwif = &ide_hwifs[index];
+	hw = &hwif->hw;
+	ocp_set_drvdata(ocp, hwif);
+	
+ 	memset(hw, 0, sizeof(*hw));
+
+	mtdcr(DCRN_DCRXICR, 0x40000000);	/* set dcrx internal arbiter */
+
+	/* reconstruct phys addrs from EBIU config regs for CS2# */
+	reg = ((mfdcr(DCRN_BRCR2) & 0xff000000) >> 4) | 0xf0000000;
+	ioaddr = (unsigned long)ioremap(reg, 0x10);
+	
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+	{
+		hw->io_ports[i] = ioaddr;
+		ioaddr += 2;
+	}
+
+	/* reconstruct phys addrs from EBIU config regs for CS3# */
+	reg = ((mfdcr(DCRN_BRCR3) & 0xff000000) >> 4) | 0xf0000000;
+	ioaddr = (unsigned long)ioremap(reg, 0x02);
+	hw->io_ports[IDE_CONTROL_OFFSET] = ioaddr;
+	
+	printk("detected IOADDR: %08x/%08x vs. %08x\n", ((mfdcr(DCRN_BRCR2) & 0xff000000) >> 4) | 0xf0000000, ((mfdcr(DCRN_BRCR3) & 0xff000000) >> 4) | 0xf0000000, ocp->def->paddr);
+	printk("DMA addr: %08x\n", ((mfdcr(DCRN_BRCR7) & 0xff000000) >> 4) | 0xf0000000);
+
+	hw->irq = ocp->def->irq;
+	printk("using irq %d\n", hw->irq);
+
+	/* init CIC control reg to enable IDE interface PIO mode */
+	mtdcr(DCRN_CICCR, (mfdcr(DCRN_CICCR) & 0xffff7bff) | 0x0003);
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = 2;
+
+	mtdcr(DCRN_DMACR2, 0x4d600000 | dmacr_def);
+	mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
+
+	/* init CIC select2 reg to connect external DMA port 3 to internal
+	 * DMA channel 2
+	 */
+	mtdcr(DCRN_DMAS2, (mfdcr(DCRN_DMAS2) & 0xfffffff0) | 0x00000002);
+
+	hwif->tuneproc = &ocp_ide_tune_drive;
+	hwif->drives[0].autotune = 1;
+	hwif->autodma = 1;
+	hwif->dma_setup = &ocp_dma_setup;
+	hwif->dma_exec_cmd = &ocp_dma_exec_cmd;
+	hwif->dma_start = &ocp_dma_start;
+#if 1
+	hwif->ide_dma_end = &ocp_ide_dma_end;
+	hwif->ide_dma_check = &ocp_ide_dma_check;
+	hwif->ide_dma_on =&ocp_ide_dma_on;
+	hwif->ide_dma_off_quietly = &ocp_ide_dma_off_quietly;
+	hwif->ide_dma_host_off =&ocp_ide_dma_off_quietly; 
+	hwif->ide_dma_test_irq =&ocp_ide_dma_test_irq;
+	hwif->ide_dma_host_on = &ocp_ide_dma_on;
+	hwif->ide_dma_lostirq = &ocp_ide_dma_lostirq;
+	hwif->ide_dma_timeout = ocp_ide_dma_timeout;
+#endif
+
+	hwif->speedproc = &ocp_ide_tune_chipset;
+	hwif->noprobe = 0;
+	/* dma count register is 16 bits. */
+#if WMODE
+	hwif->rqsize = 64*1024/SECTOR_SIZE*4;
+#else
+	hwif->rqsize = 64*1024/SECTOR_SIZE*16;
+#endif
+#ifndef SUPPORT_LBA48
+	hwif->no_lba48 = 1;
+	hwif->no_lba48_dma = 1;
+#endif
+
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hw->io_ports));
+	hwif->irq = hw->irq;
+	
+			/* hi active, edge.. glaube ich */
+//	mtdcr(0x44, mfdcr(0x44) &~ (0x80000000>>hwif->irq)); // high active
+//	mtdcr(0x45, mfdcr(0x45) & ~(0x80000000>>hwif->irq));  // 
+	
+	request_irq(IDE_DMA_INT, ocp_ide_dma_irq, 0, "ocp-ide-dma", hwif);
+	
+	return probe_hwif_init(hwif);
+}
+
+static void
+vulcan_ide_remove (struct ocp_device * const ocp)
+{
+	return;
+}
+
+static struct ocp_device_id vulcan_ide_ids[] __devinitdata =
+{
+        { .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IDE},
+        { .vendor = OCP_VENDOR_INVALID }
+};
+
+MODULE_DEVICE_TABLE (ocp, vulcan_ide_ids);
+
+static struct ocp_driver vulcan_ide_driver = {
+	.name     = "ide",
+	.id_table = vulcan_ide_ids,
+	.probe    = vulcan_ide_probe,
+	.remove   = __devexit_p (vulcan_ide_remove),
+#if defined(CONFIG_PM)
+	.suspend  = NULL,
+	.resume   = NULL,
+#endif
+};
+
+
+int __init
+vulcan_ide_init (void)
+{
+	return ocp_register_driver (&vulcan_ide_driver);
+}
+
+static void __exit
+vulcan_ide_exit (void)
+{
+	ocp_unregister_driver (&vulcan_ide_driver);
+}
+
+/* late_initcall (vulcan_ide_init); */
+
+/* unfortunately, late_initcall doesn't work: some entries in  
+   /proc/ide/hdX/ will be missing.
+   so we call vulcan_ide_init from within ide.c probe_for_hwifs.
+*/
+
+module_exit (vulcan_ide_exit);
diff -Naur archive/linux-2.6.17/drivers/input/evdev.c linux-2.6.17/drivers/input/evdev.c
--- archive/linux-2.6.17/drivers/input/evdev.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/input/evdev.c	2007-08-30 09:04:25.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/smp_lock.h>
 #include <linux/device.h>
 #include <linux/compat.h>
+#include <linux/devfs_fs_kernel.h>
 
 struct evdev {
 	int exist;
@@ -91,6 +92,7 @@
 
 static void evdev_free(struct evdev *evdev)
 {
+	devfs_remove("input/event%d", evdev->minor);
 	evdev_table[evdev->minor] = NULL;
 	kfree(evdev);
 }
@@ -645,6 +647,8 @@
 
 	evdev_table[minor] = evdev;
 
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/event%d", minor);
 	cdev = class_device_create(&input_class, &dev->cdev,
 			MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),
 			dev->cdev.dev, evdev->name);
diff -Naur archive/linux-2.6.17/drivers/input/input.c linux-2.6.17/drivers/input/input.c
--- archive/linux-2.6.17/drivers/input/input.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/input/input.c	2007-08-30 09:04:25.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/poll.h>
 #include <linux/device.h>
 #include <linux/mutex.h>
+#include <linux/devfs_fs_kernel.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
@@ -1081,6 +1082,12 @@
 		goto fail2;
 	}
 
+	err = devfs_mk_dir("input");
+	if (err) {
+		printk(KERN_ERR "input: devfs is unable to create dev_input\n");
+		goto fail2;
+	}
+
 	return 0;
 
  fail2:	input_proc_exit();
@@ -1091,6 +1098,7 @@
 static void __exit input_exit(void)
 {
 	input_proc_exit();
+	devfs_remove("input");
 	unregister_chrdev(INPUT_MAJOR, "input");
 	class_unregister(&input_class);
 }
diff -Naur archive/linux-2.6.17/drivers/input/joydev.c linux-2.6.17/drivers/input/joydev.c
--- archive/linux-2.6.17/drivers/input/joydev.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/input/joydev.c	2007-08-30 09:04:25.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/smp_lock.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
 MODULE_DESCRIPTION("Joystick device interfaces");
@@ -140,6 +141,7 @@
 
 static void joydev_free(struct joydev *joydev)
 {
+	devfs_remove("input/js%d", joydev->minor);
 	joydev_table[joydev->minor] = NULL;
 	kfree(joydev);
 }
@@ -512,6 +514,8 @@
 
 	joydev_table[minor] = joydev;
 
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + minor),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/js%d", minor);
 	cdev = class_device_create(&input_class, &dev->cdev,
 			MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + minor),
 			dev->cdev.dev, joydev->name);
diff -Naur archive/linux-2.6.17/drivers/input/mousedev.c linux-2.6.17/drivers/input/mousedev.c
--- archive/linux-2.6.17/drivers/input/mousedev.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/input/mousedev.c	2007-08-30 09:04:25.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/random.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 #ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
 #include <linux/miscdevice.h>
 #endif
@@ -352,6 +353,7 @@
 
 static void mousedev_free(struct mousedev *mousedev)
 {
+	devfs_remove("input/mouse%d", mousedev->minor);
 	mousedev_table[mousedev->minor] = NULL;
 	kfree(mousedev);
 }
@@ -644,6 +646,8 @@
 
 	mousedev_table[minor] = mousedev;
 
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + minor),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/mouse%d", minor);
 	cdev = class_device_create(&input_class, &dev->cdev,
 			MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + minor),
 			dev->cdev.dev, mousedev->name);
@@ -735,6 +739,8 @@
 	mousedev_mix.exist = 1;
 	mousedev_mix.minor = MOUSEDEV_MIX;
 
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/mice");
 	class_device_create(&input_class, NULL,
 			MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX), NULL, "mice");
 
@@ -754,6 +760,7 @@
 	if (psaux_registered)
 		misc_deregister(&psaux_mouse);
 #endif
+	devfs_remove("input/mice");
 	class_device_destroy(&input_class,
 			MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX));
 	input_unregister_handler(&mousedev_handler);
diff -Naur archive/linux-2.6.17/drivers/input/tsdev.c linux-2.6.17/drivers/input/tsdev.c
--- archive/linux-2.6.17/drivers/input/tsdev.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/input/tsdev.c	2007-08-30 09:04:26.000000000 +0200
@@ -53,6 +53,7 @@
 #include <linux/random.h>
 #include <linux/time.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 
 #ifndef CONFIG_INPUT_TSDEV_SCREEN_X
 #define CONFIG_INPUT_TSDEV_SCREEN_X	240
@@ -175,6 +176,7 @@
 
 static void tsdev_free(struct tsdev *tsdev)
 {
+	devfs_remove("input/ts%d", tsdev->minor);
 	tsdev_table[tsdev->minor] = NULL;
 	kfree(tsdev);
 }
@@ -408,6 +410,11 @@
 
 	tsdev_table[minor] = tsdev;
 
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + minor),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/ts%d", minor);
+	devfs_mk_cdev(MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + minor + TSDEV_MINORS/2),
+			S_IFCHR|S_IRUGO|S_IWUSR, "input/tsraw%d", minor);
+
 	cdev = class_device_create(&input_class, &dev->cdev,
 			MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + minor),
 			dev->cdev.dev, tsdev->name);
@@ -436,6 +443,7 @@
 			kill_fasync(&list->fasync, SIGIO, POLL_HUP);
 	} else
 		tsdev_free(tsdev);
+	devfs_remove("input/tsraw%d", tsdev->minor);
 }
 
 static struct input_device_id tsdev_ids[] = {
diff -Naur archive/linux-2.6.17/drivers/mmc/Kconfig linux-2.6.17/drivers/mmc/Kconfig
--- archive/linux-2.6.17/drivers/mmc/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mmc/Kconfig	2007-08-30 09:04:28.000000000 +0200
@@ -109,4 +109,15 @@
 
 	  If unsure, say N.
 
+config MMC_SPI
+	tristate "MMC/SD over SPI"
+	depends on MMC && SPI && EXPERIMENTAL
+	help
+	  Some systems accss MMC/SD cards using the SPI protocol instead of
+	  using an MMC/SD controller.  The disadvantage of using SPI is that
+	  it's often not as fast; its compensating advantage is that SPI is
+	  available on many systems without MMC/SD controllers.
+
+	  If unsure, or if your system has no SPI controller driver, say N.
+
 endmenu
diff -Naur archive/linux-2.6.17/drivers/mmc/Makefile linux-2.6.17/drivers/mmc/Makefile
--- archive/linux-2.6.17/drivers/mmc/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mmc/Makefile	2007-08-30 09:04:28.000000000 +0200
@@ -23,6 +23,7 @@
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_AT91RM9200)	+= at91_mci.o
+obj-$(CONFIG_MMC_SPI)           += mmc_spi.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
 
diff -Naur archive/linux-2.6.17/drivers/mmc/mmc_spi.c linux-2.6.17/drivers/mmc/mmc_spi.c
--- archive/linux-2.6.17/drivers/mmc/mmc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mmc/mmc_spi.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,1499 @@
+/*
+ * mmc_spi.c - Access an SD/MMC card using the SPI bus
+ *
+ * (C) Copyright 2005, Intec Automation,
+ *		 Mike Lavender (mike@steroidmicros)
+ * (C) Copyright 2006, David Brownell
+ * (C) Copyright 2007, Axis Communications,
+ *		 Hans-Peter Nilsson (hp@axis.com)
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+
+
+/* NOTES:
+ *
+ * - For now, we won't try to interoperate with a real mmc/sd/sdio
+ *   controller.  The main reason for such configs would be mmc-format
+ *   cards which (like dataflash) don't support that "other" protocol.
+ *   SPI mode is a bit slower than non-parallel versions of MMC.
+ *
+ * - Likewise we don't try to detect dataflash cards, which would
+ *   imply switching to a different driver.  Not many folk folk use
+ *   both dataflash cards and MMC/SD cards, and Linux doesn't have
+ *   an "MMC/SD interface" abstraction for coupling to drivers.
+ *
+ * - This version gets part way through enumeration of MMC cards.
+ *
+ * - Protocol details, including timings, need to be audited
+ *
+ * - A "use CRCs" option would probably be useful.
+ */
+
+
+/*
+ * Local defines
+ */
+
+// MOVE TO <linux/mmc/protocol.h> ?
+#define SPI_MMC_COMMAND		0x40	/* mask into mmc command */
+
+/* class 0 */
+#define SPI_MMC_READ_OCR	58	/* R3, SPI-only */
+#define SPI_MMC_CRC_ON_OFF	59	/* SPI-only */
+
+/* R1 response status to almost all commands */
+#define SPI_MMC_R1_IDLE			0x01
+#define SPI_MMC_R1_ERASE_RESET		0x02
+#define SPI_MMC_R1_ILLEGAL_COMMAND	0x04
+#define SPI_MMC_R1_COM_CRC		0x08
+#define SPI_MMC_R1_ERASE_SEQ		0x10
+#define SPI_MMC_R1_ADDRESS		0x20
+#define SPI_MMC_R1_PARAMETER		0x40
+
+/* R2 response to CMD13 (SEND_STATUS) is an R1 plus a high byte */
+#define SPI_MMC_R2_CARD_LOCKED		0x01
+#define SPI_MMC_R2_WP_ERASE_SKIP	0x02
+#define SPI_MMC_R2_ERROR		0x04
+#define SPI_MMC_R2_CC_ERROR		0x08
+#define SPI_MMC_R2_CARD_ECC_ERROR	0x10
+#define SPI_MMC_R2_WP_VIOLATION		0x20
+#define SPI_MMC_R2_ERASE_PARAM		0x40
+#define SPI_MMC_R2_OUT_OF_RANGE		0x80
+
+/* response tokens used to ack each block written: */
+#define SPI_MMC_RESPONSE_CODE(x) ((x) & (7 << 1))
+#define SPI_RESPONSE_ACCEPTED	(2 << 1)
+#define SPI_RESPONSE_CRC_ERR	(5 << 1)
+#define SPI_RESPONSE_WRITE_ERR	(6 << 1)
+
+/* read and write blocks start with these tokens and end with crc;
+ * on error, read tokens act like SPI_MMC_R2 values.
+ */
+#define SPI_TOKEN_SINGLE	0xfe	/* single block r/w, multiblock read */
+#define SPI_TOKEN_MULTI_WRITE	0xfc	/* multiblock write */
+#define SPI_TOKEN_STOP_TRAN	0xfd	/* terminate multiblock write */
+// END MOVE
+
+
+#define NO_ARG			0x00000000  // No argument all 0's
+
+#define CRC_GO_IDLE_STATE	0x95
+#define CRC_NO_CRC		0x01
+
+#define	MMC_POWERCYCLE_MSECS	20		/* board-specific? */
+
+
+/* The unit for these timeouts is milliseconds.  See mmc_spi_scanbyte.  */
+#define MINI_TIMEOUT		1
+#define READ_TIMEOUT		100
+#define WRITE_TIMEOUT		250
+
+
+/****************************************************************************/
+
+/*
+ * Local Data Structures
+ */
+
+union mmc_spi_command {
+	u8 buf[7];
+	struct {
+		u8 dummy;
+		u8 code;
+		u8 addr1;
+		u8 addr2;
+		u8 addr3;
+		u8 addr4;
+		u8 crc;
+	} command;
+};
+
+
+struct mmc_spi_host {
+	struct mmc_host		*mmc;
+	struct spi_device	*spi;
+	u8			*rx_buf;
+	u8			*tx_buf;
+	u32			tx_idx;
+	u32			rx_idx;
+	u8			cid_sequence;
+	u8			rsp_type;
+	u8			app_cmd;
+
+	struct mmc_spi_platform_data	*pdata;
+
+	/* for bulk data transfers */
+	struct spi_transfer	token, t, crc;
+	struct spi_message	m;
+	struct spi_transfer	early_status;
+
+	/* for status readback */
+	struct spi_transfer	status;
+	struct spi_message	readback;
+
+	/* underlying controller might support dma, but we can't
+	 * rely on it being used for any particular request
+	 */
+	struct device		*dma_dev;
+	dma_addr_t		dma;		/* of mmc_spi_host */
+
+	/* pre-allocated dma-safe buffers */
+	union mmc_spi_command	command;
+	u8			data_token;
+	u8			status_byte;
+	u16			crc_val;
+	u8			response[2];
+	u8			bundled_status[2];
+
+	/* specs describe always writing ones even if we
+	 * don't think the card should care what it sees.
+	 * (Unused if the spi controller can specify default tx data.)
+	 */
+	u8			ones[];
+#define ONES_BUFFER_SIZE 512
+};
+
+#ifdef	DEBUG
+static unsigned debug = 1;
+module_param(debug, uint, 0644);
+#else
+#define	debug	0
+#endif
+
+/****************************************************************************/
+
+static inline int mmc_spi_readbyte(struct mmc_spi_host *host)
+{
+	int status = spi_sync(host->spi, &host->readback);
+	if (status < 0)
+		return status;
+	return host->status_byte;
+}
+
+static inline int
+mmc_spi_readbytes(struct mmc_spi_host *host, void *bytes, unsigned len)
+{
+	int status;
+
+	host->status.rx_buf = bytes;
+	host->status.len = len;
+
+	host->readback.is_dma_mapped = 0;
+	status = spi_sync(host->spi, &host->readback);
+	host->readback.is_dma_mapped = 1;
+
+	host->status.rx_buf = &host->status_byte;
+	host->status.len = 1;
+	return status;
+}
+
+
+/* REVISIT:  is this fast enough?  these kinds of sync points could easily
+ * be offloaded to irq-ish code called by controller drivers, eliminating
+ * context switch costs.
+ *
+ * REVISIT:  after writes and erases, mmc_spi_busy() == true might be a
+ * fair hint to yield exclusive access to the card (so another driver can
+ * use the bus) and msleep if busy-waiting doesn't succeed quickly.
+ * Measurements on half a dozen cards show however that a simple
+ * implementation doing msleep(1) every 100 busy-iterations (when
+ * busy, increment and test a static variable, reset it after the
+ * msleep) doesn't provide any consistent speedup or increased
+ * user-level system performance (less load).
+ */
+static int mmc_spi_busy(u8 byte)
+{
+	return byte == 0;
+}
+
+static int mmc_spi_delayed(u8 byte)
+{
+	return byte == 0xff;
+}
+
+static int
+mmc_spi_scanbyte(struct mmc_spi_host *host, int (*fail)(u8), unsigned delay)
+{
+	int		value;
+	unsigned	wait;
+
+	/*
+	 * Because we might (we will, for bitbanged SPI) be scheduled
+	 * out for extensive periods in this call, we'd get an
+	 * abundance of timeouts if we counted in jiffies on a system
+	 * with load, so instead we calculate it in the max number of
+	 * bytes we could theoretically scan before the timeout, if
+	 * everything else took zero time.
+	 */
+	unsigned long	end_wait = delay * host->spi->max_speed_hz / 1000 / 8;
+
+	for (wait = 0; wait < end_wait; wait++) {
+		value = mmc_spi_readbyte(host);
+		if (value < 0)
+			return value;
+		if (!fail(value)) {
+			if (debug > 1)
+				dev_dbg(&host->spi->dev,
+					"  mmc_spi: token %02x, wait %d\n",
+					value, wait);
+			return value;
+		}
+	}
+
+	return -ETIMEDOUT;
+}
+
+static inline void mmc_spi_map_r1(struct mmc_command *cmd, u8 r1)
+{
+	u32	mapped = 0;
+
+	/* spi mode doesn't expose the mmc/sd state machine, but
+	 * we can at least avoid lying about the IDLE state
+	 */
+	if (!(r1 & SPI_MMC_R1_IDLE))
+		mapped |= (3 /*standby*/ << 9);
+
+	if (r1 & (SPI_MMC_R1_ERASE_RESET
+			| SPI_MMC_R1_ERASE_SEQ
+			| SPI_MMC_R1_ADDRESS
+			| SPI_MMC_R1_PARAMETER)) {
+		cmd->error = MMC_ERR_FAILED;
+		if (r1 & SPI_MMC_R1_ERASE_RESET)
+			mapped |= R1_ERASE_RESET;
+		if (r1 & SPI_MMC_R1_ERASE_SEQ)
+			mapped |= R1_ERASE_SEQ_ERROR;
+		if (r1 & SPI_MMC_R1_ADDRESS)
+			mapped |= R1_ADDRESS_ERROR;
+		/* this one's a loose match... */
+		if (r1 & SPI_MMC_R1_PARAMETER)
+			mapped |= R1_BLOCK_LEN_ERROR;
+	}
+	if (r1 & SPI_MMC_R1_ILLEGAL_COMMAND) {
+		cmd->error = MMC_ERR_INVALID;
+		mapped |= R1_ILLEGAL_COMMAND;
+	}
+	if (r1 & SPI_MMC_R1_COM_CRC) {
+		cmd->error = MMC_ERR_BADCRC;
+		mapped |= R1_COM_CRC_ERROR;
+	}
+
+	cmd->resp[0] = mapped;
+}
+
+static void mmc_spi_map_r2(struct mmc_command *cmd, u8 r2)
+{
+	u32	mapped = 0;
+
+	if (!r2)
+		return;
+
+	if (r2 & SPI_MMC_R2_CARD_LOCKED)
+		mapped |= R1_CARD_IS_LOCKED;
+	if (r2 & SPI_MMC_R2_WP_ERASE_SKIP)
+		mapped |= R1_WP_ERASE_SKIP;
+	if (r2 & SPI_MMC_R2_ERROR)
+		mapped |= R1_ERROR;
+	if (r2 & SPI_MMC_R2_CC_ERROR)
+		mapped |= R1_CC_ERROR;
+	if (r2 & SPI_MMC_R2_CARD_ECC_ERROR)
+		mapped |= R1_CARD_ECC_FAILED;
+	if (r2 & SPI_MMC_R2_WP_VIOLATION)
+		mapped |= R1_WP_VIOLATION;
+	if (r2 & SPI_MMC_R2_ERASE_PARAM)
+		mapped |= R1_ERASE_PARAM;
+	if (r2 & SPI_MMC_R2_OUT_OF_RANGE)
+		mapped |= R1_OUT_OF_RANGE | R1_CID_CSD_OVERWRITE;
+
+	if (mapped) {
+		cmd->resp[0] |= mapped;
+		if (cmd->error == MMC_ERR_NONE)
+			cmd->error = MMC_ERR_FAILED;
+	}
+}
+
+#ifdef	DEBUG
+static char *maptype(u8 type)
+{
+	switch (type) {
+	case MMC_RSP_R1:	return "R1";
+	case MMC_RSP_R1B:	return "R1B";
+	case MMC_RSP_R2:	return "R2";
+	case MMC_RSP_R3:	return "R3";
+	case MMC_RSP_NONE:	return "NONE";
+	default:		return "?";
+	}
+}
+#endif
+
+static void
+mmc_spi_response_get(struct mmc_spi_host *host, struct mmc_command *cmd)
+{
+	int value;
+
+	dev_dbg(&host->spi->dev,
+		"%sCMD%d response SPI_%s: ",
+		host->app_cmd ? "A" : "",
+		cmd->opcode, maptype(host->rsp_type));
+
+	if (cmd->opcode == MMC_STOP_TRANSMISSION) {
+		/*
+		 * We can't tell whether we read block data or the
+		 * command reply, so to cope with trash data during
+		 * the latency, we just read in 14 bytes (8 would be
+		 * enough according to the MMC spec; SD doesn't say)
+		 * after the command and fake a clean reply.  We could
+		 * avoid this if we saved what the card sent us while
+		 * we sent the command, and treat it like a normal
+		 * response if we didn't get a SPI_TOKEN_SINGLE.
+		 */
+		(void) mmc_spi_readbytes(host, host->command.buf,
+					 sizeof host->command.buf);
+		(void) mmc_spi_readbytes(host, host->command.buf,
+					 sizeof host->command.buf);
+		value = 0;
+	} else
+		value = mmc_spi_scanbyte(host, mmc_spi_delayed, MINI_TIMEOUT);
+	host->response[0] = value;
+	host->response[1] = 0;
+
+	if (value < 0) {
+		dev_dbg(&host->spi->dev,
+			"mmc_spi: response error, %d\n", value);
+		cmd->error = MMC_ERR_FAILED;
+		return;
+	}
+
+	if (host->response[0] & 0x80) {
+		dev_err(&host->spi->dev, "INVALID RESPONSE, %02x\n",
+					host->response[0]);
+		cmd->error = MMC_ERR_FAILED;
+		return;
+	}
+
+	cmd->error = MMC_ERR_NONE;
+	mmc_spi_map_r1(cmd, host->response[0]);
+
+	switch (host->rsp_type) {
+
+	/* SPI R1 and R1B are a subset of the MMC/SD R1 */
+	case MMC_RSP_R1B:
+		/* wait for not-busy (could be deferred...) */
+		// REVISIT:  could be a (shorter) read timeout
+		// ... and the timeouts derived from chip parameters
+		// will likely be nicer/shorter
+		(void) mmc_spi_scanbyte(host, mmc_spi_busy, WRITE_TIMEOUT);
+		/* FALLTHROUGH */
+	case MMC_RSP_R1:
+		/* no more */
+		break;
+
+	/* SPI R2 is bigger subset of the MMC/SD R1; unrelated to MMC/SD R2 */
+	case MMC_RSP_R2:
+		/* read second status byte */
+		host->response[1] = mmc_spi_readbyte(host);
+		mmc_spi_map_r2(cmd, host->response[1]);
+		break;
+
+	/* SPI R3 is SPI R1 plus OCR */
+	case MMC_RSP_R3:
+		/* NOTE: many controllers can't support 32 bit words,
+		 * which is why we use byteswapping here instead.
+		 */
+		(void) mmc_spi_readbytes(host, &cmd->resp[0], 4);
+		be32_to_cpus(&cmd->resp[0]);
+		be32_to_cpus(&cmd->resp[1]);
+		be32_to_cpus(&cmd->resp[2]);
+		be32_to_cpus(&cmd->resp[3]);
+		break;
+
+	default:
+		dev_dbg(&host->spi->dev,
+			"unknown rsp_type\n");
+	}
+
+	if (host->response[0] || host->response[1])
+		dev_dbg(&host->spi->dev,
+			"  mmc_spi: resp %02x.%02x\n",
+			host->response[1],
+			host->response[0]);
+
+	/* The SPI binding to MMC/SD cards uses different conventions
+	 * than the other one.  Unless/until the mmc core learns about
+	 * SPI rules, we must handle it here...
+	 */
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1:
+	case MMC_RSP_R1B:
+		switch (host->rsp_type) {
+		case MMC_RSP_R1B:
+		case MMC_RSP_R1:
+		case MMC_RSP_R2:
+			/* spi doesn't explicitly expose this bit */
+			if (cmd->error == MMC_ERR_NONE
+					&& cmd->opcode == MMC_APP_CMD)
+				cmd->resp[0] |= R1_APP_CMD;
+			break;
+		default:
+badmap:
+			dev_dbg(&host->spi->dev,
+				"mmc_spi: no map SPI_%s --> MMC_%s/%02x\n",
+				maptype(host->rsp_type),
+				maptype(mmc_resp_type(cmd)),
+				mmc_resp_type(cmd));
+			if (cmd->error == MMC_ERR_NONE)
+				cmd->error = MMC_ERR_FAILED;
+		}
+		break;
+	case MMC_RSP_R2:
+		switch (cmd->opcode) {
+		case MMC_SEND_CID:
+		case MMC_SEND_CSD:
+			/* we special case these by waiting for the
+			 * data stage (with CID/CSD)
+			 */
+			break;
+		default:
+			goto badmap;
+		}
+		break;
+	case MMC_RSP_R3:
+		/* for some cases, OCR is patched up later */
+		if (host->rsp_type != MMC_RSP_R3
+				&& cmd->error == MMC_ERR_NONE
+				&& !( (cmd->opcode == MMC_SEND_OP_COND
+					&& !host->app_cmd)
+				   || (cmd->opcode == SD_APP_OP_COND
+					&& host->app_cmd))
+				) {
+			dev_dbg(&host->spi->dev,
+				"** MMC_R3 mismatch to SPI_%s\n",
+				maptype(host->rsp_type));
+			cmd->error = MMC_ERR_FAILED;
+		}
+		break;
+	case MMC_RSP_NONE:
+		if (cmd->opcode == MMC_GO_IDLE_STATE) {
+			if (!(host->response[0] & SPI_MMC_R1_IDLE)
+					&& cmd->error == MMC_ERR_NONE) {
+				/* maybe it finished initialization early */
+				dev_dbg(&host->spi->dev, "  ?? not idle ??\n");
+			}
+		} else
+			goto badmap;
+	}
+}
+
+/* SPI response types aren't always good matches for "native" ones */
+
+/* REVISIT probably should have SPI_RSP_R1 etc */
+
+static const u8 resp_map[64] = {
+	[ 0] = MMC_RSP_R1,
+	[ 1] = MMC_RSP_R1,
+	[ 6] = MMC_RSP_R1,
+	[ 9] = MMC_RSP_R1,
+
+	[10] = MMC_RSP_R1,
+	[12] = MMC_RSP_R1B,
+	[13] = MMC_RSP_R2,
+	[16] = MMC_RSP_R1,
+	[17] = MMC_RSP_R1,
+	[18] = MMC_RSP_R1,
+
+	[24] = MMC_RSP_R1,
+	[25] = MMC_RSP_R1,
+	[27] = MMC_RSP_R1,
+	[28] = MMC_RSP_R1B,
+	[29] = MMC_RSP_R1B,
+
+	[30] = MMC_RSP_R1,
+	[32] = MMC_RSP_R1,
+	[33] = MMC_RSP_R1,
+	[34] = MMC_RSP_R1,
+	[35] = MMC_RSP_R1,
+	[36] = MMC_RSP_R1,
+	[37] = MMC_RSP_R1,
+	[38] = MMC_RSP_R1B,
+
+	[42] = MMC_RSP_R1B,
+
+	[55] = MMC_RSP_R1,
+	[56] = MMC_RSP_R1,
+	[58] = MMC_RSP_R3,	/* SPI-only command */
+	[59] = MMC_RSP_R1,	/* SPI-only command */
+};
+
+static const u8 acmd_map[64] = {
+	[13] = MMC_RSP_R2,
+
+	[22] = MMC_RSP_R1,
+	[23] = MMC_RSP_R1,
+
+	[41] = MMC_RSP_R1,
+	[42] = MMC_RSP_R1,
+
+	[51] = MMC_RSP_R1,
+};
+
+
+/* Issue command and read its response.
+ * Returns zero on success, negative for error.
+ *
+ * On error, caller must cope with mmc core retry mechanism.  That
+ * means immediate low-level resubmit, which affects the bus lock...
+ */
+static int
+mmc_spi_command_send(struct mmc_spi_host *host,
+		     struct mmc_request *mrq, u32 crc,
+		     struct mmc_command *cmd)
+{
+	union mmc_spi_command	*tx = &host->command;
+	u32			arg = cmd->arg;
+	int			status;
+	unsigned		opcode;
+	unsigned		opcond_retries = 25;
+
+again:
+	opcode = cmd->opcode;
+	if (host->app_cmd)
+		host->rsp_type = acmd_map[opcode & 0x3f];
+	else
+		host->rsp_type = resp_map[opcode & 0x3f];
+
+	if (host->rsp_type == MMC_RSP_NONE) {
+		dev_dbg(&host->spi->dev,
+			"  mmc_spi: INVALID %sCMD%d (%02x)\n",
+			host->app_cmd ? "A" : "",
+			opcode, opcode);
+		cmd->error = MMC_ERR_INVALID;
+		cmd->resp[0] = R1_ILLEGAL_COMMAND;
+		return -EBADR;
+	}
+
+	/* after 8 clock cycles the card is ready, and done previous cmd */
+	tx->command.dummy = 0xFF;
+
+	tx->command.code = opcode | SPI_MMC_COMMAND;
+	tx->command.addr1 = (arg & 0xFF000000) >> 24;
+	tx->command.addr2 = (arg & 0x00FF0000) >> 16;
+	tx->command.addr3 = (arg & 0x0000FF00) >> 8;
+	tx->command.addr4 = (arg & 0x000000FF);
+	tx->command.crc = crc & 0x000000FF;
+
+	dev_dbg(&host->spi->dev, "  mmc_spi: %scmd%d (%02x)\n",
+		host->app_cmd ? "a" : "", opcode, opcode);
+	status = spi_write(host->spi, tx->buf, sizeof(tx->buf));
+	if (status < 0) {
+		dev_dbg(&host->spi->dev, "  ... write returned %d\n", status);
+		cmd->error = MMC_ERR_FAILED;
+		return -EBADR;
+	}
+
+	mmc_spi_response_get(host, cmd);
+	if (cmd->error != MMC_ERR_NONE)
+		return -EBADR;
+
+	switch (opcode) {
+	case MMC_SEND_CID:
+	case MMC_SEND_CSD:
+		if (host->app_cmd)
+			goto done;
+		/* we report success later, after making it look like
+		 * there was no data stage (just a big status stage)
+		 */
+		break;
+	case SD_APP_OP_COND:
+		if (!host->app_cmd)
+			goto done;
+		/* retry MMC's OP_COND; it does the same thing, and it's
+		 * simpler to not send MMC_APP_COND then SD_APP_OP_COND
+		 */
+		host->app_cmd = 0;
+		cmd->opcode = MMC_SEND_OP_COND;
+		/* FALLTHROUGH */
+	case MMC_SEND_OP_COND:
+		if (host->app_cmd)
+			goto done;
+		/* without retries, the OCR we read is garbage */
+		if (host->status_byte & 0x01) {
+			if (opcond_retries == 0) {
+				dev_err(&host->spi->dev, "init failed\n");
+				goto done;
+			}
+			dev_dbg(&host->spi->dev,
+				"  retry for init complete...\n");
+			msleep(50);
+			opcond_retries--;
+			goto again;
+		}
+		dev_dbg(&host->spi->dev, "  patchup R3/OCR ...\n");
+		cmd->opcode = SPI_MMC_READ_OCR;
+		goto again;
+	default:
+done:
+		/*
+		 * If this was part of a request that has a stop-part,
+		 * don't signal the request as done; the caller will
+		 * do that.  Just return successfully.
+		 */
+		if (mrq->stop != NULL)
+			return 0;
+		mmc_request_done(host->mmc, mrq);
+	}
+	return 0;
+}
+
+/* Set up data message: first byte, data block (filled in later), then CRC. */
+static void
+mmc_spi_setup_message(
+	struct mmc_spi_host	*host,
+	int			multiple,
+	enum dma_data_direction	direction)
+{
+	struct device		*dma_dev = host->dma_dev;
+	struct spi_transfer	*t;
+
+	spi_message_init(&host->m);
+	if (dma_dev)
+		host->m.is_dma_mapped = 1;
+
+	/* for reads, we (manually) skip 0xff bytes before finding
+	 * the token; for writes, we issue it ourselves.
+	 */
+	if (direction == DMA_TO_DEVICE) {
+		t = &host->token;
+		memset(t, 0, sizeof *t);
+		t->len = 1;
+		if (multiple)
+			host->data_token = SPI_TOKEN_MULTI_WRITE;
+		else
+			host->data_token = SPI_TOKEN_SINGLE;
+		t->tx_buf = &host->data_token;
+		spi_message_add_tail(t, &host->m);
+	}
+
+	t = &host->t;
+	memset(t, 0, sizeof *t);
+	spi_message_add_tail(t, &host->m);
+
+	t = &host->crc;
+	memset(t, 0, sizeof *t);
+	t->len = 2;
+	spi_message_add_tail(t, &host->m);
+
+	t = &host->early_status;
+	memset(t, 0, sizeof *t);
+
+	/*
+	 * If this is a read, we need room for 0xFF (for
+	 * N\subscript{AC}) and the next token.  For a write, we need
+	 * room just for the one-byte data response.
+	 */
+	t->len = (direction == DMA_FROM_DEVICE) ? 2 : 1;
+	spi_message_add_tail(t, &host->m);
+	t->rx_buf = host->bundled_status;
+	if (dma_dev)
+		t->rx_dma = host->dma
+			+ offsetof(struct mmc_spi_host, bundled_status);
+	if ((host->spi->mode & SPI_TX_1) == 0) {
+		t->tx_buf = &host->ones;
+		if (dma_dev)
+			t->tx_dma = host->dma
+				+ offsetof(struct mmc_spi_host, ones);
+	}
+
+	t = &host->crc;
+
+	/* REVISIT crc wordsize == 2, avoid byteswap issues ... */
+
+	if (direction == DMA_TO_DEVICE) {
+		host->crc_val = CRC_NO_CRC;
+		t->tx_buf = &host->crc_val;
+		if (dma_dev) {
+			host->token.tx_dma = host->dma
+				+ offsetof(struct mmc_spi_host, data_token);
+			t->tx_dma = host->dma
+				+ offsetof(struct mmc_spi_host, crc_val);
+		}
+	} else {
+		t->rx_buf = &host->crc_val;
+		if (dma_dev)
+			t->rx_dma = host->dma
+				+ offsetof(struct mmc_spi_host, crc_val);
+
+		/* while we read data, write all-ones */
+		if ((host->spi->mode & SPI_TX_1) == 0) {
+			t->tx_buf = host->t.tx_buf = &host->ones;
+			if (dma_dev)
+				t->tx_dma = host->t.tx_dma = host->dma
+					+ offsetof(struct mmc_spi_host, ones);
+		}
+	}
+}
+
+
+static inline int resp2status(u8 write_resp)
+{
+	switch (SPI_MMC_RESPONSE_CODE(write_resp)) {
+	case SPI_RESPONSE_ACCEPTED:
+		return 0;
+	case SPI_RESPONSE_CRC_ERR:
+	case SPI_RESPONSE_WRITE_ERR:
+		/* host shall then issue MMC_STOP_TRANSMISSION */
+		return -EIO;
+	default:
+		return -EILSEQ;
+	}
+}
+
+
+static void
+mmc_spi_data_do(struct mmc_spi_host *host, struct mmc_command *cmd,
+		struct mmc_data *data, u32 blk_size)
+{
+	struct spi_device	*spi = host->spi;
+	struct device		*dma_dev = host->dma_dev;
+	struct spi_transfer	*t;
+	enum dma_data_direction	direction;
+	struct scatterlist	*sg;
+	unsigned		n_sg;
+	int			multiple;
+
+	if (data->flags & MMC_DATA_READ) {
+		direction = DMA_FROM_DEVICE;
+		multiple = (cmd->opcode == MMC_READ_MULTIPLE_BLOCK);
+
+		/*
+		 * We need to scan for the SPI_TOKEN_SINGLE token
+		 * *before* we issue the first (of multiple)
+		 * spi_messages reading the data plus two extra bytes,
+		 * (implying N\subscript{AC} and the *next* token), so
+		 * to avoid looking at garbage from an earlier
+		 * command, we reset the location where we'll read in
+		 * subsequent tokens.
+		 */
+		host->bundled_status[0] = 0xff;
+		host->bundled_status[1] = 0xff;
+	} else {
+		direction = DMA_TO_DEVICE;
+		multiple = (cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK);
+	}
+	mmc_spi_setup_message(host, multiple, direction);
+	t = &host->t;
+
+	/* Handle scatterlist segments one at a time, with synch for
+	 * each 512-byte block
+	 */
+	for (sg = data->sg, n_sg = data->sg_len; n_sg; n_sg--, sg++) {
+		int			status = 0;
+		dma_addr_t		dma_addr = 0;
+		void			*kmap_addr;
+		unsigned		length = sg->length;
+
+		/* set up dma mapping for controller drivers that might
+		 * use DMA ... though they may fall back to PIO
+		 */
+		if (dma_dev) {
+			dma_addr = dma_map_page(dma_dev, sg->page, 0,
+						PAGE_SIZE, direction);
+			if (direction == DMA_TO_DEVICE)
+				t->tx_dma = dma_addr + sg->offset;
+			else
+				t->rx_dma = dma_addr + sg->offset;
+			dma_sync_single_for_device(host->dma_dev,
+				host->dma, sizeof *host, direction);
+		}
+
+		/* allow pio too, with kmap handling any highmem */
+		kmap_addr = kmap_atomic(sg->page, 0);
+		if (direction == DMA_TO_DEVICE)
+			t->tx_buf = kmap_addr + sg->offset;
+		else
+			t->rx_buf = kmap_addr + sg->offset;
+
+		/* transfer each block, and update request status */
+		while (length && status == 0) {
+			t->len = min(length, blk_size);
+
+			dev_dbg(&host->spi->dev,
+				"    mmc_spi: %s block, %d bytes\n",
+				(direction == DMA_TO_DEVICE)
+				? "write"
+				: "read",
+				t->len);
+
+			if (direction == DMA_TO_DEVICE) {
+				int	response;
+
+				/* REVISIT once we start using TX crc, first
+				 * compute that value then dma_sync
+				 */
+
+				status = spi_sync(spi, &host->m);
+				if (status != 0) {
+					dev_err(&spi->dev,
+						"write error (%d)\n", status);
+					break;
+				}
+
+				/*
+				 * Get the transmission data-response
+				 * reply.  It must follow immediately
+				 * after the data block we
+				 * transferred.  This reply doesn't
+				 * necessarily tell whether the write
+				 * operation succeeded, it just tells
+				 * that the transmission was ok and
+				 * whether *earlier* writes succeeded;
+				 * see the standard.
+				 */
+				response = host->bundled_status[0];
+				if (response == 0xff) {
+					dev_err(&spi->dev,
+						"missing card response\n");
+					status = -EIO;
+					break;
+				}
+
+				if (response < 0)
+					status = response;
+				else
+					status = resp2status(response);
+				if (status != 0) {
+					dev_err(&spi->dev,
+						"write error %02x (%d)\n",
+						response, status);
+					break;
+				}
+				t->tx_buf += t->len;
+				if (dma_dev)
+					t->tx_dma += t->len;
+
+				/* Wait until not busy.  */
+				response = mmc_spi_scanbyte(host, mmc_spi_busy,
+							WRITE_TIMEOUT);
+			} else {
+				/*
+				 * Note that N\subscript{AC} is *at
+				 * least* one byte, so we should never
+				 * see a card that responds in the
+				 * first byte (otherwise defined to be
+				 * 0xff).  Right, better assert that...
+				 */
+				if (host->bundled_status[0] != 0xff) {
+					/* We either make it an error or
+					 * somehow wedge in the next byte,
+					 * because that's then the first
+					 * in the block we read.  */
+					dev_err(&spi->dev,
+						"too-early card "
+						"response %02x %02x\n",
+						host->bundled_status[0],
+						host->bundled_status[1]);
+					status = -EIO;
+					break;
+				}
+
+				if (host->bundled_status[1] != 0xff)
+					status = host->bundled_status[1];
+				else
+					status = mmc_spi_scanbyte(host, mmc_spi_delayed,
+								  READ_TIMEOUT);
+
+				if (status == SPI_TOKEN_SINGLE) {
+					status = spi_sync(spi, &host->m);
+					dma_sync_single_for_cpu(host->dma_dev,
+						host->dma, sizeof *host,
+						direction);
+				} else {
+					/* we've read extra garbage */
+					dev_err(&spi->dev,
+						"read error %02x\n",
+						status);
+					cmd->resp[0] = 0;
+					mmc_spi_map_r2(cmd, status);
+					if (cmd->error == MMC_ERR_NONE)
+						cmd->error = MMC_ERR_FAILED;
+					break;
+				}
+
+				/* REVISIT eventually, check crc */
+				t->rx_buf += t->len;
+				if (dma_dev)
+					t->rx_dma += t->len;
+			}
+
+			data->bytes_xfered += t->len;
+			if (status == 0) {
+				status = host->m.status;
+				length -= t->len;
+			}
+
+			if (!multiple)
+				break;
+		}
+
+		/* discard mappings */
+		kunmap_atomic(addr, 0);
+		if (direction == DMA_FROM_DEVICE)
+			flush_kernel_dcache_page(sg->page);
+		if (dma_dev)
+			dma_unmap_page(dma_dev, dma_addr,
+					PAGE_SIZE, direction);
+
+		if (status < 0) {
+			dev_dbg(&spi->dev, "%s status %d\n",
+				(direction == DMA_TO_DEVICE)
+					? "write" : "read",
+				status);
+			if (cmd->error == MMC_ERR_NONE)
+				cmd->error = MMC_ERR_FAILED;
+			break;
+		}
+	}
+
+	if (direction == DMA_TO_DEVICE && multiple) {
+		/*
+		 * Send the SPI_TOKEN_STOP_TRAN byte, ignoring the
+		 * received byte (presumably 0xff).
+		 */
+		u8 dat = SPI_TOKEN_STOP_TRAN;
+		ssize_t status = spi_write(spi, &dat, 1);
+
+		if (status < 0) {
+			cmd->error = MMC_ERR_FAILED;
+			return;
+		}
+
+		/*
+		 * Then skip the next byte.  This is the maximum
+		 * non-busy time before the first busy-token.  If we
+		 * don't skip it, we'll mistake it for the end of the
+		 * busy-period.  See also "Figure 5-28" in SanDisk's
+		 * ProdManRS-MMCv1.3.pdf; this is marked "X"
+		 * (undefined value) of length N\subscript{BR} (min 0
+		 * max 1 byte).
+		 */
+		status = mmc_spi_readbyte(host);
+		if (status < 0) {
+			cmd->error = MMC_ERR_FAILED;
+			return;
+		}
+
+		/*
+		 * Now wait until the end of the busy period.  If
+		 * N\subscript{BR} (see ref above) was 0, we'll never
+		 * see any busy period.  FIXME: defer the wait to next
+		 * command; sleep.
+		 */
+		status = mmc_spi_scanbyte(host, mmc_spi_busy, WRITE_TIMEOUT);
+		if (status < 0) {
+			cmd->error = MMC_ERR_FAILED;
+			return;
+		}
+	}
+}
+
+static int
+mmc_spi_command_do(struct mmc_spi_host *host, struct mmc_request *mrq)
+{
+	int status;
+
+	status = mmc_spi_command_send(host, mrq, CRC_NO_CRC, mrq->cmd);
+
+	if (status == 0 && mrq->data)
+		mmc_spi_data_do(host, mrq->cmd, mrq->data,
+				mrq->data->blksz);
+	if (mrq->stop) {
+		if (status == 0) {
+			status = mmc_spi_command_send(host, mrq, CRC_NO_CRC,
+						      mrq->stop);
+			if (status != 0)
+				mrq->stop->error = MMC_ERR_FAILED;
+			mmc_request_done(host->mmc, mrq);
+		}
+	}
+
+	return status;
+}
+
+static int
+mmc_spi_send_cXd(struct mmc_spi_host *host, struct mmc_request *mrq)
+{
+	int	status;
+	u32	*resp = mrq->cmd->resp;
+
+	mrq->cmd->arg = NO_ARG;
+	status = mmc_spi_command_send(host, mrq, CRC_NO_CRC, mrq->cmd);
+	if (status < 0)
+		return status;
+
+	/* response_get() saw an SPI R1 response, but command_send()
+	 * knew we'd patch the expected MMC/SD "R2" style status here.
+	 */
+	mmc_spi_setup_message(host, 0, DMA_FROM_DEVICE);
+	host->m.is_dma_mapped = 0;
+	host->t.rx_buf = resp;
+	host->t.len = 16;
+
+	status = mmc_spi_scanbyte(host, mmc_spi_delayed, READ_TIMEOUT);
+
+	if (status == SPI_TOKEN_SINGLE) {
+		/* NOTE: many controllers can't support 32 bit words,
+		 * which is why we use byteswapping here instead.
+		 */
+		status = spi_sync(host->spi, &host->m);
+		if (status < 0)
+			mrq->cmd->error = MMC_ERR_FAILED;
+		else {
+			be32_to_cpus(&resp[0]);
+			be32_to_cpus(&resp[1]);
+			be32_to_cpus(&resp[2]);
+			be32_to_cpus(&resp[3]);
+		}
+	} else {
+		if (status >= 0) {
+			dev_dbg(&host->spi->dev,
+				"mmc_spi: read cXd err %02x\n",
+				status);
+			mmc_spi_map_r2(mrq->cmd, status);
+			status = -ETIMEDOUT;
+		}
+		mrq->cmd->error = MMC_ERR_TIMEOUT;
+	}
+	if (status == 0)
+		mmc_request_done(host->mmc, mrq);
+	else
+		dev_dbg(&host->spi->dev,
+			"mmc_spi: read cXd, %d \n", status);
+	return status;
+}
+
+/* reset ... with cmd->opcode == MMC_GO_IDLE_STATE */
+static int
+mmc_spi_initialize(struct mmc_spi_host *host, struct mmc_request *mrq)
+{
+	struct mmc_command	*cmd = mrq->cmd;
+	int			status;
+	int			could_invert_cs = 0;
+
+	host->cid_sequence = 0;
+
+	/* REVISIT put a powercycle reset here?  */
+
+	/* try to be very sure any previous command has completed;
+	 * wait till not-busy, skip debris from any old commands,
+	 */
+	(void) mmc_spi_scanbyte(host, mmc_spi_busy, WRITE_TIMEOUT);
+	(void) mmc_spi_readbytes(host, host->command.buf,
+				 sizeof host->command.buf);
+
+	/*
+	 * Do a burst with chipselect deactivated.  We need to do this
+	 * to meet the requirement of 74 clock cycles with chipselect
+	 * high before CMD0.  (Section 6.4.1, in "Simplified Physical
+	 * Layer Specification 2.0".)  Some cards are particularly
+	 * needy of this (e.g. Viking "SD256") while most others don't
+	 * seem to care.  Note that it's not enough to deactivate
+	 * chipselect without toggling the clock.  Beware of the hack:
+	 * we "know" that mmc_spi_readbytes uses the host->status
+	 * spi_transfer.
+	 */
+	host->spi->mode |= SPI_CS_HIGH;
+	if (spi_setup(host->spi) != 0)
+		/* Just a brief warning; most cards work without it.  */
+		dev_warn(&host->spi->dev,
+			 "can't invert the active chip-select level\n");
+	else
+		could_invert_cs = 1;
+
+	(void) mmc_spi_readbytes(host, host->command.buf,
+				 sizeof host->command.buf);
+	(void) mmc_spi_readbytes(host, host->command.buf,
+				 sizeof host->command.buf);
+
+	host->spi->mode &= ~SPI_CS_HIGH;
+	if (spi_setup(host->spi) != 0) {
+		/* Wot, we can't get (back) the same setup we had before?  */
+		dev_err(&host->spi->dev,
+			 "failed inverting the active chip-select level\n");
+		return -EIO;
+	}
+
+	/* issue software reset */
+	cmd->arg = 0;
+	status = mmc_spi_command_send(host, mrq, CRC_GO_IDLE_STATE, cmd);
+	if (status < 0) {
+		/* maybe:
+		 *  - there's no card present
+		 *  - the card isn't seated correctly (bad contacts)
+		 *  - it didn't leave MMC/SD mode
+		 *  - there's other confusion in the card state
+		 *
+		 * power cycling the card ought to help a lot.
+		 * At any rate, let's try again.
+		 */
+		status = mmc_spi_command_send(host, mrq, CRC_GO_IDLE_STATE,
+					      cmd);
+		if (status < 0)
+			dev_err(&host->spi->dev,
+				"can't initialize the card: no card%s?\n",
+				!could_invert_cs
+				? (" or because the active chip-select"
+				   " level can't be inverted") : "");
+	}
+	return status;
+}
+
+/****************************************************************************/
+
+/*
+ * MMC Implementation
+ */
+
+static void mmc_spi_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct mmc_spi_host	*host = mmc_priv(mmc);
+	int			status = 0;
+	u8			opcode = mrq->cmd->opcode;
+
+	/*
+	 * Translation between MMC/SD protocol commands and SPI ones
+	 */
+	if (!host->app_cmd) {
+		switch (opcode) {
+		case MMC_GO_IDLE_STATE:
+			status = mmc_spi_initialize(host, mrq);
+			break;
+		case MMC_APP_CMD:
+			status = mmc_spi_command_do(host, mrq);
+			if (status == 0) {
+				host->app_cmd = 1;
+				mrq->cmd->resp[0] |= R1_APP_CMD;
+			}
+			break;
+		case MMC_ALL_SEND_CID:
+			/* fake a one-node broadcast */
+			if (host->cid_sequence) {
+				mrq->cmd->retries = 0;
+				mrq->cmd->error = MMC_ERR_TIMEOUT;
+				host->cid_sequence = 0;
+				status = -ETIMEDOUT;
+			} else {
+				mrq->cmd->opcode = MMC_SEND_CID;
+				status = mmc_spi_send_cXd(host, mrq);
+				host->cid_sequence++;
+			}
+			break;
+		case MMC_SEND_CID:
+		case MMC_SEND_CSD:
+			status = mmc_spi_send_cXd(host, mrq);
+			break;
+
+		/* No honest translation for these in SPI mode :(
+		 * ... mmc core shouldn't issue them, then!!
+		 */
+		case MMC_SET_RELATIVE_ADDR:
+		case MMC_SET_DSR:
+		case MMC_SELECT_CARD:
+		case MMC_READ_DAT_UNTIL_STOP:
+		case MMC_GO_INACTIVE_STATE:
+		case MMC_SET_BLOCK_COUNT:
+		case MMC_PROGRAM_CID:
+			mmc_request_done(host->mmc, mrq);
+			break;
+
+		case MMC_SEND_STATUS:
+			/*
+			 * This command must be allowed to fail, else we
+			 * won't notice card changes (de/insertion).
+			 */
+			status = mmc_spi_command_do(host, mrq);
+
+			if (status == 0) {
+				mrq->cmd->resp[0] |= R1_READY_FOR_DATA;
+				/*
+				 * The mmc_spi_map_r2 function in the
+				 * mmc_spi_command_do call helpfully filled in the
+				 * "failed" status, but we're just the messenger.
+				 * We have no way to show that *this* command
+				 * actually failed.
+				 */
+				mrq->cmd->error = MMC_ERR_NONE;
+			}
+			break;
+
+		default:
+			status = mmc_spi_command_do(host, mrq);
+		}
+	} else {
+		status = mmc_spi_command_do(host, mrq);
+		host->app_cmd = 0;
+	}
+
+	/*
+	 * No need to wait before the next command.  The minimum time
+	 * between commands is handled by the "dummy" byte in the command.
+	 */
+
+	/*
+	 * If status was ok, the request would have been signalled done by
+	 * mmc_spi_command_do.
+	 */
+	if (status < 0)
+		mmc_request_done(host->mmc, mrq);
+}
+
+
+static void mmc_spi_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mmc_spi_host *host = mmc_priv(mmc);
+
+	if (host->pdata && host->pdata->setpower) {
+		dev_dbg(&host->spi->dev,
+			"mmc_spi:  power %08x\n", ios->vdd);
+		host->pdata->setpower(&host->spi->dev, ios->vdd);
+		msleep(MMC_POWERCYCLE_MSECS);
+	}
+
+	if (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {
+		int		status;
+
+		host->spi->max_speed_hz = ios->clock;
+		status = spi_setup(host->spi);
+		dev_dbg(&host->spi->dev,
+			"mmc_spi:  clock to %d Hz, %d\n",
+			host->spi->max_speed_hz, status);
+	}
+}
+
+static int mmc_spi_get_ro(struct mmc_host *mmc)
+{
+	struct mmc_spi_host *host = mmc_priv(mmc);
+
+	if (host->pdata && host->pdata->get_ro)
+		return host->pdata->get_ro(mmc->dev);
+	/* board doesn't support read only detection; assume writeable */
+	return 0;
+}
+
+
+static struct mmc_host_ops mmc_spi_ops = {
+	.request	= mmc_spi_request,
+	.set_ios	= mmc_spi_set_ios,
+	.get_ro		= mmc_spi_get_ro,
+};
+
+
+/****************************************************************************/
+
+/*
+ * Generic Device driver routines and interface implementation
+ */
+
+static irqreturn_t
+mmc_spi_detect_irq(int irq, void *mmc)
+{
+	struct mmc_spi_host *host = mmc_priv(mmc);
+
+	mmc_detect_change(mmc, host->pdata->detect_delay);
+	return IRQ_HANDLED;
+}
+
+static int __devinit mmc_spi_probe(struct spi_device *spi)
+{
+	struct mmc_host		*mmc;
+	struct mmc_spi_host	*host;
+	int			status;
+	int			power_manageable = 1;
+
+	spi->mode |= (SPI_CPOL|SPI_CPHA|SPI_TX_1);
+	spi->bits_per_word = 8;
+
+	status = spi_setup(spi);
+	if (status < 0) {
+		dev_dbg(&spi->dev, "can't handle SPI_TX_1?\n");
+
+		/*
+		 * Maybe because we specified SPI_TX_1, and the controller
+		 * can't handle it.  We'll fall back on using a buffer
+		 * with ones.
+		 */
+		spi->mode = SPI_CPOL|SPI_CPHA;
+		status = spi_setup(spi);
+		if (status < 0) {
+			/* Nope, guess it's the mode then.  */
+			dev_dbg(&spi->dev, "needs SPI mode 3\n");
+			return status;
+		}
+	}
+
+	mmc = mmc_alloc_host(sizeof *host
+			     + ((spi->mode & SPI_TX_1) == 0
+				? ONES_BUFFER_SIZE : 0), &spi->dev);
+	if (!mmc)
+		/* Luckily, there's no spi_takedown or any need for it.  */
+		return -ENOMEM;
+
+	mmc->ops = &mmc_spi_ops;
+	mmc->ocr_avail = 0xFFFFFFFF;
+
+	/*
+	 * As long as we keep track of the number of successfully
+	 * transmitted blocks, we're good for this.  The lesser bytes
+	 * over the wire, the better.
+	 */
+	mmc->caps |= MMC_CAP_MULTIWRITE;
+
+	mmc->f_min = 125000;
+	mmc->f_max = 25 * 1000 * 1000;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->spi = spi;
+	host->cid_sequence = 0;
+	if ((host->spi->mode & SPI_TX_1) == 0)
+		memset(host->ones, 0xff, ONES_BUFFER_SIZE);
+
+	/* platform data is used to hook up things like card sensing
+	 * and power switching gpios
+	 */
+	host->pdata = spi->dev.platform_data;
+	mmc->ocr_avail = host->pdata
+			?  host->pdata->ocr_mask
+			: MMC_VDD_32_33|MMC_VDD_33_34;
+
+	dev_set_drvdata(&spi->dev, mmc);
+
+	/* setup message for status readback/write-ones */
+	spi_message_init(&host->readback);
+	spi_message_add_tail(&host->status, &host->readback);
+	if ((host->spi->mode & SPI_TX_1) == 0)
+		host->status.tx_buf = host->ones;
+	host->status.rx_buf = &host->status_byte;
+	host->status.len = 1;
+
+	if (spi->master->cdev.dev->dma_mask) {
+		host->dma_dev = spi->master->cdev.dev;
+		host->dma = dma_map_single(host->dma_dev, host,
+				sizeof *host, DMA_BIDIRECTIONAL);
+#ifdef	CONFIG_HIGHMEM
+		dev_dbg(&spi->dev, "highmem + dma-or-pio ...\n");
+#endif
+	}
+
+	/* once card enters SPI mode it stays that way till power cycled.
+	 * power cycling can be used as a hard reset for fault recovery.
+	 */
+	if (!host->pdata || !host->pdata->setpower)
+		power_manageable = 0;
+	else
+		host->pdata->setpower(&spi->dev, 0);
+
+	if (host->pdata && host->pdata->init) {
+		status = host->pdata->init(&spi->dev,
+					   mmc_spi_detect_irq, mmc);
+		if (status != 0)
+			goto fail_glue_init;
+	}
+
+	status = mmc_add_host(mmc);
+	if (status != 0)
+		goto fail_add_host;
+
+	dev_info(&spi->dev, "SD/MMC <-> SPI proxy driver%s\n",
+		 power_manageable ? "" : ", no card power management");
+	return 0;
+
+ fail_add_host:
+	mmc_remove_host (mmc);
+	if (host->dma_dev)
+		dma_unmap_single(host->dma_dev, host->dma,
+				 sizeof *host, DMA_BIDIRECTIONAL);
+ fail_glue_init:
+	mmc_free_host(mmc);
+	dev_set_drvdata(&spi->dev, NULL);
+	return status;
+}
+
+
+static int __devexit mmc_spi_remove(struct spi_device *spi)
+{
+	struct mmc_host		*mmc = dev_get_drvdata(&spi->dev);
+	struct mmc_spi_host	*host;
+
+	if (mmc) {
+		mmc_remove_host(mmc);
+		host = mmc_priv(mmc);
+
+		if (host->pdata && host->pdata->exit)
+			host->pdata->exit(&spi->dev, mmc);
+		if (host->dma_dev)
+			dma_unmap_single(host->dma_dev, host->dma,
+				sizeof *host, DMA_BIDIRECTIONAL);
+
+		mmc_free_host(mmc);
+		dev_set_drvdata(&spi->dev, NULL);
+	}
+	return 0;
+}
+
+
+static struct spi_driver mmc_spi_driver = {
+	.driver = {
+		.name =		"mmc_spi",
+		.bus =		&spi_bus_type,
+		.owner =	THIS_MODULE,
+	},
+	.probe =	mmc_spi_probe,
+	.remove =	__devexit_p(mmc_spi_remove),
+};
+
+
+static int __init mmc_spi_init(void)
+{
+	return spi_register_driver(&mmc_spi_driver);
+}
+module_init(mmc_spi_init);
+
+
+static void __exit mmc_spi_exit(void)
+{
+	spi_unregister_driver(&mmc_spi_driver);
+}
+module_exit(mmc_spi_exit);
+
+
+MODULE_AUTHOR("Mike Lavender, David Brownell");
+MODULE_DESCRIPTION("SPI SD/MMC driver");
+MODULE_LICENSE("GPL");
diff -Naur archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0001.c
--- archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0001.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0001.c	2007-08-30 09:04:28.000000000 +0200
@@ -331,20 +331,13 @@
 	return extp;
 }
 
-/* This routine is made available to other mtd code via
- * inter_module_register.  It must only be accessed through
- * inter_module_get which will bump the use count of this module.  The
- * addresses passed back in cfi are valid as long as the use count of
- * this module is non-zero, i.e. between inter_module_get and
- * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
- */
 struct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct mtd_info *mtd;
 	int i;
 
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	mtd = kzalloc(sizeof(*mtd), GFP_KERNEL);
 	if (!mtd) {
 		printk(KERN_ERR "Failed to allocate memory for MTD device\n");
 		return NULL;
@@ -415,6 +408,11 @@
 
 	return cfi_intelext_setup(mtd);
 }
+struct mtd_info *cfi_cmdset_0003(struct map_info *map, int primary) __attribute__((alias("cfi_cmdset_0001")));
+struct mtd_info *cfi_cmdset_0200(struct map_info *map, int primary) __attribute__((alias("cfi_cmdset_0001")));
+EXPORT_SYMBOL_GPL(cfi_cmdset_0001);
+EXPORT_SYMBOL_GPL(cfi_cmdset_0003);
+EXPORT_SYMBOL_GPL(cfi_cmdset_0200);
 
 static struct mtd_info *cfi_intelext_setup(struct mtd_info *mtd)
 {
@@ -2445,28 +2443,8 @@
 	kfree(mtd->eraseregions);
 }
 
-static char im_name_0001[] = "cfi_cmdset_0001";
-static char im_name_0003[] = "cfi_cmdset_0003";
-static char im_name_0200[] = "cfi_cmdset_0200";
-
-static int __init cfi_intelext_init(void)
-{
-	inter_module_register(im_name_0001, THIS_MODULE, &cfi_cmdset_0001);
-	inter_module_register(im_name_0003, THIS_MODULE, &cfi_cmdset_0001);
-	inter_module_register(im_name_0200, THIS_MODULE, &cfi_cmdset_0001);
-	return 0;
-}
-
-static void __exit cfi_intelext_exit(void)
-{
-	inter_module_unregister(im_name_0001);
-	inter_module_unregister(im_name_0003);
-	inter_module_unregister(im_name_0200);
-}
-
-module_init(cfi_intelext_init);
-module_exit(cfi_intelext_exit);
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
 MODULE_DESCRIPTION("MTD chip driver for Intel/Sharp flash chips");
+MODULE_ALIAS("cfi_cmdset_0003");
+MODULE_ALIAS("cfi_cmdset_0200");
diff -Naur archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0002.c
--- archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0002.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0002.c	2007-08-30 09:04:28.000000000 +0200
@@ -21,7 +21,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -218,7 +217,7 @@
 	struct mtd_info *mtd;
 	int i;
 
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	mtd = kzalloc(sizeof(*mtd), GFP_KERNEL);
 	if (!mtd) {
 		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
 		return NULL;
@@ -326,7 +325,7 @@
 
 	return cfi_amdstd_setup(mtd);
 }
-
+EXPORT_SYMBOL_GPL(cfi_cmdset_0002);
 
 static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
 {
@@ -1640,6 +1639,7 @@
 
 		default:
 			/* Not an idle state */
+			set_current_state(TASK_UNINTERRUPTIBLE);	//<- DGS mod.
 			add_wait_queue(&chip->wq, &wait);
 
 			spin_unlock(chip->mutex);
@@ -1758,25 +1758,6 @@
 	kfree(mtd->eraseregions);
 }
 
-static char im_name[]="cfi_cmdset_0002";
-
-
-static int __init cfi_amdstd_init(void)
-{
-	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0002);
-	return 0;
-}
-
-
-static void __exit cfi_amdstd_exit(void)
-{
-	inter_module_unregister(im_name);
-}
-
-
-module_init(cfi_amdstd_init);
-module_exit(cfi_amdstd_exit);
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Crossnet Co. <info@crossnet.co.jp> et al.");
 MODULE_DESCRIPTION("MTD chip driver for AMD/Fujitsu flash chips");
diff -Naur archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0020.c linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0020.c
--- archive/linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0020.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/chips/cfi_cmdset_0020.c	2007-08-30 09:04:28.000000000 +0200
@@ -162,6 +162,7 @@
 
 	return cfi_staa_setup(map);
 }
+EXPORT_SYMBOL_GPL(cfi_cmdset_0020);
 
 static struct mtd_info *cfi_staa_setup(struct map_info *map)
 {
@@ -171,7 +172,7 @@
 	int i,j;
 	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	mtd = kzalloc(sizeof(*mtd), GFP_KERNEL);
 	//printk(KERN_DEBUG "number of CFI chips: %d\n", cfi->numchips);
 
 	if (!mtd) {
@@ -1410,20 +1411,4 @@
 	kfree(cfi);
 }
 
-static char im_name[]="cfi_cmdset_0020";
-
-static int __init cfi_staa_init(void)
-{
-	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0020);
-	return 0;
-}
-
-static void __exit cfi_staa_exit(void)
-{
-	inter_module_unregister(im_name);
-}
-
-module_init(cfi_staa_init);
-module_exit(cfi_staa_exit);
-
 MODULE_LICENSE("GPL");
diff -Naur archive/linux-2.6.17/drivers/mtd/chips/gen_probe.c linux-2.6.17/drivers/mtd/chips/gen_probe.c
--- archive/linux-2.6.17/drivers/mtd/chips/gen_probe.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/chips/gen_probe.c	2007-08-30 09:04:28.000000000 +0200
@@ -101,7 +101,7 @@
 	 */
 	max_chips = map->size >> cfi.chipshift;
 	mapsize = (max_chips / 8) + ((max_chips % 8) ? 1 : 0);
-	chip_map = kmalloc(mapsize, GFP_KERNEL);
+	chip_map = kzalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
 		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);
 		kfree(cfi.cfiq);
@@ -194,25 +194,28 @@
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
-#if defined(CONFIG_MODULES) && defined(HAVE_INTER_MODULE)
-	char probename[32];
+#ifdef CONFIG_MODULES
+	char probename[16+sizeof(MODULE_SYMBOL_PREFIX)];
 	cfi_cmdset_fn_t *probe_function;
 
-	sprintf(probename, "cfi_cmdset_%4.4X", type);
+	sprintf(probename, MODULE_SYMBOL_PREFIX "cfi_cmdset_%4.4X", type);
 
-	probe_function = inter_module_get_request(probename, probename);
+	probe_function = __symbol_get(probename);
+	if (!probe_function) {
+		request_module(probename + sizeof(MODULE_SYMBOL_PREFIX) - 1);
+		probe_function = __symbol_get(probename);
+	}
 
 	if (probe_function) {
 		struct mtd_info *mtd;
 
 		mtd = (*probe_function)(map, primary);
 		/* If it was happy, it'll have increased its own use count */
-		inter_module_put(probename);
+		symbol_put_addr(probe_function);
 		return mtd;
 	}
 #endif
-	printk(KERN_NOTICE "Support for command set %04X not present\n",
-	       type);
+	printk(KERN_NOTICE "Support for command set %04X not present\n", type);
 
 	return NULL;
 }
diff -Naur archive/linux-2.6.17/drivers/mtd/devices/doc2000.c linux-2.6.17/drivers/mtd/devices/doc2000.c
--- archive/linux-2.6.17/drivers/mtd/devices/doc2000.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/devices/doc2000.c	2007-08-30 09:04:28.000000000 +0200
@@ -517,16 +517,9 @@
 	return retval;
 }
 
-static const char im_name[] = "DoC2k_init";
-
-/* This routine is made available to other mtd code via
- * inter_module_register.  It must only be accessed through
- * inter_module_get which will bump the use count of this module.  The
- * addresses passed back in mtd are valid as long as the use count of
- * this module is non-zero, i.e. between inter_module_get and
- * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
- */
-static void DoC2k_init(struct mtd_info *mtd)
+/* This routine is found from the docprobe code by symbol_get(),
+ * which will bump the use count of this module. */
+void DoC2k_init(struct mtd_info *mtd)
 {
 	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
@@ -623,6 +616,7 @@
 		return;
 	}
 }
+EXPORT_SYMBOL_GPL(DoC2k_init);
 
 static int doc_read(struct mtd_info *mtd, loff_t from, size_t len,
 		    size_t * retlen, u_char * buf)
@@ -1277,12 +1271,6 @@
  *
  ****************************************************************************/
 
-static int __init init_doc2000(void)
-{
-       inter_module_register(im_name, THIS_MODULE, &DoC2k_init);
-       return 0;
-}
-
 static void __exit cleanup_doc2000(void)
 {
 	struct mtd_info *mtd;
@@ -1298,11 +1286,9 @@
 		kfree(this->chips);
 		kfree(mtd);
 	}
-	inter_module_unregister(im_name);
 }
 
 module_exit(cleanup_doc2000);
-module_init(init_doc2000);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
diff -Naur archive/linux-2.6.17/drivers/mtd/devices/doc2001.c linux-2.6.17/drivers/mtd/devices/doc2001.c
--- archive/linux-2.6.17/drivers/mtd/devices/doc2001.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/devices/doc2001.c	2007-08-30 09:04:28.000000000 +0200
@@ -324,16 +324,9 @@
 	return retval;
 }
 
-static const char im_name[] = "DoCMil_init";
-
-/* This routine is made available to other mtd code via
- * inter_module_register.  It must only be accessed through
- * inter_module_get which will bump the use count of this module.  The
- * addresses passed back in mtd are valid as long as the use count of
- * this module is non-zero, i.e. between inter_module_get and
- * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
- */
-static void DoCMil_init(struct mtd_info *mtd)
+/* This routine is found from the docprobe code by symbol_get(),
+ * which will bump the use count of this module. */
+void DoCMil_init(struct mtd_info *mtd)
 {
 	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
@@ -401,6 +394,7 @@
 		return;
 	}
 }
+EXPORT_SYMBOL_GPL(DoCMil_init);
 
 static int doc_read (struct mtd_info *mtd, loff_t from, size_t len,
 		     size_t *retlen, u_char *buf)
@@ -856,12 +850,6 @@
  *
  ****************************************************************************/
 
-static int __init init_doc2001(void)
-{
-	inter_module_register(im_name, THIS_MODULE, &DoCMil_init);
-	return 0;
-}
-
 static void __exit cleanup_doc2001(void)
 {
 	struct mtd_info *mtd;
@@ -877,11 +865,9 @@
 		kfree(this->chips);
 		kfree(mtd);
 	}
-	inter_module_unregister(im_name);
 }
 
 module_exit(cleanup_doc2001);
-module_init(init_doc2001);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
diff -Naur archive/linux-2.6.17/drivers/mtd/devices/doc2001plus.c linux-2.6.17/drivers/mtd/devices/doc2001plus.c
--- archive/linux-2.6.17/drivers/mtd/devices/doc2001plus.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/devices/doc2001plus.c	2007-08-30 09:04:28.000000000 +0200
@@ -447,16 +447,9 @@
 	return retval;
 }
 
-static const char im_name[] = "DoCMilPlus_init";
-
-/* This routine is made available to other mtd code via
- * inter_module_register.  It must only be accessed through
- * inter_module_get which will bump the use count of this module.  The
- * addresses passed back in mtd are valid as long as the use count of
- * this module is non-zero, i.e. between inter_module_get and
- * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
- */
-static void DoCMilPlus_init(struct mtd_info *mtd)
+/* This routine is found from the docprobe code by symbol_get(),
+ * which will bump the use count of this module. */
+void DoCMilPlus_init(struct mtd_info *mtd)
 {
 	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
@@ -524,6 +517,7 @@
 		return;
 	}
 }
+EXPORT_SYMBOL_GPL(DoCMilPlus_init);
 
 #if 0
 static int doc_dumpblk(struct mtd_info *mtd, loff_t from)
@@ -1122,12 +1116,6 @@
  *
  ****************************************************************************/
 
-static int __init init_doc2001plus(void)
-{
-	inter_module_register(im_name, THIS_MODULE, &DoCMilPlus_init);
-	return 0;
-}
-
 static void __exit cleanup_doc2001plus(void)
 {
 	struct mtd_info *mtd;
@@ -1143,11 +1131,9 @@
 		kfree(this->chips);
 		kfree(mtd);
 	}
-	inter_module_unregister(im_name);
 }
 
 module_exit(cleanup_doc2001plus);
-module_init(init_doc2001plus);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Greg Ungerer <gerg@snapgear.com> et al.");
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/Kconfig linux-2.6.17/drivers/mtd/maps/Kconfig
--- archive/linux-2.6.17/drivers/mtd/maps/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/maps/Kconfig	2007-08-30 09:04:28.000000000 +0200
@@ -355,6 +355,118 @@
 	  TQ Components TQM834x boards. If you have one of these boards
 	  and would like to use the flash chips on it, say 'Y'.
 
+config MTD_RELOOK100S
+	tristate "Flash devices mapped on DGStation relook100s"
+	depends on RELOOK100S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook100 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK200S
+	tristate "Flash devices mapped on DGStation relook200s"
+	depends on RELOOK200S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook200 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK210
+	tristate "Flash devices mapped on DGStation relook210"
+	depends on RELOOK210
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook200 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK300
+	tristate "Flash devices mapped on DGStation relook300"
+	depends on RELOOK300
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook300 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK400
+	tristate "Flash devices mapped on DGStation relook400"
+	depends on RELOOK400
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook400 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK500S
+	tristate "Flash devices mapped on DGStation relook500s"
+	depends on RELOOK500S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook500s board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK500T
+	tristate "Flash devices mapped on DGStation relook500t"
+	depends on RELOOK500T
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook500t board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK510S
+	tristate "Flash devices mapped on DGStation relook510s"
+	depends on RELOOK510S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook510s board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK100S
+	tristate "Flash devices mapped on DGStation relook100s"
+	depends on RELOOK100S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook100 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK300
+	tristate "Flash devices mapped on DGStation relook300"
+	depends on RELOOK300
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook300 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK400
+	tristate "Flash devices mapped on DGStation relook400"
+	depends on RELOOK400
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook400 board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK500S
+	tristate "Flash devices mapped on DGStation relook500s"
+	depends on RELOOK500S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook500s board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK500T
+	tristate "Flash devices mapped on DGStation relook500t"
+	depends on RELOOK500T
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook500t board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
+config MTD_RELOOK510S
+	tristate "Flash devices mapped on DGStation relook510s"
+	depends on RELOOK510S
+	help
+	  This enables access routines for the flash chips on the DGStation
+	  relook510s board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
 config MTD_CSTM_MIPS_IXX
 	tristate "Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board"
 	depends on MIPS && MTD_CFI && MTD_JEDECPROBE && MTD_PARTITIONS
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/Makefile linux-2.6.17/drivers/mtd/maps/Makefile
--- archive/linux-2.6.17/drivers/mtd/maps/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/maps/Makefile	2007-08-30 09:04:28.000000000 +0200
@@ -50,6 +50,15 @@
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
 obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
 obj-$(CONFIG_MTD_REDWOOD)	+= redwood.o
+obj-$(CONFIG_MTD_RELOOK100S)	+= relook100s.o
+obj-$(CONFIG_MTD_RELOOK200S)	+= relook200s.o
+obj-$(CONFIG_MTD_RELOOK210)	+= relook210.o
+obj-$(CONFIG_MTD_RELOOK300)	+= relook300.o
+obj-$(CONFIG_MTD_RELOOK400)	+= relook400.o
+obj-$(CONFIG_MTD_RELOOK400C)	+= relook400c.o
+obj-$(CONFIG_MTD_RELOOK500S)	+= relook500s.o
+obj-$(CONFIG_MTD_RELOOK500T)	+= relook500t.o
+obj-$(CONFIG_MTD_RELOOK510S)	+= relook510s.o
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/relook100s.c linux-2.6.17/drivers/mtd/maps/relook100s.c
--- archive/linux-2.6.17/drivers/mtd/maps/relook100s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mtd/maps/relook100s.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,145 @@
+/*
+ * relook100.c - mapper for DGStation relook100
+ *
+ * Author : Hyunwoo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x00800000
+
+#define WELCOME_SIZE	0x040000
+#define KERNEL_SIZE	0x140000	// kernel size
+#define SYSTEM_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x1F0000
+#define BOOT_SIZE	0x030000	// boot loader
+
+static struct mtd_partition relook_flash_partitions[] = {
+	{
+		.name		= "nor.config_welcome",
+		.offset		= 0x0000,
+		.size		= WELCOME_SIZE,
+	},
+	{
+		.name		= "nor.db",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE),
+		.size		= DB_SIZE,
+	},
+	{
+		.name		= "nor.root",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE),
+		.size		= SYSTEM_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{	.name		= "nor.kernel",
+		.offset		= WELCOME_SIZE,
+		.size		= KERNEL_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	/* boot firmware */
+	{
+		.name		= "nor.boot",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+		.size		= BOOT_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+
+	/* partitions for upgrade */
+	{
+		.name		= "nor.kernel_root",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE),
+	},
+	{
+		.name		= "nor.kernel_root_db",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+	},
+	{
+		.name		= "nor.all_noboot",
+		.offset		= 0,
+		.size		= (WINDOW_SIZE-BOOT_SIZE),
+	},
+	{
+		.name		= "nor.all",
+		.offset		= 0,
+		.size		= WINDOW_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+};
+
+
+struct map_info relook_flash_map = {
+	.name = "DGStation relook100",
+	.size = WINDOW_SIZE,
+	.bankwidth = 2,
+	.phys = WINDOW_ADDR,
+};
+
+
+#define NUM_REDWOOD_FLASH_PARTITIONS \
+	(sizeof(relook_flash_partitions)/sizeof(relook_flash_partitions[0]))
+
+static struct mtd_info *relook_mtd;
+
+int __init init_relook_flash(void)
+{
+	printk(KERN_NOTICE "relook: flash mapping: %x at %x\n",
+			WINDOW_SIZE, WINDOW_ADDR);
+
+	relook_flash_map.virt =
+		(void __iomem*)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!relook_flash_map.virt) {
+		printk("init_relook_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&relook_flash_map);
+
+#ifdef CONFIG_MTD_CFI
+	relook_mtd = do_map_probe("cfi_probe",&relook_flash_map);
+#elif defined(CONFIG_MTD_AMDSTD)
+	relook_mtd = do_map_probe("amd_flash",&relook_flash_map);
+#else
+#error we have no chip driver.
+#endif
+
+	if (relook_mtd) {
+		relook_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(relook_mtd,
+				relook_flash_partitions,
+				NUM_REDWOOD_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_relook_flash(void)
+{
+	if (relook_mtd) {
+		del_mtd_partitions(relook_mtd);
+		/* moved iounmap after map_destroy - armin */
+		map_destroy(relook_mtd);
+		iounmap((void *)relook_flash_map.virt);
+	}
+}
+
+module_init(init_relook_flash);
+module_exit(cleanup_relook_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hyun-woo Park <parkhw00@dgstation.co.kr>");
+MODULE_DESCRIPTION("MTD map driver for the DGStation relook");
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/relook200s.c linux-2.6.17/drivers/mtd/maps/relook200s.c
--- archive/linux-2.6.17/drivers/mtd/maps/relook200s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mtd/maps/relook200s.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,144 @@
+/*
+ * relook100.c - mapper for DGStation relook100
+ *
+ * Author : Hyunwoo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x00800000
+
+#define WELCOME_SIZE	0x040000
+#define KERNEL_SIZE	0x160000	// kernel size
+#define SYSTEM_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x1d0000
+#define BOOT_SIZE	0x030000	// boot loader
+
+static struct mtd_partition relook_flash_partitions[] = {
+	{
+		.name		= "nor.config_welcome",
+		.offset		= 0x0000,
+		.size		= WELCOME_SIZE,
+	},
+	{
+		.name		= "nor.db",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE),
+		.size		= DB_SIZE,
+	},
+	{
+		.name		= "nor.root",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE),
+		.size		= SYSTEM_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{	.name		= "nor.kernel",
+		.offset		= WELCOME_SIZE,
+		.size		= KERNEL_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	/* boot firmware */
+	{
+		.name		= "nor.boot",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+		.size		= BOOT_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+
+	/* partitions for upgrade */
+	{
+		.name		= "nor.kernel_root",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE),
+	},
+	{
+		.name		= "nor.kernel_root_db",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+	},
+	{
+		.name		= "nor.all_noboot",
+		.offset		= 0,
+		.size		= (WINDOW_SIZE-BOOT_SIZE),
+	},
+	{
+		.name		= "nor.all",
+		.offset		= 0,
+		.size		= WINDOW_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+};
+
+struct map_info relook_flash_map = {
+	.name = "DGStation relook200",
+	.size = WINDOW_SIZE,
+	.bankwidth = 2,
+	.phys = WINDOW_ADDR,
+};
+
+
+#define NUM_REDWOOD_FLASH_PARTITIONS \
+	(sizeof(relook_flash_partitions)/sizeof(relook_flash_partitions[0]))
+
+static struct mtd_info *relook_mtd;
+
+int __init init_relook_flash(void)
+{
+	printk(KERN_NOTICE "relook: flash mapping: %x at %x\n",
+			WINDOW_SIZE, WINDOW_ADDR);
+
+	relook_flash_map.virt =
+		(void __iomem*)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!relook_flash_map.virt) {
+		printk("init_relook_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&relook_flash_map);
+
+#ifdef CONFIG_MTD_CFI
+	relook_mtd = do_map_probe("cfi_probe",&relook_flash_map);
+#elif defined(CONFIG_MTD_AMDSTD)
+	relook_mtd = do_map_probe("amd_flash",&relook_flash_map);
+#else
+#error we have no chip driver.
+#endif
+
+	if (relook_mtd) {
+		relook_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(relook_mtd,
+				relook_flash_partitions,
+				NUM_REDWOOD_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_relook_flash(void)
+{
+	if (relook_mtd) {
+		del_mtd_partitions(relook_mtd);
+		/* moved iounmap after map_destroy - armin */
+		map_destroy(relook_mtd);
+		iounmap((void *)relook_flash_map.virt);
+	}
+}
+
+module_init(init_relook_flash);
+module_exit(cleanup_relook_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hyun-woo Park <parkhw00@dgstation.co.kr>");
+MODULE_DESCRIPTION("MTD map driver for the DGStation relook");
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/relook210.c linux-2.6.17/drivers/mtd/maps/relook210.c
--- archive/linux-2.6.17/drivers/mtd/maps/relook210.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mtd/maps/relook210.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,144 @@
+/*
+ * relook100.c - mapper for DGStation relook100
+ *
+ * Author : Hyunwoo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x00800000
+
+#define WELCOME_SIZE	0x040000
+#define KERNEL_SIZE	0x160000	// kernel size
+#define SYSTEM_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x1d0000
+#define BOOT_SIZE	0x030000	// boot loader
+
+static struct mtd_partition relook_flash_partitions[] = {
+	{
+		.name		= "nor.config_welcome",
+		.offset		= 0x0000,
+		.size		= WELCOME_SIZE,
+	},
+	{
+		.name		= "nor.db",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE),
+		.size		= DB_SIZE,
+	},
+	{
+		.name		= "nor.root",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE),
+		.size		= SYSTEM_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{	.name		= "nor.kernel",
+		.offset		= WELCOME_SIZE,
+		.size		= KERNEL_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	/* boot firmware */
+	{
+		.name		= "nor.boot",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+		.size		= BOOT_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+
+	/* partitions for upgrade */
+	{
+		.name		= "nor.kernel_root",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE),
+	},
+	{
+		.name		= "nor.kernel_root_db",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+	},
+	{
+		.name		= "nor.all_noboot",
+		.offset		= 0,
+		.size		= (WINDOW_SIZE-BOOT_SIZE),
+	},
+	{
+		.name		= "nor.all",
+		.offset		= 0,
+		.size		= WINDOW_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+};
+
+struct map_info relook_flash_map = {
+	.name = "DGStation relook210",
+	.size = WINDOW_SIZE,
+	.bankwidth = 2,
+	.phys = WINDOW_ADDR,
+};
+
+
+#define NUM_REDWOOD_FLASH_PARTITIONS \
+	(sizeof(relook_flash_partitions)/sizeof(relook_flash_partitions[0]))
+
+static struct mtd_info *relook_mtd;
+
+int __init init_relook_flash(void)
+{
+	printk(KERN_NOTICE "relook: flash mapping: %x at %x\n",
+			WINDOW_SIZE, WINDOW_ADDR);
+
+	relook_flash_map.virt =
+		(void __iomem*)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!relook_flash_map.virt) {
+		printk("init_relook_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&relook_flash_map);
+
+#ifdef CONFIG_MTD_CFI
+	relook_mtd = do_map_probe("cfi_probe",&relook_flash_map);
+#elif defined(CONFIG_MTD_AMDSTD)
+	relook_mtd = do_map_probe("amd_flash",&relook_flash_map);
+#else
+#error we have no chip driver.
+#endif
+
+	if (relook_mtd) {
+		relook_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(relook_mtd,
+				relook_flash_partitions,
+				NUM_REDWOOD_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_relook_flash(void)
+{
+	if (relook_mtd) {
+		del_mtd_partitions(relook_mtd);
+		/* moved iounmap after map_destroy - armin */
+		map_destroy(relook_mtd);
+		iounmap((void *)relook_flash_map.virt);
+	}
+}
+
+module_init(init_relook_flash);
+module_exit(cleanup_relook_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hyun-woo Park <parkhw00@dgstation.co.kr>");
+MODULE_DESCRIPTION("MTD map driver for the DGStation relook");
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/relook300.c linux-2.6.17/drivers/mtd/maps/relook300.c
--- archive/linux-2.6.17/drivers/mtd/maps/relook300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mtd/maps/relook300.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,119 @@
+/*
+ * relook300.c - mapper for DGStation relook300
+ *
+ * Author : Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x00800000
+
+#define WELCOME_SIZE	0x030000
+#define KERNEL_SIZE	0x0f0000	// kernel size
+#define SYSTEM_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x240000
+#define BOOT_SIZE	0x030000	// boot loader
+
+static struct mtd_partition relook_flash_partitions[] = {
+	{
+		.name = "DGStation config,welcomeimg",
+		.offset = 0x0000,
+		.size = WELCOME_SIZE,
+	},
+	{	.name = "DGStation kernel",
+		.offset = WELCOME_SIZE,
+		.size = KERNEL_SIZE,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name = "DGStation root filesystem",
+		.offset = (WELCOME_SIZE+KERNEL_SIZE),
+		.size = SYSTEM_SIZE,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name = "DGStation DB filesystem",
+		.offset = (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE),
+		.size =   DB_SIZE,
+	},
+	/* boot firmware */
+	{
+		.name = "DGStation boot firmware",
+		.offset = (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+		.size =   BOOT_SIZE,
+		.mask_flags = MTD_WRITEABLE,	/* force read-only */
+	},
+};
+
+struct map_info relook_flash_map = {
+	.name = "DGStation relook300",
+	.size = WINDOW_SIZE,
+	.bankwidth = 2,
+	.phys = WINDOW_ADDR,
+};
+
+
+#define NUM_REDWOOD_FLASH_PARTITIONS \
+	(sizeof(relook_flash_partitions)/sizeof(relook_flash_partitions[0]))
+
+static struct mtd_info *relook_mtd;
+
+int __init init_relook_flash(void)
+{
+	printk(KERN_NOTICE "relook: flash mapping: %x at %x\n",
+			WINDOW_SIZE, WINDOW_ADDR);
+
+	relook_flash_map.virt =
+		(void __iomem*)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!relook_flash_map.virt) {
+		printk("init_relook_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&relook_flash_map);
+
+#ifdef CONFIG_MTD_CFI
+	relook_mtd = do_map_probe("cfi_probe",&relook_flash_map);
+#elif defined(CONFIG_MTD_AMDSTD)
+	relook_mtd = do_map_probe("amd_flash",&relook_flash_map);
+#else
+#error we have no chip driver.
+#endif
+
+	if (relook_mtd) {
+		relook_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(relook_mtd,
+				relook_flash_partitions,
+				NUM_REDWOOD_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_relook_flash(void)
+{
+	if (relook_mtd) {
+		del_mtd_partitions(relook_mtd);
+		/* moved iounmap after map_destroy - armin */
+		map_destroy(relook_mtd);
+		iounmap((void *)relook_flash_map.virt);
+	}
+}
+
+module_init(init_relook_flash);
+module_exit(cleanup_relook_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hyun-woo Park <parkhw00@dgstation.co.kr>");
+MODULE_DESCRIPTION("MTD map driver for the DGStation relook");
diff -Naur archive/linux-2.6.17/drivers/mtd/maps/relook400.c linux-2.6.17/drivers/mtd/maps/relook400.c
--- archive/linux-2.6.17/drivers/mtd/maps/relook400.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/mtd/maps/relook400.c	2007-08-30 09:04:28.000000000 +0200
@@ -0,0 +1,142 @@
+/*
+ * relook400.c - mapper for DGStation relook400
+ *
+ * Author : Hyun-woo Park <parkhw00@dgstation.co.kr>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define WINDOW_ADDR	0xff800000
+#define WINDOW_SIZE	0x00800000
+
+#define WELCOME_SIZE	0x040000
+#define KERNEL_SIZE	0x150000	// kernel size
+#define SYSTEM_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x1e0000
+#define BOOT_SIZE	0x030000	// boot loader
+
+static struct mtd_partition relook_flash_partitions[] = {
+	{
+		.name		= "nor.config_welcome",
+		.offset		= 0x0000,
+		.size		= WELCOME_SIZE,
+	},
+	{
+		.name		= "nor.db",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE),
+		.size		= DB_SIZE,
+	},
+	{
+		.name		= "nor.root",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE),
+		.size		= SYSTEM_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{	.name		= "nor.kernel",
+		.offset		= WELCOME_SIZE,
+		.size		= KERNEL_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	/* boot firmware */
+	{
+		.name		= "nor.boot",
+		.offset		= (WELCOME_SIZE+KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+		.size		= BOOT_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+
+	/* partitions for upgrade */
+	{
+		.name		= "nor.kernel_root",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE),
+	},
+	{
+		.name		= "nor.kernel_root_db",
+		.offset		= (WELCOME_SIZE),
+		.size		= (KERNEL_SIZE+SYSTEM_SIZE+DB_SIZE),
+	},
+	{
+		.name		= "nor.all_noboot",
+		.offset		= 0,
+		.size		= (WINDOW_SIZE-BOOT_SIZE),
+	},
+	{
+		.name		= "nor.all",
+		.offset		= 0,
+		.size		= WINDOW_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+};
+
+struct map_info relook_flash_map = {
+	.name = "DGStation relook400",
+	.size = WINDOW_SIZE,
+	.bankwidth = 2,
+	.phys = WINDOW_ADDR,
+};
+
+
+#define NUM_REDWOOD_FLASH_PARTITIONS \
+	(sizeof(relook_flash_partitions)/sizeof(relook_flash_partitions[0]))
+
+static struct mtd_info *relook_mtd;
+
+int __init init_relook_flash(void)
+{
+	printk(KERN_NOTICE "relook: flash mapping: %x at %x\n",
+			WINDOW_SIZE, WINDOW_ADDR);
+
+	relook_flash_map.virt =
+		(void __iomem*)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!relook_flash_map.virt) {
+		printk("init_relook_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&relook_flash_map);
+
+#ifdef CONFIG_MTD_CFI
+	relook_mtd = do_map_probe("cfi_probe",&relook_flash_map);
+#elif defined(CONFIG_MTD_AMDSTD)
+	relook_mtd = do_map_probe("amd_flash",&relook_flash_map);
+#else
+#error we have no chip driver.
+#endif
+
+	if (relook_mtd) {
+		relook_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(relook_mtd,
+				relook_flash_partitions,
+				NUM_REDWOOD_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_relook_flash(void)
+{
+	if (relook_mtd) {
+		del_mtd_partitions(relook_mtd);
+		/* moved iounmap after map_destroy - armin */
+		map_destroy(relook_mtd);
+		iounmap((void *)relook_flash_map.virt);
+	}
+}
+
+module_init(init_relook_flash);
+module_exit(cleanup_relook_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hyun-woo Park <parkhw00@dgstation.co.kr>");
+MODULE_DESCRIPTION("MTD map driver for the DGStation relook");
diff -Naur archive/linux-2.6.17/drivers/mtd/mtd_blkdevs.c linux-2.6.17/drivers/mtd/mtd_blkdevs.c
--- archive/linux-2.6.17/drivers/mtd/mtd_blkdevs.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/mtd_blkdevs.c	2007-08-30 09:04:28.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <asm/uaccess.h>
+#include <linux/devfs_fs_kernel.h>
 
 static LIST_HEAD(blktrans_majors);
 
@@ -284,17 +285,32 @@
 
 	if (tr->part_bits)
 		if (new->devnum < 26)
+		{
 			snprintf(gd->disk_name, sizeof(gd->disk_name),
 				 "%s%c", tr->name, 'a' + new->devnum);
+			snprintf(gd->devfs_name, sizeof(gd->devfs_name),
+				 "%s/%c", tr->name, 'a' + new->devnum);
+		}
 		else
+		{
 			snprintf(gd->disk_name, sizeof(gd->disk_name),
 				 "%s%c%c", tr->name,
 				 'a' - 1 + new->devnum / 26,
 				 'a' + new->devnum % 26);
+
+			snprintf(gd->devfs_name, sizeof(gd->devfs_name),
+				 "%s/%c%c", tr->name,
+				 'a' - 1 + new->devnum / 26,
+				 'a' + new->devnum % 26);
+		
+		}
 	else
+	{
 		snprintf(gd->disk_name, sizeof(gd->disk_name),
 			 "%s%d", tr->name, new->devnum);
-
+		snprintf(gd->devfs_name, sizeof(gd->devfs_name),
+			 "%s/%d", tr->name, new->devnum);
+	 }
 	/* 2.5 has capacity in units of 512 bytes while still
 	   having BLOCK_SIZE_BITS set to 10. Just to keep us amused. */
 	set_capacity(gd, (new->size * new->blksize) >> 9);
@@ -411,6 +427,8 @@
 		return ret;
 	}
 
+	devfs_mk_dir(tr->name);
+	
 	INIT_LIST_HEAD(&tr->devs);
 	list_add(&tr->list, &blktrans_majors);
 
@@ -442,7 +460,8 @@
 		struct mtd_blktrans_dev *dev = list_entry(this, struct mtd_blktrans_dev, list);
 		tr->remove_dev(dev);
 	}
-
+	
+	devfs_remove(tr->name);
 	blk_cleanup_queue(tr->blkcore_priv->rq);
 	unregister_blkdev(tr->major, tr->name);
 
diff -Naur archive/linux-2.6.17/drivers/mtd/mtdchar.c linux-2.6.17/drivers/mtd/mtdchar.c
--- archive/linux-2.6.17/drivers/mtd/mtdchar.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/mtd/mtdchar.c	2007-08-30 09:04:28.000000000 +0200
@@ -19,19 +19,37 @@
 
 #include <asm/uaccess.h>
 
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+
 static struct class *mtd_class;
 
 static void mtd_notify_add(struct mtd_info* mtd)
 {
+	dev_t mtd_dev;
+	dev_t mtd_dev_ro;
+
 	if (!mtd)
 		return;
 
-	class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+	mtd_dev 	= MKDEV(MTD_CHAR_MAJOR, mtd->index*2);
+	mtd_dev_ro	= MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1);
+	class_device_create(mtd_class, NULL, mtd_dev,
 			    NULL, "mtd%d", mtd->index);
 
 	class_device_create(mtd_class, NULL,
-			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+			    mtd_dev_ro,
 			    NULL, "mtd%dro", mtd->index);
+
+#ifdef CONFIG_DEVFS_FS				
+	devfs_mk_cdev(mtd_dev,
+		      S_IFCHR | S_IRUGO | S_IWUGO, "mtd/%d", mtd->index);
+	devfs_mk_cdev(mtd_dev_ro,
+		      S_IFCHR | S_IRUGO, "mtd/%dro", mtd->index);
+#endif					
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)
@@ -41,6 +59,12 @@
 
 	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
 	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_remove("mtd/%d", mtd->index);
+	devfs_remove("mtd/%dro", mtd->index);
+#endif	
+	
 }
 
 static struct mtd_notifier notifier = {
@@ -48,6 +72,7 @@
 	.remove	= mtd_notify_remove,
 };
 
+
 /*
  * We use file->private_data to store a pointer to the MTDdevice.
  * Since alighment is at least 32 bits, we have 2 bits free for OTP
@@ -642,11 +667,13 @@
 		       MTD_CHAR_MAJOR);
 		return -EAGAIN;
 	}
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_dir("mtd");
+#endif 
 
 	mtd_class = class_create(THIS_MODULE, "mtd");
 
 	if (IS_ERR(mtd_class)) {
-		printk(KERN_ERR "Error creating mtd class.\n");
 		unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
 		return PTR_ERR(mtd_class);
 	}
@@ -658,6 +685,10 @@
 static void __exit cleanup_mtdchar(void)
 {
 	unregister_mtd_user(&notifier);
+#ifdef CONFIG_DEVFS_FS
+	devfs_remove("mtd");
+#endif
+
 	class_destroy(mtd_class);
 	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
 }
diff -Naur archive/linux-2.6.17/drivers/net/Kconfig linux-2.6.17/drivers/net/Kconfig
--- archive/linux-2.6.17/drivers/net/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/net/Kconfig	2007-08-30 09:04:29.000000000 +0200
@@ -855,7 +855,7 @@
 
 config DM9000
 	tristate "DM9000 support"
-	depends on (ARM || MIPS) && NET_ETHERNET
+	depends on NET_ETHERNET
 	select CRC32
 	select MII
 	---help---
@@ -865,6 +865,17 @@
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called dm9000.
 
+config DM9000X
+       depends on RELOOK100S || RELOOK400 || RELOOK400C || RELOOK500S || RELOOK500T || RELOOK510S
+       tristate "Davicom Semiconductor DM9000"
+       ---help---
+         Device driver for Davicom Semiconductor DM9000.
+
+         See the home page http://www.davicom.com.tw for more information.
+
+         To compile this driver as a module, choose M here: the module
+         will be called dm9000x.  If unsure, say N.
+
 config NET_VENDOR_RACAL
 	bool "Racal-Interlan (Micom) NI cards"
 	depends on NET_ETHERNET && ISA
diff -Naur archive/linux-2.6.17/drivers/net/Makefile linux-2.6.17/drivers/net/Makefile
--- archive/linux-2.6.17/drivers/net/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/net/Makefile	2007-08-30 09:04:29.000000000 +0200
@@ -194,6 +194,7 @@
 obj-$(CONFIG_S2IO) += s2io.o
 obj-$(CONFIG_SMC91X) += smc91x.o
 obj-$(CONFIG_DM9000) += dm9000.o
+obj-$(CONFIG_DM9000X) += dm9000x.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 
 obj-$(CONFIG_ARM) += arm/
diff -Naur archive/linux-2.6.17/drivers/net/dm9000.c linux-2.6.17/drivers/net/dm9000.c
--- archive/linux-2.6.17/drivers/net/dm9000.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/net/dm9000.c	2007-08-30 09:04:29.000000000 +0200
@@ -146,7 +146,7 @@
 	struct mii_if_info mii;
 	u32 msg_enable;
 } board_info_t;
-
+#include "dm9000_ppc.c"	//PowerPc stuff
 /* function declaration ------------------------------------- */
 static int dm9000_probe(struct platform_device *);
 static int dm9000_open(struct net_device *);
@@ -291,12 +291,14 @@
 		db->dumpblk = dm9000_dumpblk_8bit;
 		db->outblk  = dm9000_outblk_8bit;
 		db->inblk   = dm9000_inblk_8bit;
+		printk("%s: 8 bit io datasize.\n", CARDNAME);
 		break;
 
 	case 2:
 		db->dumpblk = dm9000_dumpblk_16bit;
 		db->outblk  = dm9000_outblk_16bit;
 		db->inblk   = dm9000_inblk_16bit;
+		printk("%s: 16 bit io datasize.\n", CARDNAME);
 		break;
 
 	case 3:
@@ -311,6 +313,7 @@
 		db->dumpblk = dm9000_dumpblk_32bit;
 		db->outblk  = dm9000_outblk_32bit;
 		db->inblk   = dm9000_inblk_32bit;
+		printk("%s: 32 bit io datasize.\n", CARDNAME);
 		break;
 	}
 }
@@ -420,11 +423,15 @@
 			ret = -EBUSY;
 			goto out;
 		}
+		if (!request_mem_region(base+4, 4, ndev->name)) {
+			ret = -EBUSY;
+			goto out;
+		}
 
 		ndev->base_addr = base;
 		ndev->irq = pdev->resource[1].start;
-		db->io_addr = (void *)base;
-		db->io_data = (void *)(base + 4);
+		db->io_addr = ioremap(base, 4);
+		db->io_data = ioremap((base + 4),4);
 
 		break;
 
@@ -485,6 +492,15 @@
 
 	}
 
+	/* I/O mode */
+	db->io_mode = ior(db, DM9000_ISR) >> 6;	/* ISR bit7:6 keeps I/O mode */
+	if (db->io_mode == 2)
+		dm9000_set_io(db, 1);
+	if (db->io_mode == 0)
+		dm9000_set_io(db, 2);
+	if (db->io_mode == 1)
+		dm9000_set_io(db, 4);
+
 	/* check to see if anything is being over-ridden */
 	if (pdata != NULL) {
 		/* check to see if the driver wants to over-ride the
@@ -560,13 +576,23 @@
 	for (i = 0; i < 64; i++)
 		((u16 *) db->srom)[i] = read_srom_word(db, i);
 
+	//First check srom
+	for (i = 0; i < 6; i++)
+		ndev->dev_addr[i] = db->srom[i];
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+	{
+		printk("%s: Invalid ethernet MAC address feched from srom, tring bios\n",CARDNAME);
+		dm9000_get_mac_from_bi(db);
+	}
+
 	/* Set Node Address */
 	for (i = 0; i < 6; i++)
 		ndev->dev_addr[i] = db->srom[i];
 
 	if (!is_valid_ether_addr(ndev->dev_addr))
 		printk("%s: Invalid ethernet MAC address.  Please "
-		       "set using ifconfig\n", ndev->name);
+		       "set using ifconfig\n", CARDNAME);
 
 	platform_set_drvdata(pdev, ndev);
 	ret = register_netdev(ndev);
@@ -634,9 +660,6 @@
 
 	PRINTK1("entering %s\n",__FUNCTION__);
 
-	/* I/O mode */
-	db->io_mode = ior(db, DM9000_ISR) >> 6;	/* ISR bit7:6 keeps I/O mode */
-
 	/* GPIO0 on pre-activate PHY */
 	iow(db, DM9000_GPR, 0);	/* REG_1F bit0 activate phyxcer */
 	iow(db, DM9000_GPCR, GPCR_GEP_CNTL);	/* Let GPIO0 output */
diff -Naur archive/linux-2.6.17/drivers/net/dm9000_ppc.c linux-2.6.17/drivers/net/dm9000_ppc.c
--- archive/linux-2.6.17/drivers/net/dm9000_ppc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/net/dm9000_ppc.c	2007-08-30 09:04:32.000000000 +0200
@@ -0,0 +1,117 @@
+//PowerPc stuff
+//This File to be included in the dm9000.c after board definition
+//will provide missing functions to powerpc plafrom
+
+static void dm9000_get_mac_from_bi (board_info_t * db)
+{
+	int i;
+	bd_t *bd;
+	bd = &__res;
+	for (i=0; i<6; i++)
+		db->srom[i]=bd->bi_enetaddr[i];
+}
+
+static inline int dm9000_reg_read(const volatile unsigned short __iomem *addr)
+{
+	return in_be16(addr)& 0xff;
+}
+static inline void dm9000_reg_write(volatile unsigned short __iomem *addr, int val)
+{
+	out_be16(addr,val);
+}
+
+
+#undef writeb
+#undef readb
+#undef writew
+#undef readw
+
+#define readb(addr)    dm9000_reg_read ((volatile u16 *)(addr))
+#define writeb(b,addr) dm9000_reg_write((volatile u16 *)(addr),(b))
+
+#define readw_be(addr) (*(volatile u16 *) (addr))
+#define readw(addr)    in_le16 ((volatile u16 *)(addr))
+#define writew(b,addr) out_le16((volatile u16 *)(addr),(b))
+
+
+#ifndef readsb
+static inline void
+dm9000_readsb(const volatile void __iomem *bus_addr, u8 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readb(bus_addr);
+}
+
+#define readsb(p, v, l)                 dm9000_readsb(p, v, l)
+#endif
+
+#ifndef readsw
+static inline void
+dm9000_readsw(const volatile void __iomem *bus_addr, u16 *vaddr, u32 count)
+{
+	u16 val;
+	if (count==2)	/* bad workaround but works*/
+	{
+		while (count--)
+		{
+			val = readw_be(bus_addr);
+			*vaddr++ = val;
+		}
+	} else {
+		while (count--)
+		{
+			val = readw(bus_addr);
+			*vaddr++ = val;
+		}
+	}
+}
+#define readsw(p, v, l)                 dm9000_readsw(p, v, l)
+#endif
+
+#ifndef readsl
+static inline void
+dm9000_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = __raw_readl(bus_addr);
+}
+#define readsl(p, v, l)                 dm9000_readsl(p, v, l)
+#endif
+
+
+#ifndef writesb
+static inline void
+dm9000_writesb(volatile void __iomem *bus_addr, const u8 *vaddr, int count)
+{
+	while (count--)
+	{
+		writeb(*vaddr++, bus_addr);
+	}
+}
+#define writesb(p, v, l)                dm9000_writesw(p, v, l)
+#endif
+
+
+#ifndef writesw
+static inline void
+dm9000_writesw(volatile void __iomem *bus_addr, const u16 *vaddr, int count)
+{
+	while (count--)
+	{
+		writew(*vaddr++, bus_addr);
+	}
+}
+#define writesw(p, v, l)                dm9000_writesw(p, v, l)
+#endif
+
+#ifndef writesl
+static inline void
+dm9000_writesl(volatile void __iomem *bus_addr, const u32 *vaddr, int count)
+{
+	while (count--)
+		__raw_writel(*vaddr++, bus_addr);
+}
+#define writesl(p, v, l)                dm9000_writesl(p, v, l)
+#endif
+
+
diff -Naur archive/linux-2.6.17/drivers/net/dm9000x.c linux-2.6.17/drivers/net/dm9000x.c
--- archive/linux-2.6.17/drivers/net/dm9000x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/drivers/net/dm9000x.c	2007-08-30 09:04:32.000000000 +0200
@@ -0,0 +1,1146 @@
+/*
+  dm9000.c: Version 1.2 03/18/2003
+  
+        A Davicom DM9000 ISA NIC fast Ethernet driver for Linux.
+	Copyright (C) 1997  Sten Wang
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public License
+	as published by the Free Software Foundation; either version 2
+	of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+
+  (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
+
+
+V0.11	06/20/2001	REG_0A bit3=1, default enable BP with DA match
+	06/22/2001 	Support DM9801 progrmming	
+	 	 	E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
+		 	E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
+		     		R17 = (R17 & 0xfff0) | NF + 3
+		 	E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
+		     		R17 = (R17 & 0xfff0) | NF
+				
+v1.00               	modify by simon 2001.9.5
+                        change for kernel 2.4.x    
+			
+v1.1   11/09/2001      	fix force mode bug             
+
+v1.2   03/18/2003       Weilun Huang <weilun_huang@davicom.com.tw>: 
+			Fixed phy reset.
+			Added tx/rx 32 bit mode.
+			Cleaned up for kernel merge.
+
+v1.2.1 11/23/2004       Hyun-woo Park <parkhw00@dgstation.co.kr>: 
+			port to relook300
+*/
+
+#if defined(MODVERSIONS)
+#include <linux/modversions.h>
+#endif
+				
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <asm/dma.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/platform_device.h>
+
+#include <linux/err.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+
+
+/* Board/System/Debug information/definition ---------------- */
+
+#define DM9000_ID		0x90000A46
+
+#define DM9000_REG00		0x00
+#define DM9000_REG05		0x30	/* SKIP_CRC/SKIP_LONG */
+#define DM9000_REG08		0x27
+#define DM9000_REG09		0x38
+#define DM9000_REG0A		0xff 
+#define DM9000_REGFF		0x83	/* IMR */
+
+#define DM9000_PHY		0x40	/* PHY address 0x01 */
+#define DM9000_PKT_MAX		1536	/* Received packet max size */
+#define DM9000_PKT_RDY		0x01	/* Packet ready to receive */
+#define DM9000_INT_MII		0x00
+#define DM9000_EXT_MII		0x80
+
+#define DM9000_VID_L		0x28
+#define DM9000_VID_H		0x29
+#define DM9000_PID_L		0x2A
+#define DM9000_PID_H		0x2B
+
+#define DM9801_NOISE_FLOOR	0x08
+#define DM9802_NOISE_FLOOR	0x05
+
+#define DMFE_SUCC       	0
+#define MAX_PACKET_SIZE 	1514
+#define DMFE_MAX_MULTICAST 	14
+
+#define DM9000_RX_INTR		0x01
+#define DM9000_TX_INTR		0x02
+#define DM9000_OVERFLOW_INTR	0x04
+
+#define DM9000_DWORD_MODE	1
+#define DM9000_BYTE_MODE	2
+#define DM9000_WORD_MODE	0
+
+#define TRUE			1
+#define FALSE			0
+
+#define DMFE_TIMER_WUT  jiffies+(HZ*2)	/* timer wakeup time : 2 second */
+#define DMFE_TX_TIMEOUT (HZ*2)		/* tx packet time-out time 1.5 s" */
+
+//#define DM9000_DEBUG
+#if defined(DM9000_DEBUG)
+#define DMFE_DBUG(dbug_now, msg, vaule) printk(KERN_ERR "dmfe: %s %x\n", msg, vaule)
+#else
+#define DMFE_DBUG(dbug_now, msg, vaule) 
+#endif
+
+#ifdef outb
+#undef outb
+#undef outw
+#undef outl
+#endif
+#ifdef inb
+#undef inb
+#undef inl
+#endif
+#define outb(dat,adr)	out_be16((unsigned short*)(adr),dat)
+#define outw(dat,adr)	out_le16((unsigned short*)(adr),dat)
+#define outl(dat,adr)	out_le32((unsigned *)(adr),dat)
+#define inb(adr)	(unsigned char)in_be16((unsigned short*)(adr))
+#define inw(adr)	(unsigned short)in_le16((unsigned short*)(adr))
+#define inl(adr)	(unsigned long)in_le32((unsigned *)(adr))
+
+enum DM9000_PHY_mode {
+	DM9000_10MHD   = 0, 
+	DM9000_100MHD  = 1, 
+	DM9000_10MFD   = 4,
+	DM9000_100MFD  = 5, 
+	DM9000_AUTO    = 8, 
+	DM9000_1M_HPNA = 0x10 
+};
+
+enum DM9000_NIC_TYPE {
+	FASTETHER_NIC = 0, 
+	HOMERUN_NIC   = 1, 
+	LONGRUN_NIC   = 2 
+};
+
+/* Structure/enum declaration ------------------------------- */
+typedef struct dm9k_board_info {
+
+	u32 runt_length_counter;	/* counter: RX length < 64byte */ 
+	u32 long_length_counter;	/* counter: RX length > 1514byte */ 
+	u32 reset_counter;		/* counter: RESET */ 
+	u32 reset_tx_timeout;		/* RESET caused by TX Timeout */ 
+	u32 reset_rx_status;		/* RESET caused by RX Statsus wrong */ 
+
+	u32 ioaddr;			/* Register I/O base address */
+	u32 io_data;			/* Data I/O address */
+	u16 irq;			/* IRQ */
+
+	u16 tx_pkt_cnt;
+	u16 queue_pkt_len;
+	u16 queue_start_addr;
+	u16 dbug_cnt;
+	u8 reg0, reg5, reg8, reg9, rega;/* registers saved */
+	u8 op_mode;			/* PHY operation mode */
+	u8 io_mode;			/* 0:word, 2:byte */
+	u8 phy_addr;
+	u8 link_failed;			/* Ever link failed */
+	u8 device_wait_reset;		/* device state */
+	u8 nic_type;			/* NIC type */
+	struct timer_list timer;
+	struct net_device_stats stats;
+	unsigned char srom[128];
+	spinlock_t lock;
+
+	struct tasklet_struct rx_tasklet;
+} dm9k_board_info_t;
+
+/* Global variable declaration ----------------------------- */
+static int dmfe_debug = 0;
+
+/* For module input parameter */
+static int debug      = 0;
+static int mode       = DM9000_AUTO;
+static int media_mode = DM9000_AUTO;
+static u8 reg5 	      = DM9000_REG05;
+static u8 reg8 	      = DM9000_REG08;
+static u8 reg9 	      = DM9000_REG09;
+static u8 rega 	      = DM9000_REG0A;
+static u8 nfloor      = 0;
+
+/* function declaration ------------------------------------- */
+static int dmfe_open(struct net_device *);
+static int dmfe_start_xmit(struct sk_buff *, struct net_device *);
+static int dmfe_stop(struct net_device *);
+static struct net_device_stats * dmfe_get_stats(struct net_device *); 
+static int dmfe_do_ioctl(struct net_device *, struct ifreq *, int);
+static irqreturn_t dmfe_interrupt(int , void *, struct pt_regs *);
+static void dmfe_timer(unsigned long);
+static void dmfe_init_dm9000(struct net_device *);
+static unsigned long cal_CRC(unsigned char *, unsigned int, u8);
+static u8 ior(dm9k_board_info_t *, int);
+static void iow(dm9k_board_info_t *, int, u8);
+static u16 phy_read(dm9k_board_info_t *, int);
+static void phy_write(dm9k_board_info_t *, int, u16);
+#if 0
+static u16 read_srom_word(dm9k_board_info_t *, int);
+#endif
+static void dmfe_packet_receive(unsigned long);
+static void dm9000_hash_table(struct net_device *);
+
+/* DM9000 network baord routine ---------------------------- */
+
+/*
+  Open the interface.
+  The interface is opened whenever "ifconfig" actives it.
+*/
+static int dmfe_open(struct net_device *dev)
+{
+	dm9k_board_info_t * db = (dm9k_board_info_t *)dev->priv;
+
+	DMFE_DBUG(0, "dmfe_open", 0);
+
+	if (request_irq(dev->irq,&dmfe_interrupt,SA_SHIRQ,dev->name,dev)) 
+		return -EAGAIN;
+
+	/* Initilize DM910X board */
+	dmfe_init_dm9000(dev);
+ 
+	/* Init driver variable */
+	db->dbug_cnt 		= 0;
+	db->runt_length_counter = 0;
+	db->long_length_counter = 0;
+	db->reset_counter 	= 0;
+	tasklet_init( &db->rx_tasklet, dmfe_packet_receive, (unsigned long)dev );
+
+	/* set and active a timer process */
+	init_timer(&db->timer);
+	db->timer.expires 	= DMFE_TIMER_WUT * 2;
+	db->timer.data 		= (unsigned long)dev;
+	db->timer.function 	= &dmfe_timer;
+	add_timer(&db->timer);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/* Set PHY operationg mode
+*/
+static void set_PHY_mode(dm9k_board_info_t *db)
+{
+	u16 phy_reg4 = 0x01e1, phy_reg0=0x1000;
+
+	if ( !(db->op_mode & DM9000_AUTO) ) {
+		
+		switch(db->op_mode) {
+			case DM9000_10MHD:  phy_reg4 = 0x21; 
+                        	            phy_reg0 = 0x0000; 
+					    break;
+			case DM9000_10MFD:  phy_reg4 = 0x41; 
+                        	            phy_reg0 = 0x1100; 
+                                	    break;
+			case DM9000_100MHD: phy_reg4 = 0x81; 
+					    phy_reg0 = 0x2000; 
+				    	    break;
+			case DM9000_100MFD: phy_reg4 = 0x101; 
+				    	    phy_reg0 =0x3100; 
+				   	    break;
+		}
+		phy_write(db, 4, phy_reg4);	/* Set PHY media mode */
+		phy_write(db, 0, phy_reg0);	/*  Tmp */
+	}
+
+	iow(db, 0x1e, 0x01);			/* Let GPIO0 output */
+	iow(db, 0x1f, 0x00);			/* Enable PHY */
+}
+
+/*
+	Init HomeRun DM9801
+*/
+static void program_dm9801(dm9k_board_info_t *db, u16 HPNA_rev)
+{
+	__u16 reg16, reg17, reg24, reg25;
+
+	if ( !nfloor ) 
+		nfloor = DM9801_NOISE_FLOOR;
+
+	reg16 = phy_read(db, 16);
+	reg17 = phy_read(db, 17);
+	reg24 = phy_read(db, 24);
+	reg25 = phy_read(db, 25);
+
+	switch(HPNA_rev) {
+		case 0xb900: /* DM9801 E3 */
+			reg16 |= 0x1000;
+			reg25 = ( (reg24 + nfloor) & 0x00ff) | 0xf000;
+			break;
+		case 0xb901: /* DM9801 E4 */
+			reg25 = ( (reg24 + nfloor) & 0x00ff) | 0xc200;
+			reg17 = (reg17 & 0xfff0) + nfloor + 3;
+			break;
+		case 0xb902: /* DM9801 E5 */
+		case 0xb903: /* DM9801 E6 */
+		default:
+			reg16 |= 0x1000;
+			reg25 = ( (reg24 + nfloor - 3) & 0x00ff) | 0xc200;
+			reg17 = (reg17 & 0xfff0) + nfloor;
+	}
+
+	phy_write(db, 16, reg16);
+	phy_write(db, 17, reg17);
+	phy_write(db, 25, reg25);
+}
+
+/*
+	Init LongRun DM9802
+*/
+static void program_dm9802(dm9k_board_info_t *db)
+{
+	__u16 reg25;
+
+	if ( !nfloor ) 
+		nfloor = DM9802_NOISE_FLOOR;
+
+	reg25 = phy_read(db, 25);
+	reg25 = (reg25 & 0xff00) + nfloor;
+	phy_write(db, 25, reg25);
+}
+
+/* Identify NIC type
+*/
+static void identify_nic(dm9k_board_info_t *db)
+{
+	u16 phy_reg3;
+
+	iow(db, 0, DM9000_EXT_MII);
+	phy_reg3 = phy_read(db, 3);
+	
+	switch(phy_reg3 & 0xfff0) {
+		
+		case 0xb900:
+			
+			if (phy_read(db, 31) == 0x4404) {
+				db->nic_type =  HOMERUN_NIC;
+				program_dm9801(db, phy_reg3);
+			} else {
+				db->nic_type = LONGRUN_NIC;
+				program_dm9802(db);
+			}
+			break;
+			
+		default: db->nic_type = FASTETHER_NIC; 
+			 break;
+		 
+	}
+	
+	iow(db, 0, DM9000_INT_MII);	
+}
+
+/* Initilize dm9000 board
+*/
+static void dmfe_init_dm9000(struct net_device *dev)
+{
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+ 
+	DMFE_DBUG(0, "dmfe_init_dm9000()", 0);
+
+	/* RESET device */
+	iow(db, 0, 1);
+	udelay(100);			  /* delay 100us */
+
+	/* I/O mode */
+	db->io_mode = ior(db, 0xfe) >> 6; /* ISR bit7:6 keeps I/O mode */
+	DMFE_DBUG(0, "iomode", db->io_mode);
+
+	/* NIC Type: FASTETHER, HOMERUN, LONGRUN */
+	identify_nic(db);	
+
+	/* GPIO0 on pre-activate PHY */
+	iow(db,0x1f,0x00); 		/*REG_1F bit0 activate phyxcer*/
+
+	/* Set PHY */
+	db->op_mode = media_mode;
+	set_PHY_mode(db);
+
+	/* Init needed register value */
+	db->reg0 = DM9000_REG00;
+	if ( (db->nic_type != FASTETHER_NIC) && (db->op_mode & DM9000_1M_HPNA) )
+		db->reg0 |= DM9000_EXT_MII;
+	
+	/* User passed argument */
+	db->reg5 = reg5;
+	db->reg8 = reg8;
+	db->reg9 = reg9;
+	db->rega = rega;
+
+	/* Program operating register */
+	iow(db, 0x00, db->reg0);
+	iow(db, 0x02, 0);		/* TX Polling clear */
+	iow(db, 0x08, 0x3f);		/* Less 3Kb, 200us */
+	iow(db, 0x09, db->reg9);	/* Flow Control : High/Low Water */
+	iow(db, 0x0a, db->rega);	/* Flow Control */
+	iow(db, 0x2f, 0);		/* Special Mode */
+	iow(db, 0x01, 0x2c);		/* clear TX status */
+	iow(db, 0xfe, 0x0f); 		/* Clear interrupt status */
+ 
+	/* Set address filter table */
+	dm9000_hash_table(dev);
+
+	/* Activate DM9000 */
+	iow(db, 0x05, db->reg5 | 1);	/* RX enable */
+	iow(db, 0xff, DM9000_REGFF); 	/* Enable TX/RX interrupt mask */
+ 
+	/* Init Driver variable */
+	db->link_failed = 1;
+	db->tx_pkt_cnt = 0;
+	db->queue_pkt_len = 0;
+	dev->trans_start = 0;
+	spin_lock_init(&db->lock); 
+}
+
+/*
+  Hardware start transmission.
+  Send a packet to media from the upper layer.
+*/
+static int dmfe_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+	char * data_ptr;
+	int i, tmplen;
+
+	DMFE_DBUG(0, "dmfe_start_xmit", 0);
+
+	if (db->tx_pkt_cnt > 1) 
+		return 1; 
+	
+	netif_stop_queue(dev); 
+
+	/* Disable all interrupt */
+	iow(db, 0xff, 0x80);
+	
+	/* Move data to DM9000 TX RAM */
+	data_ptr = (char *)skb->data;
+	outb(0xf8, db->ioaddr);
+	
+	if (db->io_mode == DM9000_BYTE_MODE) {
+		/* Byte mode */
+		for (i = 0; i < skb->len; i++)
+			outb((data_ptr[i] & 0xff), db->io_data);
+	} else if (db->io_mode == DM9000_WORD_MODE) {
+		/* Word mode */
+		tmplen = (skb->len + 1) / 2;
+		for (i = 0; i < tmplen; i++)
+         		outw(((u16 *)data_ptr)[i], db->io_data);
+	} else {
+		/* DWord mode */
+		tmplen = (skb->len + 3) / 4;
+		for (i = 0; i< tmplen; i++)
+			outl(((u32 *)data_ptr)[i], db->io_data);
+	} 
+
+	/* TX control: First packet immediately send, second packet queue */
+	if (db->tx_pkt_cnt == 0) {
+		
+		/* First Packet */
+		db->tx_pkt_cnt++;
+
+		/* Set TX length to DM9000 */
+		iow(db, 0xfc, skb->len & 0xff);
+		iow(db, 0xfd, (skb->len >> 8) & 0xff);
+
+		/* Issue TX polling command */
+		iow(db, 0x2, 0x1);		/* Cleared after TX complete */
+
+		dev->trans_start = jiffies;	/* saved the time stamp */
+		
+	} else {
+		/* Second packet */
+		db->tx_pkt_cnt++;
+		db->queue_pkt_len = skb->len;
+	}
+ 
+	/* free this SKB */
+	dev_kfree_skb(skb);
+
+	/* Re-enable resource check */
+	if (db->tx_pkt_cnt == 1)
+              netif_wake_queue(dev); 
+		
+	/* Re-enable interrupt*/ 
+	iow(db,0xff,0x83);
+	
+	return 0;
+}
+
+/*
+  Stop the interface.
+  The interface is stopped when it is brought.
+*/
+static int dmfe_stop(struct net_device *dev)
+{
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+
+	DMFE_DBUG(0, "dmfe_stop", 0);
+
+	/* deleted timer */
+	del_timer(&db->timer);
+
+	netif_stop_queue(dev); 
+
+	/* free interrupt */
+	free_irq(dev->irq, dev);
+
+	/* RESET devie */
+	phy_write(db, 0x00, 0x8000);	/* PHY RESET */
+	iow(db, 0x1f, 0x01); 		/* Power-Down PHY */
+	iow(db, 0xff, 0x80);		/* Disable all interrupt */
+	iow(db, 0x05, 0x00);		/* Disable RX */
+
+	//MOD_DEC_USE_COUNT;
+	module_put (THIS_MODULE);
+
+
+	/* Dump Statistic counter */
+#if FALSE
+	printk("\nRX FIFO OVERFLOW %lx\n", db->stats.rx_fifo_errors);
+	printk("RX CRC %lx\n", db->stats.rx_crc_errors);
+	printk("RX LEN Err %lx\n", db->stats.rx_length_errors);
+	printk("RX LEN < 64byte %x\n", db->runt_length_counter);
+	printk("RX LEN > 1514byte %x\n", db->long_length_counter);
+	printk("RESET %x\n", db->reset_counter);
+	printk("RESET: TX Timeout %x\n", db->reset_tx_timeout);
+	printk("RESET: RX Status Wrong %x\n", db->reset_rx_status);
+#endif
+
+	return 0;
+}
+
+/*
+  DM9102 insterrupt handler
+  receive the packet to upper layer, free the transmitted packet
+*/
+
+void dmfe_tx_done(struct net_device *dev, dm9k_board_info_t *db)
+{
+		int tx_status = ior(db, 0x01);	/* Got TX status */
+		
+		if (tx_status & 0xc) {
+			/* One packet sent complete */
+			db->tx_pkt_cnt--;
+			dev->trans_start = 0;
+			db->stats.tx_packets++;
+
+			/* Queue packet check & send */
+			if (db->tx_pkt_cnt > 0) {
+				iow(db, 0xfc, db->queue_pkt_len & 0xff);
+				iow(db, 0xfd, (db->queue_pkt_len >> 8) & 0xff);
+				iow(db, 0x2, 0x1);
+				dev->trans_start = jiffies;
+			}
+
+			netif_wake_queue(dev); 
+		}
+}
+
+static irqreturn_t dmfe_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	dm9k_board_info_t *db;
+	int int_status;
+	u8 reg_save;
+
+	DMFE_DBUG(0, "dmfe_interrupt()", 0);
+
+	if (!dev) {
+		DMFE_DBUG(1, "dmfe_interrupt() without DEVICE arg", 0);
+		return IRQ_NONE;
+	}
+
+	/* A real interrupt coming */
+	db = (dm9k_board_info_t *)dev->priv;
+	spin_lock(&db->lock);
+
+	/* Save previous register address */
+	reg_save = inb(db->ioaddr);
+
+	/* Disable all interrupt */
+	iow(db, 0xff, 0x80); 
+
+	/* Got DM9000 interrupt status */
+	int_status = ior(db, 0xfe);		/* Got ISR */
+	iow(db, 0xfe, int_status);		/* Clear ISR status */ 
+
+	/* Received the coming packet */
+	if (int_status & DM9000_RX_INTR) 
+		tasklet_schedule(&db->rx_tasklet);
+
+	/* Trnasmit Interrupt check */
+	if (int_status & DM9000_TX_INTR)
+		dmfe_tx_done(dev,db);
+		
+	/* Re-enable interrupt mask */ 
+	iow(db, 0xff, 0x83);
+
+	/* Restore previous register address */
+	outb(reg_save, db->ioaddr); 
+
+	spin_unlock(&db->lock); 
+
+	return IRQ_HANDLED;
+}
+
+/*
+  Get statistics from driver.
+*/
+static struct net_device_stats * dmfe_get_stats(struct net_device *dev)
+{
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+
+	DMFE_DBUG(0, "dmfe_get_stats", 0);
+	return &db->stats;
+}
+
+/*
+  Process the upper socket ioctl command
+*/
+static int dmfe_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	DMFE_DBUG(0, "dmfe_do_ioctl()", 0);
+	return 0;
+}
+
+/*
+  A periodic timer routine
+  Dynamic media sense, allocated Rx buffer...
+*/
+static void dmfe_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+	u8 reg_save, tmp_reg;
+
+	DMFE_DBUG(0, "dmfe_timer()", 0);
+
+	/* Save previous register address */
+	reg_save = inb(db->ioaddr);
+
+	/* TX timeout check */
+	if (dev->trans_start&&((jiffies-dev->trans_start)>DMFE_TX_TIMEOUT)) {
+		db->device_wait_reset = 1;
+		db->reset_tx_timeout++;
+	}
+
+	/* DM9000 dynamic RESET check and do */
+	if (db->device_wait_reset) {
+		printk( KERN_WARNING "dm9000: reset.\n" );
+		netif_stop_queue(dev); 
+		db->reset_counter++;
+		db->device_wait_reset = 0;
+		dev->trans_start = 0;
+		dmfe_init_dm9000(dev);
+		netif_wake_queue(dev);
+	}
+
+	/* Auto Sense Media mode policy:
+		FastEthernet NIC: don't need to do anything.
+		Media Force mode: don't need to do anything.
+		HomeRun/LongRun NIC and AUTO_Mode:
+			INT_MII not link, select EXT_MII
+			EXT_MII not link, select INT_MII
+	 */
+	if ( (db->nic_type != FASTETHER_NIC) && (db->op_mode & DM9000_AUTO) ) {
+		tmp_reg = ior(db, 0x01);	/* Got link status */
+		if ( !(tmp_reg & 0x40) ) { 	/* not link */
+			db->reg0 ^= 0x80;
+			iow(db, 0x00, db->reg0);
+		}
+	}
+
+	/* Restore previous register address */
+	outb(reg_save, db->ioaddr);
+
+	/* Set timer again */
+	db->timer.expires = DMFE_TIMER_WUT;
+	add_timer(&db->timer);
+}
+
+/*
+  Received a packet and pass to upper layer
+*/
+static void dmfe_packet_receive( unsigned long arg )
+{
+	struct net_device *dev = (struct net_device*)arg;
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+	struct sk_buff *skb;
+	u8 rxbyte, *rdptr;
+	u16 i, RxStatus, RxLen, GoodPacket, tmplen;
+	u32 tmpdata;
+
+	DMFE_DBUG(0, "dmfe_packet_receive", 0);
+ 
+	/* Check packet ready or not */
+	do {
+		ior(db, 0xf0);			/* Dummy read */
+		rxbyte = inb(db->io_data);	/* Got most updated data */
+
+		/* Status check: this byte must be 0 or 1 */
+		if (rxbyte > DM9000_PKT_RDY) {
+			iow(db, 0x05, 0x00);	/* Stop Device */
+			iow(db, 0xfe, 0x80);	/* Stop INT request */
+			db->device_wait_reset = TRUE; 
+			db->reset_rx_status++;
+		}
+
+		/* packet ready to receive check */
+		if (rxbyte == DM9000_PKT_RDY) {
+			/* A packet ready now  & Get status/length */
+			GoodPacket = TRUE;
+			outb(0xf2, db->ioaddr);
+			
+			if (db->io_mode == DM9000_BYTE_MODE) {
+				/* Byte mode */
+				RxStatus = inb(db->io_data)+(inb(db->io_data) << 8);
+				RxLen    = inb(db->io_data)+(inb(db->io_data) << 8);
+			} else if (db->io_mode == DM9000_WORD_MODE) {
+				/* Word mode */
+				RxStatus = in_be16((unsigned short*)(db->io_data));
+				RxLen    = in_be16((unsigned short*)(db->io_data));
+			} else {
+				/* DWord mode */
+				tmpdata  = inl(db->io_data);
+				RxStatus = tmpdata;
+				RxLen	 = tmpdata >> 16;
+			} 
+
+			/* Packet Status check */
+			if (RxLen < 0x40) { 
+				GoodPacket = FALSE; 
+				db->runt_length_counter++; 
+			}
+			
+			if (RxLen > DM9000_PKT_MAX) { 
+				printk("<DM9000> RST: RX Len:%x\n", RxLen);
+				db->device_wait_reset = TRUE; 
+				db->long_length_counter++; 
+			}
+			
+			if (RxStatus & 0xbf00) {
+				GoodPacket = FALSE;
+				if (RxStatus & 0x100) 
+					db->stats.rx_fifo_errors++;
+				if (RxStatus & 0x200) 
+					db->stats.rx_crc_errors++;
+				if (RxStatus & 0x8000) 
+					db->stats.rx_length_errors++;
+			}
+
+			/* Move data from DM9000 */
+			if (!db->device_wait_reset) {
+				if ( GoodPacket && ((skb = dev_alloc_skb(RxLen + 4)) != NULL ) ) {
+					skb->dev = dev;
+					skb_reserve(skb, 2);
+					rdptr = (u8 *) skb_put(skb, RxLen-4);
+					
+					/* Read received packet from RX SARM */
+					if (db->io_mode == DM9000_BYTE_MODE) {
+						/* Byte mode */
+						DMFE_DBUG(0, "bytemode", 0);
+						for (i=0; i<RxLen; i++)
+							rdptr[i]=inb(db->io_data);
+					} else if (db->io_mode == DM9000_WORD_MODE) {
+						/* Word mode */
+						DMFE_DBUG(0, "wordmode", 0);
+						tmplen = (RxLen + 1) / 2;
+						for (i = 0; i < tmplen; i++)
+							((u16 *)rdptr)[i] = inw(db->io_data);
+					} else {
+						/* DWord mode */
+						DMFE_DBUG(0, "dwordmode", 0);
+						tmplen = (RxLen + 3) / 4;
+						for (i = 0; i < tmplen; i++)
+							((u32 *)rdptr)[i] = inl(db->io_data);
+					} 
+					
+					/* Pass to upper layer */
+					skb->protocol = eth_type_trans(skb,dev);
+					netif_rx(skb);
+					db->stats.rx_packets++; 
+					DMFE_DBUG(0, "dmfe_netif_rx", 0 );
+					
+				} else {
+					/* Without buffer or error packet */
+					if (db->io_mode == DM9000_BYTE_MODE) {
+						/* Byte mode */
+						for (i = 0; i < RxLen; i++)
+							inb(db->io_data);
+					} else if (db->io_mode == DM9000_WORD_MODE) {
+						/* Word mode */
+						tmplen = (RxLen + 1) / 2;
+						for (i = 0; i < tmplen; i++)
+							inw(db->io_data);
+					} else {
+						/* DWord mode */
+						tmplen = (RxLen + 3) / 4;
+						for (i = 0; i < tmplen; i++)
+							inl(db->io_data);
+					} 
+				}
+			}
+		}
+	}while(rxbyte == DM9000_PKT_RDY && !db->device_wait_reset);
+}
+
+#if 0
+/*
+  Read a word data from SROM
+*/
+static u16 read_srom_word(dm9k_board_info_t *db, int offset)
+{
+	iow(db, 0xc, offset);
+	iow(db, 0xb, 0x4);
+	udelay(200);
+	iow(db, 0xb, 0x0);
+	return (ior(db, 0xd) + (ior(db, 0xe) << 8) );
+}
+#endif
+
+/*
+  Set DM9000 multicast address
+*/
+static void dm9000_hash_table(struct net_device *dev)
+{
+	dm9k_board_info_t *db = (dm9k_board_info_t *)dev->priv;
+	struct dev_mc_list *mcptr = dev->mc_list;
+	int mc_cnt = dev->mc_count;
+	u32 hash_val;
+	u16 i, oft, hash_table[4];
+
+	DMFE_DBUG(0, "dm9000_hash_table()", 0);
+
+	/* Set Node address */
+	for (i = 0, oft = 0x10; i < 6; i++, oft++)
+		iow(db, oft, dev->dev_addr[i]);
+  
+	/* Clear Hash Table */
+	for (i = 0; i < 4; i++)
+		hash_table[i] = 0x0;
+
+	/* broadcast address */
+	hash_table[3] = 0x8000;
+
+	/* the multicast address in Hash Table : 64 bits */
+	for (i = 0; i < mc_cnt; i++, mcptr = mcptr->next) {
+		hash_val = cal_CRC((char *)mcptr->dmi_addr, 6, 0) & 0x3f; 
+		hash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);
+	}
+
+	/* Write the hash table to MAC MD table */
+	for (i = 0, oft = 0x16; i < 4; i++) {
+		iow(db, oft++, hash_table[i] & 0xff);
+		iow(db, oft++, (hash_table[i] >> 8) & 0xff);
+	}
+}
+
+/*
+  Calculate the CRC valude of the Rx packet
+  flag = 1 : return the reverse CRC (for the received packet CRC)
+         0 : return the normal CRC (for Hash Table index)
+*/
+static unsigned long cal_CRC(unsigned char * Data, unsigned int Len, u8 flag)
+{
+	
+	u32 crc = ether_crc_le(Len, Data);
+
+	if (flag) 
+		return ~crc;
+		
+	return crc;
+	 
+}
+
+/*
+   Read a byte from I/O port
+*/
+static u8 ior(dm9k_board_info_t *db, int reg)
+{
+	outb(reg, db->ioaddr);
+	return inb(db->io_data);
+}
+
+/*
+   Write a byte to I/O port
+*/
+static void iow(dm9k_board_info_t *db, int reg, u8 value)
+{
+	outb(reg, db->ioaddr);
+	outb(value, db->io_data);
+}
+
+/*
+   Read a word from phyxcer
+*/
+static u16 phy_read(dm9k_board_info_t *db, int reg)
+{
+	/* Fill the phyxcer register into REG_0C */
+	iow(db, 0xc, DM9000_PHY | reg);
+
+	iow(db, 0xb, 0xc); 	/* Issue phyxcer read command */
+	udelay(100);		/* Wait read complete */
+	iow(db, 0xb, 0x0); 	/* Clear phyxcer read command */
+
+	/* The read data keeps on REG_0D & REG_0E */
+	return ( ior(db, 0xe) << 8 ) | ior(db, 0xd);
+}
+
+/*
+   Write a word to phyxcer
+*/
+static void phy_write(dm9k_board_info_t *db, int reg, u16 value)
+{
+	/* Fill the phyxcer register into REG_0C */
+	iow(db, 0xc, DM9000_PHY | reg);
+
+	/* Fill the written data into REG_0D & REG_0E */
+	iow(db, 0xd, (value & 0xff));
+	iow(db, 0xe, ( (value >> 8) & 0xff));
+
+	iow(db, 0xb, 0xa);		/* Issue phyxcer write command */
+	udelay(500);			/* Wait write complete */
+	iow(db, 0xb, 0x0);		/* Clear phyxcer write command */
+}
+
+static __init int dm9000_probe( struct device *dev )
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dm9k_board_info *db;    /* Point a board information structure */
+	struct net_device *ndev;
+	struct resource *res;
+	u32 id_val;
+	u32 iobase;
+	u16 i;
+	int irq;
+	int ret;
+
+	DMFE_DBUG(0, "dm9000_probe()",0);
+
+	/* get hardware resource from platform device structure */
+	res = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+	if( res == NULL )
+	{
+		ret = -ENODEV;
+		printk( KERN_ERR "no memory resource for dm9000.\n" );
+		goto failed_noresource;
+	}
+	irq = platform_get_irq( pdev, 0 );
+
+	/* reserve our IO space from system */
+	if( request_region( res->start, 1024, "dmfe") == NULL )
+	{
+		printk( KERN_ERR "request_region failed.\n" );
+		ret = -EIO;
+		goto failed_request_region;
+	}
+	iobase = (u32)ioremap( res->start, 1024 );
+	if( !iobase )
+	{
+		printk( KERN_ERR "dmfe: ioremap failed.\n" );
+		ret = -EIO;
+		goto failed_ioremap;
+	}
+
+	/* Search DM9000 NIC */
+	outb(DM9000_VID_L, iobase);
+	id_val = inb(iobase + 4);
+	outb(DM9000_VID_H, iobase);
+	id_val |= inb(iobase + 4) << 8;
+	outb(DM9000_PID_L, iobase);
+	id_val |= inb(iobase + 4) << 16;
+	outb(DM9000_PID_H, iobase);
+	id_val |= inb(iobase + 4) << 24;
+	if (id_val == DM9000_ID)
+	{
+		printk(KERN_INFO "found dm9000 network device.\n");
+
+		/* Init network device */
+		ndev = alloc_etherdev( sizeof(struct dm9k_board_info) );
+		if( !ndev )
+		{
+			ret = -ENOMEM;
+			goto failed;
+		}
+
+		/* Allocated board information structure */
+		db = ndev->priv;   /* link device and board info */
+		memset(db, 0, sizeof(*db));
+		db->ioaddr  = iobase;
+		db->io_data = iobase + 4;
+
+		ndev->base_addr 	= iobase;
+		ndev->irq 		= irq;
+		ndev->open 		= &dmfe_open;
+		ndev->hard_start_xmit 	= &dmfe_start_xmit;
+		ndev->stop 		= &dmfe_stop;
+		ndev->get_stats 	= &dmfe_get_stats;
+		ndev->set_multicast_list = &dm9000_hash_table;
+		ndev->do_ioctl 		= &dmfe_do_ioctl;
+
+		SET_MODULE_OWNER(ndev);
+		SET_NETDEV_DEV(ndev, dev);
+
+#if 0
+		/* Read SROM content */
+		for (i=0; i<64; i++)
+			((u16 *)db->srom)[i] = read_srom_word(db, i);
+
+		/* Set Node Address */
+		for (i=0; i<6; i++)
+			ndev->dev_addr[i] = db->srom[i];
+#else
+		/* Set Node Address */
+		{
+			bd_t *bd;
+
+			bd = &__res;
+
+			for (i=0; i<6; i++)
+				ndev->dev_addr[i] = bd->bi_enetaddr[i];
+		}
+#endif
+
+		/* register network device */
+		ret = register_netdev( ndev );
+		if( ret < 0 )
+		{
+			free_netdev( ndev );
+			printk( KERN_ERR "dm9000: register_netdev failed.\n" );
+			goto failed;
+		}
+	}
+	else
+	{
+		printk( KERN_WARNING "dmfe: no device. %x\n", id_val );
+		ret = -ENODEV;
+		goto failed;
+	}
+
+	dev_set_drvdata( dev, ndev );
+
+	return ret;
+
+failed:
+	iounmap( (void*)res->start );
+failed_ioremap:
+	release_region( res->start, 1024 );
+failed_request_region:
+failed_noresource:
+
+	dev_set_drvdata( dev, NULL );
+
+	printk( KERN_ERR "failed to probe dm9000.\n" );
+
+	return ret;
+}
+
+static int dm9000_remove( struct device *dev )
+{
+	struct platform_device *pdev;
+	struct net_device *ndev;
+	struct resource *res;
+
+	pdev = to_platform_device( dev );
+	ndev = dev_get_drvdata( dev );
+	res = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+	unregister_netdev( ndev );
+	if( res ) release_region( res->start, 1024 );
+	free_netdev( ndev );
+
+	return 0;
+}
+
+static int dm9000_suspend( struct device *dev,  pm_message_t state )
+{
+	return 0;
+}
+
+static int dm9000_resume( struct device *dev )
+{
+	return 0;
+}
+
+static struct device_driver dm9000_driver =
+{
+	.name		= "dm9000",
+	.bus		= &platform_bus_type,
+	.probe		= dm9000_probe,
+	.remove		= dm9000_remove,
+	.suspend	= dm9000_suspend,
+	.resume		= dm9000_resume,
+};
+
+static __init int dmfe_init_module(void)
+{
+	DMFE_DBUG(0, "init_module() ", debug);
+
+	printk( KERN_INFO "dm9000 network device driver. $Revision: 1.5 $\n" );
+
+	if (debug) 
+		dmfe_debug = debug;   /* set debug flag */
+
+	switch(mode) {
+		case DM9000_10MHD:
+		case DM9000_100MHD:
+		case DM9000_10MFD:
+		case DM9000_100MFD:
+		case DM9000_1M_HPNA:
+			media_mode = mode;
+			break;
+		default:
+			media_mode = DM9000_AUTO;
+	}
+
+	nfloor = (nfloor > 15) ? 0:nfloor;
+
+	return driver_register( &dm9000_driver );
+}
+
+static __exit void dmfe_cleanup_module(void)
+{
+	DMFE_DBUG(0, "clean_module()", 0);
+
+	driver_unregister( &dm9000_driver );
+	
+	DMFE_DBUG(0, "clean_module() exit", 0);
+}
+
+MODULE_AUTHOR("Sten Wang, sten_wang@davicom.com.tw");
+MODULE_DESCRIPTION("Davicom DM9000 ISA/uP Fast Ethernet Driver");
+module_param(debug, int,0);
+module_param(mode,int,0);
+module_param(reg5,byte,0);
+module_param(reg9,byte,0);
+module_param(rega,byte,0);
+module_param(nfloor,byte,0);
+
+module_init(dmfe_init_module);
+module_exit(dmfe_cleanup_module);
+
diff -Naur archive/linux-2.6.17/drivers/scsi/hosts.c linux-2.6.17/drivers/scsi/hosts.c
--- archive/linux-2.6.17/drivers/scsi/hosts.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/hosts.c	2007-08-30 09:04:35.000000000 +0200
@@ -40,9 +40,6 @@
 #include "scsi_logging.h"
 
 
-static int scsi_host_next_hn;		/* host_no for next new host */
-
-
 static void scsi_host_cls_release(struct class_device *class_dev)
 {
 	put_device(&class_to_shost(class_dev)->shost_gendev);
@@ -272,6 +269,38 @@
 	kfree(shost);
 }
 
+static DECLARE_MUTEX(host_num_lock);
+/**
+ * scsi_host_num_alloc - allocate a unique host number for a scsi host.
+ *
+ * Note:
+ *      Must hold host_num_lock when calling this, and continue holding it
+ *      till after the host is added to the shost_class.
+ *
+ * Return value:
+ *      A unique host number.
+ **/
+static int scsi_host_num_alloc(void)
+{
+	int host_num = 0;
+	struct class *class = &shost_class;
+	struct class_device *cdev;
+	struct Scsi_Host *shost;
+
+	down_read(&class->subsys.rwsem);
+next_host_num_try:
+	list_for_each_entry(cdev, &class->children, node) {
+		shost = class_to_shost(cdev);
+		if (shost->host_no == host_num) {
+			host_num++;
+			goto next_host_num_try;
+		}
+	}
+	up_read(&class->subsys.rwsem);
+
+	return host_num;
+}
+
 /**
  * scsi_host_alloc - register a scsi host adapter instance.
  * @sht:	pointer to scsi host template
@@ -309,7 +338,6 @@
 
 	mutex_init(&shost->scan_mutex);
 
-	shost->host_no = scsi_host_next_hn++; /* XXX(hch): still racy */
 	shost->dma_channel = 0xff;
 
 	/* These three are default values which can be overridden */
@@ -362,6 +390,12 @@
 	if (rval)
 		goto fail_kfree;
 
+	/* Hold this lock until after we've added this to the scsi_host
+	 * class, to avoid race condititons with the host number
+	 * allocation scheme. */
+	down(&host_num_lock);
+	shost->host_no = scsi_host_num_alloc();
+
 	device_initialize(&shost->shost_gendev);
 	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
 		shost->host_no);
@@ -373,6 +407,8 @@
 	snprintf(shost->shost_classdev.class_id, BUS_ID_SIZE, "host%d",
 		  shost->host_no);
 
+	up(&host_num_lock);
+
 	shost->ehandler = kthread_run(scsi_error_handler, shost,
 			"scsi_eh_%d", shost->host_no);
 	if (IS_ERR(shost->ehandler)) {
diff -Naur archive/linux-2.6.17/drivers/scsi/scsi.c linux-2.6.17/drivers/scsi/scsi.c
--- archive/linux-2.6.17/drivers/scsi/scsi.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/scsi.c	2007-08-30 09:04:36.000000000 +0200
@@ -48,6 +48,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/completion.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/unistd.h>
 #include <linux/spinlock.h>
 #include <linux/kmod.h>
@@ -1247,6 +1248,7 @@
 	for_each_possible_cpu(i)
 		INIT_LIST_HEAD(&per_cpu(scsi_done_q, i));
 
+	devfs_mk_dir("scsi");
 	printk(KERN_NOTICE "SCSI subsystem initialized\n");
 	return 0;
 
@@ -1271,6 +1273,7 @@
 	scsi_exit_sysctl();
 	scsi_exit_hosts();
 	scsi_exit_devinfo();
+	devfs_remove("scsi");
 	scsi_exit_procfs();
 	scsi_exit_queue();
 }
diff -Naur archive/linux-2.6.17/drivers/scsi/scsi_scan.c linux-2.6.17/drivers/scsi/scsi_scan.c
--- archive/linux-2.6.17/drivers/scsi/scsi_scan.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/scsi_scan.c	2007-08-30 09:04:36.000000000 +0200
@@ -716,6 +716,10 @@
 	if (inq_result[7] & 0x10)
 		sdev->sdtr = 1;
 
+	sprintf(sdev->devfs_name, "scsi/host%d/bus%d/target%d/lun%d",
+				sdev->host->host_no, sdev->channel,
+				sdev->id, sdev->lun);
+
 	/*
 	 * End sysfs code.
 	 */
diff -Naur archive/linux-2.6.17/drivers/scsi/sd.c linux-2.6.17/drivers/scsi/sd.c
--- archive/linux-2.6.17/drivers/scsi/sd.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/sd.c	2007-08-30 09:04:36.000000000 +0200
@@ -1683,6 +1683,8 @@
 			'a' + m1, 'a' + m2, 'a' + m3);
 	}
 
+	strcpy(gd->devfs_name, sdp->devfs_name);
+
 	gd->private_data = &sdkp->driver;
 	gd->queue = sdkp->device->request_queue;
 
diff -Naur archive/linux-2.6.17/drivers/scsi/sg.c linux-2.6.17/drivers/scsi/sg.c
--- archive/linux-2.6.17/drivers/scsi/sg.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/sg.c	2007-08-30 09:04:36.000000000 +0200
@@ -44,6 +44,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/moduleparam.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/cdev.h>
 #include <linux/seq_file.h>
 #include <linux/blkdev.h>
@@ -1427,10 +1428,14 @@
 	k = error;
 	sdp = sg_dev_arr[k];
 
+	devfs_mk_cdev(MKDEV(SCSI_GENERIC_MAJOR, k),
+			S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP,
+			"%s/generic", scsidp->devfs_name);
 	error = cdev_add(cdev, MKDEV(SCSI_GENERIC_MAJOR, k), 1);
-	if (error)
+	if (error) {
+		devfs_remove("%s/generic", scsidp->devfs_name);
 		goto out;
-
+	}
 	sdp->cdev = cdev;
 	if (sg_sysfs_valid) {
 		struct class_device * sg_class_member;
@@ -1520,6 +1525,7 @@
 		class_device_destroy(sg_sysfs_class, MKDEV(SCSI_GENERIC_MAJOR, k));
 		cdev_del(sdp->cdev);
 		sdp->cdev = NULL;
+		devfs_remove("%s/generic", scsidp->devfs_name);
 		put_disk(sdp->disk);
 		sdp->disk = NULL;
 		if (NULL == sdp->headfp)
diff -Naur archive/linux-2.6.17/drivers/scsi/sr.c linux-2.6.17/drivers/scsi/sr.c
--- archive/linux-2.6.17/drivers/scsi/sr.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/scsi/sr.c	2007-08-30 09:04:36.000000000 +0200
@@ -592,6 +592,8 @@
 	get_capabilities(cd);
 	sr_vendor_init(cd);
 
+	snprintf(disk->devfs_name, sizeof(disk->devfs_name),
+			"%s/cd", sdev->devfs_name);
 	disk->driverfs_dev = &sdev->sdev_gendev;
 	set_capacity(disk, cd->capacity);
 	disk->private_data = &cd->driver;
diff -Naur archive/linux-2.6.17/drivers/spi/Makefile linux-2.6.17/drivers/spi/Makefile
--- archive/linux-2.6.17/drivers/spi/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/spi/Makefile	2007-08-30 09:04:36.000000000 +0200
@@ -15,7 +15,7 @@
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
-obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
+obj-$(CONFIG_SPI_S3C24XX_GPIO)	+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 # 	... add above this line ...
 
diff -Naur archive/linux-2.6.17/drivers/usb/Kconfig linux-2.6.17/drivers/usb/Kconfig
--- archive/linux-2.6.17/drivers/usb/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/usb/Kconfig	2007-08-30 09:04:36.000000000 +0200
@@ -12,6 +12,7 @@
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
 	default y if ARM				# SL-811
+	default y if RELOOK210
 	default PCI
 
 # many non-PCI SOC chips embed OHCI
@@ -25,7 +26,7 @@
 	default y if PXA27x
 	default y if ARCH_AT91RM9200
 	# PPC:
-	default y if STB03xxx
+	default y if STB02xxx
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
diff -Naur archive/linux-2.6.17/drivers/usb/host/isp116x-hcd.c linux-2.6.17/drivers/usb/host/isp116x-hcd.c
--- archive/linux-2.6.17/drivers/usb/host/isp116x-hcd.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/usb/host/isp116x-hcd.c	2008-01-09 11:16:32.000000000 +0100
@@ -1246,6 +1246,8 @@
 	int retries = 15;
 	unsigned long flags;
 	int ret = 0;
+	struct isp116x_platform_data *board = isp116x->board;
+	u32 val = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);
 
 	spin_lock_irqsave(&isp116x->lock, flags);
 	isp116x_write_reg16(isp116x, HCSWRES, HCSWRES_MAGIC);
@@ -1260,6 +1262,20 @@
 		ERR("Software reset timeout\n");
 		ret = -ETIME;
 	}
+	
+	if (board->sel15Kres)
+		val |= HCHWCFG_15KRSEL;
+	/* Remote wakeup won't work without working clock */
+	if (board->remote_wakeup_enable)
+		val |= HCHWCFG_CLKNOTSTOP;
+	if (board->oc_enable)
+		val |= HCHWCFG_ANALOG_OC;
+	if (board->int_act_high)
+		val |= HCHWCFG_INT_POL;
+	if (board->int_edge_triggered)
+		val |= HCHWCFG_INT_TRIGGER;
+	isp116x_write_reg16(isp116x, HCHWCFG, val);
+
 	spin_unlock_irqrestore(&isp116x->lock, flags);
 	return ret;
 }
@@ -1343,21 +1359,6 @@
 	isp116x_write_reg16(isp116x, HCITLBUFLEN, ISP116x_ITL_BUFSIZE);
 	isp116x_write_reg16(isp116x, HCATLBUFLEN, ISP116x_ATL_BUFSIZE);
 
-	/* ----- HW conf */
-	val = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);
-	if (board->sel15Kres)
-		val |= HCHWCFG_15KRSEL;
-	/* Remote wakeup won't work without working clock */
-	if (board->remote_wakeup_enable)
-		val |= HCHWCFG_CLKNOTSTOP;
-	if (board->oc_enable)
-		val |= HCHWCFG_ANALOG_OC;
-	if (board->int_act_high)
-		val |= HCHWCFG_INT_POL;
-	if (board->int_edge_triggered)
-		val |= HCHWCFG_INT_TRIGGER;
-	isp116x_write_reg16(isp116x, HCHWCFG, val);
-
 	/* ----- Root hub conf */
 	val = (25 << 24) & RH_A_POTPGT;
 	/* AN10003_1.pdf recommends RH_A_NPS (no power switching) to
diff -Naur archive/linux-2.6.17/drivers/usb/host/isp116x.h linux-2.6.17/drivers/usb/host/isp116x.h
--- archive/linux-2.6.17/drivers/usb/host/isp116x.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/usb/host/isp116x.h	2008-01-09 17:17:05.000000000 +0100
@@ -365,6 +365,13 @@
 #define	IRQ_TEST()	do{}while(0)
 #endif
 
+#ifdef __BIG_ENDIAN
+#undef readw
+#define readw(addr) (*(volatile u16 *) (addr))
+#undef writew
+#define writew(b,addr) ((*(volatile u16 *) (addr)) = (b))
+#endif
+
 static inline void isp116x_write_addr(struct isp116x *isp116x, unsigned reg)
 {
 	IRQ_TEST();
@@ -380,7 +387,11 @@
 
 static inline void isp116x_raw_write_data16(struct isp116x *isp116x, u16 val)
 {
+#ifdef __BIG_ENDIAN
+	out_le16(isp116x->data_reg,val);
+#else
 	__raw_writew(val, isp116x->data_reg);
+#endif
 	isp116x_delay(isp116x, 150);
 }
 
@@ -396,8 +407,11 @@
 static inline u16 isp116x_raw_read_data16(struct isp116x *isp116x)
 {
 	u16 val;
-
+#ifdef __BIG_ENDIAN
+	val = in_le16(isp116x->data_reg);
+#else
 	val = __raw_readw(isp116x->data_reg);
+#endif
 	isp116x_delay(isp116x, 150);
 	return val;
 }
diff -Naur archive/linux-2.6.17/drivers/video/Kconfig linux-2.6.17/drivers/video/Kconfig
--- archive/linux-2.6.17/drivers/video/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/drivers/video/Kconfig	2007-08-30 09:04:38.000000000 +0200
@@ -209,6 +209,13 @@
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 
+config FB_STB2500FB
+	tristate "Power Pc stb 2500 Framebuffer"
+	depends on FB 
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+
 config FB_CYBER2000
 	tristate "CyberPro 2000/2010/5000 support"
 	depends on FB && PCI && (BROKEN || !SPARC64)
diff -Naur archive/linux-2.6.17/fs/Kconfig linux-2.6.17/fs/Kconfig
--- archive/linux-2.6.17/fs/Kconfig	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/fs/Kconfig	2007-08-30 09:04:40.000000000 +0200
@@ -827,6 +827,56 @@
 
 	Designers of embedded systems may wish to say N here to conserve space.
 
+config DEVFS_FS
+        bool "/dev file system support (OBSOLETE)"
+        depends on EXPERIMENTAL
+        help
+          This is support for devfs, a virtual file system (like /proc) which
+          provides the file system interface to device drivers, normally found
+          in /dev. Devfs does not depend on major and minor number
+          allocations. Device drivers register entries in /dev which then
+          appear automatically, which means that the system administrator does
+          not have to create character and block special device files in the
+          /dev directory using the mknod command (or MAKEDEV script) anymore.
+
+          This is work in progress. If you want to use this, you *must* read
+          the material in <file:Documentation/filesystems/devfs/>, especially
+          the file README there.
+
+          Note that devfs no longer manages /dev/pts!  If you are using UNIX98
+          ptys, you will also need to mount the /dev/pts filesystem (devpts).
+
+          Note that devfs has been obsoleted by udev,
+          <http://www.kernel.org/pub/linux/utils/kernel/hotplug/>.
+          It has been stripped down to a bare minimum and is only provided for
+          legacy installations that use its naming scheme which is
+          unfortunately different from the names normal Linux installations
+          use.
+
+          If unsure, say N.
+
+config DEVFS_MOUNT
+        bool "Automatically mount at boot"
+        depends on DEVFS_FS
+        help
+          This option appears if you have CONFIG_DEVFS_FS enabled. Setting
+          this to 'Y' will make the kernel automatically mount devfs onto /dev
+          when the system is booted, before the init thread is started.
+          You can override this with the "devfs=nomount" boot option.
+
+          If unsure, say N.
+
+config DEVFS_DEBUG
+        bool "Debug devfs"
+        depends on DEVFS_FS
+        help
+          If you say Y here, then the /dev file system code will generate
+          debugging messages. See the file
+          <file:Documentation/filesystems/devfs/boot-options> for more
+          details.
+
+          If unsure, say N.
+
 config TMPFS
 	bool "Virtual memory file system support (former shm fs)"
 	help
@@ -1188,6 +1238,92 @@
 
 	  If unsure, say N.
 
+config SQUASHFS
+        tristate "SquashFS 3.1 - Squashed file system support"
+        select ZLIB_INFLATE
+        help
+          Saying Y here includes support for SquashFS 3.1 (a Compressed Read-Only File
+          System).  Squashfs is a highly compressed read-only filesystem for Linux.
+          It uses zlib compression to compress both files, inodes and directories.
+          Inodes in the system are very small and all blocks are packed to minimise
+          data overhead. Block sizes greater than 4K are supported up to a maximum of 64K.
+          SquashFS 3.1 supports 64 bit filesystems and files (larger than 4GB), full
+          uid/gid information, hard links and timestamps.
+
+          Squashfs is intended for general read-only filesystem use, for archival
+          use (i.e. in cases where a .tar.gz file may be used), and in embedded
+          systems where low overhead is needed.  Further information and filesystem tools
+          are available from http://squashfs.sourceforge.net.
+
+          If you want to compile this as a module ( = code which can be
+          inserted in and removed from the running kernel whenever you want),
+          say M here and read <file:Documentation/modules.txt>.  The module
+          will be called squashfs.  Note that the root file system (the one
+          containing the directory /) cannot be compiled as a module.
+
+          If unsure, say N.
+
+config SQUASHFS_LZMA
+
+        bool "Use LZMA Squashfs"
+        depends on SQUASHFS
+        default n
+
+config SQUASHFS_LZMA_LC
+        int "Number of literal context bits" if SQUASHFS_LZMA
+        depends on SQUASHFS
+        default "3"
+
+config SQUASHFS_LZMA_LP
+        int "Number of literal pos bits" if SQUASHFS_LZMA
+        depends on SQUASHFS
+        default "0"
+
+config SQUASHFS_LZMA_PB
+        int "Number of pos bits" if SQUASHFS_LZMA
+        depends on SQUASHFS
+        default "2"
+
+config SQUASHFS_EMBEDDED
+
+        bool "Additional options for memory-constrained systems"
+        depends on SQUASHFS
+        default n
+        help
+          Saying Y here allows you to specify cache sizes and how Squashfs
+          allocates memory.  This is only intended for memory constrained
+          systems.
+
+          If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+        int "Number of fragments cached" if SQUASHFS_EMBEDDED
+        depends on SQUASHFS
+        default "3"
+        help
+          By default SquashFS caches the last 3 fragments read from
+          the filesystem.  Increasing this amount may mean SquashFS
+          has to re-read fragments less often from disk, at the expense
+          of extra system memory.  Decreasing this amount will mean
+          SquashFS uses less memory at the expense of extra reads from disk.
+
+          Note there must be at least one cached fragment.  Anything
+          much more than three will probably not make much difference.
+
+config SQUASHFS_VMALLOC
+        bool "Use Vmalloc rather than Kmalloc" if SQUASHFS_EMBEDDED
+        depends on SQUASHFS
+        default n
+        help
+          By default SquashFS uses kmalloc to obtain fragment cache memory.
+          Kmalloc memory is the standard kernel allocator, but it can fail
+          on memory constrained systems.  Because of the way Vmalloc works,
+          Vmalloc can succeed when kmalloc fails.  Specifying this option
+          will make SquashFS always use Vmalloc to allocate the
+          fragment cache memory.
+
+          If unsure, say N.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	help
diff -Naur archive/linux-2.6.17/fs/Makefile linux-2.6.17/fs/Makefile
--- archive/linux-2.6.17/fs/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/fs/Makefile	2007-08-30 09:04:40.000000000 +0200
@@ -56,6 +56,7 @@
 obj-$(CONFIG_JBD)		+= jbd/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)          += squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
diff -Naur archive/linux-2.6.17/fs/devfs/base.c linux-2.6.17/fs/devfs/base.c
--- archive/linux-2.6.17/fs/devfs/base.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/fs/devfs/base.c	2007-08-30 09:04:40.000000000 +0200
@@ -2033,7 +2033,7 @@
 {
 	int err;
 	int minor = MINOR(inode->i_rdev);
-	struct file_operations *old_fops, *new_fops;
+	const struct file_operations *old_fops, *new_fops;
 
 	switch (minor) {
 	case 0:		/* /dev/.devfsd */
diff -Naur archive/linux-2.6.17/fs/squashfs/Makefile linux-2.6.17/fs/squashfs/Makefile
--- archive/linux-2.6.17/fs/squashfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/fs/squashfs/Makefile	2007-08-30 09:04:43.000000000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+squashfs-y += inode.o
+squashfs-y += squashfs2_0.o
diff -Naur archive/linux-2.6.17/fs/squashfs/inode.c linux-2.6.17/fs/squashfs/inode.c
--- archive/linux-2.6.17/fs/squashfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/fs/squashfs/inode.c	2007-08-30 09:04:43.000000000 +0200
@@ -0,0 +1,2199 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#include <linux/types.h>
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include "../../lib/LzmaDecode.h"
+#include "../../lib/LzmaDecode.c"
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <linux/wait.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+#include "squashfs.h"
+
+static void squashfs_put_super(struct super_block *);
+static int squashfs_statfs(struct super_block *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readpage4K(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+static struct super_block *squashfs_get_sb(struct file_system_type *, int,
+				const char *, void *);
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_aops_4K = {
+	.readpage = squashfs_readpage4K
+};
+
+static struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static struct buffer_head *get_block_length(struct super_block *s,
+				int *cur_index, int *offset, int *c_byte)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if (!(bh = sb_bread(s, *cur_index)))
+		goto out;
+
+	if (msblk->devblksize - *offset == 1) {
+		if (msblk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+		brelse(bh);
+		if (!(bh = sb_bread(s, ++(*cur_index))))
+			goto out;
+		if (msblk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				bh->b_data);
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				bh->b_data);
+		*c_byte = temp;
+		*offset = 1;
+	} else {
+		if (msblk->swap) {
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset + 1));
+		} else {
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset + 1));
+		}
+		*c_byte = temp;
+		*offset += 2;
+	}
+
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (*offset == msblk->devblksize) {
+			brelse(bh);
+			if (!(bh = sb_bread(s, ++(*cur_index))))
+				goto out;
+			*offset = 0;
+		}
+		if (*((unsigned char *) (bh->b_data + *offset)) !=
+						SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n",
+						*cur_index);
+			brelse(bh);
+			goto out;
+		}
+		(*offset)++;
+	}
+	return bh;
+
+out:
+	return NULL;
+}
+
+
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct buffer_head *bh[((SQUASHFS_FILE_MAX_SIZE - 1) >>
+			msblk->devblksize_log2) + 2];
+	unsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k;
+	char *c_buffer;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	if (c_byte) {
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_buffer = compressed ? msblk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		if (!(bh[0] = sb_getblk(s, cur_index)))
+			goto block_release;
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if (!(bh[0] = get_block_length(s, &cur_index, &offset,
+								&c_byte)))
+			goto read_failure;
+
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_buffer = compressed ? msblk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if (compressed)
+		down(&msblk->read_data_mutex);
+
+	for (bytes = 0, k = 0; k < b; k++) {
+		avail_bytes = (c_byte - bytes) > (msblk->devblksize - offset) ?
+					msblk->devblksize - offset :
+					c_byte - bytes;
+		wait_on_buffer(bh[k]);
+		if (!buffer_uptodate(bh[k]))
+			goto block_release;
+		memcpy(c_buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+		bytes += avail_bytes;
+		offset = 0;
+		brelse(bh[k]);
+	}
+
+	/*
+	 * uncompress block
+	 */
+	if (compressed)
+	{
+		int zlib_err,i;
+		for (i=0;i<2;i++)
+		{
+			if (msblk->use_lzma)
+			{
+				SizeT InProcessed;
+				if((zlib_err = LzmaDecode(&msblk->state,
+						c_buffer, c_byte, &InProcessed,
+						buffer, msblk->read_size, &bytes)) != LZMA_RESULT_OK) {
+					ERROR("lzma_fs returned unexpected result 0x%x\n", zlib_err);
+					ERROR("lzma_fs Failed!!! no idea ..\n\n");
+					bytes = 0;
+
+				} else {
+					msblk->use_lzma=1;
+
+					break;
+				}
+			}
+			else
+			{
+				msblk->stream.next_in = c_buffer;
+				msblk->stream.avail_in = c_byte;
+				msblk->stream.next_out = buffer;
+				msblk->stream.avail_out = msblk->read_size;
+
+				if (((zlib_err = zlib_inflateInit(&msblk->stream)) != Z_OK) ||
+						((zlib_err = zlib_inflate(&msblk->stream, Z_FINISH))
+						 != Z_STREAM_END) || ((zlib_err =
+						zlib_inflateEnd(&msblk->stream)) != Z_OK)) {
+					ERROR("zlib_fs returned unexpected result 0x%x\n",
+						zlib_err);
+					bytes = 0;
+					ERROR("zlib_fs Failed!! trying to lzma\n\n");
+					msblk->use_lzma=1;
+				} else {
+					bytes = msblk->stream.total_out;
+					msblk->use_lzma=0;
+					break;
+				}
+			}
+		}
+		up(&msblk->read_data_mutex);
+	}
+
+	if (next_index)
+		*next_index = index + c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags)
+				 ? 3 : 2));
+	return bytes;
+
+block_release:
+	while (--b >= 0)
+		brelse(bh[b]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	return 0;
+}
+
+
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	long long next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
+
+	while ( 1 ) {
+		for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+			if (msblk->block_cache[i].block == block)
+				break;
+
+		down(&msblk->block_cache_mutex);
+
+		if (i == SQUASHFS_CACHED_BLKS) {
+			/* read inode header block */
+			for (i = msblk->next_cache, n = SQUASHFS_CACHED_BLKS;
+					n ; n --, i = (i + 1) %
+					SQUASHFS_CACHED_BLKS)
+				if (msblk->block_cache[i].block !=
+							SQUASHFS_USED_BLK)
+					break;
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->waitq, &wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+ 				up(&msblk->block_cache_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->waitq, &wait);
+				continue;
+			}
+			msblk->next_cache = (i + 1) % SQUASHFS_CACHED_BLKS;
+
+			if (msblk->block_cache[i].block ==
+							SQUASHFS_INVALID_BLK) {
+				if (!(msblk->block_cache[i].data =
+						kmalloc(SQUASHFS_METADATA_SIZE,
+						GFP_KERNEL))) {
+					ERROR("Failed to allocate cache"
+							"block\n");
+					up(&msblk->block_cache_mutex);
+					goto out;
+				}
+			}
+
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			up(&msblk->block_cache_mutex);
+
+			if (!(msblk->block_cache[i].length =
+						squashfs_read_data(s,
+						msblk->block_cache[i].data,
+						block, 0, &next_index))) {
+				ERROR("Unable to read cache block [%llx:%x]\n",
+						block, offset);
+				goto out;
+			}
+
+			down(&msblk->block_cache_mutex);
+			wake_up(&msblk->waitq);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
+		}
+
+		if (msblk->block_cache[i].block != block) {
+			up(&msblk->block_cache_mutex);
+			continue;
+		}
+
+		if ((bytes = msblk->block_cache[i].length - offset) >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+			up(&msblk->block_cache_mutex);
+			goto finish;
+		} else {
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, bytes);
+				buffer += bytes;
+			}
+			block = msblk->block_cache[i].next_index;
+			up(&msblk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+
+finish:
+	return return_length;
+out:
+	return 0;
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	struct squashfs_fragment_entry fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment)
+{
+	down(&msblk->fragment_mutex);
+	fragment->locked --;
+	wake_up(&msblk->fragment_wait_queue);
+	up(&msblk->fragment_mutex);
+}
+
+
+SQSH_EXTERN struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length)
+{
+	int i, n;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+
+	while ( 1 ) {
+		down(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
+
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			for (i = msblk->next_fragment, n =
+				SQUASHFS_CACHED_FRAGMENTS; n &&
+				msblk->fragment[i].locked; n--, i = (i + 1) %
+				SQUASHFS_CACHED_FRAGMENTS);
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				up(&msblk->fragment_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				continue;
+			}
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+
+			if (msblk->fragment[i].data == NULL)
+				if (!(msblk->fragment[i].data = SQUASHFS_ALLOC
+						(SQUASHFS_FILE_MAX_SIZE))) {
+					ERROR("Failed to allocate fragment "
+							"cache block\n");
+					up(&msblk->fragment_mutex);
+					goto out;
+				}
+
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			up(&msblk->fragment_mutex);
+
+			if (!(msblk->fragment[i].length = squashfs_read_data(s,
+						msblk->fragment[i].data,
+						start_block, length, NULL))) {
+				ERROR("Unable to read fragment cache block "
+							"[%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				goto out;
+			}
+
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+						i, msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+			break;
+		}
+
+		msblk->fragment[i].locked++;
+		up(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+						msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
+}
+
+
+static struct inode *squashfs_new_inode(struct super_block *s,
+		struct squashfs_base_inode_header *inodeb)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = new_inode(s);
+
+	if (i) {
+		i->i_ino = inodeb->inode_number;
+		i->i_mtime.tv_sec = inodeb->mtime;
+		i->i_atime.tv_sec = inodeb->mtime;
+		i->i_ctime.tv_sec = inodeb->mtime;
+		i->i_uid = msblk->uid[inodeb->uid];
+		i->i_mode = inodeb->mode;
+		i->i_size = 0;
+		if (inodeb->guid == SQUASHFS_GUIDS)
+			i->i_gid = i->i_uid;
+		else
+			i->i_gid = msblk->guid[inodeb->guid];
+	}
+
+	return i;
+}
+
+
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode)
+{
+	struct inode *i;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header *sinodep =
+								&sid.symlink;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	/* Allocate fragment index table */
+	if (!(msblk->fragment_index = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->iget = squashfs_iget;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >
+			SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
+	int i;
+	char b[BDEVNAME_SIZE];
+	struct inode *root;
+
+	TRACE("Entered squashfs_read_superblock\n");
+
+	if (!(s->s_fs_info = kmalloc(sizeof(struct squashfs_sb_info),
+						GFP_KERNEL))) {
+		ERROR("Failed to allocate superblock\n");
+		goto failure;
+	}
+	memset(s->s_fs_info, 0, sizeof(struct squashfs_sb_info));
+	msblk = s->s_fs_info;
+	msblk->state.Properties.lc = CONFIG_SQUASHFS_LZMA_LC;
+	msblk->state.Properties.lp = CONFIG_SQUASHFS_LZMA_LP;
+	msblk->state.Properties.pb = CONFIG_SQUASHFS_LZMA_PB;
+	if(!(msblk->state.Probs = (CProb *) kmalloc(LzmaGetNumProbs(&msblk->state.Properties) * sizeof(CProb), GFP_KERNEL))) {
+		ERROR("Failed to allocate lzma workspace\n");
+		goto failure;
+	}
+	if (!(msblk->stream.workspace = vmalloc(zlib_inflate_workspacesize()))) {
+		ERROR("Failed to allocate zlib workspace\n");
+		goto failure;
+	}
+
+	sblk = &msblk->sblk;
+
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	init_MUTEX(&msblk->read_data_mutex);
+	init_MUTEX(&msblk->read_page_mutex);
+	init_MUTEX(&msblk->block_cache_mutex);
+	init_MUTEX(&msblk->fragment_mutex);
+	init_MUTEX(&msblk->meta_index_mutex);
+
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		SERROR("unable to read superblock\n");
+		goto failed_mount;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	msblk->swap = 0;
+	if ((s->s_magic = sblk->s_magic) != SQUASHFS_MAGIC) {
+		if (sblk->s_magic == SQUASHFS_MAGIC_SWAP) {
+			struct squashfs_super_block ssblk;
+
+			WARNING("Mounting a different endian SQUASHFS "
+				"filesystem on %s\n", bdevname(s->s_bdev, b));
+
+			SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+			memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+			msblk->swap = 1;
+		} else  {
+			SERROR("Can't find a SQUASHFS superblock on %s\n",
+							bdevname(s->s_bdev, b));
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(!supported_squashfs_filesystem(msblk, silent))
+		goto failed_mount;
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_INODES
+					(sblk->flags) ? "un" : "");
+	TRACE("Data is %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %s present in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?
+					"" : "not");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n",
+					sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_ops;
+
+	/* Init inode_table block pointer array */
+	if (!(msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					SQUASHFS_CACHED_BLKS, GFP_KERNEL))) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+
+	/* Allocate read_data block */
+	msblk->read_size = (sblk->block_size < SQUASHFS_METADATA_SIZE) ?
+					SQUASHFS_METADATA_SIZE :
+					sblk->block_size;
+
+	if (!(msblk->read_data = kmalloc(msblk->read_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_data block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate read_page block */
+	if (!(msblk->read_page = kmalloc(sblk->block_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_page block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate uid and gid tables */
+	if (!(msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount;
+	}
+	msblk->guid = msblk->uid + sblk->no_uids;
+
+	if (msblk->swap) {
+		unsigned int suid[sblk->no_uids + sblk->no_guids];
+
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
+	} else
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
+		goto allocate_root;
+
+	if (!(msblk->fragment = kmalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL))) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].locked = 0;
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+		msblk->fragment[i].data = NULL;
+	}
+
+	msblk->next_fragment = 0;
+
+	/* Allocate fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto failed_mount;
+
+allocate_root:
+	if ((root = (msblk->iget)(s, sblk->root_inode)) == NULL)
+		goto failed_mount;
+
+	if ((s->s_root = d_alloc_root(root)) == NULL) {
+		ERROR("Root inode create failed\n");
+		iput(root);
+		goto failed_mount;
+	}
+
+	TRACE("Leaving squashfs_read_super\n");
+	return 0;
+
+failed_mount:
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment);
+	kfree(msblk->uid);
+	kfree(msblk->read_page);
+	kfree(msblk->read_data);
+	kfree(msblk->block_cache);
+	kfree(msblk->fragment_index_2);
+	//if (msblk->use_lzma) {
+		kfree(msblk->state.Probs);
+	//} else {
+		vfree(msblk->stream.workspace);
+	//}
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+	return -EINVAL;
+
+failure:
+	return -ENOMEM;
+}
+
+
+static int squashfs_statfs(struct super_block *s, struct kstatfs *buf)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	TRACE("Entered squashfs_statfs\n");
+
+	buf->f_type = SQUASHFS_MAGIC;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sblk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		if (!(bytes = squashfs_get_cached_block(inode->i_sb, NULL,
+				block, offset, PAGE_CACHE_SIZE, &block,
+				&offset))) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block,
+					offset);
+			goto skip_read;
+		}
+	}
+
+	if (length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	bytes = (i_size_read(inode) - length) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE :
+					i_size_read(inode) - length;
+
+	if (!(bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block,
+					offset, bytes, &block, &offset)))
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
+
+	down(&msblk->meta_index_mutex);
+
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if(msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++)
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
+
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	up(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	down(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if(msblk->meta_index == NULL) {
+		if (!(msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL))) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
+		}
+		for(i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
+		}
+		msblk->next_meta_index = 0;
+	}
+
+	for(i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if(i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	up(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+}
+
+
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+		long long *start_block, int *offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned int *block_listp;
+	int block = 0;
+
+	if (msblk->swap) {
+		char sblock_list[blocks << 2];
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+	} else
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
+		block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+
+	return block;
+
+failure:
+	return -1;
+}
+
+
+#define SIZE 256
+
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
+
+
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
+
+	index /= SQUASHFS_META_INDEXES * skip;
+
+	while ( offset < index ) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			if ((meta = empty_meta_index(inode, offset + 1,
+							skip)) == NULL)
+				goto all_done;
+		} else {
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset,
+				meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
+		}
+
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
+
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) :
+					blocks;
+				int res = read_block_index(inode->i_sb, block,
+					block_list, &cur_index_block,
+					&cur_offset);
+
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
+			}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
+		}
+
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
+
+		release_meta_index(inode, meta);
+	}
+
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
+
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
+}
+
+
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
+{
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
+
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset,
+		       block);
+
+	if(res == -1)
+		goto failure;
+
+	index -= res;
+
+	while ( index ) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
+	}
+
+	if (read_block_index(inode->i_sb, 1, block_list,
+			&block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
+
+failure:
+	return 0;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list;
+	long long block;
+	unsigned int bsize, i = 0, bytes = 0, byte_offset = 0;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
+
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (!(block_list = kmalloc(SIZE, GFP_KERNEL))) {
+		ERROR("Failed to allocate block_list\n");
+		goto skip_read;
+	}
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto skip_read;
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		if ((block = (msblk->read_blocklist)(inode, index, 1,
+					block_list, NULL, &bsize)) == 0)
+			goto skip_read;
+
+		down(&msblk->read_page_mutex);
+
+		if (!(bytes = squashfs_read_data(inode->i_sb, msblk->read_page,
+					block, bsize, NULL))) {
+			ERROR("Unable to read page, block %llx, size %x\n", block,
+					bsize);
+			up(&msblk->read_page_mutex);
+			goto skip_read;
+		}
+	} else {
+		if ((fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size))
+					== NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->
+					u.s1.fragment_size);
+			goto skip_read;
+		}
+		bytes = SQUASHFS_I(inode)->u.s1.fragment_offset +
+					(i_size_read(inode) & (sblk->block_size
+					- 1));
+		byte_offset = SQUASHFS_I(inode)->u.s1.fragment_offset;
+		data_ptr = fragment->data;
+	}
+
+	for (i = start_index; i <= end_index && byte_offset < bytes;
+					i++, byte_offset += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int available_bytes = (bytes - byte_offset) > PAGE_CACHE_SIZE ?
+					PAGE_CACHE_SIZE : bytes - byte_offset;
+
+		TRACE("bytes %d, i %d, byte_offset %d, available_bytes %d\n",
+					bytes, i, byte_offset, available_bytes);
+
+		if (i == page->index)  {
+			pageaddr = kmap_atomic(page, KM_USER0);
+			memcpy(pageaddr, data_ptr + byte_offset,
+					available_bytes);
+			memset(pageaddr + available_bytes, 0,
+					PAGE_CACHE_SIZE - available_bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			unlock_page(page);
+		} else if ((push_page =
+				grab_cache_page_nowait(page->mapping, i))) {
+ 			pageaddr = kmap_atomic(push_page, KM_USER0);
+
+			memcpy(pageaddr, data_ptr + byte_offset,
+					available_bytes);
+			memset(pageaddr + available_bytes, 0,
+					PAGE_CACHE_SIZE - available_bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+			flush_dcache_page(push_page);
+			SetPageUptodate(push_page);
+			unlock_page(push_page);
+			page_cache_release(push_page);
+		}
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log))
+		up(&msblk->read_page_mutex);
+	else
+		release_cached_fragment(msblk, fragment);
+
+	kfree(block_list);
+	return 0;
+
+skip_read:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int squashfs_readpage4K(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list;
+	long long block;
+	unsigned int bsize, bytes = 0;
+ 	void *pageaddr;
+
+	TRACE("Entered squashfs_readpage4K, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT)) {
+		pageaddr = kmap_atomic(page, KM_USER0);
+		block_list = NULL;
+		goto skip_read;
+	}
+
+	if (!(block_list = kmalloc(SIZE, GFP_KERNEL))) {
+		ERROR("Failed to allocate block_list\n");
+		pageaddr = kmap_atomic(page, KM_USER0);
+		block_list = NULL;
+		goto skip_read;
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| page->index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		block = (msblk->read_blocklist)(inode, page->index, 1,
+					block_list, NULL, &bsize);
+
+		down(&msblk->read_page_mutex);
+		bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+					bsize, NULL);
+		pageaddr = kmap_atomic(page, KM_USER0);
+		if (bytes)
+			memcpy(pageaddr, msblk->read_page, bytes);
+		else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					block, bsize);
+		up(&msblk->read_page_mutex);
+	} else {
+		struct squashfs_fragment_cache *fragment =
+			get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+		pageaddr = kmap_atomic(page, KM_USER0);
+		if (fragment) {
+			bytes = i_size_read(inode) & (sblk->block_size - 1);
+			memcpy(pageaddr, fragment->data + SQUASHFS_I(inode)->
+					u.s1.fragment_offset, bytes);
+			release_cached_fragment(msblk, fragment);
+		} else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block, (int)
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+	}
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length + 3;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length + 3;
+}
+
+
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]);
+
+		if (filldir(dirent, name, size,
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+		}
+		file->f_pos += size;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %d\n", name,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
+
+				inode = (msblk->iget)(i->i_sb, ino);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+				if (sbi->block_cache[i].block !=
+							SQUASHFS_INVALID_BLK)
+					kfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++)
+				SQUASHFS_FREE(sbi->fragment[i].data);
+		kfree(sbi->fragment);
+		kfree(sbi->block_cache);
+		kfree(sbi->read_data);
+		kfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		//if (sbi->use_lzma) {
+			kfree(sbi->state.Probs);
+		//} else {
+			vfree(sbi->stream.workspace);
+		//}
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static struct super_block *squashfs_get_sb(struct file_system_type *fs_type,
+				int flags, const char *dev_name, void *data)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);
+}
+
+
+static int __init init_squashfs_fs(void)
+{
+	int err = init_inodecache();
+	if (err)
+		goto out;
+
+	printk(KERN_INFO "squashfs: version 3.1 + autolzma (2006/10/05) "
+		"Phillip Lougher\n");
+
+	if ((err = register_filesystem(&squashfs_fs_type)))
+		destroy_inodecache();
+
+out:
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	unregister_filesystem(&squashfs_fs_type);
+	destroy_inodecache();
+}
+
+
+static kmem_cache_t * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, SLAB_KERNEL);
+	if (!ei)
+		return NULL;
+	return &ei->vfs_inode;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct squashfs_inode_info *ei = foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+							SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&ei->vfs_inode);
+}
+
+
+static int __init init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+	     sizeof(struct squashfs_inode_info),
+	     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
+	     init_once, NULL);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(squashfs_inode_cachep))
+		printk(KERN_INFO "squashfs_inode_cache: not all structures "
+			"were freed\n");
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs 3.1, a compressed read-only filesystem");
+MODULE_AUTHOR("Phillip Lougher <phillip@lougher.org.uk>");
+MODULE_LICENSE("GPL");
diff -Naur archive/linux-2.6.17/fs/squashfs/squashfs.h linux-2.6.17/fs/squashfs/squashfs.h
--- archive/linux-2.6.17/fs/squashfs/squashfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/fs/squashfs/squashfs.h	2007-08-30 09:04:43.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index);
+extern int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct address_space_operations squashfs_symlink_aops;
+extern struct address_space_operations squashfs_aops;
+extern struct address_space_operations squashfs_aops_4K;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
diff -Naur archive/linux-2.6.17/fs/squashfs/squashfs2_0.c linux-2.6.17/fs/squashfs/squashfs2_0.c
--- archive/linux-2.6.17/fs/squashfs/squashfs2_0.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/fs/squashfs/squashfs2_0.c	2007-08-30 09:04:43.000000000 +0200
@@ -0,0 +1,780 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/types.h>
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include "../../lib/LzmaDecode.h"
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/zlib.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <linux/wait.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static struct inode *squashfs_new_inode(struct super_block *s,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	struct inode *i = new_inode(s);
+
+	if (i) {
+		i->i_ino = ino;
+		i->i_mtime.tv_sec = sblk->mkfs_time;
+		i->i_atime.tv_sec = sblk->mkfs_time;
+		i->i_ctime.tv_sec = sblk->mkfs_time;
+		i->i_uid = msblk->uid[inodeb->uid];
+		i->i_mode = inodeb->mode;
+		i->i_nlink = 1;
+		i->i_size = 0;
+		if (inodeb->guid == SQUASHFS_GUIDS)
+			i->i_gid = i->i_uid;
+		else
+			i->i_gid = msblk->guid[inodeb->guid];
+	}
+
+	return i;
+}
+
+
+static struct inode *squashfs_iget_2(struct super_block *s, squashfs_inode_t inode)
+{
+	struct inode *i;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = SQUASHFS_MK_VFS_INODE(block
+		- sblk->inode_table_start, offset);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			if ((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length;
+}
+
+
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = (msblk->iget)(i->i_sb, ino);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->iget = squashfs_iget_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
diff -Naur archive/linux-2.6.17/include/asm-ppc/ibm4xx.h linux-2.6.17/include/asm-ppc/ibm4xx.h
--- archive/linux-2.6.17/include/asm-ppc/ibm4xx.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/asm-ppc/ibm4xx.h	2007-08-30 09:04:48.000000000 +0200
@@ -55,6 +55,42 @@
 #include <platforms/4xx/xilinx_ml403.h>
 #endif
 
+#if defined(CONFIG_RELOOK100S)
+#include <platforms/4xx/relook100s.h>
+#endif
+
+#if defined(CONFIG_RELOOK200S)
+#include <platforms/4xx/relook200s.h>
+#endif
+
+#if defined(CONFIG_RELOOK210)
+#include <platforms/4xx/relook210.h>
+#endif
+
+#if defined(CONFIG_RELOOK300)
+#include <platforms/4xx/relook300.h>
+#endif
+
+#if defined(CONFIG_RELOOK400)
+#include <platforms/4xx/relook400.h>
+#endif
+
+#if defined(CONFIG_RELOOK400C)
+#include <platforms/4xx/relook400c.h>
+#endif
+
+#if defined(CONFIG_RELOOK500S)
+#include <platforms/4xx/relook500s.h>
+#endif
+
+#if defined(CONFIG_RELOOK500T)
+#include <platforms/4xx/relook500t.h>
+#endif
+
+#if defined(CONFIG_RELOOK510S)
+#include <platforms/4xx/relook510s.h>
+#endif
+
 #ifndef __ASSEMBLY__
 
 #ifdef CONFIG_40x
diff -Naur archive/linux-2.6.17/include/asm-ppc/ocp_ids.h linux-2.6.17/include/asm-ppc/ocp_ids.h
--- archive/linux-2.6.17/include/asm-ppc/ocp_ids.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/asm-ppc/ocp_ids.h	2007-08-30 09:04:48.000000000 +0200
@@ -49,6 +49,7 @@
 #define OCP_FUNC_DMA		0x0091
 
 /* Display 0x00A0 - 0x00AF */
+#define OCP_FUNC_FB		0x00A0	/* for STBxxxxx */
 
 /* Sound 0x00B0 - 0x00BF */
 
diff -Naur archive/linux-2.6.17/include/asm-ppc/ppc4xx_dma.h linux-2.6.17/include/asm-ppc/ppc4xx_dma.h
--- archive/linux-2.6.17/include/asm-ppc/ppc4xx_dma.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/asm-ppc/ppc4xx_dma.h	2007-08-30 09:04:48.000000000 +0200
@@ -485,7 +485,7 @@
 	char ch_enable;
 	char tcd_disable;
 	char ece_enable;
-	char td;		/* transfer direction */
+//	char td;		/* transfer direction */
 #endif
 
 	char int_on_final_sg;/* for scatter/gather - only interrupt on last sg */
diff -Naur archive/linux-2.6.17/include/linux/i2c.h linux-2.6.17/include/linux/i2c.h
--- archive/linux-2.6.17/include/linux/i2c.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/i2c.h	2007-08-30 09:04:50.000000000 +0200
@@ -26,9 +26,11 @@
 #ifndef _LINUX_I2C_H
 #define _LINUX_I2C_H
 
-#include <linux/module.h>
-#include <linux/types.h>
 #include <linux/i2c-id.h>
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+#include <linux/module.h>
 #include <linux/mod_devicetable.h>
 #include <linux/device.h>	/* for struct device */
 #include <linux/sched.h>	/* for completion */
@@ -355,6 +357,8 @@
 	return adap->nr;
 }
 
+#endif /* __KERNEL__ */
+
 /*
  * I2C Message - used for pure i2c transaction, also from /dev interface
  */
@@ -476,6 +480,7 @@
 /* The length of the option lists */
 #define I2C_CLIENT_MAX_OPTS 48
 
+#ifdef __KERNEL__
 /* Default fill of many variables */
 #define I2C_CLIENT_DEFAULTS {I2C_CLIENT_END, I2C_CLIENT_END, I2C_CLIENT_END, \
                           I2C_CLIENT_END, I2C_CLIENT_END, I2C_CLIENT_END, \
@@ -647,4 +652,5 @@
 				    force_##chip8, NULL };		\
 I2C_CLIENT_INSMOD_COMMON
 
+#endif /* __KERNEL__ */
 #endif /* _LINUX_I2C_H */
diff -Naur archive/linux-2.6.17/include/linux/ibm_gpio.h linux-2.6.17/include/linux/ibm_gpio.h
--- archive/linux-2.6.17/include/linux/ibm_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/include/linux/ibm_gpio.h	2007-08-30 09:04:52.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+typedef struct gpio_regs {
+	u32 or;
+	u32 tcr;
+	u32 pad[4];
+	u32 odr;
+	u32 ir;
+} gpio_t;
+#endif
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ibm_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ibm_gpio_ioctl_data)
+
+#endif
diff -Naur archive/linux-2.6.17/include/linux/mmc/host.h linux-2.6.17/include/linux/mmc/host.h
--- archive/linux-2.6.17/include/linux/mmc/host.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/mmc/host.h	2007-08-30 09:04:51.000000000 +0200
@@ -85,6 +85,9 @@
 	unsigned long		caps;		/* Host capabilities */
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
+#define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
+#define MMC_CAP_BYTEBLOCK	(1 << 2)	/* Can do non-log2 block sizes */
+#define MMC_CAP_LOCK_UNLOCK	(1 << 3)	/* Host password support capability */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
diff -Naur archive/linux-2.6.17/include/linux/module.h linux-2.6.17/include/linux/module.h
--- archive/linux-2.6.17/include/linux/module.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/module.h	2007-08-30 09:04:51.000000000 +0200
@@ -557,13 +557,4 @@
 
 #define __MODULE_STRING(x) __stringify(x)
 
-/* Use symbol_get and symbol_put instead.  You'll thank me. */
-#define HAVE_INTER_MODULE
-extern void __deprecated inter_module_register(const char *,
-		struct module *, const void *);
-extern void __deprecated inter_module_unregister(const char *);
-extern const void * __deprecated inter_module_get_request(const char *,
-		const char *);
-extern void __deprecated inter_module_put(const char *);
-
 #endif /* _LINUX_MODULE_H */
diff -Naur archive/linux-2.6.17/include/linux/mtd/cfi.h linux-2.6.17/include/linux/mtd/cfi.h
--- archive/linux-2.6.17/include/linux/mtd/cfi.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/mtd/cfi.h	2007-08-30 09:04:51.000000000 +0200
@@ -243,7 +243,6 @@
 	int mfr, id;
 	int numchips;
 	unsigned long chipshift; /* Because they're of the same type */
-	const char *im_name;	 /* inter_module name for cmdset_setup */
 	struct flchip chips[0];  /* per-chip data structure for each chip */
 };
 
diff -Naur archive/linux-2.6.17/include/linux/spi/mmc_spi.h linux-2.6.17/include/linux/spi/mmc_spi.h
--- archive/linux-2.6.17/include/linux/spi/mmc_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/include/linux/spi/mmc_spi.h	2007-08-30 09:04:51.000000000 +0200
@@ -0,0 +1,34 @@
+#ifndef __LINUX_SPI_MMC_SPI_H
+#define __LINUX_SPI_MMC_SPI_H
+
+#include <linux/mmc/protocol.h>
+#include <linux/interrupt.h>
+
+struct device;
+struct mmc_host;
+
+/* something to put in platform_data of a device being used
+ * to manage an MMC/SD card slot
+ *
+ * REVISIT this isn't spi-specific, any card slot should be
+ * able to handle it
+ */
+struct mmc_spi_platform_data {
+	/* driver activation and (optional) card detect irq */
+	int (*init)(struct device *,
+		irqreturn_t (*)(int, void *),
+		void *);
+	void (*exit)(struct device *, void *);
+
+	/* how long to debounce card detect, in jiffies */
+	unsigned long detect_delay;
+
+	/* sense switch on sd cards */
+	int (*get_ro)(struct device *);
+
+	/* power management */
+	unsigned int ocr_mask;			/* available voltages */
+	void (*setpower)(struct device *, unsigned int);
+};
+
+#endif /* __LINUX_SPI_MMC_SPI_H */
diff -Naur archive/linux-2.6.17/include/linux/spi/spi.h linux-2.6.17/include/linux/spi/spi.h
--- archive/linux-2.6.17/include/linux/spi/spi.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/spi/spi.h	2007-08-30 09:04:51.000000000 +0200
@@ -71,6 +71,7 @@
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
+#define SPI_TX_1	0x10			/* shift out ones on rx-only */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
@@ -289,8 +290,9 @@
  * the data being transferred; that may reduce overhead, when the
  * underlying driver uses dma.
  *
- * If the transmit buffer is null, undefined data will be shifted out
- * while filling rx_buf.  If the receive buffer is null, the data
+ * If the transmit buffer is null, zeroes will be shifted out while
+ * filling rx_buf, unless SPI_TX_1 is set in spi->mode (in which case
+ * ones will be shifted out). If the receive buffer is null, the data
  * shifted in will be discarded.  Only "len" bytes shift out (or in).
  * It's an error to try to shift out a partial word.  (For example, by
  * shifting out three bytes with word size of sixteen or twenty bits;
diff -Naur archive/linux-2.6.17/include/linux/squashfs_fs.h linux-2.6.17/include/linux/squashfs_fs.h
--- archive/linux-2.6.17/include/linux/squashfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/include/linux/squashfs_fs.h	2007-08-30 09:04:52.000000000 +0200
@@ -0,0 +1,911 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#ifdef	CONFIG_SQUASHFS_VMALLOC
+#define SQUASHFS_ALLOC(a)		vmalloc(a)
+#define SQUASHFS_FREE(a)		vfree(a)
+#else
+#define SQUASHFS_ALLOC(a)		kmalloc(a, GFP_KERNEL)
+#define SQUASHFS_FREE(a)		kfree(a)
+#endif
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			0
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		65536
+#define SQUASHFS_FILE_LOG		16
+
+#define SQUASHFS_FILE_MAX_SIZE		65536
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+		(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK) ? (B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)	(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES(A)	(A * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
+
+struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode_t	root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		unused;
+} __attribute__ ((packed));
+
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		i_count:16;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
+	
+struct squashfs_dir_entry {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	int			inode_number:16;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_header {
+	unsigned int		count:8;
+	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
+	unsigned int		size;
+	unsigned int		unused;
+} __attribute__ ((packed));
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->unused, d, 888, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+
+struct squashfs_base_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
+ */
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
+#endif
+#endif
diff -Naur archive/linux-2.6.17/include/linux/squashfs_fs_i.h linux-2.6.17/include/linux/squashfs_fs_i.h
--- archive/linux-2.6.17/include/linux/squashfs_fs_i.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/include/linux/squashfs_fs_i.h	2007-08-30 09:04:52.000000000 +0200
@@ -0,0 +1,45 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+struct squashfs_inode_info {
+	long long	start_block;
+	unsigned int	offset;
+	union {
+		struct {
+			long long	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+			long long	block_list_start;
+		} s1;
+		struct {
+			long long	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+};
+#endif
diff -Naur archive/linux-2.6.17/include/linux/squashfs_fs_sb.h linux-2.6.17/include/linux/squashfs_fs_sb.h
--- archive/linux-2.6.17/include/linux/squashfs_fs_sb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/include/linux/squashfs_fs_sb.h	2007-08-30 09:04:52.000000000 +0200
@@ -0,0 +1,77 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+struct squashfs_cache {
+	long long	block;
+	int		length;
+	long long	next_index;
+	char		*data;
+};
+
+struct squashfs_fragment_cache {
+	long long	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+};
+
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	struct squashfs_cache	*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
+	unsigned int		read_size;
+	char			*read_data;
+	char			*read_page;
+	struct semaphore	read_data_mutex;
+	struct semaphore	read_page_mutex;
+	struct semaphore	block_cache_mutex;
+	struct semaphore	fragment_mutex;
+	struct semaphore	meta_index_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct meta_index	*meta_index;
+	int			use_lzma;
+	CLzmaDecoderState 	state;
+	z_stream		stream;
+	struct inode		*(*iget)(struct super_block *s,  squashfs_inode_t
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int
+				index, int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+};
+#endif
diff -Naur archive/linux-2.6.17/include/linux/zconf.h linux-2.6.17/include/linux/zconf.h
--- archive/linux-2.6.17/include/linux/zconf.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/linux/zconf.h	2007-08-30 09:04:52.000000000 +0200
@@ -36,7 +36,9 @@
 #endif
 
                         /* Type declarations */
-
+#ifdef Byte
+#undef Byte
+#endif
 typedef unsigned char  Byte;  /* 8 bits */
 typedef unsigned int   uInt;  /* 16 bits or more */
 typedef unsigned long  uLong; /* 32 bits or more */
diff -Naur archive/linux-2.6.17/include/scsi/scsi_device.h linux-2.6.17/include/scsi/scsi_device.h
--- archive/linux-2.6.17/include/scsi/scsi_device.h	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/include/scsi/scsi_device.h	2007-08-30 09:04:52.000000000 +0200
@@ -74,6 +74,7 @@
 	unsigned sector_size;	/* size in bytes */
 
 	void *hostdata;		/* available to low-level driver */
+	char devfs_name[256];	/* devfs junk */
 	char type;
 	char scsi_level;
 	char inq_periph_qual;	/* PQ from INQUIRY data */	
diff -Naur archive/linux-2.6.17/init/do_mounts_rd.c linux-2.6.17/init/do_mounts_rd.c
--- archive/linux-2.6.17/init/do_mounts_rd.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/init/do_mounts_rd.c	2007-08-30 09:04:52.000000000 +0200
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ *      squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,18 @@
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+			"RAMDISK: squashfs filesystem found at block %d\n",
+			start_block);
+		if (squashfsb->s_major < 3)
+			nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		else
+			nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
diff -Naur archive/linux-2.6.17/kernel/Makefile linux-2.6.17/kernel/Makefile
--- archive/linux-2.6.17/kernel/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/kernel/Makefile	2007-08-30 09:04:52.000000000 +0200
@@ -20,7 +20,6 @@
 obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock.o
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += module.o
-obj-$(CONFIG_OBSOLETE_INTERMODULE) += intermodule.o
 obj-$(CONFIG_KALLSYMS) += kallsyms.o
 obj-$(CONFIG_PM) += power/
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
diff -Naur archive/linux-2.6.17/kernel/intermodule.c linux-2.6.17/kernel/intermodule.c
--- archive/linux-2.6.17/kernel/intermodule.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/kernel/intermodule.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,184 +0,0 @@
-/* Deprecated, do not use.  Moved from module.c to here. --RR */
-
-/* Written by Keith Owens <kaos@ocs.com.au> Oct 2000 */
-#include <linux/module.h>
-#include <linux/kmod.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <linux/slab.h>
-
-/* inter_module functions are always available, even when the kernel is
- * compiled without modules.  Consumers of inter_module_xxx routines
- * will always work, even when both are built into the kernel, this
- * approach removes lots of #ifdefs in mainline code.
- */
-
-static struct list_head ime_list = LIST_HEAD_INIT(ime_list);
-static DEFINE_SPINLOCK(ime_lock);
-static int kmalloc_failed;
-
-struct inter_module_entry {
-	struct list_head list;
-	const char *im_name;
-	struct module *owner;
-	const void *userdata;
-};
-
-/**
- * inter_module_register - register a new set of inter module data.
- * @im_name: an arbitrary string to identify the data, must be unique
- * @owner: module that is registering the data, always use THIS_MODULE
- * @userdata: pointer to arbitrary userdata to be registered
- *
- * Description: Check that the im_name has not already been registered,
- * complain if it has.  For new data, add it to the inter_module_entry
- * list.
- */
-void inter_module_register(const char *im_name, struct module *owner, const void *userdata)
-{
-	struct list_head *tmp;
-	struct inter_module_entry *ime, *ime_new;
-
-	if (!(ime_new = kzalloc(sizeof(*ime), GFP_KERNEL))) {
-		/* Overloaded kernel, not fatal */
-		printk(KERN_ERR
-			"Aiee, inter_module_register: cannot kmalloc entry for '%s'\n",
-			im_name);
-		kmalloc_failed = 1;
-		return;
-	}
-	ime_new->im_name = im_name;
-	ime_new->owner = owner;
-	ime_new->userdata = userdata;
-
-	spin_lock(&ime_lock);
-	list_for_each(tmp, &ime_list) {
-		ime = list_entry(tmp, struct inter_module_entry, list);
-		if (strcmp(ime->im_name, im_name) == 0) {
-			spin_unlock(&ime_lock);
-			kfree(ime_new);
-			/* Program logic error, fatal */
-			printk(KERN_ERR "inter_module_register: duplicate im_name '%s'", im_name);
-			BUG();
-		}
-	}
-	list_add(&(ime_new->list), &ime_list);
-	spin_unlock(&ime_lock);
-}
-
-/**
- * inter_module_unregister - unregister a set of inter module data.
- * @im_name: an arbitrary string to identify the data, must be unique
- *
- * Description: Check that the im_name has been registered, complain if
- * it has not.  For existing data, remove it from the
- * inter_module_entry list.
- */
-void inter_module_unregister(const char *im_name)
-{
-	struct list_head *tmp;
-	struct inter_module_entry *ime;
-
-	spin_lock(&ime_lock);
-	list_for_each(tmp, &ime_list) {
-		ime = list_entry(tmp, struct inter_module_entry, list);
-		if (strcmp(ime->im_name, im_name) == 0) {
-			list_del(&(ime->list));
-			spin_unlock(&ime_lock);
-			kfree(ime);
-			return;
-		}
-	}
-	spin_unlock(&ime_lock);
-	if (kmalloc_failed) {
-		printk(KERN_ERR
-			"inter_module_unregister: no entry for '%s', "
-			"probably caused by previous kmalloc failure\n",
-			im_name);
-		return;
-	}
-	else {
-		/* Program logic error, fatal */
-		printk(KERN_ERR "inter_module_unregister: no entry for '%s'", im_name);
-		BUG();
-	}
-}
-
-/**
- * inter_module_get - return arbitrary userdata from another module.
- * @im_name: an arbitrary string to identify the data, must be unique
- *
- * Description: If the im_name has not been registered, return NULL.
- * Try to increment the use count on the owning module, if that fails
- * then return NULL.  Otherwise return the userdata.
- */
-static const void *inter_module_get(const char *im_name)
-{
-	struct list_head *tmp;
-	struct inter_module_entry *ime;
-	const void *result = NULL;
-
-	spin_lock(&ime_lock);
-	list_for_each(tmp, &ime_list) {
-		ime = list_entry(tmp, struct inter_module_entry, list);
-		if (strcmp(ime->im_name, im_name) == 0) {
-			if (try_module_get(ime->owner))
-				result = ime->userdata;
-			break;
-		}
-	}
-	spin_unlock(&ime_lock);
-	return(result);
-}
-
-/**
- * inter_module_get_request - im get with automatic request_module.
- * @im_name: an arbitrary string to identify the data, must be unique
- * @modname: module that is expected to register im_name
- *
- * Description: If inter_module_get fails, do request_module then retry.
- */
-const void *inter_module_get_request(const char *im_name, const char *modname)
-{
-	const void *result = inter_module_get(im_name);
-	if (!result) {
-		request_module("%s", modname);
-		result = inter_module_get(im_name);
-	}
-	return(result);
-}
-
-/**
- * inter_module_put - release use of data from another module.
- * @im_name: an arbitrary string to identify the data, must be unique
- *
- * Description: If the im_name has not been registered, complain,
- * otherwise decrement the use count on the owning module.
- */
-void inter_module_put(const char *im_name)
-{
-	struct list_head *tmp;
-	struct inter_module_entry *ime;
-
-	spin_lock(&ime_lock);
-	list_for_each(tmp, &ime_list) {
-		ime = list_entry(tmp, struct inter_module_entry, list);
-		if (strcmp(ime->im_name, im_name) == 0) {
-			if (ime->owner)
-				module_put(ime->owner);
-			spin_unlock(&ime_lock);
-			return;
-		}
-	}
-	spin_unlock(&ime_lock);
-	printk(KERN_ERR "inter_module_put: no entry for '%s'", im_name);
-	BUG();
-}
-
-EXPORT_SYMBOL(inter_module_register);
-EXPORT_SYMBOL(inter_module_unregister);
-EXPORT_SYMBOL(inter_module_get_request);
-EXPORT_SYMBOL(inter_module_put);
-
-MODULE_LICENSE("GPL");
-
diff -Naur archive/linux-2.6.17/kernel/sys.c linux-2.6.17/kernel/sys.c
--- archive/linux-2.6.17/kernel/sys.c	2006-06-18 03:49:35.000000000 +0200
+++ linux-2.6.17/kernel/sys.c	2007-08-30 09:04:53.000000000 +0200
@@ -587,7 +587,7 @@
 {
 	blocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);
 	system_state = SYSTEM_RESTART;
-	device_shutdown();
+//	device_shutdown();
 }
 
 /**
@@ -677,7 +677,6 @@
 asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user * arg)
 {
 	char buffer[256];
-
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
diff -Naur archive/linux-2.6.17/lib/LzmaDecode.c linux-2.6.17/lib/LzmaDecode.c
--- archive/linux-2.6.17/lib/LzmaDecode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/lib/LzmaDecode.c	2007-08-30 09:04:53.000000000 +0200
@@ -0,0 +1,588 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.22 Copyright (c) 1999-2005 Igor Pavlov (2005-06-10)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff -Naur archive/linux-2.6.17/lib/LzmaDecode.h linux-2.6.17/lib/LzmaDecode.h
--- archive/linux-2.6.17/lib/LzmaDecode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17/lib/LzmaDecode.h	2007-08-30 09:04:53.000000000 +0200
@@ -0,0 +1,131 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting*/
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifndef SizeT
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+#define SizeT size_t
+#else
+#define SizeT UInt32
+#endif
+#endif
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb unsigned short
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
