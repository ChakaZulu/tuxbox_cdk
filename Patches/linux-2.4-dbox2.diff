--- linux-2.4.37/Makefile.orig	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37/Makefile	2009-01-13 22:32:58.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 37
-EXTRAVERSION = .7
+EXTRAVERSION = .7-dbox2
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -Naur linux-2.4.31/arch/ppc/8xx_io/enet.c linux-2.4.31-dbox2/arch/ppc/8xx_io/enet.c
--- linux-2.4.31/arch/ppc/8xx_io/enet.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.31-dbox2/arch/ppc/8xx_io/enet.c	2005-06-03 11:02:05.000000000 +0200
@@ -14,13 +14,6 @@
  * Buffer descriptors are kept in the CPM dual port RAM, and the frame
  * buffers are in the host memory.
  *
- * Right now, I am very watseful with the buffers.  I allocate memory
- * pages and then divide them into 2K frame buffers.  This way I know I
- * have buffers large enough to hold one frame within one buffer descriptor.
- * Once I get this working, I will use 64 or 128 byte CPM buffers, which
- * will be much more memory efficient and will easily handle lots of
- * small packets.
- *
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -56,11 +49,7 @@
  *
  * The buffer descriptors are allocated from the CPM dual port memory
  * with the data buffers allocated from host memory, just like all other
- * serial communication protocols.  The host memory buffers are allocated
- * from the free page pool, and then divided into smaller receive and
- * transmit buffers.  The size of the buffers should be a power of two,
- * since that nicely divides the page.  This creates a ring buffer
- * structure similar to the LANCE and other controllers.
+ * serial communication protocols.
  *
  * Like the LANCE driver:
  * The driver runs as two independent, single-threaded flows of control.  One
@@ -92,20 +81,14 @@
  * pool.  The code may assume these are power of two, so it is best
  * to keep them that size.
  * We don't need to allocate pages for the transmitter.  We just use
- * the skbuffer directly.
+ * the skbuffer directly. Receiving data works by swapping skbuffers.
  */
 #ifdef CONFIG_ENET_BIG_BUFFERS
-#define CPM_ENET_RX_PAGES	32
-#define CPM_ENET_RX_FRSIZE	2048
-#define CPM_ENET_RX_FRPPG	(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
+#define RX_RING_SIZE		64
 #define TX_RING_SIZE		64	/* Must be power of two */
 #define TX_RING_MOD_MASK	63	/*   for this to work */
 #else
-#define CPM_ENET_RX_PAGES	4
-#define CPM_ENET_RX_FRSIZE	2048
-#define CPM_ENET_RX_FRPPG	(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
+#define RX_RING_SIZE		8
 #define TX_RING_SIZE		8	/* Must be power of two */
 #define TX_RING_MOD_MASK	7	/*   for this to work */
 #endif
@@ -129,6 +112,8 @@
 	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
 	ushort	skb_cur;
 	ushort	skb_dirty;
+	struct	sk_buff* rx_skbuff[RX_RING_SIZE];
+	ushort	skb_cur_rx;
 
 	/* CPM dual port RAM relative addresses.
 	*/
@@ -141,7 +126,6 @@
 	/* Virtual addresses for the receive buffers because we can't
 	 * do a __va() on them anymore.
 	 */
-	unsigned char *rx_vaddr[RX_RING_SIZE];
 	struct	net_device_stats stats;
 	uint	tx_free;
 	spinlock_t lock;
@@ -207,7 +191,7 @@
 		/* Ooops.  All transmit buffers are full.  Bail out.
 		 * This should not happen, since the tx queue should be stopped.
 		 */
-		printk("%s: tx queue full!.\n", dev->name);
+		printk(KERN_ERR "%s: tx queue full!.\n", dev->name);
 		return 1;
 	}
 #endif
@@ -267,29 +251,133 @@
 	return 0;
 }
 
+/*
+ * Transmits up to 3 memory locations. This 3 locations must be cache-flushed
+ * before this function is invoked. The memory won't be freed after
+ * transmission. The function takes physical addresses!
+ */
+
+int scc_enet_multiple_xmit(struct net_device *dev,unsigned count, unsigned first,
+	unsigned first_len, unsigned second, unsigned second_len, unsigned third,
+	unsigned third_len)
+{
+	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
+	volatile cbd_t	*bdp,*first_bdp;
+	unsigned pad = 0;
+
+	/* nothing to send ? */
+	if (!count)
+		return 0;
+
+	spin_lock_irq(&cep->lock);
+
+	/* not enough free descriptors? */
+	if (cep->tx_free < count)
+	{
+		spin_unlock_irq(&cep->lock);
+		return 1;
+	}
+
+	bdp = cep->cur_tx;
+	first_bdp = bdp;
+
+	if (first_len + second_len + third_len < ETH_ZLEN)
+	{
+		pad = BD_ENET_TX_PAD;
+	}
+
+	/* setup first descriptor */
+
+	cep->tx_skbuff[cep->skb_cur] = NULL;
+	bdp->cbd_datlen = first_len;
+	bdp->cbd_bufaddr = first;
+	cep->tx_free--;
+	cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+
+	/* setup second descriptor */
+	if (count > 1)
+	{
+		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+		{
+			bdp = cep->tx_bd_base;
+		}
+		else
+		{
+			bdp++;
+		}
+		cep->tx_skbuff[cep->skb_cur] = NULL;
+		bdp->cbd_datlen = second_len;
+		bdp->cbd_bufaddr = second;
+		cep->tx_free--;
+		cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+
+		if (count > 2)
+		{
+			bdp->cbd_sc = (bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY;
+			if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+			{
+				bdp = cep->tx_bd_base;
+			}
+			else
+			{
+				bdp++;
+			}
+			cep->tx_skbuff[cep->skb_cur] = NULL;
+			bdp->cbd_datlen = third_len;
+			bdp->cbd_bufaddr = third;
+			cep->tx_free--;
+			cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+		}
+	}
+	bdp->cbd_sc = (bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY |
+	BD_ENET_TX_INTR | BD_ENET_TX_LAST | BD_ENET_TX_TC | pad;
+	if (count > 1)
+	{
+		first_bdp->cbd_sc = (first_bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY;
+	}
+
+	if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+	{
+		bdp = cep->tx_bd_base;
+	}
+	else
+	{
+		bdp++;
+	}
+
+	if (!cep->tx_free)
+		netif_stop_queue(dev);
+
+	cep->cur_tx = (cbd_t *) bdp;
+
+	spin_unlock_irq(&cep->lock);
+
+	return 0;
+}
+
 static void
 scc_enet_timeout(struct net_device *dev)
 {
 	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
 
-	printk("%s: transmit timed out.\n", dev->name);
+	printk(KERN_ERR "%s: transmit timed out.\n", dev->name);
 	cep->stats.tx_errors++;
 #ifndef final_version
 	{
 		int	i;
 		cbd_t	*bdp;
-		printk(" Ring data dump: cur_tx %p tx_free %d cur_rx %p.\n",
+		printk(KERN_DEBUG " Ring data dump: cur_tx %p tx_free %d cur_rx %p.\n",
 		       cep->cur_tx, cep->tx_free,
 		       cep->cur_rx);
 		bdp = cep->tx_bd_base;
 		for (i = 0 ; i < TX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
+			printk(KERN_DEBUG "%04x %04x %08x\n",
 			       bdp->cbd_sc,
 			       bdp->cbd_datlen,
 			       bdp->cbd_bufaddr);
 		bdp = cep->rx_bd_base;
 		for (i = 0 ; i < RX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
+			printk(KERN_DEBUG "%04x %04x %08x\n",
 			       bdp->cbd_sc,
 			       bdp->cbd_datlen,
 			       bdp->cbd_bufaddr);
@@ -373,7 +461,8 @@
 
 		/* Free the sk buffer associated with this last transmit.
 		*/
-		dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+		if (cep->tx_skbuff[cep->skb_dirty])
+			dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
 		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
 
 		/* Update pointer to next buffer descriptor to be transmitted.
@@ -439,8 +528,9 @@
 {
 	struct	scc_enet_private *cep;
 	volatile cbd_t	*bdp;
-	struct	sk_buff *skb;
+	struct	sk_buff *skb,*rx_skb;
 	ushort	pkt_len;
+	ushort	skb_cur_rx;
 
 	cep = (struct scc_enet_private *)dev->priv;
 
@@ -448,6 +538,7 @@
 	 * These get messed up if we get called due to a busy condition.
 	 */
 	bdp = cep->cur_rx;
+	skb_cur_rx = cep->skb_cur_rx;
 
 for (;;) {
 	if (bdp->cbd_sc & BD_ENET_RX_EMPTY)
@@ -459,7 +550,7 @@
 	 */
 	if ((bdp->cbd_sc & (BD_ENET_RX_FIRST | BD_ENET_RX_LAST)) !=
 		(BD_ENET_RX_FIRST | BD_ENET_RX_LAST))
-			printk("CPM ENET: rcv is not first+last\n");
+			printk(KERN_CRIT "CPM ENET: rcv is not first+last\n");
 #endif
 
 	/* Frame too long or too short.
@@ -486,47 +577,53 @@
 		*/
 		cep->stats.rx_packets++;
 		pkt_len = bdp->cbd_datlen;
-		cep->stats.rx_bytes += pkt_len;
+		cep->stats.rx_bytes += pkt_len - 4;
 
-		/* This does 16 byte alignment, much more than we need.
-		 * The packet length includes FCS, but we don't want to
-		 * include that when passing upstream as it messes up
-		 * bridging applications.
-		 */
-		skb = dev_alloc_skb(pkt_len-4);
+		/* Allocate a new skb
+		*/
 
-		if (skb == NULL) {
-			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
-			cep->stats.rx_dropped++;
-		}
+		if ( (skb = dev_alloc_skb(PKT_MAXBLR_SIZE)) == NULL)
+		{
+			printk(KERN_ERR "%s: Memory squeeze, dropping packet.\n",dev->name);
+ 			cep->stats.rx_dropped++;
+ 		}
 		else {
-			skb->dev = dev;
-			skb_put(skb,pkt_len-4);	/* Make room */
-			eth_copy_and_sum(skb,
-				cep->rx_vaddr[bdp - cep->rx_bd_base],
-				pkt_len-4, 0);
-			skb->protocol=eth_type_trans(skb,dev);
-			netif_rx(skb);
+			/* swap new and filled skb
+			*/
+ 			skb->dev = dev;
+			/* invalidate data cache to prevent memory-modification in
+			 * write-back-mode and to get the real data on the next read
+			 */
+			invalidate_dcache_range((unsigned long) skb->data,(unsigned long) skb->data + PKT_MAXBLR_SIZE - 1);
+			rx_skb = cep->rx_skbuff[skb_cur_rx];
+			cep->rx_skbuff[skb_cur_rx] = skb;
+			bdp->cbd_bufaddr = __pa(skb->data);
+
+			/* Don't include FCS as it messes up bridging applications */
+			skb_put(rx_skb,pkt_len-4);
+			rx_skb->protocol=eth_type_trans(rx_skb,dev);
+			netif_rx(rx_skb);
 		}
 	}
 
-	/* Clear the status flags for this buffer.
-	*/
-	bdp->cbd_sc &= ~BD_ENET_RX_STATS;
-
-	/* Mark the buffer empty.
+	/* Clear the status flags for this buffer and mark the buffer empty.
 	*/
-	bdp->cbd_sc |= BD_ENET_RX_EMPTY;
+	bdp->cbd_sc = (bdp->cbd_sc & ~BD_ENET_RX_STATS) | BD_ENET_RX_EMPTY;
 
 	/* Update BD pointer to next entry.
 	*/
-	if (bdp->cbd_sc & BD_ENET_RX_WRAP)
+	if (bdp->cbd_sc & BD_ENET_RX_WRAP) {
 		bdp = cep->rx_bd_base;
-	else
+		skb_cur_rx = 0;
+	}
+	else {
 		bdp++;
+		skb_cur_rx++;
+	}
 
    }
 	cep->cur_rx = (cbd_t *)bdp;
+	cep->skb_cur_rx = skb_cur_rx;
 
 	return 0;
 }
@@ -574,7 +671,7 @@
 	if (dev->flags&IFF_PROMISC) {
 
 		/* Log any net taps. */
-		printk("%s: Promiscuous mode enabled.\n", dev->name);
+		printk(KERN_INFO "%s: Promiscuous mode enabled.\n", dev->name);
 		cep->sccp->scc_pmsr |= SCC_PMSR_PRO;
 	} else {
 
@@ -637,9 +734,8 @@
 {
 	struct net_device *dev;
 	struct scc_enet_private *cep;
-	int i, j, k;
-	unsigned char	*eap, *ba;
-	dma_addr_t	mem_addr;
+	int i;
+	unsigned char	*eap;
 	bd_t		*bd;
 	volatile	cbd_t		*bdp;
 	volatile	cpm8xx_t	*cp;
@@ -749,6 +845,7 @@
 	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
 	cep->tx_free = TX_RING_SIZE;
 	cep->cur_rx = cep->rx_bd_base;
+	cep->skb_cur_rx = 0;
 
 	/* Issue init Rx BD command for SCC.
 	 * Manual says to perform an Init Rx parameters here.  We have
@@ -829,24 +926,21 @@
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
-	bdp = cep->rx_bd_base;
-	k = 0;
-	for (i=0; i<CPM_ENET_RX_PAGES; i++) {
+	/* allocate skbs for receive-buffers */
 
-		/* Allocate a page.
-		*/
-		ba = (unsigned char *)consistent_alloc(GFP_KERNEL, PAGE_SIZE, &mem_addr);
+	bdp = cep->rx_bd_base;
 
-		/* Initialize the BD for every fragment in the page.
-		*/
-		for (j=0; j<CPM_ENET_RX_FRPPG; j++) {
-			bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
-			bdp->cbd_bufaddr = mem_addr;
-			cep->rx_vaddr[k++] = ba;
-			mem_addr += CPM_ENET_RX_FRSIZE;
-			ba += CPM_ENET_RX_FRSIZE;
-			bdp++;
-		}
+	for (i=0; i<RX_RING_SIZE; i++) {
+		cep->rx_skbuff[i] = dev_alloc_skb(PKT_MAXBLR_SIZE);
+		cep->rx_skbuff[i]->dev = dev;
+		/* invalidate data cache to prevent memory-modification in
+		 * write-back-mode and to get the real data on the next read.
+		 */
+		invalidate_dcache_range((unsigned long) cep->rx_skbuff[i]->data,
+			(unsigned long) cep->rx_skbuff[i]->data + PKT_MAXBLR_SIZE - 1);
+		bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
+		bdp->cbd_bufaddr = __pa(cep->rx_skbuff[i]->data);
+		bdp++;
 	}
 
 	/* Set the last buffer to wrap.
@@ -954,7 +1048,7 @@
 	*/
 	sccp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
 
-	printk("%s: CPM ENET Version 0.2 on SCC%d, ", dev->name, SCC_ENET+1);
+	printk(KERN_INFO "%s: CPM ENET Version 0.2.dbox2 on SCC%d, ", dev->name, SCC_ENET+1);
 	for (i=0; i<5; i++)
 		printk("%02x:", dev->dev_addr[i]);
 	printk("%02x\n", dev->dev_addr[5]);
diff -Naur linux-2.4.31/arch/ppc/kernel/m8xx_setup.c linux-2.4.31-dbox2/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.31/arch/ppc/kernel/m8xx_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.31-dbox2/arch/ppc/kernel/m8xx_setup.c	2005-06-03 11:02:05.000000000 +0200
@@ -134,6 +134,17 @@
 	/* Force all 8xx processors to use divide by 16 processor clock. */
 	((volatile immap_t *)IMAP_ADDR)->im_clkrst.car_sccr |= 0x02000000;
 
+#ifdef CONFIG_DBOX2
+	if ((binfo->bi_intfreq < 1000000) || (binfo->bi_busfreq < 1000000)) {
+	    printk(KERN_INFO "WARNING: Frequency is not in HZ. Please consider using a newer bootloader!\n");
+	    printk(KERN_INFO "WARNING: OLD intfreq = %ld busfreq = %ld\n", binfo->bi_intfreq, binfo->bi_busfreq);
+
+	    binfo->bi_intfreq *= 1000000;
+	    binfo->bi_busfreq *= 1000000;
+
+	    printk(KERN_INFO "WARNING: NEW intfreq = %ld busfreq = %ld\n", binfo->bi_intfreq, binfo->bi_busfreq);
+	}
+#endif
 	/* Processor frequency is MHz.
 	 * The value 'fp' is the number of decrementer ticks per second.
 	 */
diff -Naur linux-2.4.31/arch/ppc/kernel/ppc_ksyms.c linux-2.4.31-dbox2/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.4.31/arch/ppc/kernel/ppc_ksyms.c	2004-04-14 15:05:27.000000000 +0200
+++ linux-2.4.31-dbox2/arch/ppc/kernel/ppc_ksyms.c	2005-06-03 11:02:05.000000000 +0200
@@ -359,6 +359,9 @@
 EXPORT_SYMBOL(cpm_free_handler);
 EXPORT_SYMBOL(m8xx_cpm_hostalloc);
 EXPORT_SYMBOL(m8xx_cpm_dpalloc);
+extern int scc_enet_multiple_xmit(struct net_device, unsigned, unsigned,
+	unsigned, unsigned, unsigned, unsigned, unsigned);
+EXPORT_SYMBOL(scc_enet_multiple_xmit);
 #ifdef CONFIG_8xx_WDT
 extern int m8xx_wdt_get_timeout(void);
 extern void m8xx_wdt_reset(void);
diff -Naur linux-2.4.31/arch/ppc/kernel/time.c linux-2.4.31-dbox2/arch/ppc/kernel/time.c
--- linux-2.4.31/arch/ppc/kernel/time.c	2005-06-01 02:56:56.000000000 +0200
+++ linux-2.4.31-dbox2/arch/ppc/kernel/time.c	2005-06-03 11:02:05.000000000 +0200
@@ -70,6 +70,9 @@
 unsigned long disarm_decr[NR_CPUS];
 
 extern int do_sys_settimeofday(struct timeval *tv, struct timezone *tz);
+#ifdef CONFIG_DBOX2
+extern void m8xx_wdt_reset(void);
+#endif
 
 /* keep track of when we need to update the rtc */
 time_t last_rtc_update;
@@ -320,6 +323,10 @@
 		sec = ppc_md.get_rtc_time();
 		elapsed = 0;
 		do {
+#ifdef CONFIG_DBOX2
+			/* needed to fix wdt problems during boot on some boxes */
+			m8xx_wdt_reset();
+#endif
 			old_stamp = stamp;
 			old_sec = sec;
 			stamp = get_native_tbl();
diff -Naur linux-2.4.31/drivers/char/console.c linux-2.4.31-dbox2/drivers/char/console.c
--- linux-2.4.31/drivers/char/console.c	2005-01-19 15:09:44.000000000 +0100
+++ linux-2.4.31-dbox2/drivers/char/console.c	2005-06-03 11:02:05.000000000 +0200
@@ -110,7 +110,11 @@
 #include "console_macros.h"
 
 
-const struct consw *conswitchp;
+#ifdef CONFIG_DUMMY_CONSOLE
+const struct consw *conswitchp = &dummy_con;
+#else
+const struct consw *conswitchp = 0;
+#endif
 
 static void __console_callback(void);
 
diff -Naur linux-2.4.31/drivers/char/vt.c linux-2.4.31-dbox2/drivers/char/vt.c
--- linux-2.4.31/drivers/char/vt.c	2005-01-19 15:09:53.000000000 +0100
+++ linux-2.4.31-dbox2/drivers/char/vt.c	2005-06-03 11:02:05.000000000 +0200
@@ -93,7 +93,8 @@
 #if defined(__i386__) || defined(__alpha__) || defined(CONFIG_PPC_ISATIMER) \
     || (defined(__mips__) && defined(CONFIG_ISA)) \
     || (defined(__arm__) && defined(CONFIG_HOST_FOOTBRIDGE)) \
-    || defined(__x86_64__)
+    || defined(__x86_64__) \
+    || (defined(__powerpc__) && !defined(CONFIG_DBOX2))
 
 static void
 kd_nosound(unsigned long ignored)
diff -Naur linux-2.4.31/drivers/input/keybdev.c linux-2.4.31-dbox2/drivers/input/keybdev.c
--- linux-2.4.31/drivers/input/keybdev.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.31-dbox2/drivers/input/keybdev.c	2005-06-03 11:02:05.000000000 +0200
@@ -108,7 +108,11 @@
 #endif	/* CONFIG_MAC_ADBKEYCODES || CONFIG_ADB_KEYBOARD */
 
 	if (keycode > 255 || !x86_keycodes[keycode])
+#ifdef CONFIG_DBOX2
+		return 0; 
+#else
 		return -1; 
+#endif
 
 	if (keycode == KEY_PAUSE) {
 		handle_scancode(0xe1, 1);
diff -Naur linux-2.4.31/drivers/video/fbcmap.c linux-2.4.31-dbox2/drivers/video/fbcmap.c
--- linux-2.4.31/drivers/video/fbcmap.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.31-dbox2/drivers/video/fbcmap.c	2005-06-03 11:02:05.000000000 +0200
@@ -271,7 +271,7 @@
 	    hred = *red;
 	    hgreen = *green;
 	    hblue = *blue;
-	    htransp = transp ? *transp : 0xffff;
+	    htransp = transp ? *transp : 0;
 	} else {
 	    get_user(hred, red);
 	    get_user(hgreen, green);
@@ -279,7 +279,7 @@
 	    if (transp)
 		get_user(htransp, transp);
 	    else
-		htransp = 0xffff;
+		htransp = 0;
 	}
 	red++;
 	green++;
diff -Naur linux-2.4.31/include/linux/input.h linux-2.4.31-dbox2/include/linux/input.h
--- linux-2.4.31/include/linux/input.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.31-dbox2/include/linux/input.h	2005-06-03 11:02:05.000000000 +0200
@@ -304,12 +304,84 @@
 #define KEY_PROG4		203
 #define KEY_SUSPEND		205
 #define KEY_CLOSE		206
+#define KEY_CAMERA		212
 
 #define KEY_UNKNOWN		220
 
 #define KEY_BRIGHTNESSDOWN	224
 #define KEY_BRIGHTNESSUP	225
 
+#define KEY_OK           0x160
+#define KEY_SELECT       0x161
+#define KEY_GOTO         0x162
+#define KEY_CLEAR        0x163
+#define KEY_POWER2       0x164
+#define KEY_OPTION       0x165
+#define KEY_INFO         0x166
+#define KEY_TIME         0x167
+#define KEY_VENDOR       0x168
+#define KEY_ARCHIVE      0x169
+#define KEY_PROGRAM      0x16a
+#define KEY_CHANNEL      0x16b
+#define KEY_FAVORITES    0x16c
+#define KEY_EPG          0x16d
+#define KEY_PVR          0x16e
+#define KEY_MHP          0x16f
+#define KEY_LANGUAGE     0x170
+#define KEY_TITLE        0x171
+#define KEY_SUBTITLE     0x172
+#define KEY_ANGLE        0x173
+#define KEY_ZOOM         0x174
+#define KEY_MODE         0x175
+#define KEY_KEYBOARD     0x176
+#define KEY_SCREEN       0x177
+#define KEY_PC           0x178
+#define KEY_TV           0x179
+#define KEY_TV2          0x17a
+#define KEY_VCR          0x17b
+#define KEY_VCR2         0x17c
+#define KEY_SAT          0x17d
+#define KEY_SAT2         0x17e
+#define KEY_CD           0x17f
+#define KEY_TAPE         0x180
+#define KEY_RADIO        0x181
+#define KEY_TUNER        0x182
+#define KEY_PLAYER       0x183
+#define KEY_TEXT         0x184
+#define KEY_DVD          0x185
+#define KEY_AUX          0x186
+#define KEY_MP3          0x187
+#define KEY_AUDIO        0x188
+#define KEY_VIDEO        0x189
+#define KEY_DIRECTORY    0x18a
+#define KEY_LIST         0x18b
+#define KEY_MEMO         0x18c
+#define KEY_CALENDAR     0x18d
+#define KEY_RED          0x18e
+#define KEY_GREEN        0x18f
+#define KEY_YELLOW       0x190
+#define KEY_BLUE         0x191
+#define KEY_CHANNELUP    0x192
+#define KEY_CHANNELDOWN  0x193
+#define KEY_FIRST        0x194
+#define KEY_LAST         0x195
+#define KEY_AB           0x196
+#define KEY_PLAY         0x197
+#define KEY_RESTART      0x198
+#define KEY_SLOW         0x199
+#define KEY_SHUFFLE      0x19a
+#define KEY_FASTFORWARD  0x19b
+#define KEY_PREVIOUS     0x19c
+#define KEY_NEXT         0x19d
+#define KEY_DIGITS       0x19e
+#define KEY_TEEN         0x19f
+#define KEY_TWEN         0x1a0
+#define KEY_BREAK        0x1a1
+#define KEY_TOPLEFT      0x1a2
+#define KEY_TOPRIGHT     0x1a3
+#define KEY_BOTTOMLEFT   0x1a4
+#define KEY_BOTTOMRIGHT  0x1a5
+
 #define BTN_MISC		0x100
 #define BTN_0			0x100
 #define BTN_1			0x101
--- linux-2.4.31/drivers/mtd/chips/cfi_cmdset_0001.c.orig	2007-09-24 00:02:58.000000000 +0200
+++ linux-2.4.31/drivers/mtd/chips/cfi_cmdset_0001.c	2007-10-05 06:18:20.000000000 +0200
@@ -152,7 +152,7 @@
 		}
 		
 		if (extp->MajorVersion != '1' || 
-		    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
+		    (extp->MinorVersion < '0' || extp->MinorVersion > '3')) {
 			printk(KERN_WARNING "  Unknown IntelExt Extended Query "
 			       "version %c.%c.\n",  extp->MajorVersion,
 			       extp->MinorVersion);
diff -Naur linux-2.4.33/drivers/video/Config.in linux-2.4.33-shift/drivers/video/Config.in
--- linux-2.4.33/drivers/video/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.33-shift/drivers/video/Config.in	2006-08-11 21:33:35.000000000 +0200
@@ -258,6 +258,7 @@
       tristate '    VGA 16-color planar support' CONFIG_FBCON_VGA_PLANES
       tristate '    VGA characters/attributes support' CONFIG_FBCON_VGA
       tristate '    HGA monochrome support (EXPERIMENTAL)' CONFIG_FBCON_HGA
+      bool '    console shift' CONFIG_FBCON_SHIFT 0
    else
       # Guess what we need
       if [ "$CONFIG_FB_ACORN" = "y" -o "$CONFIG_FB_AMIGA" = "y" -o \
diff -Naur linux-2.4.33/drivers/video/fbcon.c linux-2.4.33-shift/drivers/video/fbcon.c
--- linux-2.4.33/drivers/video/fbcon.c	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.33-shift/drivers/video/fbcon.c	2006-08-11 21:33:35.000000000 +0200
@@ -655,8 +655,13 @@
     old_cols = conp->vc_cols;
     old_rows = conp->vc_rows;
     
+#ifdef CONFIG_FBCON_SHIFT
+    nr_cols = p->var.xres/fontwidth(p) - 2*p->shift_x;
+    nr_rows = p->var.yres/fontheight(p) - 2*p->shift_y;
+#else /* CONFIG_FBCON_SHIFT */
     nr_cols = p->var.xres/fontwidth(p);
     nr_rows = p->var.yres/fontheight(p);
+#endif /* CONFIG_FBCON_SHIFT */
     
     if (logo) {
     	/* Need to make room for the logo */
diff -Naur linux-2.4.33/drivers/video/fbcon-cfb16.c linux-2.4.33-shift/drivers/video/fbcon-cfb16.c
--- linux-2.4.33/drivers/video/fbcon-cfb16.c	2001-10-15 22:47:13.000000000 +0200
+++ linux-2.4.33-shift/drivers/video/fbcon-cfb16.c	2006-08-11 21:33:35.000000000 +0200
@@ -46,6 +46,12 @@
     int bytes = p->next_line, linesize = bytes * fontheight(p), rows;
     u8 *src, *dst;
 
+#ifdef CONFIG_FBCON_SHIFT
+    width += p->shift_x;
+    dy += p->shift_y;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     if (sx == 0 && dx == 0 && width * fontwidth(p) * 2 == bytes) {
 	fb_memmove(p->screen_base + dy * linesize,
 		  p->screen_base + sy * linesize,
@@ -108,6 +114,11 @@
     int bytes = p->next_line, lines = height * fontheight(p);
     u32 bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    sx += p->shift_x;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + sy * fontheight(p) * bytes + sx * fontwidth(p) * 2;
 
     bgx = ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
@@ -126,6 +137,11 @@
     int bytes = p->next_line, rows;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p) * 2;
 
     fgx = ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
@@ -177,6 +193,11 @@
     int rows, bytes = p->next_line;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest0 = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p) * 2;
     c = scr_readw(s);
     fgx = ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
@@ -233,6 +254,11 @@
     u8 *dest;
     int bytes = p->next_line, rows;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p)*2;
     for (rows = fontheight(p); rows--; dest += bytes) {
 	switch (fontwidth(p)) {
@@ -261,18 +287,31 @@
     int bytes = p->next_line;
     u32 bgx;
 
+#ifndef CONFIG_FBCON_SHIFT
     unsigned int right_start = conp->vc_cols*fontwidth(p);
     unsigned int bottom_start = conp->vc_rows*fontheight(p);
     unsigned int right_width, bottom_width;
+#endif /* CONFIG_FBCON_SHIFT */
 
     bgx = ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
 
+#ifndef CONFIG_FBCON_SHIFT
     if (!bottom_only && (right_width = p->var.xres-right_start))
 	rectfill(p->screen_base+right_start*2, right_width,
 		 p->var.yres_virtual, bgx, bytes);
     if ((bottom_width = p->var.yres-bottom_start))
 	rectfill(p->screen_base+(p->var.yoffset+bottom_start)*bytes,
 		 right_start, bottom_width, bgx, bytes);
+#else /* CONFIG_FBCON_SHIFT */
+    rectfill(p->screen_base, p->var.xres_virtual,
+	     p->shift_y*fontheight(p), bgx, bytes);
+    rectfill(p->screen_base, p->shift_x*fontwidth(p),
+	     p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_cols+p->shift_x)*fontwidth(p)*2, p->shift_x*fontwidth(p),
+	     p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_rows+p->shift_y)*fontheight(p)*bytes, p->var.xres_virtual,
+	     p->shift_y*fontheight(p), bgx, bytes);
+#endif /* CONFIG_FBCON_SHIFT */
 }
 
 
diff -Naur linux-2.4.33/drivers/video/fbcon-cfb8.c linux-2.4.33-shift/drivers/video/fbcon-cfb8.c
--- linux-2.4.33/drivers/video/fbcon-cfb8.c	2001-10-15 22:47:13.000000000 +0200
+++ linux-2.4.33-shift/drivers/video/fbcon-cfb8.c	2006-08-11 21:33:35.000000000 +0200
@@ -51,6 +51,12 @@
     int bytes = p->next_line, linesize = bytes * fontheight(p), rows;
     u8 *src,*dst;
 
+#ifdef CONFIG_FBCON_SHIFT
+    width += p->shift_x;
+    dy += p->shift_y;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     if (sx == 0 && dx == 0 && width * fontwidth(p) == bytes) {
 	fb_memmove(p->screen_base + dy * linesize,
 		  p->screen_base + sy * linesize,
@@ -97,6 +103,11 @@
     int bytes=p->next_line,lines=height * fontheight(p);
     u8 bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    sx += p->shift_x;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + sy * fontheight(p) * bytes + sx * fontwidth(p);
 
     bgx=attr_bgcol_ec(p,conp);
@@ -115,6 +126,11 @@
     int bytes=p->next_line,rows;
     u32 eorx,fgx,bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     if (fontwidth(p) <= 8)
 	cdat = p->fontdata + (c & p->charmask) * fontheight(p);
@@ -162,6 +178,11 @@
     int rows,bytes=p->next_line;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest0 = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     c = scr_readw(s);
     fgx = attr_fgcol(p, c);
@@ -219,6 +240,11 @@
     u8 *dest;
     int bytes=p->next_line, rows;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     for (rows = fontheight(p) ; rows-- ; dest += bytes) {
     	switch (fontwidth(p)) {
@@ -237,18 +263,31 @@
     int bytes=p->next_line;
     u8 bgx;
 
+#ifndef CONFIG_FBCON_SHIFT
     unsigned int right_start = conp->vc_cols*fontwidth(p);
     unsigned int bottom_start = conp->vc_rows*fontheight(p);
     unsigned int right_width, bottom_width;
+#endif /* CONFIG_FBCON_SHIFT */
 
     bgx=attr_bgcol_ec(p,conp);
 
+#ifndef CONFIG_FBCON_SHIFT
     if (!bottom_only && (right_width = p->var.xres-right_start))
 	rectfill(p->screen_base+right_start, right_width, p->var.yres_virtual,
 		 bgx, bytes);
     if ((bottom_width = p->var.yres-bottom_start))
 	rectfill(p->screen_base+(p->var.yoffset+bottom_start)*bytes,
 		 right_start, bottom_width, bgx, bytes);
+#else /* CONFIG_FBCON_SHIFT */
+    rectfill(p->screen_base, p->var.xres_virtual,
+             p->shift_y*fontheight(p), bgx, bytes);
+    rectfill(p->screen_base, p->shift_x*fontwidth(p),
+             p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_cols+p->shift_x)*fontwidth(p), p->shift_x*fontwidth(p),
+             p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_rows+p->shift_y)*fontheight(p)*bytes, p->var.xres_virtual,
+             p->shift_y*fontheight(p), bgx, bytes);
+#endif /* CONFIG_FBCON_SHIFT */
 }
 
 
diff -Naur linux-2.4.33/include/video/fbcon.h linux-2.4.33-shift/include/video/fbcon.h
--- linux-2.4.33/include/video/fbcon.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.33-shift/include/video/fbcon.h	2006-08-11 21:33:35.000000000 +0200
@@ -95,6 +95,11 @@
     short yscroll;                  /* Hardware scrolling */
     unsigned char fgshift, bgshift;
     unsigned short charmask;        /* 0xff or 0x1ff */
+
+#ifdef CONFIG_FBCON_SHIFT
+    int shift_x;
+    int shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
 };
 
 /* drivers/video/fbcon.c */
diff -Naur linux-2.4.33/arch/ppc/kernel/m8xx_setup.c linux-2.4.33-keyboard/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.33/arch/ppc/kernel/m8xx_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.33-keyboard/arch/ppc/kernel/m8xx_setup.c	2006-08-11 21:14:57.000000000 +0200
@@ -60,6 +60,14 @@
 extern void m8xx_cpm_reset(uint);
 extern void m8xx_wdt_handler_install(bd_t *bp);
 
+#if defined(CONFIG_DBOX2) && defined(CONFIG_VT)
+extern int pckbd_setkeycode(unsigned int scancode, unsigned int keycode);
+extern int pckbd_getkeycode(unsigned int scancode);
+extern int pckbd_translate(unsigned char scancode, unsigned char *keycode,
+                           char raw_mode);
+extern char pckbd_unexpected_up(unsigned char keycode);
+#endif
+
 void __init
 m8xx_setup_arch(void)
 {
@@ -402,10 +410,17 @@
 	ppc_md.find_end_of_memory	= m8xx_find_end_of_memory;
 	ppc_md.setup_io_mappings	= m8xx_map_io;
 
+#if defined(CONFIG_DBOX2) && defined(CONFIG_VT)
+	ppc_md.kbd_setkeycode		= pckbd_setkeycode;
+	ppc_md.kbd_getkeycode		= pckbd_getkeycode;
+	ppc_md.kbd_translate		= pckbd_translate;
+	ppc_md.kbd_unexpected_up	= pckbd_unexpected_up;
+#else
 	ppc_md.kbd_setkeycode		= NULL;
 	ppc_md.kbd_getkeycode		= NULL;
 	ppc_md.kbd_translate		= NULL;
 	ppc_md.kbd_unexpected_up	= NULL;
+#endif
 	ppc_md.kbd_leds			= NULL;
 	ppc_md.kbd_init_hw		= NULL;
 	ppc_md.ppc_kbd_sysrq_xlate	= NULL;
diff -Naur linux-2.4.33/include/linux/pc_keyb.h linux-2.4.33-keyboard/include/linux/pc_keyb.h
--- linux-2.4.33/include/linux/pc_keyb.h	1999-10-11 19:15:40.000000000 +0200
+++ linux-2.4.33-keyboard/include/linux/pc_keyb.h	2006-08-11 21:14:57.000000000 +0200
@@ -11,7 +11,7 @@
  */
 
 #undef KBD_REPORT_ERR			/* Report keyboard errors */
-#define KBD_REPORT_UNKN			/* Report unknown scan codes */
+#undef KBD_REPORT_UNKN			/* Report unknown scan codes */
 #define KBD_REPORT_TIMEOUTS		/* Report keyboard timeouts */
 #undef KBD_IS_FOCUS_9000		/* We have the brain-damaged FOCUS-9000 keyboard */
 #undef INITIALIZE_MOUSE			/* Define if your PS/2 mouse needs initialization. */
diff -Naur linux-2.4.33/drivers/media/video/Makefile linux-2.4.33-v4l2/drivers/media/video/Makefile
--- linux-2.4.33/drivers/media/video/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.33-v4l2/drivers/media/video/Makefile	2006-08-11 21:35:33.000000000 +0200
@@ -25,13 +25,14 @@
 # All of the (potential) objects that export symbols.
 # This list comes from 'grep -l EXPORT_SYMBOL *.[hc]'.
 
-export-objs     :=	i2c-old.o videodev.o bttv-if.o cpia.o
+export-objs     :=	i2c-old.o videodev.o bttv-if.o cpia.o	\
+			v4l2-common.o v4l1-compat.o
 
 list-multi	:=	bttv.o zoran.o
 bttv-objs	:=	bttv-driver.o bttv-cards.o bttv-if.o
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 
-obj-$(CONFIG_VIDEO_DEV) += videodev.o
+obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
 obj-$(CONFIG_BUS_I2C) += i2c-old.o
 obj-$(CONFIG_VIDEO_BT848) += bttv.o msp3400.o tvaudio.o \
diff -Naur linux-2.4.33/drivers/media/video/v4l1-compat.c linux-2.4.33-v4l2/drivers/media/video/v4l1-compat.c
--- linux-2.4.33/drivers/media/video/v4l1-compat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-v4l2/drivers/media/video/v4l1-compat.c	2006-08-11 21:35:33.000000000 +0200
@@ -0,0 +1,1027 @@
+/*
+ *	Video for Linux Two
+ *	Backward Compatibility Layer
+ *
+ *	Support subroutines for providing V4L2 drivers with backward
+ *	compatibility with applications using the old API.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Author:	Bill Dirks <bdirks@pacbell.net>
+ *		et al.
+ *
+ */
+
+#ifndef __KERNEL__
+#define __KERNEL__
+#endif
+
+#include <linux/config.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/videodev.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+static unsigned int debug  = 0;
+MODULE_PARM(debug,"i");
+MODULE_PARM_DESC(debug,"enable debug messages");
+MODULE_AUTHOR("Bill Dirks");
+MODULE_DESCRIPTION("v4l(1) compatibility layer for v4l2 drivers.");
+MODULE_LICENSE("GPL");
+
+#define dprintk(fmt, arg...)	if (debug) \
+	printk(KERN_DEBUG "v4l1-compat: " fmt , ## arg)
+
+/*
+ *	I O C T L   T R A N S L A T I O N
+ *
+ *	From here on down is the code for translating the numerous
+ *	ioctl commands from the old API to the new API.
+ */
+
+static int
+get_v4l_control(struct inode            *inode,
+		struct file             *file,
+		int			cid,
+		v4l2_kioctl             drv)
+{
+	struct v4l2_queryctrl	qctrl2;
+	struct v4l2_control	ctrl2;
+	int			err;
+
+	qctrl2.id = cid;
+	err = drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2);
+	if (err < 0)
+		dprintk("VIDIOC_QUERYCTRL: %d\n",err);
+	if (err == 0 &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED))
+	{
+		ctrl2.id = qctrl2.id;
+		err = drv(inode, file, VIDIOC_G_CTRL, &ctrl2);
+		if (err < 0) {
+			dprintk("VIDIOC_G_CTRL: %d\n",err);
+			return 0;
+		}
+		return ((ctrl2.value - qctrl2.minimum) * 65535
+			 + (qctrl2.maximum - qctrl2.minimum) / 2)
+			/ (qctrl2.maximum - qctrl2.minimum);
+	}
+	return 0;
+}
+
+static int
+set_v4l_control(struct inode            *inode,
+		struct file             *file,
+		int			cid,
+		int			value,
+		v4l2_kioctl             drv)
+{
+	struct v4l2_queryctrl	qctrl2;
+	struct v4l2_control	ctrl2;
+	int			err;
+
+	qctrl2.id = cid;
+	err = drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2);
+	if (err < 0)
+		dprintk("VIDIOC_QUERYCTRL: %d\n",err);
+	if (err == 0 &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED) &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_GRABBED))
+	{
+		if (value < 0)
+			value = 0;
+		if (value > 65535)
+			value = 65535;
+		if (value && qctrl2.type == V4L2_CTRL_TYPE_BOOLEAN)
+			value = 65535;
+		ctrl2.id = qctrl2.id;
+		ctrl2.value = 
+			(value * (qctrl2.maximum - qctrl2.minimum)
+			 + 32767)
+			/ 65535;
+		ctrl2.value += qctrl2.minimum;
+		err = drv(inode, file, VIDIOC_S_CTRL, &ctrl2);
+		if (err < 0)
+			dprintk("VIDIOC_S_CTRL: %d\n",err);
+	}
+	return 0;
+}
+
+/* ----------------------------------------------------------------- */
+
+static int palette2pixelformat[] = {
+	[VIDEO_PALETTE_GREY]    = V4L2_PIX_FMT_GREY,
+	[VIDEO_PALETTE_RGB555]  = V4L2_PIX_FMT_RGB555,
+	[VIDEO_PALETTE_RGB565]  = V4L2_PIX_FMT_RGB565,
+	[VIDEO_PALETTE_RGB24]   = V4L2_PIX_FMT_BGR24,
+	[VIDEO_PALETTE_RGB32]   = V4L2_PIX_FMT_BGR32,
+	/* yuv packed pixel */
+	[VIDEO_PALETTE_YUYV]    = V4L2_PIX_FMT_YUYV,
+	[VIDEO_PALETTE_YUV422]  = V4L2_PIX_FMT_YUYV,
+	[VIDEO_PALETTE_UYVY]    = V4L2_PIX_FMT_UYVY,
+	/* yuv planar */
+	[VIDEO_PALETTE_YUV410P] = V4L2_PIX_FMT_YUV410,
+	[VIDEO_PALETTE_YUV420]  = V4L2_PIX_FMT_YUV420,
+	[VIDEO_PALETTE_YUV420P] = V4L2_PIX_FMT_YUV420,
+	[VIDEO_PALETTE_YUV411P] = V4L2_PIX_FMT_YUV411P,
+	[VIDEO_PALETTE_YUV422P] = V4L2_PIX_FMT_YUV422P,
+};
+
+static unsigned int
+palette_to_pixelformat(unsigned int palette)
+{
+	if (palette < ARRAY_SIZE(palette2pixelformat))
+		return palette2pixelformat[palette];
+	else
+		return 0;
+}
+
+static unsigned int
+pixelformat_to_palette(int pixelformat)
+{
+	int	palette = 0;
+	switch (pixelformat)
+	{
+	case V4L2_PIX_FMT_GREY:
+		palette = VIDEO_PALETTE_GREY;
+		break;
+	case V4L2_PIX_FMT_RGB555:
+		palette = VIDEO_PALETTE_RGB555;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+		palette = VIDEO_PALETTE_RGB565;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		palette = VIDEO_PALETTE_RGB24;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		palette = VIDEO_PALETTE_RGB32;
+		break;
+	/* yuv packed pixel */
+	case V4L2_PIX_FMT_YUYV:
+		palette = VIDEO_PALETTE_YUYV;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		palette = VIDEO_PALETTE_UYVY;
+		break;
+	/* yuv planar */
+	case V4L2_PIX_FMT_YUV410:
+		palette = VIDEO_PALETTE_YUV420;
+		break;
+	case V4L2_PIX_FMT_YUV420:
+		palette = VIDEO_PALETTE_YUV420;
+		break;
+	case V4L2_PIX_FMT_YUV411P:
+		palette = VIDEO_PALETTE_YUV411P;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		palette = VIDEO_PALETTE_YUV422P;
+		break;
+	}
+	return palette;
+}
+
+/* ----------------------------------------------------------------- */
+
+static int poll_one(struct file *file)
+{
+	int retval = 1;
+	poll_table *table;
+	poll_table wait_table;
+
+	poll_initwait(&wait_table);
+	table = &wait_table;
+	for (;;) {
+		int mask;
+		set_current_state(TASK_INTERRUPTIBLE);
+		mask = file->f_op->poll(file, table);
+		if (mask & POLLIN)
+			break;
+		table = NULL;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	poll_freewait(&wait_table);
+	return retval;
+}
+
+static int count_inputs(struct inode         *inode,
+			struct file          *file,
+			v4l2_kioctl          drv)
+{
+	struct v4l2_input input2;
+	int i;
+
+	for (i = 0;; i++) {
+		memset(&input2,0,sizeof(input2));
+		input2.index = i;
+		if (0 != drv(inode,file,VIDIOC_ENUMINPUT, &input2))
+			break;
+	}
+	return i;
+}
+
+static int check_size(struct inode         *inode,
+		      struct file          *file,
+		      v4l2_kioctl          drv,
+		      int *maxw, int *maxh)
+{
+	struct v4l2_fmtdesc desc2;
+	struct v4l2_format  fmt2;
+
+	memset(&desc2,0,sizeof(desc2));
+	memset(&fmt2,0,sizeof(fmt2));
+	
+	desc2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (0 != drv(inode,file,VIDIOC_ENUM_FMT, &desc2))
+		goto done;
+
+	fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt2.fmt.pix.width       = 10000;
+	fmt2.fmt.pix.height      = 10000;
+	fmt2.fmt.pix.pixelformat = desc2.pixelformat;
+	if (0 != drv(inode,file,VIDIOC_TRY_FMT, &fmt2))
+		goto done;
+
+	*maxw = fmt2.fmt.pix.width;
+	*maxh = fmt2.fmt.pix.height;
+
+ done:
+	return 0;
+}
+
+/* ----------------------------------------------------------------- */
+
+/*
+ *	This function is exported.
+ */
+int
+v4l_compat_translate_ioctl(struct inode         *inode,
+			   struct file		*file,
+			   int			cmd,
+			   void			*arg,
+			   v4l2_kioctl          drv)
+{
+	struct v4l2_capability  *cap2 = NULL;
+	struct v4l2_format	*fmt2 = NULL;
+
+	struct v4l2_framebuffer fbuf2;
+	struct v4l2_input	input2;
+	struct v4l2_tuner	tun2;
+	struct v4l2_standard	std2;
+	struct v4l2_frequency   freq2;
+	struct v4l2_audio	aud2;
+	struct v4l2_queryctrl	qctrl2;
+	struct v4l2_buffer	buf2;
+	v4l2_std_id    		sid;
+	int i, err = 0;
+
+	switch (cmd) {
+	case VIDIOCGCAP:	/* capability */
+	{
+		struct video_capability *cap = arg;
+
+		cap2 = kmalloc(sizeof(*cap2),GFP_KERNEL);
+		memset(cap, 0, sizeof(*cap));
+		memset(cap2, 0, sizeof(*cap2));
+		memset(&fbuf2, 0, sizeof(fbuf2));
+
+		err = drv(inode, file, VIDIOC_QUERYCAP, cap2);
+		if (err < 0) {
+			dprintk("VIDIOCGCAP / VIDIOC_QUERYCAP: %d\n",err);
+			break;
+		}
+		if (cap2->capabilities & V4L2_CAP_VIDEO_OVERLAY) {
+			err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+			if (err < 0) {
+				dprintk("VIDIOCGCAP / VIDIOC_G_FBUF: %d\n",err);
+				memset(&fbuf2, 0, sizeof(fbuf2));
+			}
+			err = 0;
+		}
+
+		memcpy(cap->name, cap2->card, 
+		       min(sizeof(cap->name), sizeof(cap2->card)));
+		cap->name[sizeof(cap->name) - 1] = 0;
+		if (cap2->capabilities & V4L2_CAP_VIDEO_CAPTURE)
+			cap->type |= VID_TYPE_CAPTURE;
+		if (cap2->capabilities & V4L2_CAP_TUNER)
+			cap->type |= VID_TYPE_TUNER;
+		if (cap2->capabilities & V4L2_CAP_VBI_CAPTURE)
+			cap->type |= VID_TYPE_TELETEXT;
+		if (cap2->capabilities & V4L2_CAP_VIDEO_OVERLAY)
+			cap->type |= VID_TYPE_OVERLAY;
+		if (fbuf2.capability & V4L2_FBUF_CAP_LIST_CLIPPING)
+			cap->type |= VID_TYPE_CLIPPING;
+
+		cap->channels  = count_inputs(inode,file,drv);
+		check_size(inode,file,drv,
+			   &cap->maxwidth,&cap->maxheight);
+		cap->audios    =  0; /* FIXME */
+		cap->minwidth  = 48; /* FIXME */
+		cap->minheight = 32; /* FIXME */
+		break;
+	}
+	case VIDIOCGFBUF: /*  get frame buffer  */
+	{
+		struct video_buffer	*buffer = arg;
+
+		err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+		if (err < 0) {
+			dprintk("VIDIOCGFBUF / VIDIOC_G_FBUF: %d\n",err);
+			break;
+		}
+		buffer->base   = fbuf2.base;
+		buffer->height = fbuf2.fmt.height;
+		buffer->width  = fbuf2.fmt.width;
+
+		switch (fbuf2.fmt.pixelformat) {
+		case V4L2_PIX_FMT_RGB332:
+			buffer->depth = 8;
+				break;
+		case V4L2_PIX_FMT_RGB555:
+			buffer->depth = 15;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+			buffer->depth = 16;
+			break;
+		case V4L2_PIX_FMT_BGR24:
+			buffer->depth = 24;
+			break;
+		case V4L2_PIX_FMT_BGR32:
+			buffer->depth = 32;
+			break;
+		default:
+			buffer->depth = 0;
+		}
+		if (0 != fbuf2.fmt.bytesperline)
+			buffer->bytesperline = fbuf2.fmt.bytesperline;
+		else {
+			buffer->bytesperline = 
+				(buffer->width * buffer->depth + 7) & 7;
+			buffer->bytesperline >>= 3;
+		}
+		break;
+	}
+	case VIDIOCSFBUF: /*  set frame buffer  */
+	{
+		struct video_buffer	*buffer = arg;
+
+		memset(&fbuf2, 0, sizeof(fbuf2));
+		fbuf2.base       = buffer->base;
+		fbuf2.fmt.height = buffer->height;
+		fbuf2.fmt.width  = buffer->width;
+		switch (buffer->depth) {
+		case 8:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB332;
+			break;
+		case 15:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB555;
+			break;
+		case 16:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB565;
+			break;
+		case 24:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_BGR24;
+			break;
+		case 32:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_BGR32;
+			break;
+		}
+		fbuf2.fmt.bytesperline = buffer->bytesperline;
+		err = drv(inode, file, VIDIOC_S_FBUF, &fbuf2);
+		if (err < 0)
+			dprintk("VIDIOCSFBUF / VIDIOC_S_FBUF: %d\n",err);
+		break;
+	}
+	case VIDIOCGWIN: /*  get window or capture dimensions  */
+	{
+		struct video_window	*win = arg;
+
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(win,0,sizeof(*win));
+		memset(fmt2,0,sizeof(*fmt2));
+
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0)
+			dprintk("VIDIOCGWIN / VIDIOC_G_WIN: %d\n",err);
+		if (err == 0) {
+			win->x         = fmt2->fmt.win.w.left;
+			win->y         = fmt2->fmt.win.w.top;
+			win->width     = fmt2->fmt.win.w.width;
+			win->height    = fmt2->fmt.win.w.height;
+			win->chromakey = fmt2->fmt.win.chromakey;
+			win->clips     = NULL;
+			win->clipcount = 0;
+			break;
+		}
+
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCGWIN / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+		win->x         = 0;
+		win->y         = 0;
+		win->width     = fmt2->fmt.pix.width;
+		win->height    = fmt2->fmt.pix.height;
+		win->chromakey = 0;
+		win->clips     = NULL;
+		win->clipcount = 0;
+		break;
+	}
+	case VIDIOCSWIN: /*  set window and/or capture dimensions  */
+	{
+		struct video_window	*win = arg;
+		int err1,err2;
+
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(fmt2,0,sizeof(*fmt2));
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err1 = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err1 < 0)
+			dprintk("VIDIOCSWIN / VIDIOC_G_FMT: %d\n",err);
+		if (err1 == 0) {
+			fmt2->fmt.pix.width  = win->width;
+			fmt2->fmt.pix.height = win->height;
+			fmt2->fmt.pix.field  = V4L2_FIELD_ANY;
+			fmt2->fmt.pix.bytesperline = 0;
+			err = drv(inode, file, VIDIOC_S_FMT, fmt2);
+			if (err < 0)
+				dprintk("VIDIOCSWIN / VIDIOC_S_FMT #1: %d\n",
+					err);
+			win->width  = fmt2->fmt.pix.width;
+			win->height = fmt2->fmt.pix.height;
+		}
+
+		memset(fmt2,0,sizeof(*fmt2));
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+		fmt2->fmt.win.w.left    = win->x;
+		fmt2->fmt.win.w.top     = win->y;
+		fmt2->fmt.win.w.width   = win->width;
+		fmt2->fmt.win.w.height  = win->height;
+		fmt2->fmt.win.chromakey = win->chromakey;
+		fmt2->fmt.win.clips     = (void *)win->clips;
+		fmt2->fmt.win.clipcount = win->clipcount;
+		err2 = drv(inode, file, VIDIOC_S_FMT, fmt2);
+		if (err2 < 0)
+			dprintk("VIDIOCSWIN / VIDIOC_S_FMT #2: %d\n",err);
+
+		if (err1 != 0 && err2 != 0)
+			err = err1;
+		break;
+	}
+	case VIDIOCCAPTURE: /*  turn on/off preview  */
+	{
+		int *on = arg;
+
+		if (0 == *on) {
+			/* dirty hack time.  But v4l1 has no STREAMOFF
+			 * equivalent in the API, and this one at
+			 * least comes close ... */
+			drv(inode, file, VIDIOC_STREAMOFF, NULL);
+		}
+		err = drv(inode, file, VIDIOC_OVERLAY, arg);
+		if (err < 0)
+			dprintk("VIDIOCCAPTURE / VIDIOC_PREVIEW: %d\n",err);
+		break;
+	}
+	case VIDIOCGCHAN: /*  get input information  */
+	{
+		struct video_channel	*chan = arg;
+
+		memset(&input2,0,sizeof(input2));
+		input2.index = chan->channel;
+		err = drv(inode, file, VIDIOC_ENUMINPUT, &input2);
+		if (err < 0) {
+			dprintk("VIDIOCGCHAN / VIDIOC_ENUMINPUT: "
+				"channel=%d err=%d\n",chan->channel,err);
+			break;
+		}
+		chan->channel = input2.index;
+		memcpy(chan->name, input2.name,
+		       min(sizeof(chan->name), sizeof(input2.name)));
+		chan->name[sizeof(chan->name) - 1] = 0;
+		chan->tuners = (input2.type == V4L2_INPUT_TYPE_TUNER) ? 1 : 0;
+		chan->flags = (chan->tuners) ? VIDEO_VC_TUNER : 0;
+		switch (input2.type) {
+		case V4L2_INPUT_TYPE_TUNER:
+			chan->type = VIDEO_TYPE_TV;
+			break;
+		default:
+		case V4L2_INPUT_TYPE_CAMERA:
+			chan->type = VIDEO_TYPE_CAMERA;
+			break;
+		}
+		chan->norm = 0;
+		err = drv(inode, file, VIDIOC_G_STD, &sid);
+		if (err < 0)
+			dprintk("VIDIOCGCHAN / VIDIOC_G_STD: %d\n",err);
+		if (err == 0) {
+			if (sid & V4L2_STD_PAL)
+				chan->norm = VIDEO_MODE_PAL;
+			if (sid & V4L2_STD_NTSC)
+				chan->norm = VIDEO_MODE_NTSC;
+			if (sid & V4L2_STD_SECAM)
+				chan->norm = VIDEO_MODE_SECAM;
+		}
+		break;
+	}
+	case VIDIOCSCHAN: /*  set input  */
+	{
+		struct video_channel *chan = arg;
+
+		sid = 0;
+		err = drv(inode, file, VIDIOC_S_INPUT, &chan->channel);
+		if (err < 0)
+			dprintk("VIDIOCSCHAN / VIDIOC_S_INPUT: %d\n",err);
+		switch (chan->norm) {
+		case VIDEO_MODE_PAL:
+			sid = V4L2_STD_PAL;
+			break;
+		case VIDEO_MODE_NTSC:
+			sid = V4L2_STD_NTSC;
+			break;
+		case VIDEO_MODE_SECAM:
+			sid = V4L2_STD_SECAM;
+			break;
+		}
+		if (0 != sid) {
+			err = drv(inode, file, VIDIOC_S_STD, &sid);
+			if (err < 0)
+				dprintk("VIDIOCSCHAN / VIDIOC_S_STD: %d\n",err);
+		}
+		break;
+	}
+	case VIDIOCGPICT: /*  get tone controls & partial capture format  */
+	{
+		struct video_picture	*pict = arg;
+
+		pict->brightness = get_v4l_control(inode, file,
+						   V4L2_CID_BRIGHTNESS,drv);
+		pict->hue = get_v4l_control(inode, file,
+					    V4L2_CID_HUE, drv);
+		pict->contrast = get_v4l_control(inode, file,
+						 V4L2_CID_CONTRAST, drv);
+		pict->colour = get_v4l_control(inode, file,
+					       V4L2_CID_SATURATION, drv);
+		pict->whiteness = get_v4l_control(inode, file,
+						  V4L2_CID_WHITENESS, drv);
+
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(fmt2,0,sizeof(*fmt2));
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCGPICT / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+#if 0 /* FIXME */
+		pict->depth   = fmt2->fmt.pix.depth;
+#endif
+		pict->palette = pixelformat_to_palette(
+			fmt2->fmt.pix.pixelformat);
+		break;
+	}
+	case VIDIOCSPICT: /*  set tone controls & partial capture format  */
+	{
+		struct video_picture	*pict = arg;
+
+		set_v4l_control(inode, file,
+				V4L2_CID_BRIGHTNESS, pict->brightness, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_HUE, pict->hue, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_CONTRAST, pict->contrast, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_SATURATION, pict->colour, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_WHITENESS, pict->whiteness, drv);
+
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(fmt2,0,sizeof(*fmt2));
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0)
+			dprintk("VIDIOCSPICT / VIDIOC_G_FMT: %d\n",err);
+		if (fmt2->fmt.pix.pixelformat != 
+		    palette_to_pixelformat(pict->palette)) {
+			fmt2->fmt.pix.pixelformat = palette_to_pixelformat(
+				pict->palette);
+			err = drv(inode, file, VIDIOC_S_FMT, fmt2);
+			if (err < 0)
+				dprintk("VIDIOCSPICT / VIDIOC_S_FMT: %d\n",err);
+		}
+
+		err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+		if (err < 0)
+			dprintk("VIDIOCSPICT / VIDIOC_G_FBUF: %d\n",err);
+		if (fbuf2.fmt.pixelformat !=
+		    palette_to_pixelformat(pict->palette)) {
+			fbuf2.fmt.pixelformat = palette_to_pixelformat(
+				pict->palette);
+			err = drv(inode, file, VIDIOC_S_FBUF, &fbuf2);
+			if (err < 0)
+				dprintk("VIDIOCSPICT / VIDIOC_S_FBUF: %d\n",err);
+			err = 0; /* likely fails for non-root */
+		}
+		break;
+	}
+	case VIDIOCGTUNER: /*  get tuner information  */
+	{
+		struct video_tuner	*tun = arg;
+
+		memset(&tun2,0,sizeof(tun2));
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0) {
+			dprintk("VIDIOCGTUNER / VIDIOC_G_TUNER: %d\n",err);
+			break;
+		}
+		memcpy(tun->name, tun2.name,
+		       min(sizeof(tun->name), sizeof(tun2.name)));
+		tun->name[sizeof(tun->name) - 1] = 0;
+		tun->rangelow = tun2.rangelow;
+		tun->rangehigh = tun2.rangehigh;
+		tun->flags = 0;
+		tun->mode = VIDEO_MODE_AUTO;
+
+		for (i = 0; i < 64; i++) {
+			memset(&std2,0,sizeof(std2));
+			std2.index = i;
+			if (0 != drv(inode, file, VIDIOC_ENUMSTD, &std2))
+				break;
+			if (std2.id & V4L2_STD_PAL)
+				tun->flags |= VIDEO_TUNER_PAL;
+			if (std2.id & V4L2_STD_NTSC)
+				tun->flags |= VIDEO_TUNER_NTSC;
+			if (std2.id & V4L2_STD_SECAM)
+				tun->flags |= VIDEO_TUNER_SECAM;
+		}
+
+		err = drv(inode, file, VIDIOC_G_STD, &sid);
+		if (err < 0)
+			dprintk("VIDIOCGTUNER / VIDIOC_G_STD: %d\n",err);
+		if (err == 0) {
+			if (sid & V4L2_STD_PAL)
+				tun->mode = VIDEO_MODE_PAL;
+			if (sid & V4L2_STD_NTSC)
+				tun->mode = VIDEO_MODE_NTSC;
+			if (sid & V4L2_STD_SECAM)
+				tun->mode = VIDEO_MODE_SECAM;
+		}
+
+		if (tun2.capability & V4L2_TUNER_CAP_LOW)
+			tun->flags |= VIDEO_TUNER_LOW;
+		if (tun2.rxsubchans & V4L2_TUNER_SUB_STEREO)
+			tun->flags |= VIDEO_TUNER_STEREO_ON;
+		tun->signal = tun2.signal;
+		break;
+	}
+	case VIDIOCSTUNER: /*  select a tuner input  */
+	{
+#if 0 /* FIXME */
+		err = drv(inode, file, VIDIOC_S_INPUT, &i);
+		if (err < 0)
+			dprintk("VIDIOCSTUNER / VIDIOC_S_INPUT: %d\n",err);
+#else
+		err = 0;
+#endif
+		break;
+	}
+	case VIDIOCGFREQ: /*  get frequency  */
+	{
+		int *freq = arg;
+
+		freq2.tuner = 0;
+		err = drv(inode, file, VIDIOC_G_FREQUENCY, &freq2);
+		if (err < 0)
+			dprintk("VIDIOCGFREQ / VIDIOC_G_FREQUENCY: %d\n",err);
+		if (0 == err)
+			*freq = freq2.frequency;
+		break;
+	}
+	case VIDIOCSFREQ: /*  set frequency  */
+	{
+		int *freq = arg;
+
+		freq2.tuner = 0;
+		drv(inode, file, VIDIOC_G_FREQUENCY, &freq2);
+		freq2.frequency = *freq;
+		err = drv(inode, file, VIDIOC_S_FREQUENCY, &freq2);
+		if (err < 0)
+			dprintk("VIDIOCSFREQ / VIDIOC_S_FREQUENCY: %d\n",err);
+		break;
+	}
+	case VIDIOCGAUDIO: /*  get audio properties/controls  */
+	{
+		struct video_audio	*aud = arg;
+
+		err = drv(inode, file, VIDIOC_G_AUDIO, &aud2);
+		if (err < 0) {
+			dprintk("VIDIOCGAUDIO / VIDIOC_G_AUDIO: %d\n",err);
+			break;
+		}
+		memcpy(aud->name, aud2.name,
+		       min(sizeof(aud->name), sizeof(aud2.name)));
+		aud->name[sizeof(aud->name) - 1] = 0;
+		aud->audio = aud2.index;
+		aud->flags = 0;
+		i = get_v4l_control(inode, file, V4L2_CID_AUDIO_VOLUME, drv);
+		if (i >= 0) {
+			aud->volume = i;
+			aud->flags |= VIDEO_AUDIO_VOLUME;
+		}
+		i = get_v4l_control(inode, file, V4L2_CID_AUDIO_BASS, drv);
+		if (i >= 0) {
+			aud->bass = i;
+			aud->flags |= VIDEO_AUDIO_BASS;
+		}
+		i = get_v4l_control(inode, file, V4L2_CID_AUDIO_TREBLE, drv);
+		if (i >= 0) {
+			aud->treble = i;
+			aud->flags |= VIDEO_AUDIO_TREBLE;
+		}
+		i = get_v4l_control(inode, file, V4L2_CID_AUDIO_BALANCE, drv);
+		if (i >= 0) {
+			aud->balance = i;
+			aud->flags |= VIDEO_AUDIO_BALANCE;
+		}
+		i = get_v4l_control(inode, file, V4L2_CID_AUDIO_MUTE, drv);
+		if (i >= 0) {
+			if (i)
+				aud->flags |= VIDEO_AUDIO_MUTE;
+			aud->flags |= VIDEO_AUDIO_MUTABLE;
+		}
+		aud->step = 1;
+		qctrl2.id = V4L2_CID_AUDIO_VOLUME;
+		if (drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2) == 0 &&
+		    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED))
+			aud->step = qctrl2.step;
+		aud->mode = 0;
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0) {
+			dprintk("VIDIOCGAUDIO / VIDIOC_G_TUNER: %d\n",err);
+			err = 0;
+			break;
+		}
+		if (tun2.rxsubchans & V4L2_TUNER_SUB_LANG2)
+			aud->mode = VIDEO_SOUND_LANG1 | VIDEO_SOUND_LANG2;
+		else if (tun2.rxsubchans & V4L2_TUNER_SUB_STEREO)
+			aud->mode = VIDEO_SOUND_STEREO;
+		else if (tun2.rxsubchans & V4L2_TUNER_SUB_MONO)
+			aud->mode = VIDEO_SOUND_MONO;
+		break;
+	}
+	case VIDIOCSAUDIO: /*  set audio controls  */
+	{
+		struct video_audio	*aud = arg;
+
+		memset(&aud2,0,sizeof(aud2));
+		memset(&tun2,0,sizeof(tun2));
+		
+		aud2.index = aud->audio;
+		err = drv(inode, file, VIDIOC_S_AUDIO, &aud2);
+		if (err < 0) {
+			dprintk("VIDIOCSAUDIO / VIDIOC_S_AUDIO: %d\n",err);
+			break;
+		}
+
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_VOLUME, 
+				aud->volume, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_BASS,
+				aud->bass, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_TREBLE,
+				aud->treble, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_BALANCE,
+				aud->balance, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_MUTE,
+				!!(aud->flags & VIDEO_AUDIO_MUTE), drv);
+
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0)
+			dprintk("VIDIOCSAUDIO / VIDIOC_G_TUNER: %d\n",err);
+		if (err == 0) {
+			switch (aud->mode) {
+			default:
+			case VIDEO_SOUND_MONO:
+			case VIDEO_SOUND_LANG1:
+				tun2.audmode = V4L2_TUNER_MODE_MONO;
+				break;
+			case VIDEO_SOUND_STEREO:
+				tun2.audmode = V4L2_TUNER_MODE_STEREO;
+				break;
+			case VIDEO_SOUND_LANG2:
+				tun2.audmode = V4L2_TUNER_MODE_LANG2;
+				break;
+			}
+			err = drv(inode, file, VIDIOC_S_TUNER, &tun2);
+			if (err < 0)
+				dprintk("VIDIOCSAUDIO / VIDIOC_S_TUNER: %d\n",err);
+		}
+		err = 0;
+		break;
+	}
+#if 0
+	case VIDIOCGMBUF:
+		/* v4l2 drivers must implement that themself.  The
+		   mmap() differences can't be translated fully
+		   transparent, thus there is no point to try that */
+#endif
+	case VIDIOCMCAPTURE: /*  capture a frame  */
+	{
+		struct video_mmap	*mm = arg;
+
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(&buf2,0,sizeof(buf2));
+		memset(fmt2,0,sizeof(*fmt2));
+		
+		fmt2->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+		if (mm->width   != fmt2->fmt.pix.width  || 
+		    mm->height  != fmt2->fmt.pix.height ||
+		    palette_to_pixelformat(mm->format) != 
+		    fmt2->fmt.pix.pixelformat)
+		{/* New capture format...  */
+			fmt2->fmt.pix.width = mm->width;
+			fmt2->fmt.pix.height = mm->height;
+			fmt2->fmt.pix.pixelformat =
+				palette_to_pixelformat(mm->format);
+			fmt2->fmt.pix.field = V4L2_FIELD_ANY;
+			fmt2->fmt.pix.bytesperline = 0;
+			err = drv(inode, file, VIDIOC_S_FMT, fmt2);
+			if (err < 0) {
+				dprintk("VIDIOCMCAPTURE / VIDIOC_S_FMT: %d\n",err);
+				break;
+			}
+		}
+		buf2.index = mm->frame;
+		buf2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_QUERYBUF: %d\n",err);
+			break;
+		}
+		err = drv(inode, file, VIDIOC_QBUF, &buf2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_QBUF: %d\n",err);
+			break;
+		}
+		err = drv(inode, file, VIDIOC_STREAMON, NULL);
+		if (err < 0)
+			dprintk("VIDIOCMCAPTURE / VIDIOC_STREAMON: %d\n",err);
+		break;
+	}
+	case VIDIOCSYNC: /*  wait for a frame  */
+	{
+		int			*i = arg;
+
+		buf2.index = *i;
+		buf2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+		if (err < 0) {
+			/*  No such buffer */
+			dprintk("VIDIOCSYNC / VIDIOC_QUERYBUF: %d\n",err);
+			break;
+		}
+		if (!(buf2.flags & V4L2_BUF_FLAG_MAPPED)) {
+			/* Buffer is not mapped  */
+			err = -EINVAL;
+			break;
+		}
+
+		/*  Loop as long as the buffer is queued, but not done  */
+		while ((buf2.flags &
+			(V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE))
+		       == V4L2_BUF_FLAG_QUEUED)
+		{
+			err = poll_one(file);
+			if (err < 0 ||	/* error or sleep was interrupted  */
+			    err == 0)	/* timeout? Shouldn't occur.  */
+				break;
+			err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+			if (err < 0)
+				dprintk("VIDIOCSYNC / VIDIOC_QUERYBUF: %d\n",err);
+		}
+		if (!(buf2.flags & V4L2_BUF_FLAG_DONE)) /* not done */
+			break;
+		do {
+			err = drv(inode, file, VIDIOC_DQBUF, &buf2);
+			if (err < 0)
+				dprintk("VIDIOCSYNC / VIDIOC_DQBUF: %d\n",err);
+		} while (err == 0 && buf2.index != *i);
+		break;
+	}
+
+	case VIDIOCGVBIFMT: /* query VBI data capture format */
+	{
+		struct vbi_format      *fmt = arg;
+		
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(fmt2, 0, sizeof(*fmt2));
+		fmt2->type = V4L2_BUF_TYPE_VBI_CAPTURE;
+		
+		err = drv(inode, file, VIDIOC_G_FMT, fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCGVBIFMT / VIDIOC_G_FMT: %d\n", err);
+			break;
+		}
+		memset(fmt, 0, sizeof(*fmt));
+		fmt->samples_per_line = fmt2->fmt.vbi.samples_per_line;
+		fmt->sampling_rate    = fmt2->fmt.vbi.sampling_rate;
+		fmt->sample_format    = VIDEO_PALETTE_RAW;
+		fmt->start[0]         = fmt2->fmt.vbi.start[0];
+		fmt->count[0]         = fmt2->fmt.vbi.count[0];
+		fmt->start[1]         = fmt2->fmt.vbi.start[1];
+		fmt->count[1]         = fmt2->fmt.vbi.count[1];
+		fmt->flags            = fmt2->fmt.vbi.flags & 0x03;
+                break;
+	}
+	case VIDIOCSVBIFMT:
+	{
+		struct vbi_format      *fmt = arg;
+		
+		fmt2 = kmalloc(sizeof(*fmt2),GFP_KERNEL);
+		memset(fmt2, 0, sizeof(*fmt2));
+
+		fmt2->type = V4L2_BUF_TYPE_VBI_CAPTURE;
+		fmt2->fmt.vbi.samples_per_line = fmt->samples_per_line;
+		fmt2->fmt.vbi.sampling_rate    = fmt->sampling_rate;
+		fmt2->fmt.vbi.sample_format    = V4L2_PIX_FMT_GREY;
+		fmt2->fmt.vbi.start[0]         = fmt->start[0]; 
+		fmt2->fmt.vbi.count[0]         = fmt->count[0]; 
+		fmt2->fmt.vbi.start[1]         = fmt->start[1]; 
+		fmt2->fmt.vbi.count[1]         = fmt->count[1]; 
+		fmt2->fmt.vbi.flags            = fmt->flags;
+		err = drv(inode, file, VIDIOC_TRY_FMT, fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCSVBIFMT / VIDIOC_TRY_FMT: %d\n", err);
+			break;
+		}
+
+		if (fmt2->fmt.vbi.samples_per_line != fmt->samples_per_line ||
+		    fmt2->fmt.vbi.sampling_rate    != fmt->sampling_rate    ||
+		    VIDEO_PALETTE_RAW              != fmt->sample_format    ||
+		    fmt2->fmt.vbi.start[0]         != fmt->start[0]         ||
+		    fmt2->fmt.vbi.count[0]         != fmt->count[0]         ||
+		    fmt2->fmt.vbi.start[1]         != fmt->start[1]         ||
+		    fmt2->fmt.vbi.count[1]         != fmt->count[1]         ||
+		    fmt2->fmt.vbi.flags            != fmt->flags) {
+			err = -EINVAL;
+			break;
+		}
+		err = drv(inode, file, VIDIOC_S_FMT, fmt2);
+		if (err < 0)
+			dprintk("VIDIOCSVBIFMT / VIDIOC_S_FMT: %d\n", err);
+		break;
+	}
+	
+	default:
+		err = -ENOIOCTLCMD;
+		break;
+	}
+
+	if (cap2)
+		kfree(cap2);
+	if (fmt2)
+		kfree(fmt2);
+	return err;
+}
+
+EXPORT_SYMBOL(v4l_compat_translate_ioctl);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.4.33/drivers/media/video/v4l2-common.c linux-2.4.33-v4l2/drivers/media/video/v4l2-common.c
--- linux-2.4.33/drivers/media/video/v4l2-common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-v4l2/drivers/media/video/v4l2-common.c	2006-08-11 21:35:33.000000000 +0200
@@ -0,0 +1,281 @@
+/*
+ *	Video for Linux Two
+ *
+ *	A generic video device interface for the LINUX operating system
+ *	using a set of device structures/vectors for low level operations.
+ *
+ *	This file replaces the videodev.c file that comes with the
+ *	regular kernel distribution.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Author:	Bill Dirks <bdirks@pacbell.net>
+ *		based on code by Alan Cox, <alan@cymru.net>
+ *
+ */
+
+/*
+ * Video capture interface for Linux
+ *
+ *	A generic video device interface for the LINUX operating system
+ *	using a set of device structures/vectors for low level operations.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Author:	Alan Cox, <alan@redhat.com>
+ *
+ * Fixes:
+ */
+
+/*
+ * Video4linux 1/2 integration by Justin Schoeman
+ * <justin@suntiger.ee.up.ac.za>
+ * 2.4 PROCFS support ported from 2.4 kernels by 
+ *  Iaki Garca Etxebarria <garetxe@euskalnet.net>
+ * Makefile fix by "W. Michael Petullo" <mike@flyn.org>
+ * 2.4 devfs support ported from 2.4 kernels by
+ *  Dan Merillat <dan@merillat.org>
+ * Added Gerd Knorrs v4l1 enhancements (Justin Schoeman)
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+#if defined(CONFIG_UST) || defined(CONFIG_UST_MODULE)
+#include <linux/ust.h>
+#endif
+
+# define strlcpy(dest,src,len) strncpy(dest,src,(len)-1)
+
+#include <linux/videodev.h>
+
+MODULE_AUTHOR("Bill Dirks, Justin Schoeman, Gerd Knorr");
+MODULE_DESCRIPTION("misc helper functions for v4l2 device drivers");
+MODULE_LICENSE("GPL");
+
+/*
+ *
+ *	V 4 L 2   D R I V E R   H E L P E R   A P I
+ *
+ */
+
+/*
+ *  Video Standard Operations (contributed by Michael Schimek)
+ */
+
+/* This is the recommended method to deal with the framerate fields. More 
+   sophisticated drivers will access the fields directly. */
+unsigned int
+v4l2_video_std_fps(struct v4l2_standard *vs)
+{ 
+	if (vs->frameperiod.numerator > 0)
+		return (((vs->frameperiod.denominator << 8) / 
+			 vs->frameperiod.numerator) + 
+			(1 << 7)) / (1 << 8);
+	return 0;
+}
+
+/* Fill in the fields of a v4l2_standard structure according to the
+   'id' and 'transmission' parameters.  Returns negative on error.  */
+int v4l2_video_std_construct(struct v4l2_standard *vs,
+			     int id, char *name)
+{
+	u32 index = vs->index;
+
+	memset(vs, 0, sizeof(struct v4l2_standard));
+	vs->index = index;
+	vs->id    = id;
+	if (id & (V4L2_STD_NTSC | V4L2_STD_PAL_M)) {
+		vs->frameperiod.numerator = 1001;
+		vs->frameperiod.denominator = 30000;
+		vs->framelines = 525;
+	} else {
+		vs->frameperiod.numerator = 1;
+		vs->frameperiod.denominator = 25;
+		vs->framelines = 625;
+	}
+	strlcpy(vs->name,name,sizeof(vs->name));
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------- */
+/* priority handling                                                 */
+
+#define V4L2_PRIO_VALID(val) (val == V4L2_PRIORITY_BACKGROUND   || \
+			      val == V4L2_PRIORITY_INTERACTIVE  || \
+			      val == V4L2_PRIORITY_RECORD)
+
+int v4l2_prio_init(struct v4l2_prio_state *global)
+{
+	memset(global,0,sizeof(*global));
+	return 0;
+}
+	
+int v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,
+		     enum v4l2_priority new)
+{
+	if (!V4L2_PRIO_VALID(new))
+		return -EINVAL;
+	if (*local == new)
+		return 0;
+
+	atomic_inc(&global->prios[new]);
+	if (V4L2_PRIO_VALID(*local))
+		atomic_dec(&global->prios[*local]);
+	*local = new;
+	return 0;
+}
+
+int v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)
+{
+	return v4l2_prio_change(global,local,V4L2_PRIORITY_DEFAULT);
+}
+
+int v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority *local)
+{
+	if (V4L2_PRIO_VALID(*local))
+		atomic_dec(&global->prios[*local]);
+	return 0;
+}
+
+enum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global)
+{
+	if (atomic_read(&global->prios[V4L2_PRIORITY_RECORD]) > 0)
+		return V4L2_PRIORITY_RECORD;
+	if (atomic_read(&global->prios[V4L2_PRIORITY_INTERACTIVE]) > 0)
+		return V4L2_PRIORITY_INTERACTIVE;
+	if (atomic_read(&global->prios[V4L2_PRIORITY_BACKGROUND]) > 0)
+		return V4L2_PRIORITY_BACKGROUND;
+	return V4L2_PRIORITY_UNSET;
+}
+
+int v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority *local)
+{
+	if (*local < v4l2_prio_max(global))
+		return -EBUSY;
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------- */
+/* some arrays for pretty-printing debug messages                    */
+
+char *v4l2_field_names[] = {
+	[V4L2_FIELD_ANY]        = "any",
+	[V4L2_FIELD_NONE]       = "none",
+	[V4L2_FIELD_TOP]        = "top",
+	[V4L2_FIELD_BOTTOM]     = "bottom",
+	[V4L2_FIELD_INTERLACED] = "interlaced",
+	[V4L2_FIELD_SEQ_TB]     = "seq-tb",
+	[V4L2_FIELD_SEQ_BT]     = "seq-bt",
+	[V4L2_FIELD_ALTERNATE]  = "alternate",
+};
+
+char *v4l2_type_names[] = {
+	[V4L2_BUF_TYPE_VIDEO_CAPTURE] = "video-cap",
+	[V4L2_BUF_TYPE_VIDEO_OVERLAY] = "video-over",
+	[V4L2_BUF_TYPE_VIDEO_OUTPUT]  = "video-out",
+	[V4L2_BUF_TYPE_VBI_CAPTURE]   = "vbi-cap",
+	[V4L2_BUF_TYPE_VBI_OUTPUT]    = "vbi-out",
+};
+
+char *v4l2_ioctl_names[256] = {
+#if __GNUC__ >= 3
+	[0 ... 255]                      = "UNKNOWN",
+#endif
+	[_IOC_NR(VIDIOC_QUERYCAP)]       = "VIDIOC_QUERYCAP",
+	[_IOC_NR(VIDIOC_RESERVED)]       = "VIDIOC_RESERVED",
+	[_IOC_NR(VIDIOC_ENUM_FMT)]       = "VIDIOC_ENUM_FMT",
+	[_IOC_NR(VIDIOC_G_FMT)]          = "VIDIOC_G_FMT",
+	[_IOC_NR(VIDIOC_S_FMT)]          = "VIDIOC_S_FMT",
+#if 0
+	[_IOC_NR(VIDIOC_G_COMP)]         = "VIDIOC_G_COMP",
+	[_IOC_NR(VIDIOC_S_COMP)]         = "VIDIOC_S_COMP",
+#endif
+	[_IOC_NR(VIDIOC_REQBUFS)]        = "VIDIOC_REQBUFS",
+	[_IOC_NR(VIDIOC_QUERYBUF)]       = "VIDIOC_QUERYBUF",
+	[_IOC_NR(VIDIOC_G_FBUF)]         = "VIDIOC_G_FBUF",
+	[_IOC_NR(VIDIOC_S_FBUF)]         = "VIDIOC_S_FBUF",
+	[_IOC_NR(VIDIOC_OVERLAY)]        = "VIDIOC_OVERLAY",
+	[_IOC_NR(VIDIOC_QBUF)]           = "VIDIOC_QBUF",
+	[_IOC_NR(VIDIOC_DQBUF)]          = "VIDIOC_DQBUF",
+	[_IOC_NR(VIDIOC_STREAMON)]       = "VIDIOC_STREAMON",
+	[_IOC_NR(VIDIOC_STREAMOFF)]      = "VIDIOC_STREAMOFF",
+	[_IOC_NR(VIDIOC_G_PARM)]         = "VIDIOC_G_PARM",
+	[_IOC_NR(VIDIOC_S_PARM)]         = "VIDIOC_S_PARM",
+	[_IOC_NR(VIDIOC_G_STD)]          = "VIDIOC_G_STD",
+	[_IOC_NR(VIDIOC_S_STD)]          = "VIDIOC_S_STD",
+	[_IOC_NR(VIDIOC_ENUMSTD)]        = "VIDIOC_ENUMSTD",
+	[_IOC_NR(VIDIOC_ENUMINPUT)]      = "VIDIOC_ENUMINPUT",
+	[_IOC_NR(VIDIOC_G_CTRL)]         = "VIDIOC_G_CTRL",
+	[_IOC_NR(VIDIOC_S_CTRL)]         = "VIDIOC_S_CTRL",
+	[_IOC_NR(VIDIOC_G_TUNER)]        = "VIDIOC_G_TUNER",
+	[_IOC_NR(VIDIOC_S_TUNER)]        = "VIDIOC_S_TUNER",
+	[_IOC_NR(VIDIOC_G_AUDIO)]        = "VIDIOC_G_AUDIO",
+	[_IOC_NR(VIDIOC_S_AUDIO)]        = "VIDIOC_S_AUDIO",
+	[_IOC_NR(VIDIOC_QUERYCTRL)]      = "VIDIOC_QUERYCTRL",
+	[_IOC_NR(VIDIOC_QUERYMENU)]      = "VIDIOC_QUERYMENU",
+	[_IOC_NR(VIDIOC_G_INPUT)]        = "VIDIOC_G_INPUT",
+	[_IOC_NR(VIDIOC_S_INPUT)]        = "VIDIOC_S_INPUT",
+	[_IOC_NR(VIDIOC_G_OUTPUT)]       = "VIDIOC_G_OUTPUT",
+	[_IOC_NR(VIDIOC_S_OUTPUT)]       = "VIDIOC_S_OUTPUT",
+	[_IOC_NR(VIDIOC_ENUMOUTPUT)]     = "VIDIOC_ENUMOUTPUT",
+	[_IOC_NR(VIDIOC_G_AUDOUT)]       = "VIDIOC_G_AUDOUT",
+	[_IOC_NR(VIDIOC_S_AUDOUT)]       = "VIDIOC_S_AUDOUT",
+	[_IOC_NR(VIDIOC_G_MODULATOR)]    = "VIDIOC_G_MODULATOR",
+	[_IOC_NR(VIDIOC_S_MODULATOR)]    = "VIDIOC_S_MODULATOR",
+	[_IOC_NR(VIDIOC_G_FREQUENCY)]    = "VIDIOC_G_FREQUENCY",
+	[_IOC_NR(VIDIOC_S_FREQUENCY)]    = "VIDIOC_S_FREQUENCY",
+	[_IOC_NR(VIDIOC_CROPCAP)]        = "VIDIOC_CROPCAP",
+	[_IOC_NR(VIDIOC_G_CROP)]         = "VIDIOC_G_CROP",
+	[_IOC_NR(VIDIOC_S_CROP)]         = "VIDIOC_S_CROP",
+	[_IOC_NR(VIDIOC_G_JPEGCOMP)]     = "VIDIOC_G_JPEGCOMP",
+	[_IOC_NR(VIDIOC_S_JPEGCOMP)]     = "VIDIOC_S_JPEGCOMP",
+	[_IOC_NR(VIDIOC_QUERYSTD)]       = "VIDIOC_QUERYSTD",
+	[_IOC_NR(VIDIOC_TRY_FMT)]        = "VIDIOC_TRY_FMT",
+};
+
+/* ----------------------------------------------------------------- */
+
+EXPORT_SYMBOL(v4l2_video_std_fps);
+EXPORT_SYMBOL(v4l2_video_std_construct);
+
+EXPORT_SYMBOL(v4l2_prio_init);
+EXPORT_SYMBOL(v4l2_prio_change);
+EXPORT_SYMBOL(v4l2_prio_open);
+EXPORT_SYMBOL(v4l2_prio_close);
+EXPORT_SYMBOL(v4l2_prio_max);
+EXPORT_SYMBOL(v4l2_prio_check);
+
+EXPORT_SYMBOL(v4l2_field_names);
+EXPORT_SYMBOL(v4l2_type_names);
+EXPORT_SYMBOL(v4l2_ioctl_names);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.4.33/drivers/media/video/videodev.c linux-2.4.33-v4l2/drivers/media/video/videodev.c
--- linux-2.4.33/drivers/media/video/videodev.c	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.33-v4l2/drivers/media/video/videodev.c	2006-08-11 21:35:33.000000000 +0200
@@ -255,6 +255,30 @@
 /*
  * helper function -- handles userspace copying for ioctl arguments
  */
+
+static unsigned int
+video_fix_command(unsigned int cmd)
+{
+	switch (cmd) {
+	case VIDIOC_OVERLAY_OLD:
+		cmd = VIDIOC_OVERLAY;
+		break;
+	case VIDIOC_S_PARM_OLD:
+		cmd = VIDIOC_S_PARM;
+		break;
+	case VIDIOC_S_CTRL_OLD:
+		cmd = VIDIOC_S_CTRL;
+		break;
+	case VIDIOC_G_AUDIO_OLD:
+		cmd = VIDIOC_G_AUDIO;
+		break;
+	case VIDIOC_G_AUDOUT_OLD:
+		cmd = VIDIOC_G_AUDOUT;
+		break;
+	}
+	return cmd;
+}
+
 int
 video_usercopy(struct inode *inode, struct file *file,
 	       unsigned int cmd, unsigned long arg,
@@ -266,12 +290,14 @@
 	void	*parg = NULL;
 	int	err  = -EINVAL;
 
+	cmd = video_fix_command(cmd);
+
 	/*  Copy arguments into temp kernel buffer  */
 	switch (_IOC_DIR(cmd)) {
 	case _IOC_NONE:
 		parg = (void *)arg;
 		break;
-	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_READ:
 	case _IOC_WRITE:
 	case (_IOC_WRITE | _IOC_READ):
 		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
@@ -285,8 +311,9 @@
 		}
 		
 		err = -EFAULT;
-		if (copy_from_user(parg, (void *)arg, _IOC_SIZE(cmd)))
-			goto out;
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(parg, (void *)arg, _IOC_SIZE(cmd)))
+				goto out;
 		break;
 	}
 
diff -Naur linux-2.4.33/include/linux/videodev2.h linux-2.4.33-v4l2/include/linux/videodev2.h
--- linux-2.4.33/include/linux/videodev2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-v4l2/include/linux/videodev2.h	2006-08-11 21:35:33.000000000 +0200
@@ -0,0 +1,938 @@
+#ifndef __LINUX_VIDEODEV2_H
+#define __LINUX_VIDEODEV2_H
+/*
+ *	Video for Linux Two
+ *
+ *	Header file for v4l or V4L2 drivers and applications, for
+ *	Linux kernels 2.2.x or 2.4.x.
+ *
+ *	See http://bytesex.org/v4l/ for API specs and other
+ *	v4l2 documentation.
+ *
+ *	Author: Bill Dirks <bdirks@pacbell.net>
+ *		Justin Schoeman
+ *		et al.
+ */
+#ifdef __KERNEL__
+#include <linux/time.h> /* need struct timeval */
+#endif
+
+/*
+ *	M I S C E L L A N E O U S
+ */
+
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*
+ *	E N U M S
+ */
+enum v4l2_field {
+	V4L2_FIELD_ANY        = 0, /* driver can choose from none,
+				      top, bottom, interlaced
+				      depending on whatever it thinks
+				      is approximate ... */
+	V4L2_FIELD_NONE       = 1, /* this device has no fields ... */
+	V4L2_FIELD_TOP        = 2, /* top field only */
+	V4L2_FIELD_BOTTOM     = 3, /* bottom field only */
+	V4L2_FIELD_INTERLACED = 4, /* both fields interlaced */
+	V4L2_FIELD_SEQ_TB     = 5, /* both fields sequential into one
+				      buffer, top-bottom order */
+	V4L2_FIELD_SEQ_BT     = 6, /* same as above + bottom-top order */
+	V4L2_FIELD_ALTERNATE  = 7, /* both fields alternating into
+				      separate buffers */
+};
+#define V4L2_FIELD_HAS_TOP(field)	\
+	((field) == V4L2_FIELD_TOP 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTTOM(field)	\
+	((field) == V4L2_FIELD_BOTTOM 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTH(field)	\
+	((field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+
+enum v4l2_buf_type {
+	V4L2_BUF_TYPE_VIDEO_CAPTURE  = 1,
+	V4L2_BUF_TYPE_VIDEO_OUTPUT   = 2,
+	V4L2_BUF_TYPE_VIDEO_OVERLAY  = 3,
+	V4L2_BUF_TYPE_VBI_CAPTURE    = 4,
+	V4L2_BUF_TYPE_VBI_OUTPUT     = 5,
+	V4L2_BUF_TYPE_PRIVATE        = 0x80,
+};
+
+enum v4l2_ctrl_type {
+	V4L2_CTRL_TYPE_INTEGER	     = 1,
+	V4L2_CTRL_TYPE_BOOLEAN	     = 2,
+	V4L2_CTRL_TYPE_MENU	     = 3,
+	V4L2_CTRL_TYPE_BUTTON	     = 4,
+};
+
+enum v4l2_tuner_type {
+	V4L2_TUNER_RADIO	     = 1,
+	V4L2_TUNER_ANALOG_TV	     = 2,
+};
+
+enum v4l2_memory {
+	V4L2_MEMORY_MMAP             = 1,
+	V4L2_MEMORY_USERPTR          = 2,
+	V4L2_MEMORY_OVERLAY          = 3,
+};
+
+/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
+enum v4l2_colorspace {
+	/* ITU-R 601 -- broadcast NTSC/PAL */
+	V4L2_COLORSPACE_SMPTE170M     = 1,
+
+	/* 1125-Line (US) HDTV */
+	V4L2_COLORSPACE_SMPTE240M     = 2,
+
+	/* HD and modern captures. */
+	V4L2_COLORSPACE_REC709        = 3,
+	
+	/* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
+	V4L2_COLORSPACE_BT878         = 4,
+	
+	/* These should be useful.  Assume 601 extents. */
+	V4L2_COLORSPACE_470_SYSTEM_M  = 5,
+	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
+	
+	/* I know there will be cameras that send this.  So, this is
+	 * unspecified chromaticities and full 0-255 on each of the
+	 * Y'CbCr components
+	 */
+	V4L2_COLORSPACE_JPEG          = 7,
+	
+	/* For RGB colourspaces, this is probably a good start. */
+	V4L2_COLORSPACE_SRGB          = 8,
+};
+
+enum v4l2_priority {
+	V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
+	V4L2_PRIORITY_BACKGROUND  = 1,
+	V4L2_PRIORITY_INTERACTIVE = 2,
+	V4L2_PRIORITY_RECORD      = 3,
+	V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
+};
+
+struct v4l2_rect {
+	__s32   left;
+	__s32   top;
+	__s32   width;
+	__s32   height;
+};
+
+struct v4l2_fract {
+	__u32   numerator;
+	__u32   denominator;
+};
+
+/*
+ *	D R I V E R   C A P A B I L I T I E S
+ */
+struct v4l2_capability
+{
+	__u8	driver[16];	/* i.e. "bttv" */
+	__u8	card[32];	/* i.e. "Hauppauge WinTV" */
+	__u8	bus_info[32];	/* "PCI:" + pci_name(pci_dev) */
+	__u32   version;        /* should use KERNEL_VERSION() */
+	__u32	capabilities;	/* Device capabilities */
+	__u32	reserved[4];
+};
+
+/* Values for 'capabilities' field */
+#define V4L2_CAP_VIDEO_CAPTURE	0x00000001  /* Is a video capture device */
+#define V4L2_CAP_VIDEO_OUTPUT	0x00000002  /* Is a video output device */
+#define V4L2_CAP_VIDEO_OVERLAY	0x00000004  /* Can do video overlay */
+#define V4L2_CAP_VBI_CAPTURE	0x00000010  /* Is a VBI capture device */
+#define V4L2_CAP_VBI_OUTPUT	0x00000020  /* Is a VBI output device */
+#define V4L2_CAP_RDS_CAPTURE	0x00000100  /* RDS data capture */
+
+#define V4L2_CAP_TUNER		0x00010000  /* has a tuner */
+#define V4L2_CAP_AUDIO		0x00020000  /* has audio support */
+#define V4L2_CAP_RADIO		0x00040000  /* is a radio device */
+
+#define V4L2_CAP_READWRITE      0x01000000  /* read/write systemcalls */
+#define V4L2_CAP_ASYNCIO        0x02000000  /* async I/O */
+#define V4L2_CAP_STREAMING      0x04000000  /* streaming I/O ioctls */
+
+/*
+ *	V I D E O   I M A G E   F O R M A T
+ */
+
+struct v4l2_pix_format
+{
+	__u32         	 	width;
+	__u32	         	height;
+	__u32	         	pixelformat;
+	enum v4l2_field  	field;
+	__u32            	bytesperline;	/* for padding, zero if unused */
+	__u32          	 	sizeimage;
+        enum v4l2_colorspace	colorspace;
+	__u32			priv;		/* private data, depends on pixelformat */
+};
+
+/*           Pixel format    FOURCC                  depth  Description   */
+#define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R','G','B','1') /*  8  RGB-3-3-2     */
+#define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R','G','B','O') /* 16  RGB-5-5-5     */
+#define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R','G','B','P') /* 16  RGB-5-6-5     */
+#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R','G','B','Q') /* 16  RGB-5-5-5 BE  */
+#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R','G','B','R') /* 16  RGB-5-6-5 BE  */
+#define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B','G','R','3') /* 24  BGR-8-8-8     */
+#define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R','G','B','3') /* 24  RGB-8-8-8     */
+#define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B','G','R','4') /* 32  BGR-8-8-8-8   */
+#define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R','G','B','4') /* 32  RGB-8-8-8-8   */
+#define V4L2_PIX_FMT_GREY    v4l2_fourcc('G','R','E','Y') /*  8  Greyscale     */
+#define V4L2_PIX_FMT_YVU410  v4l2_fourcc('Y','V','U','9') /*  9  YVU 4:1:0     */
+#define V4L2_PIX_FMT_YVU420  v4l2_fourcc('Y','V','1','2') /* 12  YVU 4:2:0     */
+#define V4L2_PIX_FMT_YUYV    v4l2_fourcc('Y','U','Y','V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_UYVY    v4l2_fourcc('U','Y','V','Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4','2','2','P') /* 16  YVU422 planar */
+#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4','1','1','P') /* 16  YVU411 planar */
+#define V4L2_PIX_FMT_Y41P    v4l2_fourcc('Y','4','1','P') /* 12  YUV 4:1:1     */
+
+/* two planes -- one Y, one Cr + Cb interleaved  */
+#define V4L2_PIX_FMT_NV12    v4l2_fourcc('N','V','1','2') /* 12  Y/CbCr 4:2:0  */
+#define V4L2_PIX_FMT_NV21    v4l2_fourcc('N','V','2','1') /* 12  Y/CrCb 4:2:0  */
+
+/*  The following formats are not defined in the V4L2 specification */
+#define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y','U','V','9') /*  9  YUV 4:1:0     */
+#define V4L2_PIX_FMT_YUV420  v4l2_fourcc('Y','U','1','2') /* 12  YUV 4:2:0     */
+#define V4L2_PIX_FMT_YYUV    v4l2_fourcc('Y','Y','U','V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_HI240   v4l2_fourcc('H','I','2','4') /*  8  8-bit color   */
+
+/* compressed formats */
+#define V4L2_PIX_FMT_MJPEG    v4l2_fourcc('M','J','P','G') /* Motion-JPEG   */
+#define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J','P','E','G') /* JFIF JPEG     */
+#define V4L2_PIX_FMT_DV       v4l2_fourcc('d','v','s','d') /* 1394          */
+#define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M','P','E','G') /* MPEG          */
+
+/*  Vendor-specific formats   */
+#define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W','N','V','A') /* Winnov hw compress */
+
+/*
+ *	F O R M A T   E N U M E R A T I O N
+ */
+struct v4l2_fmtdesc
+{
+	__u32	            index;             /* Format number      */
+	enum v4l2_buf_type  type;              /* buffer type        */
+	__u32               flags;
+	__u8	            description[32];   /* Description string */
+	__u32	            pixelformat;       /* Format fourcc      */
+	__u32	            reserved[4];
+};
+
+#define V4L2_FMT_FLAG_COMPRESSED 0x0001
+
+
+/*
+ *	T I M E C O D E
+ */
+struct v4l2_timecode
+{
+	__u32	type;
+	__u32	flags;
+	__u8	frames;
+	__u8	seconds;
+	__u8	minutes;
+	__u8	hours;
+	__u8	userbits[4];
+};
+
+/*  Type  */
+#define V4L2_TC_TYPE_24FPS		1
+#define V4L2_TC_TYPE_25FPS		2
+#define V4L2_TC_TYPE_30FPS		3
+#define V4L2_TC_TYPE_50FPS		4
+#define V4L2_TC_TYPE_60FPS		5
+
+/*  Flags  */
+#define V4L2_TC_FLAG_DROPFRAME		0x0001 /* "drop-frame" mode */
+#define V4L2_TC_FLAG_COLORFRAME		0x0002
+#define V4L2_TC_USERBITS_field		0x000C
+#define V4L2_TC_USERBITS_USERDEFINED	0x0000
+#define V4L2_TC_USERBITS_8BITCHARS	0x0008
+/* The above is based on SMPTE timecodes */
+
+
+/*
+ *	C O M P R E S S I O N   P A R A M E T E R S
+ */
+#if 0
+/* ### generic compression settings don't work, there is too much
+ * ### codec-specific stuff.  Maybe reuse that for MPEG codec settings
+ * ### later ... */
+struct v4l2_compression
+{
+	__u32	quality;
+	__u32	keyframerate;
+	__u32	pframerate;
+	__u32	reserved[5];
+
+/*  what we'll need for MPEG, extracted from some postings on
+    the v4l list (Gert Vervoort, PlasmaJohn).
+
+system stream:
+  - type: elementary stream(ES), packatised elementary stream(s) (PES)
+    program stream(PS), transport stream(TS)
+  - system bitrate
+  - PS packet size (DVD: 2048 bytes, VCD: 2324 bytes)
+  - TS video PID
+  - TS audio PID
+  - TS PCR PID
+  - TS system information tables (PAT, PMT, CAT, NIT and SIT)
+  - (MPEG-1 systems stream vs. MPEG-2 program stream (TS not supported
+    by MPEG-1 systems)
+
+audio:
+  - type: MPEG (+Layer I,II,III), AC-3, LPCM
+  - bitrate
+  - sampling frequency (DVD: 48 Khz, VCD: 44.1 KHz, 32 kHz)
+  - Trick Modes? (ff, rew)
+  - Copyright
+  - Inverse Telecine
+
+video:
+  - picturesize (SIF, 1/2 D1, 2/3 D1, D1) and PAL/NTSC norm can be set
+    through excisting V4L2 controls
+  - noise reduction, parameters encoder specific?
+  - MPEG video version: MPEG-1, MPEG-2
+  - GOP (Group Of Pictures) definition:
+    - N: number of frames per GOP
+    - M: distance between reference (I,P) frames
+    - open/closed GOP
+  - quantiser matrix: inter Q matrix (64 bytes) and intra Q matrix (64 bytes)
+  - quantiser scale: linear or logarithmic
+  - scanning: alternate or zigzag
+  - bitrate mode: CBR (constant bitrate) or VBR (variable bitrate).
+  - target video bitrate for CBR
+  - target video bitrate for VBR
+  - maximum video bitrate for VBR - min. quantiser value for VBR
+  - max. quantiser value for VBR
+  - adaptive quantisation value
+  - return the number of bytes per GOP or bitrate for bitrate monitoring
+
+*/
+};
+#endif
+
+struct v4l2_jpegcompression
+{
+	int quality;
+
+	int  APPn;              /* Number of APP segment to be written,
+				 * must be 0..15 */
+	int  APP_len;           /* Length of data in JPEG APPn segment */
+	char APP_data[60];      /* Data in the JPEG APPn segment. */
+	
+	int  COM_len;           /* Length of data in JPEG COM segment */
+	char COM_data[60];      /* Data in JPEG COM segment */
+	
+	__u32 jpeg_markers;     /* Which markers should go into the JPEG
+				 * output. Unless you exactly know what
+				 * you do, leave them untouched.
+				 * Inluding less markers will make the
+				 * resulting code smaller, but there will
+				 * be fewer aplications which can read it.
+				 * The presence of the APP and COM marker
+				 * is influenced by APP_len and COM_len
+				 * ONLY, not by this property! */
+	
+#define V4L2_JPEG_MARKER_DHT (1<<3)    /* Define Huffman Tables */
+#define V4L2_JPEG_MARKER_DQT (1<<4)    /* Define Quantization Tables */
+#define V4L2_JPEG_MARKER_DRI (1<<5)    /* Define Restart Interval */
+#define V4L2_JPEG_MARKER_COM (1<<6)    /* Comment segment */
+#define V4L2_JPEG_MARKER_APP (1<<7)    /* App segment, driver will
+                                        * allways use APP0 */
+};
+
+
+/*
+ *	M E M O R Y - M A P P I N G   B U F F E R S
+ */
+struct v4l2_requestbuffers
+{
+	__u32	                count;
+	enum v4l2_buf_type      type;
+	enum v4l2_memory        memory;
+	__u32	                reserved[2];
+};
+
+struct v4l2_buffer
+{
+	__u32			index;
+	enum v4l2_buf_type      type;
+	__u32			bytesused;
+	__u32			flags;
+	enum v4l2_field		field;
+	struct timeval		timestamp;
+	struct v4l2_timecode	timecode;
+	__u32			sequence;
+
+	/* memory location */
+	enum v4l2_memory        memory;
+	union {
+		__u32           offset;
+		unsigned long   userptr;
+	} m;
+	__u32			length;
+
+	__u32			reserved[2];
+};
+
+/*  Flags for 'flags' field */
+#define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
+#define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
+#define V4L2_BUF_FLAG_DONE	0x0004	/* Buffer is ready */
+#define V4L2_BUF_FLAG_KEYFRAME	0x0008	/* Image is a keyframe (I-frame) */
+#define V4L2_BUF_FLAG_PFRAME	0x0010	/* Image is a P-frame */
+#define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
+#define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
+
+/*
+ *	O V E R L A Y   P R E V I E W
+ */
+struct v4l2_framebuffer
+{
+	__u32			capability;
+	__u32			flags;
+/* FIXME: in theory we should pass something like PCI device + memory
+ * region + offset instead of some physical address */
+	void*                   base;
+	struct v4l2_pix_format	fmt;
+};
+/*  Flags for the 'capability' field. Read only */
+#define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
+#define V4L2_FBUF_CAP_CHROMAKEY		0x0002
+#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
+#define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
+/*  Flags for the 'flags' field. */
+#define V4L2_FBUF_FLAG_PRIMARY		0x0001
+#define V4L2_FBUF_FLAG_OVERLAY		0x0002
+#define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
+
+struct v4l2_clip
+{
+	struct v4l2_rect        c;
+	struct v4l2_clip	*next;
+};
+
+struct v4l2_window
+{
+	struct v4l2_rect        w;
+	enum v4l2_field  	field;
+	__u32			chromakey;
+	struct v4l2_clip	*clips;
+	__u32			clipcount;
+	void			*bitmap;
+};
+
+
+/*
+ *	C A P T U R E   P A R A M E T E R S
+ */
+struct v4l2_captureparm
+{
+	__u32		   capability;	  /*  Supported modes */
+	__u32		   capturemode;	  /*  Current mode */
+	struct v4l2_fract  timeperframe;  /*  Time per frame in .1us units */
+	__u32		   extendedmode;  /*  Driver-specific extensions */
+	__u32              readbuffers;   /*  # of buffers for read */
+	__u32		   reserved[4];
+};
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY	0x0001	/*  High quality imaging mode */
+#define V4L2_CAP_TIMEPERFRAME	0x1000	/*  timeperframe field is supported */
+
+struct v4l2_outputparm
+{
+	__u32		   capability;	 /*  Supported modes */
+	__u32		   outputmode;	 /*  Current mode */
+	struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
+	__u32		   extendedmode; /*  Driver-specific extensions */
+	__u32              writebuffers; /*  # of buffers for write */
+	__u32		   reserved[4];
+};
+
+/*
+ *	I N P U T   I M A G E   C R O P P I N G
+ */
+
+struct v4l2_cropcap {
+	enum v4l2_buf_type      type;	
+        struct v4l2_rect        bounds;
+        struct v4l2_rect        defrect;
+        struct v4l2_fract       pixelaspect;
+};
+
+struct v4l2_crop {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        c;
+};
+
+/*
+ *      A N A L O G   V I D E O   S T A N D A R D
+ */
+
+typedef __u64 v4l2_std_id;
+
+/* one bit for each */
+#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
+#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
+#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
+#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
+#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
+#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
+#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
+#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)
+
+#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
+#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
+#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
+#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
+
+#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
+#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
+
+#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
+#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
+#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
+#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
+#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
+#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
+#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
+
+/* ATSC/HDTV */
+#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
+#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
+
+/* some common needed stuff */
+#define V4L2_STD_PAL_BG		(V4L2_STD_PAL_B		|\
+				 V4L2_STD_PAL_B1	|\
+				 V4L2_STD_PAL_G)
+#define V4L2_STD_PAL_DK		(V4L2_STD_PAL_D		|\
+				 V4L2_STD_PAL_D1	|\
+				 V4L2_STD_PAL_K)
+#define V4L2_STD_PAL		(V4L2_STD_PAL_BG	|\
+				 V4L2_STD_PAL_DK	|\
+				 V4L2_STD_PAL_H		|\
+				 V4L2_STD_PAL_I)
+#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M	|\
+				 V4L2_STD_NTSC_M_JP)
+#define V4L2_STD_SECAM		(V4L2_STD_SECAM_B	|\
+				 V4L2_STD_SECAM_D	|\
+				 V4L2_STD_SECAM_G	|\
+				 V4L2_STD_SECAM_H	|\
+				 V4L2_STD_SECAM_K	|\
+				 V4L2_STD_SECAM_K1	|\
+				 V4L2_STD_SECAM_L)
+
+#define V4L2_STD_525_60		(V4L2_STD_PAL_M		|\
+				 V4L2_STD_PAL_60	|\
+				 V4L2_STD_NTSC)
+#define V4L2_STD_625_50		(V4L2_STD_PAL		|\
+				 V4L2_STD_PAL_N		|\
+				 V4L2_STD_PAL_Nc	|\
+				 V4L2_STD_SECAM)
+
+#define V4L2_STD_UNKNOWN        0
+#define V4L2_STD_ALL            (V4L2_STD_525_60	|\
+				 V4L2_STD_625_50)
+
+struct v4l2_standard
+{
+	__u32	       	     index;
+	v4l2_std_id          id;
+	__u8		     name[24];
+	struct v4l2_fract    frameperiod; /* Frames, not fields */
+	__u32		     framelines;
+	__u32		     reserved[4];
+};
+
+
+/*
+ *	V I D E O   I N P U T S
+ */
+struct v4l2_input
+{
+	__u32	     index;		/*  Which input */
+	__u8	     name[32];	        /*  Label */
+	__u32	     type;		/*  Type of input */
+	__u32	     audioset;	        /*  Associated audios (bitfield) */
+	__u32        tuner;             /*  Associated tuner */
+	v4l2_std_id  std;
+	__u32	     status;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_INPUT_TYPE_TUNER		1
+#define V4L2_INPUT_TYPE_CAMERA		2
+
+/* field 'status' - general */
+#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
+#define V4L2_IN_ST_NO_SIGNAL   0x00000002
+#define V4L2_IN_ST_NO_COLOR    0x00000004
+
+/* field 'status' - analog */
+#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
+#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */
+
+/* field 'status' - digital */
+#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
+#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
+#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */
+
+/* field 'status' - VCR and set-top box */
+#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
+#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
+#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */
+
+/*
+ *	V I D E O   O U T P U T S
+ */
+struct v4l2_output
+{
+	__u32	     index;		/*  Which output */
+	__u8	     name[32];	        /*  Label */
+	__u32	     type;		/*  Type of output */
+	__u32	     audioset;	        /*  Associated audios (bitfield) */
+	__u32	     modulator;         /*  Associated modulator */
+	v4l2_std_id  std;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_OUTPUT_TYPE_MODULATOR		1
+#define V4L2_OUTPUT_TYPE_ANALOG			2
+#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
+
+/*
+ *	C O N T R O L S
+ */
+struct v4l2_control
+{
+	__u32		     id;
+	__s32		     value;
+};
+
+/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
+struct v4l2_queryctrl
+{
+	__u32	             id;
+	enum v4l2_ctrl_type  type;
+	__u8		     name[32];	/* Whatever */
+	__s32		     minimum;	/* Note signedness */
+	__s32		     maximum;
+	__s32	             step;
+	__s32		     default_value;
+	__u32                flags;
+	__u32		     reserved[2];
+};
+
+/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
+struct v4l2_querymenu
+{
+	__u32		id;
+	__u32		index;
+	__u8		name[32];	/* Whatever */
+	__u32		reserved;
+};
+
+/*  Control flags  */
+#define V4L2_CTRL_FLAG_DISABLED		0x0001
+#define V4L2_CTRL_FLAG_GRABBED		0x0002
+
+/*  Control IDs defined by V4L2 */
+#define V4L2_CID_BASE			0x00980900
+/*  IDs reserved for driver specific controls */
+#define V4L2_CID_PRIVATE_BASE		0x08000000
+
+#define V4L2_CID_BRIGHTNESS		(V4L2_CID_BASE+0)
+#define V4L2_CID_CONTRAST		(V4L2_CID_BASE+1)
+#define V4L2_CID_SATURATION		(V4L2_CID_BASE+2)
+#define V4L2_CID_HUE			(V4L2_CID_BASE+3)
+#define V4L2_CID_AUDIO_VOLUME		(V4L2_CID_BASE+5)
+#define V4L2_CID_AUDIO_BALANCE		(V4L2_CID_BASE+6)
+#define V4L2_CID_AUDIO_BASS		(V4L2_CID_BASE+7)
+#define V4L2_CID_AUDIO_TREBLE		(V4L2_CID_BASE+8)
+#define V4L2_CID_AUDIO_MUTE		(V4L2_CID_BASE+9)
+#define V4L2_CID_AUDIO_LOUDNESS		(V4L2_CID_BASE+10)
+#define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11)
+#define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
+#define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+#define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
+#define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
+#define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
+#define V4L2_CID_WHITENESS		(V4L2_CID_GAMMA) /* ? Not sure */
+#define V4L2_CID_EXPOSURE		(V4L2_CID_BASE+17)
+#define V4L2_CID_AUTOGAIN		(V4L2_CID_BASE+18)
+#define V4L2_CID_GAIN			(V4L2_CID_BASE+19)
+#define V4L2_CID_HFLIP			(V4L2_CID_BASE+20)
+#define V4L2_CID_VFLIP			(V4L2_CID_BASE+21)
+#define V4L2_CID_HCENTER		(V4L2_CID_BASE+22)
+#define V4L2_CID_VCENTER		(V4L2_CID_BASE+23)
+#define V4L2_CID_LASTP1			(V4L2_CID_BASE+24) /* last CID + 1 */
+
+/*
+ *	T U N I N G
+ */
+struct v4l2_tuner
+{
+	__u32                   index;
+	__u8			name[32];
+	enum v4l2_tuner_type    type;
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			rxsubchans;
+	__u32			audmode;
+	__s32			signal;
+	__s32			afc;
+	__u32			reserved[4];
+};
+
+struct v4l2_modulator
+{
+	__u32			index;
+	__u8			name[32];
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			txsubchans;
+	__u32			reserved[4];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_TUNER_CAP_LOW		0x0001
+#define V4L2_TUNER_CAP_NORM		0x0002
+#define V4L2_TUNER_CAP_STEREO		0x0010
+#define V4L2_TUNER_CAP_LANG2		0x0020
+#define V4L2_TUNER_CAP_SAP		0x0020
+#define V4L2_TUNER_CAP_LANG1		0x0040
+
+/*  Flags for the 'rxsubchans' field */
+#define V4L2_TUNER_SUB_MONO		0x0001
+#define V4L2_TUNER_SUB_STEREO		0x0002
+#define V4L2_TUNER_SUB_LANG2		0x0004
+#define V4L2_TUNER_SUB_SAP		0x0004
+#define V4L2_TUNER_SUB_LANG1		0x0008
+
+/*  Values for the 'audmode' field */
+#define V4L2_TUNER_MODE_MONO		0x0000
+#define V4L2_TUNER_MODE_STEREO		0x0001
+#define V4L2_TUNER_MODE_LANG2		0x0002
+#define V4L2_TUNER_MODE_SAP		0x0002
+#define V4L2_TUNER_MODE_LANG1		0x0003
+
+struct v4l2_frequency
+{
+	__u32	              tuner;
+	enum v4l2_tuner_type  type;
+        __u32	              frequency;
+	__u32	              reserved[8];
+};
+
+/*
+ *	A U D I O
+ */
+struct v4l2_audio
+{
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+/*  Flags for the 'capability' field */
+#define V4L2_AUDCAP_STEREO		0x00001
+#define V4L2_AUDCAP_AVL			0x00002
+
+/*  Flags for the 'mode' field */
+#define V4L2_AUDMODE_AVL		0x00001
+
+struct v4l2_audioout
+{
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*
+ *	D A T A   S E R V I C E S   ( V B I )
+ *
+ *	Data services API by Michael Schimek
+ */
+
+struct v4l2_vbi_format
+{
+	__u32	sampling_rate;		/* in 1 Hz */
+	__u32	offset;
+	__u32	samples_per_line;
+	__u32	sample_format;		/* V4L2_PIX_FMT_* */
+	__s32	start[2];
+	__u32	count[2];
+	__u32	flags;			/* V4L2_VBI_* */
+	__u32	reserved[2];		/* must be zero */
+};
+
+/*  VBI flags  */
+#define V4L2_VBI_UNSYNC		(1<< 0)
+#define V4L2_VBI_INTERLACED	(1<< 1)
+
+
+/*
+ *	A G G R E G A T E   S T R U C T U R E S
+ */
+
+/*	Stream data format
+ */
+struct v4l2_format
+{
+	enum v4l2_buf_type type;
+	union
+	{
+		struct v4l2_pix_format	pix;  // V4L2_BUF_TYPE_VIDEO_CAPTURE
+		struct v4l2_window	win;  // V4L2_BUF_TYPE_VIDEO_OVERLAY
+		struct v4l2_vbi_format	vbi;  // V4L2_BUF_TYPE_VBI_CAPTURE
+		__u8	raw_data[200];        // user-defined
+	} fmt;
+};
+
+
+/*	Stream type-dependent parameters
+ */
+struct v4l2_streamparm
+{
+	enum v4l2_buf_type type;
+	union
+	{
+		struct v4l2_captureparm	capture;
+		struct v4l2_outputparm	output;
+		__u8	raw_data[200];  /* user-defined */
+	} parm;
+};
+
+
+
+/*
+ *	I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
+ *
+ */
+#define VIDIOC_QUERYCAP		_IOR  ('V',  0, struct v4l2_capability)
+#define VIDIOC_RESERVED		_IO   ('V',  1)
+#define VIDIOC_ENUM_FMT         _IOWR ('V',  2, struct v4l2_fmtdesc)
+#define VIDIOC_G_FMT		_IOWR ('V',  4, struct v4l2_format)
+#define VIDIOC_S_FMT		_IOWR ('V',  5, struct v4l2_format)
+#if 0
+#define VIDIOC_G_COMP		_IOR  ('V',  6, struct v4l2_compression)
+#define VIDIOC_S_COMP		_IOW  ('V',  7, struct v4l2_compression)
+#endif
+#define VIDIOC_REQBUFS		_IOWR ('V',  8, struct v4l2_requestbuffers)
+#define VIDIOC_QUERYBUF		_IOWR ('V',  9, struct v4l2_buffer)
+#define VIDIOC_G_FBUF		_IOR  ('V', 10, struct v4l2_framebuffer)
+#define VIDIOC_S_FBUF		_IOW  ('V', 11, struct v4l2_framebuffer)
+#define VIDIOC_OVERLAY		_IOW  ('V', 14, int)
+#define VIDIOC_QBUF		_IOWR ('V', 15, struct v4l2_buffer)
+#define VIDIOC_DQBUF		_IOWR ('V', 17, struct v4l2_buffer)
+#define VIDIOC_STREAMON		_IOW  ('V', 18, int)
+#define VIDIOC_STREAMOFF	_IOW  ('V', 19, int)
+#define VIDIOC_G_PARM		_IOWR ('V', 21, struct v4l2_streamparm)
+#define VIDIOC_S_PARM		_IOWR ('V', 22, struct v4l2_streamparm)
+#define VIDIOC_G_STD		_IOR  ('V', 23, v4l2_std_id)
+#define VIDIOC_S_STD		_IOW  ('V', 24, v4l2_std_id)
+#define VIDIOC_ENUMSTD		_IOWR ('V', 25, struct v4l2_standard)
+#define VIDIOC_ENUMINPUT	_IOWR ('V', 26, struct v4l2_input)
+#define VIDIOC_G_CTRL		_IOWR ('V', 27, struct v4l2_control)
+#define VIDIOC_S_CTRL		_IOWR ('V', 28, struct v4l2_control)
+#define VIDIOC_G_TUNER		_IOWR ('V', 29, struct v4l2_tuner)
+#define VIDIOC_S_TUNER		_IOW  ('V', 30, struct v4l2_tuner)
+#define VIDIOC_G_AUDIO		_IOR  ('V', 33, struct v4l2_audio)
+#define VIDIOC_S_AUDIO		_IOW  ('V', 34, struct v4l2_audio)
+#define VIDIOC_QUERYCTRL	_IOWR ('V', 36, struct v4l2_queryctrl)
+#define VIDIOC_QUERYMENU	_IOWR ('V', 37, struct v4l2_querymenu)
+#define VIDIOC_G_INPUT		_IOR  ('V', 38, int)
+#define VIDIOC_S_INPUT		_IOWR ('V', 39, int)
+#define VIDIOC_G_OUTPUT		_IOR  ('V', 46, int)
+#define VIDIOC_S_OUTPUT		_IOWR ('V', 47, int)
+#define VIDIOC_ENUMOUTPUT	_IOWR ('V', 48, struct v4l2_output)
+#define VIDIOC_G_AUDOUT		_IOR  ('V', 49, struct v4l2_audioout)
+#define VIDIOC_S_AUDOUT		_IOW  ('V', 50, struct v4l2_audioout)
+#define VIDIOC_G_MODULATOR	_IOWR ('V', 54, struct v4l2_modulator)
+#define VIDIOC_S_MODULATOR	_IOW  ('V', 55, struct v4l2_modulator)
+#define VIDIOC_G_FREQUENCY	_IOWR ('V', 56, struct v4l2_frequency)
+#define VIDIOC_S_FREQUENCY	_IOW  ('V', 57, struct v4l2_frequency)
+#define VIDIOC_CROPCAP		_IOR  ('V', 58, struct v4l2_cropcap)
+#define VIDIOC_G_CROP		_IOWR ('V', 59, struct v4l2_crop)
+#define VIDIOC_S_CROP		_IOW  ('V', 60, struct v4l2_crop)
+#define VIDIOC_G_JPEGCOMP	_IOR  ('V', 61, struct v4l2_jpegcompression)
+#define VIDIOC_S_JPEGCOMP	_IOW  ('V', 62, struct v4l2_jpegcompression)
+#define VIDIOC_QUERYSTD      	_IOR  ('V', 63, v4l2_std_id)
+#define VIDIOC_TRY_FMT      	_IOWR ('V', 64, struct v4l2_format)
+#define VIDIOC_ENUMAUDIO	_IOWR ('V', 65, struct v4l2_audio)
+#define VIDIOC_ENUMAUDOUT	_IOWR ('V', 66, struct v4l2_audioout)
+#define VIDIOC_G_PRIORITY       _IOR  ('V', 67, enum v4l2_priority)
+#define VIDIOC_S_PRIORITY       _IOW  ('V', 68, enum v4l2_priority)
+
+/* for compatibility, will go away some day */
+#define VIDIOC_OVERLAY_OLD     	_IOWR ('V', 14, int)
+#define VIDIOC_S_PARM_OLD      	_IOW  ('V', 22, struct v4l2_streamparm)
+#define VIDIOC_S_CTRL_OLD      	_IOW  ('V', 28, struct v4l2_control)
+#define VIDIOC_G_AUDIO_OLD     	_IOWR ('V', 33, struct v4l2_audio)
+#define VIDIOC_G_AUDOUT_OLD    	_IOWR ('V', 49, struct v4l2_audioout)
+
+#define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
+
+
+#ifdef __KERNEL__
+/*
+ *
+ *	V 4 L 2   D R I V E R   H E L P E R   A P I
+ *
+ *	Some commonly needed functions for drivers (v4l2-common.o module)
+ */
+#include <linux/fs.h>
+
+/*  Video standard functions  */
+extern unsigned int v4l2_video_std_fps(struct v4l2_standard *vs);
+extern int v4l2_video_std_construct(struct v4l2_standard *vs,
+				    int id, char *name);
+
+/* prority handling */
+struct v4l2_prio_state {
+	atomic_t prios[4];
+};
+int v4l2_prio_init(struct v4l2_prio_state *global);
+int v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,
+		     enum v4l2_priority new);
+int v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local);
+int v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority *local);
+enum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global);
+int v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority *local);
+
+/* names for fancy debug output */
+extern char *v4l2_field_names[];
+extern char *v4l2_type_names[];
+extern char *v4l2_ioctl_names[];
+
+/*  Compatibility layer interface  --  v4l1-compat module */
+typedef int (*v4l2_kioctl)(struct inode *inode, struct file *file,
+			   unsigned int cmd, void *arg);
+int v4l_compat_translate_ioctl(struct inode *inode, struct file *file,
+			       int cmd, void *arg, v4l2_kioctl driver_ioctl);
+
+#endif /* __KERNEL__ */
+#endif /* __LINUX_VIDEODEV2_H */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.4.33/include/linux/videodev.h linux-2.4.33-v4l2/include/linux/videodev.h
--- linux-2.4.33/include/linux/videodev.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.33-v4l2/include/linux/videodev.h	2006-08-11 21:35:33.000000000 +0200
@@ -4,6 +4,9 @@
 #include <linux/types.h>
 #include <linux/version.h>
 
+#define HAVE_V4L2 1
+#include <linux/videodev2.h>
+
 #ifdef __KERNEL__
 
 #include <linux/poll.h>
diff -Naur linux-2.4.33/Documentation/filesystems/cramfs.txt linux-2.4.33-cramfs/Documentation/filesystems/cramfs.txt
--- linux-2.4.33/Documentation/filesystems/cramfs.txt	2002-08-03 02:39:42.000000000 +0200
+++ linux-2.4.33-cramfs/Documentation/filesystems/cramfs.txt	2006-08-11 20:20:41.000000000 +0200
@@ -37,12 +37,11 @@
 the update lasts only as long as the inode is cached in memory, after
 which the timestamp reverts to 1970, i.e. moves backwards in time.
 
-Currently, cramfs must be written and read with architectures of the
-same endianness, and can be read only by kernels with PAGE_CACHE_SIZE
-== 4096.  At least the latter of these is a bug, but it hasn't been
-decided what the best fix is.  For the moment if you have larger pages
-you can just change the #define in mkcramfs.c, so long as you don't
-mind the filesystem becoming unreadable to future kernels.
+Currently, cramfs can be read only by kernels with PAGE_CACHE_SIZE ==
+4096.  This is a bug, but it hasn't been decided what the best fix is.
+For the moment if you have larger pages you can just change the
+#define in mkcramfs.c, so long as you don't mind the filesystem
+becoming unreadable to future kernels.
 
 
 For /usr/share/magic
diff -Naur linux-2.4.33/fs/cramfs/inode.c linux-2.4.33-cramfs/fs/cramfs/inode.c
--- linux-2.4.33/fs/cramfs/inode.c	2004-08-08 01:26:05.000000000 +0200
+++ linux-2.4.33-cramfs/fs/cramfs/inode.c	2006-08-11 20:20:41.000000000 +0200
@@ -1,13 +1,18 @@
 /*
- * Compressed rom filesystem for Linux.
+ * inode.c
  *
- * Copyright (C) 1999 Linus Torvalds.
+ * Copyright (C) 1999 Linus Torvalds
+ * Copyright (C) 2000-2002 Transmeta Corporation
  *
- * This file is released under the GPL.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * Compressed ROM filesystem for Linux.
  */
 
 /*
- * These are the VFS interfaces to the compressed rom filesystem.
+ * These are the VFS interfaces to the compressed ROM filesystem.
  * The actual compression is based on zlib, see the other files.
  */
 
@@ -39,7 +44,7 @@
 
 /* These two macros may change in future, to provide better st_ino
    semantics. */
-#define CRAMINO(x)	((x)->offset?(x)->offset<<2:1)
+#define CRAMINO(x)	(CRAMFS_GET_OFFSET(x) ? CRAMFS_GET_OFFSET(x)<<2 : 1)
 #define OFFSET(x)	((x)->i_ino)
 
 static struct inode *get_cramfs_inode(struct super_block *sb, struct cramfs_inode * cramfs_inode)
@@ -47,16 +52,16 @@
 	struct inode * inode = new_inode(sb);
 
 	if (inode) {
-		inode->i_mode = cramfs_inode->mode;
-		inode->i_uid = cramfs_inode->uid;
-		inode->i_size = cramfs_inode->size;
-		inode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;
+		inode->i_mode = CRAMFS_16(cramfs_inode->mode);
+		inode->i_uid = CRAMFS_16(cramfs_inode->uid);
+		inode->i_size = CRAMFS_24(cramfs_inode->size);
+		inode->i_blocks = (CRAMFS_24(cramfs_inode->size) - 1)/512 + 1;
 		inode->i_blksize = PAGE_CACHE_SIZE;
 		inode->i_gid = cramfs_inode->gid;
 		inode->i_ino = CRAMINO(cramfs_inode);
 		/* inode->i_nlink is left 1 - arguably wrong for directories,
 		   but it's the best we can do without reading the directory
-	           contents.  1 yields the right result in GNU find, even
+		   contents.  1 yields the right result in GNU find, even
 		   without -noleaf option. */
 		insert_inode_hash(inode);
 		if (S_ISREG(inode->i_mode)) {
@@ -70,7 +75,7 @@
 			inode->i_data.a_ops = &cramfs_aops;
 		} else {
 			inode->i_size = 0;
-			init_special_inode(inode, inode->i_mode, cramfs_inode->size);
+			init_special_inode(inode, inode->i_mode, CRAMFS_24(cramfs_inode->size));
 		}
 	}
 	return inode;
@@ -78,7 +83,7 @@
 
 /*
  * We have our own block cache: don't fill up the buffer cache
- * with the rom-image, because the way the filesystem is set
+ * with the ROM image, because the way the filesystem is set
  * up the accesses should be fairly regular and cached in the
  * page cache and dentry tree anyway..
  *
@@ -211,15 +216,18 @@
 	up(&read_mutex);
 
 	/* Do sanity checks on the superblock */
-	if (super.magic != CRAMFS_MAGIC) {
+	if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
 		/* check at 512 byte offset */
 		memcpy(&super, cramfs_read(sb, 512, sizeof(super)), sizeof(super));
-		if (super.magic != CRAMFS_MAGIC) {
+		if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
 			printk(KERN_ERR "cramfs: wrong magic\n");
 			goto out;
 		}
 	}
 
+	/* flags is reused several times, so swab it once */
+	super.flags = CRAMFS_32(super.flags);
+
 	/* get feature flags first */
 	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
 		printk(KERN_ERR "cramfs: unsupported filesystem features\n");
@@ -227,22 +235,22 @@
 	}
 
 	/* Check that the root inode is in a sane state */
-	if (!S_ISDIR(super.root.mode)) {
+	if (!S_ISDIR(CRAMFS_16(super.root.mode))) {
 		printk(KERN_ERR "cramfs: root is not a directory\n");
 		goto out;
 	}
-	root_offset = super.root.offset << 2;
+	root_offset = CRAMFS_GET_OFFSET(&(super.root)) << 2;
 	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
-		sb->CRAMFS_SB_SIZE=super.size;
-		sb->CRAMFS_SB_BLOCKS=super.fsid.blocks;
-		sb->CRAMFS_SB_FILES=super.fsid.files;
+		sb->CRAMFS_SB_SIZE = CRAMFS_32(super.size);
+		sb->CRAMFS_SB_BLOCKS = CRAMFS_32(super.fsid.blocks);
+		sb->CRAMFS_SB_FILES = CRAMFS_32(super.fsid.files);
 	} else {
-		sb->CRAMFS_SB_SIZE=1<<28;
-		sb->CRAMFS_SB_BLOCKS=0;
-		sb->CRAMFS_SB_FILES=0;
+		sb->CRAMFS_SB_SIZE = 1 << 28;
+		sb->CRAMFS_SB_BLOCKS = 0;
+		sb->CRAMFS_SB_FILES = 0;
 	}
-	sb->CRAMFS_SB_MAGIC=super.magic;
-	sb->CRAMFS_SB_FLAGS=super.flags;
+	sb->CRAMFS_SB_MAGIC = CRAMFS_MAGIC;
+	sb->CRAMFS_SB_FLAGS = super.flags;
 	if (root_offset == 0)
 		printk(KERN_INFO "cramfs: empty filesystem");
 	else if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&
@@ -309,7 +317,7 @@
 		 * and the name padded out to 4-byte boundaries
 		 * with zeroes.
 		 */
-		namelen = de->namelen << 2;
+		namelen = CRAMFS_GET_NAMELEN(de) << 2;
 		nextoffset = offset + sizeof(*de) + namelen;
 		for (;;) {
 			if (!namelen)
@@ -318,7 +326,7 @@
 				break;
 			namelen--;
 		}
-		error = filldir(dirent, name, namelen, offset, CRAMINO(de), de->mode >> 12);
+		error = filldir(dirent, name, namelen, offset, CRAMINO(de), CRAMFS_16(de->mode) >> 12);
 		if (error)
 			break;
 
@@ -351,7 +359,7 @@
 		if (sorted && (dentry->d_name.name[0] < name[0]))
 			break;
 
-		namelen = de->namelen << 2;
+		namelen = CRAMFS_GET_NAMELEN(de) << 2;
 		offset += sizeof(*de) + namelen;
 
 		/* Quick check that the name is roughly the right length */
@@ -398,8 +406,8 @@
 		start_offset = OFFSET(inode) + maxblock*4;
 		down(&read_mutex);
 		if (page->index)
-			start_offset = *(u32 *) cramfs_read(sb, blkptr_offset-4, 4);
-		compr_len = (*(u32 *) cramfs_read(sb, blkptr_offset, 4) - start_offset);
+			start_offset = CRAMFS_32(*(u32 *) cramfs_read(sb, blkptr_offset-4, 4));
+		compr_len = CRAMFS_32(*(u32 *) cramfs_read(sb, blkptr_offset, 4)) - start_offset;
 		up(&read_mutex);
 		pgdata = kmap(page);
 		if (compr_len == 0)
diff -Naur linux-2.4.33/fs/cramfs/README linux-2.4.33-cramfs/fs/cramfs/README
--- linux-2.4.33/fs/cramfs/README	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.33-cramfs/fs/cramfs/README	2006-08-11 20:20:41.000000000 +0200
@@ -6,8 +6,8 @@
 swapped around (though it does care that directory entries (inodes) in
 a given directory are contiguous, as this is used by readdir).
 
-All data is currently in host-endian format; neither mkcramfs nor the
-kernel ever do swabbing.  (See section `Block Size' below.)
+All data is in little-endian format; user-space tools and the kernel do
+swabbing on big-endian systems.  (See section `Byte Order' below.)
 
 <filesystem>:
 	<superblock>
@@ -71,6 +71,27 @@
 with -z if you want it to create files that can have holes in them.
 
 
+Byte Order
+----------
+
+When defining the cramfs filesystem, the two options for byte order were
+`always use little-endian' (like ext2fs) or `writer chooses endianness;
+kernel adapts at runtime'.  Little-endian wins because of code
+simplicity and little CPU overhead even on big-endian machines.
+
+While cramfs has always been defined to be little-endian, this
+implementation originally required that cramfs filesystems be written
+and read with architectures of the same endianness; big-endian machines
+would write and read cramfs filesystems with big-endian byte order (the
+"incorrect" byte order for cramfs filesystems).
+
+Now, only little-endian cramfs filesystems are supported for both
+little-endian and big-endian machines.  If you need to support
+big-endian cramfs filesystems for a legacy application on a big-endian
+machine, you could remove the byte-swapping, but it would probably be
+better to write a one-time byte order conversion program.
+
+
 Tools
 -----
 
@@ -108,17 +129,8 @@
 PAGE_CACHE_SIZE is subject to change between kernel versions
 (currently possible with arm and ia64).
 
-The remaining options try to make cramfs more sharable.
-
-One part of that is addressing endianness.  The two options here are
-`always use little-endian' (like ext2fs) or `writer chooses
-endianness; kernel adapts at runtime'.  Little-endian wins because of
-code simplicity and little CPU overhead even on big-endian machines.
-
-The cost of swabbing is changing the code to use the le32_to_cpu
-etc. macros as used by ext2fs.  We don't need to swab the compressed
-data, only the superblock, inodes and block pointers.
-
+The remaining options try to make cramfs more sharable by choosing a
+block size.  The options are:
 
 The other part of making cramfs more sharable is choosing a block
 size.  The options are:
@@ -153,7 +165,6 @@
 will disagree.  (If it is implemented, then I'll re-use that code in
 e2compr.)
 
-
 Another cost of 2 and 3 over 1 is making mkcramfs use a different
 block size, but that just means adding and parsing a -b option.
 
diff -Naur linux-2.4.33/fs/cramfs/uncompress.c linux-2.4.33-cramfs/fs/cramfs/uncompress.c
--- linux-2.4.33/fs/cramfs/uncompress.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.33-cramfs/fs/cramfs/uncompress.c	2006-08-11 20:20:41.000000000 +0200
@@ -1,7 +1,12 @@
 /*
  * uncompress.c
  *
- * (C) Copyright 1999 Linus Torvalds
+ * Copyright (C) 1999 Linus Torvalds
+ * Copyright (C) 2000-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
  *
  * cramfs interfaces to the uncompression library. There's really just
  * three entrypoints:
diff -Naur linux-2.4.33/include/linux/cramfs_fs.h linux-2.4.33-cramfs/include/linux/cramfs_fs.h
--- linux-2.4.33/include/linux/cramfs_fs.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.33-cramfs/include/linux/cramfs_fs.h	2006-08-11 20:20:41.000000000 +0200
@@ -1,13 +1,25 @@
-#ifndef __CRAMFS_H
-#define __CRAMFS_H
+#ifndef __CRAMFS_FS_H
+#define __CRAMFS_FS_H
 
-#ifndef __KERNEL__
+#ifdef __KERNEL__
+
+#include <asm/byteorder.h>
+
+/* Uncompression interfaces to the underlying zlib */
+int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen);
+int cramfs_uncompress_init(void);
+int cramfs_uncompress_exit(void);
+
+#else /* not __KERNEL__ */
+
+#include <byteswap.h>
+#include <endian.h>
 
 typedef unsigned char u8;
 typedef unsigned short u16;
 typedef unsigned int u32;
 
-#endif
+#endif /* not __KERNEL__ */
 
 #define CRAMFS_MAGIC		0x28cd3d45	/* some random number */
 #define CRAMFS_SIGNATURE	"Compressed ROMFS"
@@ -90,9 +102,50 @@
 				| CRAMFS_FLAG_WRONG_SIGNATURE \
 				| CRAMFS_FLAG_SHIFTED_ROOT_OFFSET )
 
-/* Uncompression interfaces to the underlying zlib */
-int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen);
-int cramfs_uncompress_init(void);
-int cramfs_uncompress_exit(void);
+/*
+ * Since cramfs is little-endian, provide macros to swab the bitfields.
+ */
+
+#ifndef __BYTE_ORDER
+#if defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN) && !defined(__LITTLE_ENDIAN)
+#define __BYTE_ORDER __BIG_ENDIAN
+#else
+#error "unable to define __BYTE_ORDER"
+#endif
+#endif /* not __BYTE_ORDER */
 
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#warning  "__BYTE_ORDER == __LITTLE_ENDIAN"
+#define CRAMFS_16(x)	(x)
+#define CRAMFS_24(x)	(x)
+#define CRAMFS_32(x)	(x)
+#define CRAMFS_GET_NAMELEN(x)	((x)->namelen)
+#define CRAMFS_GET_OFFSET(x)	((x)->offset)
+#define CRAMFS_SET_OFFSET(x,y)	((x)->offset = (y))
+#define CRAMFS_SET_NAMELEN(x,y)	((x)->namelen = (y))
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#warning "__BYTE_ORDER == __BIG_ENDIAN"
+#ifdef __KERNEL__
+#define CRAMFS_16(x)	swab16(x)
+#define CRAMFS_24(x)	((swab32(x)) >> 8)
+#define CRAMFS_32(x)	swab32(x)
+#else /* not __KERNEL__ */
+#define CRAMFS_16(x)	bswap_16(x)
+#define CRAMFS_24(x)	((bswap_32(x)) >> 8)
+#define CRAMFS_32(x)	bswap_32(x)
+#endif /* not __KERNEL__ */
+#define CRAMFS_GET_NAMELEN(x)	(((u8*)(x))[8] & 0x3f)
+#define CRAMFS_GET_OFFSET(x)	((CRAMFS_24(((u32*)(x))[2] & 0xffffff) << 2) |\
+				 ((((u32*)(x))[2] & 0xc0000000) >> 30))
+#define CRAMFS_SET_NAMELEN(x,y)	(((u8*)(x))[8] = (((0x3f & (y))) | \
+						  (0xc0 & ((u8*)(x))[8])))
+#define CRAMFS_SET_OFFSET(x,y)	(((u32*)(x))[2] = (((y) & 3) << 30) | \
+				 CRAMFS_24((((y) & 0x03ffffff) >> 2)) | \
+				 (((u32)(((u8*)(x))[8] & 0x3f)) << 24))
+#else
+#error "__BYTE_ORDER must be __LITTLE_ENDIAN or __BIG_ENDIAN"
 #endif
+
+#endif /* not __CRAMFS_FS_H */
diff -Naur linux-2.4.33/scripts/cramfs/cramfsck.c linux-2.4.33-cramfs/scripts/cramfs/cramfsck.c
--- linux-2.4.33/scripts/cramfs/cramfsck.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-cramfs/scripts/cramfs/cramfsck.c	2006-08-11 20:20:41.000000000 +0200
@@ -0,0 +1,718 @@
+/*
+ * cramfsck - check a cramfs file system
+ *
+ * Copyright (C) 2000-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * 1999/12/03: Linus Torvalds (cramfs tester and unarchive program)
+ * 2000/06/03: Daniel Quinlan (CRC and length checking program)
+ * 2000/06/04: Daniel Quinlan (merged programs, added options, support
+ *                            for special files, preserve permissions and
+ *                            ownership, cramfs superblock v2, bogus mode
+ *                            test, pathname length test, etc.)
+ * 2000/06/06: Daniel Quinlan (support for holes, pretty-printing,
+ *                            symlink size test)
+ * 2000/07/11: Daniel Quinlan (file length tests, start at offset 0 or 512,
+ *                            fsck-compatible exit codes)
+ * 2000/07/15: Daniel Quinlan (initial support for block devices)
+ * 2002/01/10: Daniel Quinlan (additional checks, test more return codes,
+ *                            use read if mmap fails, standardize messages)
+ * 2002/02/22: Brad Bozarth   (add support for big-endian systems)
+ */
+
+/* compile-time options */
+#define INCLUDE_FS_TESTS	/* include cramfs checking and extraction */
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/sysmacros.h>
+#include <utime.h>
+#include <sys/ioctl.h>
+#define _LINUX_STRING_H_
+#include <linux/fs.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+/* Exit codes used by fsck-type programs */
+#define FSCK_OK          0	/* No errors */
+#define FSCK_NONDESTRUCT 1	/* File system errors corrected */
+#define FSCK_REBOOT      2	/* System should be rebooted */
+#define FSCK_UNCORRECTED 4	/* File system errors left uncorrected */
+#define FSCK_ERROR       8	/* Operational error */
+#define FSCK_USAGE       16	/* Usage or syntax error */
+#define FSCK_LIBRARY     128	/* Shared library error */
+
+#define PAD_SIZE 512
+#define PAGE_CACHE_SIZE (4096)
+
+static const char *progname = "cramfsck";
+
+static int fd;			/* ROM image file descriptor */
+static char *filename;		/* ROM image filename */
+struct cramfs_super super;	/* just find the cramfs superblock once */
+static int opt_verbose = 0;	/* 1 = verbose (-v), 2+ = very verbose (-vv) */
+#ifdef INCLUDE_FS_TESTS
+static int opt_extract = 0;		/* extract cramfs (-x) */
+static char *extract_dir = "root";	/* extraction directory (-x) */
+static uid_t euid;			/* effective UID */
+
+/* (cramfs_super + start) <= start_dir < end_dir <= start_data <= end_data */
+static unsigned long start_dir = ~0UL;	/* start of first non-root inode */
+static unsigned long end_dir = 0;	/* end of the directory structure */
+static unsigned long start_data = ~0UL;	/* start of the data (256 MB = max) */
+static unsigned long end_data = 0;	/* end of the data */
+
+/* Guarantee access to at least 8kB at a time */
+#define ROMBUFFER_BITS	13
+#define ROMBUFFERSIZE	(1 << ROMBUFFER_BITS)
+#define ROMBUFFERMASK	(ROMBUFFERSIZE-1)
+static char read_buffer[ROMBUFFERSIZE * 2];
+static unsigned long read_buffer_block = ~0UL;
+
+/* Uncompressing data structures... */
+static char outbuffer[PAGE_CACHE_SIZE*2];
+static z_stream stream;
+
+/* Prototypes */
+static void expand_fs(char *, struct cramfs_inode *);
+#endif /* INCLUDE_FS_TESTS */
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-hv] [-x dir] file\n"
+		" -h         print this help\n"
+		" -x dir     extract into dir\n"
+		" -v         be more verbose\n"
+		" file       file to test\n", progname);
+
+	exit(status);
+}
+
+static void die(int status, int syserr, const char *fmt, ...)
+{
+	va_list arg_ptr;
+	int save = errno;
+
+	fflush(0);
+	va_start(arg_ptr, fmt);
+	fprintf(stderr, "%s: ", progname);
+	vfprintf(stderr, fmt, arg_ptr);
+	if (syserr) {
+		fprintf(stderr, ": %s", strerror(save));
+	}
+	fprintf(stderr, "\n");
+	va_end(arg_ptr);
+	exit(status);
+}
+
+static void test_super(int *start, size_t *length) {
+	struct stat st;
+
+	/* find the physical size of the file or block device */
+	if (stat(filename, &st) < 0) {
+		die(FSCK_ERROR, 1, "stat failed: %s", filename);
+	}
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		die(FSCK_ERROR, 1, "open failed: %s", filename);
+	}
+	if (S_ISBLK(st.st_mode)) {
+		if (ioctl(fd, BLKGETSIZE, length) < 0) {
+			die(FSCK_ERROR, 1, "ioctl failed: unable to determine device size: %s", filename);
+		}
+		*length = *length * 512;
+	}
+	else if (S_ISREG(st.st_mode)) {
+		*length = st.st_size;
+	}
+	else {
+		die(FSCK_ERROR, 0, "not a block device or file: %s", filename);
+	}
+
+	if (*length < sizeof(struct cramfs_super)) {
+		die(FSCK_UNCORRECTED, 0, "file length too short");
+	}
+
+	/* find superblock */
+	if (read(fd, &super, sizeof(super)) != sizeof(super)) {
+		die(FSCK_ERROR, 1, "read failed: %s", filename);
+	}
+	if (super.magic == CRAMFS_32(CRAMFS_MAGIC)) {
+		*start = 0;
+	}
+	else if (*length >= (PAD_SIZE + sizeof(super))) {
+		lseek(fd, PAD_SIZE, SEEK_SET);
+		if (read(fd, &super, sizeof(super)) != sizeof(super)) {
+			die(FSCK_ERROR, 1, "read failed: %s", filename);
+		}
+		if (super.magic == CRAMFS_32(CRAMFS_MAGIC)) {
+			*start = PAD_SIZE;
+		}
+	}
+
+	/* superblock tests */
+	if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
+		die(FSCK_UNCORRECTED, 0, "superblock magic not found");
+	}
+#if __BYTE_ORDER == __BIG_ENDIAN
+	super.size = CRAMFS_32(super.size);
+	super.flags = CRAMFS_32(super.flags);
+	super.future = CRAMFS_32(super.future);
+	super.fsid.crc = CRAMFS_32(super.fsid.crc);
+	super.fsid.edition = CRAMFS_32(super.fsid.edition);
+	super.fsid.blocks = CRAMFS_32(super.fsid.blocks);
+	super.fsid.files = CRAMFS_32(super.fsid.files);
+#endif /* __BYTE_ORDER == __BIG_ENDIAN */
+	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
+		die(FSCK_ERROR, 0, "unsupported filesystem features");
+	}
+	if (super.size < PAGE_CACHE_SIZE) {
+		die(FSCK_UNCORRECTED, 0, "superblock size (%d) too small", super.size);
+	}
+	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		if (super.fsid.files == 0) {
+			die(FSCK_UNCORRECTED, 0, "zero file count");
+		}
+		if (*length < super.size) {
+			die(FSCK_UNCORRECTED, 0, "file length too short");
+		}
+		else if (*length > super.size) {
+			fprintf(stderr, "warning: file extends past end of filesystem\n");
+		}
+	}
+	else {
+		fprintf(stderr, "warning: old cramfs format\n");
+	}
+}
+
+static void test_crc(int start)
+{
+	void *buf;
+	u32 crc;
+
+	if (!(super.flags & CRAMFS_FLAG_FSID_VERSION_2)) {
+#ifdef INCLUDE_FS_TESTS
+		return;
+#else /* not INCLUDE_FS_TESTS */
+		die(FSCK_USAGE, 0, "unable to test CRC: old cramfs format");
+#endif /* not INCLUDE_FS_TESTS */
+	}
+
+	crc = crc32(0L, Z_NULL, 0);
+
+	buf = mmap(NULL, super.size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+	if (buf == MAP_FAILED) {
+		buf = mmap(NULL, super.size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+		if (buf != MAP_FAILED) {
+			lseek(fd, 0, SEEK_SET);
+			read(fd, buf, super.size);
+		}
+	}
+	if (buf != MAP_FAILED) {
+		((struct cramfs_super *) (buf+start))->fsid.crc = crc32(0L, Z_NULL, 0);
+		crc = crc32(crc, buf+start, super.size-start);
+		munmap(buf, super.size);
+	}
+	else {
+		int retval;
+		size_t length = 0;
+
+		buf = malloc(4096);
+		if (!buf) {
+			die(FSCK_ERROR, 1, "malloc failed");
+		}
+		lseek(fd, start, SEEK_SET);
+		for (;;) {
+			retval = read(fd, buf, 4096);
+			if (retval < 0) {
+				die(FSCK_ERROR, 1, "read failed: %s", filename);
+			}
+			else if (retval == 0) {
+				break;
+			}
+			if (length == 0) {
+				((struct cramfs_super *) buf)->fsid.crc = crc32(0L, Z_NULL, 0);
+			}
+			length += retval;
+			if (length > (super.size-start)) {
+				crc = crc32(crc, buf, retval - (length - (super.size-start)));
+				break;
+			}
+			crc = crc32(crc, buf, retval);
+		}
+		free(buf);
+	}
+
+	if (crc != super.fsid.crc) {
+		die(FSCK_UNCORRECTED, 0, "crc error");
+	}
+}
+
+#ifdef INCLUDE_FS_TESTS
+static void print_node(char type, struct cramfs_inode *i, char *name)
+{
+	char info[10];
+
+	if (S_ISCHR(i->mode) || (S_ISBLK(i->mode))) {
+		/* major/minor numbers can be as high as 2^12 or 4096 */
+		snprintf(info, 10, "%4d,%4d", major(i->size), minor(i->size));
+	}
+	else {
+		/* size be as high as 2^24 or 16777216 */
+		snprintf(info, 10, "%9d", i->size);
+	}
+
+	printf("%c %04o %s %5d:%-3d %s\n",
+	       type, i->mode & ~S_IFMT, info, i->uid, i->gid, name);
+}
+
+/*
+ * Create a fake "blocked" access
+ */
+static void *romfs_read(unsigned long offset)
+{
+	unsigned int block = offset >> ROMBUFFER_BITS;
+	if (block != read_buffer_block) {
+		read_buffer_block = block;
+		lseek(fd, block << ROMBUFFER_BITS, SEEK_SET);
+		read(fd, read_buffer, ROMBUFFERSIZE * 2);
+	}
+	return read_buffer + (offset & ROMBUFFERMASK);
+}
+
+static struct cramfs_inode *cramfs_iget(struct cramfs_inode *i)
+{
+	struct cramfs_inode *inode = malloc(sizeof(struct cramfs_inode));
+
+	if (!inode) {
+		die(FSCK_ERROR, 1, "malloc failed");
+	}
+#if __BYTE_ORDER == __BIG_ENDIAN
+	inode->mode = CRAMFS_16(i->mode);
+	inode->uid = CRAMFS_16(i->uid);
+	inode->size = CRAMFS_24(i->size);
+	inode->gid = i->gid;
+	inode->namelen = CRAMFS_GET_NAMELEN(i);
+	inode->offset = CRAMFS_GET_OFFSET(i);
+#else /* not __BYTE_ORDER == __BIG_ENDIAN */
+	*inode = *i;
+#endif /* not __BYTE_ORDER == __BIG_ENDIAN */
+	return inode;
+}
+
+static struct cramfs_inode *iget(unsigned int ino)
+{
+	return cramfs_iget(romfs_read(ino));
+}
+
+static void iput(struct cramfs_inode *inode)
+{
+	free(inode);
+}
+
+static int uncompress_block(void *src, int len)
+{
+	int err;
+
+	stream.next_in = src;
+	stream.avail_in = len;
+
+	stream.next_out = (unsigned char *) outbuffer;
+	stream.avail_out = PAGE_CACHE_SIZE*2;
+
+	inflateReset(&stream);
+
+	if (len > PAGE_CACHE_SIZE*2) {
+		die(FSCK_UNCORRECTED, 0, "data block too large");
+	}
+	err = inflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END) {
+		die(FSCK_UNCORRECTED, 0, "decompression error %p(%d): %s",
+		    zError(err), src, len);
+	}
+	return stream.total_out;
+}
+
+static void do_uncompress(char *path, int fd, unsigned long offset, unsigned long size)
+{
+	unsigned long curr = offset + 4 * ((size + PAGE_CACHE_SIZE - 1) / PAGE_CACHE_SIZE);
+
+	do {
+		unsigned long out = PAGE_CACHE_SIZE;
+		unsigned long next = CRAMFS_32(*(u32 *) romfs_read(offset));
+
+		if (next > end_data) {
+			end_data = next;
+		}
+
+		offset += 4;
+		if (curr == next) {
+			if (opt_verbose > 1) {
+				printf("  hole at %ld (%d)\n", curr, PAGE_CACHE_SIZE);
+			}
+			if (size < PAGE_CACHE_SIZE)
+				out = size;
+			memset(outbuffer, 0x00, out);
+		}
+		else {
+			if (opt_verbose > 1) {
+				printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+			}
+			out = uncompress_block(romfs_read(curr), next - curr);
+		}
+		if (size >= PAGE_CACHE_SIZE) {
+			if (out != PAGE_CACHE_SIZE) {
+				die(FSCK_UNCORRECTED, 0, "non-block (%ld) bytes", out);
+			}
+		} else {
+			if (out != size) {
+				die(FSCK_UNCORRECTED, 0, "non-size (%ld vs %ld) bytes", out, size);
+			}
+		}
+		size -= out;
+		if (opt_extract) {
+			if (write(fd, outbuffer, out) < 0) {
+				die(FSCK_ERROR, 1, "write failed: %s", path);
+			}
+		}
+		curr = next;
+	} while (size);
+}
+
+static void change_file_status(char *path, struct cramfs_inode *i)
+{
+	struct utimbuf epoch = { 0, 0 };
+
+	if (euid == 0) {
+		if (lchown(path, i->uid, i->gid) < 0) {
+			die(FSCK_ERROR, 1, "lchown failed: %s", path);
+		}
+		if (S_ISLNK(i->mode))
+			return;
+		if ((S_ISUID | S_ISGID) & i->mode) {
+			if (chmod(path, i->mode) < 0) {
+				die(FSCK_ERROR, 1, "chown failed: %s", path);
+			}
+		}
+	}
+	if (S_ISLNK(i->mode))
+		return;
+	if (utime(path, &epoch) < 0) {
+		die(FSCK_ERROR, 1, "utime failed: %s", path);
+	}
+}
+
+static void do_directory(char *path, struct cramfs_inode *i)
+{
+	int pathlen = strlen(path);
+	int count = i->size;
+	unsigned long offset = i->offset << 2;
+	char *newpath = malloc(pathlen + 256);
+
+	if (!newpath) {
+		die(FSCK_ERROR, 1, "malloc failed");
+	}
+	if (offset == 0 && count != 0) {
+		die(FSCK_UNCORRECTED, 0, "directory inode has zero offset and non-zero size: %s", path);
+	}
+	if (offset != 0 && offset < start_dir) {
+		start_dir = offset;
+	}
+	/* TODO: Do we need to check end_dir for empty case? */
+	memcpy(newpath, path, pathlen);
+	newpath[pathlen] = '/';
+	pathlen++;
+	if (opt_verbose) {
+		print_node('d', i, path);
+	}
+	if (opt_extract) {
+		if (mkdir(path, i->mode) < 0) {
+			die(FSCK_ERROR, 1, "mkdir failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+	while (count > 0) {
+		struct cramfs_inode *child = iget(offset);
+		int size;
+		int newlen = child->namelen << 2;
+
+		size = sizeof(struct cramfs_inode) + newlen;
+		count -= size;
+
+		offset += sizeof(struct cramfs_inode);
+
+		memcpy(newpath + pathlen, romfs_read(offset), newlen);
+		newpath[pathlen + newlen] = 0;
+		if (newlen == 0) {
+			die(FSCK_UNCORRECTED, 0, "filename length is zero");
+		}
+		if ((pathlen + newlen) - strlen(newpath) > 3) {
+			die(FSCK_UNCORRECTED, 0, "bad filename length");
+		}
+		expand_fs(newpath, child);
+
+		offset += newlen;
+
+		if (offset <= start_dir) {
+			die(FSCK_UNCORRECTED, 0, "bad inode offset");
+		}
+		if (offset > end_dir) {
+			end_dir = offset;
+		}
+		iput(child); /* free(child) */
+	}
+	free(newpath);
+}
+
+static void do_file(char *path, struct cramfs_inode *i)
+{
+	unsigned long offset = i->offset << 2;
+	int fd = 0;
+
+	if (offset == 0 && i->size != 0) {
+		die(FSCK_UNCORRECTED, 0, "file inode has zero offset and non-zero size");
+	}
+	if (i->size == 0 && offset != 0) {
+		die(FSCK_UNCORRECTED, 0, "file inode has zero size and non-zero offset");
+	}
+	if (offset != 0 && offset < start_data) {
+		start_data = offset;
+	}
+	if (opt_verbose) {
+		print_node('f', i, path);
+	}
+	if (opt_extract) {
+		fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, i->mode);
+		if (fd < 0) {
+			die(FSCK_ERROR, 1, "open failed: %s", path);
+		}
+	}
+	if (i->size) {
+		do_uncompress(path, fd, offset, i->size);
+	}
+	if (opt_extract) {
+		close(fd);
+		change_file_status(path, i);
+	}
+}
+
+static void do_symlink(char *path, struct cramfs_inode *i)
+{
+	unsigned long offset = i->offset << 2;
+	unsigned long curr = offset + 4;
+	unsigned long next = CRAMFS_32(*(u32 *) romfs_read(offset));
+	unsigned long size;
+
+	if (offset == 0) {
+		die(FSCK_UNCORRECTED, 0, "symbolic link has zero offset");
+	}
+	if (i->size == 0) {
+		die(FSCK_UNCORRECTED, 0, "symbolic link has zero size");
+	}
+
+	if (offset < start_data) {
+		start_data = offset;
+	}
+	if (next > end_data) {
+		end_data = next;
+	}
+
+	size = uncompress_block(romfs_read(curr), next - curr);
+	if (size != i->size) {
+		die(FSCK_UNCORRECTED, 0, "size error in symlink: %s", path);
+	}
+	outbuffer[size] = 0;
+	if (opt_verbose) {
+		char *str;
+
+		asprintf(&str, "%s -> %s", path, outbuffer);
+		print_node('l', i, str);
+		if (opt_verbose > 1) {
+			printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+		}
+		free(str);
+	}
+	if (opt_extract) {
+		if (symlink(outbuffer, path) < 0) {
+			die(FSCK_ERROR, 1, "symlink failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+}
+
+static void do_special_inode(char *path, struct cramfs_inode *i)
+{
+	dev_t devtype = 0;
+	char type;
+
+	if (i->offset) {	/* no need to shift offset */
+		die(FSCK_UNCORRECTED, 0, "special file has non-zero offset: %s", path);
+	}
+	if (S_ISCHR(i->mode)) {
+		devtype = i->size;
+		type = 'c';
+	}
+	else if (S_ISBLK(i->mode)) {
+		devtype = i->size;
+		type = 'b';
+	}
+	else if (S_ISFIFO(i->mode)) {
+		if (i->size != 0) {
+			die(FSCK_UNCORRECTED, 0, "fifo has non-zero size: %s", path);
+		}
+		type = 'p';
+	}
+	else if (S_ISSOCK(i->mode)) {
+		if (i->size != 0) {
+			die(FSCK_UNCORRECTED, 0, "socket has non-zero size: %s", path);
+		}
+		type = 's';
+	}
+	else {
+		die(FSCK_UNCORRECTED, 0, "bogus mode: %s (%o)", path, i->mode);
+		return;		/* not reached */
+	}
+
+	if (opt_verbose) {
+		print_node(type, i, path);
+	}
+
+	if (opt_extract) {
+		if (mknod(path, i->mode, devtype) < 0) {
+			die(FSCK_ERROR, 1, "mknod failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+}
+
+static void expand_fs(char *path, struct cramfs_inode *inode)
+{
+	if (S_ISDIR(inode->mode)) {
+		do_directory(path, inode);
+	}
+	else if (S_ISREG(inode->mode)) {
+		do_file(path, inode);
+	}
+	else if (S_ISLNK(inode->mode)) {
+		do_symlink(path, inode);
+	}
+	else {
+		do_special_inode(path, inode);
+	}
+}
+
+static void test_fs(int start)
+{
+	struct cramfs_inode *root;
+	unsigned long root_offset;
+
+	root = cramfs_iget(&super.root);
+	root_offset = root->offset << 2;
+	if (!S_ISDIR(root->mode))
+		die(FSCK_UNCORRECTED, 0, "root inode is not directory");
+	if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&
+	    ((root_offset != sizeof(struct cramfs_super)) &&
+	     (root_offset != PAD_SIZE + sizeof(struct cramfs_super))))
+	{
+		die(FSCK_UNCORRECTED, 0, "bad root offset (%lu)", root_offset);
+	}
+	umask(0);
+	euid = geteuid();
+	stream.next_in = NULL;
+	stream.avail_in = 0;
+	inflateInit(&stream);
+	expand_fs(extract_dir, root);
+	inflateEnd(&stream);
+	if (start_data != ~0UL) {
+		if (start_data < (sizeof(struct cramfs_super) + start)) {
+			die(FSCK_UNCORRECTED, 0, "directory data start (%ld) < sizeof(struct cramfs_super) + start (%ld)", start_data, sizeof(struct cramfs_super) + start);
+		}
+		if (end_dir != start_data) {
+			die(FSCK_UNCORRECTED, 0, "directory data end (%ld) != file data start (%ld)", end_dir, start_data);
+		}
+	}
+	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		if (end_data > super.size) {
+			die(FSCK_UNCORRECTED, 0, "invalid file data offset");
+		}
+	}
+	iput(root);		/* free(root) */
+}
+#endif /* INCLUDE_FS_TESTS */
+
+int main(int argc, char **argv)
+{
+	int c;			/* for getopt */
+	int start = 0;
+	size_t length;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hx:v")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(FSCK_OK);
+		case 'x':
+#ifdef INCLUDE_FS_TESTS
+			opt_extract = 1;
+			extract_dir = optarg;
+			break;
+#else /* not INCLUDE_FS_TESTS */
+			die(FSCK_USAGE, 0, "compiled without -x support");
+#endif /* not INCLUDE_FS_TESTS */
+		case 'v':
+			opt_verbose++;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 1)
+		usage(FSCK_USAGE);
+	filename = argv[optind];
+
+	test_super(&start, &length);
+	test_crc(start);
+#ifdef INCLUDE_FS_TESTS
+	test_fs(start);
+#endif /* INCLUDE_FS_TESTS */
+
+	if (opt_verbose) {
+		printf("%s: OK\n", filename);
+	}
+
+	exit(FSCK_OK);
+}
+
+/*
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
diff -Naur linux-2.4.33/scripts/cramfs/GNUmakefile linux-2.4.33-cramfs/scripts/cramfs/GNUmakefile
--- linux-2.4.33/scripts/cramfs/GNUmakefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-cramfs/scripts/cramfs/GNUmakefile	2006-08-11 20:20:41.000000000 +0200
@@ -0,0 +1,12 @@
+CC = gcc
+CFLAGS = -W -Wall -O2 -g
+CPPFLAGS = -I../../include
+LDLIBS = -lz
+PROGS = mkcramfs cramfsck
+
+all: $(PROGS)
+
+distclean clean:
+	rm -f $(PROGS)
+
+.PHONY: all clean
diff -Naur linux-2.4.33/scripts/cramfs/Makefile linux-2.4.33-cramfs/scripts/cramfs/Makefile
--- linux-2.4.33/scripts/cramfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-cramfs/scripts/cramfs/Makefile	2006-08-11 20:20:41.000000000 +0200
@@ -0,0 +1,12 @@
+CC = gcc
+CFLAGS = -W -Wall -O2 -g
+CPPFLAGS = -I../../include
+LDLIBS = -lz
+PROGS = mkcramfs cramfsck
+
+all: $(PROGS)
+
+distclean clean:
+	rm -f $(PROGS)
+
+.PHONY: all clean
diff -Naur linux-2.4.33/scripts/cramfs/mkcramfs.c linux-2.4.33-cramfs/scripts/cramfs/mkcramfs.c
--- linux-2.4.33/scripts/cramfs/mkcramfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33-cramfs/scripts/cramfs/mkcramfs.c	2006-08-11 20:20:41.000000000 +0200
@@ -0,0 +1,879 @@
+/*
+ * mkcramfs - make a cramfs file system
+ *
+ * Copyright (C) 1999-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * If you change the disk format of cramfs, please update fs/cramfs/README.
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <stdarg.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+/* Exit codes used by mkfs-type programs */
+#define MKFS_OK          0	/* No errors */
+#define MKFS_ERROR       8	/* Operational error */
+#define MKFS_USAGE       16	/* Usage or syntax error */
+
+/* The kernel only supports PAD_SIZE of 0 and 512. */
+#define PAD_SIZE 512
+
+/* The kernel assumes PAGE_CACHE_SIZE as block size. */
+#define PAGE_CACHE_SIZE (4096)
+
+/*
+ * The longest filename component to allow for in the input directory tree.
+ * ext2fs (and many others) allow up to 255 bytes.  A couple of filesystems
+ * allow longer (e.g. smbfs 1024), but there isn't much use in supporting
+ * >255-byte names in the input directory tree given that such names get
+ * truncated to CRAMFS_MAXPATHLEN (252 bytes) when written to cramfs.
+ *
+ * Old versions of mkcramfs generated corrupted filesystems if any input
+ * filenames exceeded CRAMFS_MAXPATHLEN (252 bytes), however old
+ * versions of cramfsck seem to have been able to detect the corruption.
+ */
+#define MAX_INPUT_NAMELEN 255
+
+/*
+ * Maximum size fs you can create is roughly 256MB.  (The last file's
+ * data must begin within 256MB boundary but can extend beyond that.)
+ *
+ * Note that if you want it to fit in a ROM then you're limited to what the
+ * hardware and kernel can support.
+ */
+#define MAXFSLEN ((((1 << CRAMFS_OFFSET_WIDTH) - 1) << 2) /* offset */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) - 1 /* filesize */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) * 4 / PAGE_CACHE_SIZE /* block pointers */ )
+
+static const char *progname = "mkcramfs";
+static unsigned int blksize = PAGE_CACHE_SIZE;
+static long total_blocks = 0, total_nodes = 1; /* pre-count the root node */
+static int image_length = 0;
+
+/*
+ * If opt_holes is set, then mkcramfs can create explicit holes in the
+ * data, which saves 26 bytes per hole (which is a lot smaller a
+ * saving than most most filesystems).
+ *
+ * Note that kernels up to at least 2.3.39 don't support cramfs holes,
+ * which is why this is turned off by default.
+ *
+ * If opt_verbose is 1, be verbose.  If it is higher, be even more verbose.
+ */
+static u32 opt_edition = 0;
+static int opt_errors = 0;
+static int opt_holes = 0;
+static int opt_pad = 0;
+static int opt_verbose = 0;
+static char *opt_image = NULL;
+static char *opt_name = NULL;
+
+static int warn_dev, warn_gid, warn_namelen, warn_skip, warn_size, warn_uid;
+
+/* In-core version of inode / directory entry. */
+struct entry {
+	/* stats */
+	unsigned char *name;
+	unsigned int mode, size, uid, gid;
+
+	/* these are only used for non-empty files */
+	char *path;		/* always null except non-empty files */
+	int fd;			/* temporarily open files while mmapped */
+
+	/* FS data */
+	void *uncompressed;
+	/* points to other identical file */
+	struct entry *same;
+	unsigned int offset;		/* pointer to compressed data in archive */
+	unsigned int dir_offset;	/* Where in the archive is the directory entry? */
+
+	/* organization */
+	struct entry *child; /* null for non-directories and empty directories */
+	struct entry *next;
+};
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-h] [-e edition] [-i file] [-n name] dirname outfile\n"
+		" -h         print this help\n"
+		" -E         make all warnings errors (non-zero exit status)\n"
+		" -e edition set edition number (part of fsid)\n"
+		" -i file    insert a file image into the filesystem (requires >= 2.4.0)\n"
+		" -n name    set name of cramfs filesystem\n"
+		" -p         pad by %d bytes for boot code\n"
+		" -s         sort directory entries (old option, ignored)\n"
+		" -v         be more verbose\n"
+		" -z         make explicit holes (requires >= 2.3.39)\n"
+		" dirname    root of the directory tree to be compressed\n"
+		" outfile    output file\n", progname, PAD_SIZE);
+
+	exit(status);
+}
+
+static void die(int status, int syserr, const char *fmt, ...)
+{
+	va_list arg_ptr;
+	int save = errno;
+
+	fflush(0);
+	va_start(arg_ptr, fmt);
+	fprintf(stderr, "%s: ", progname);
+	vfprintf(stderr, fmt, arg_ptr);
+	if (syserr) {
+		fprintf(stderr, ": %s", strerror(save));
+	}
+	fprintf(stderr, "\n");
+	va_end(arg_ptr);
+	exit(status);
+}
+
+static void map_entry(struct entry *entry)
+{
+	if (entry->path) {
+		entry->fd = open(entry->path, O_RDONLY);
+		if (entry->fd < 0) {
+			die(MKFS_ERROR, 1, "open failed: %s", entry->path);
+		}
+		entry->uncompressed = mmap(NULL, entry->size, PROT_READ, MAP_PRIVATE, entry->fd, 0);
+		if (entry->uncompressed == MAP_FAILED) {
+			die(MKFS_ERROR, 1, "mmap failed: %s", entry->path);
+		}
+	}
+}
+
+static void unmap_entry(struct entry *entry)
+{
+	if (entry->path) {
+		if (munmap(entry->uncompressed, entry->size) < 0) {
+			die(MKFS_ERROR, 1, "munmap failed: %s", entry->path);
+		}
+		close(entry->fd);
+	}
+}
+
+static int find_identical_file(struct entry *orig, struct entry *newfile)
+{
+	if (orig == newfile)
+		return 1;
+	if (!orig)
+		return 0;
+	if (orig->size == newfile->size && (orig->path || orig->uncompressed))
+	{
+		map_entry(orig);
+		map_entry(newfile);
+		if (!memcmp(orig->uncompressed, newfile->uncompressed, orig->size))
+		{
+			newfile->same = orig;
+			unmap_entry(newfile);
+			unmap_entry(orig);
+			return 1;
+		}
+		unmap_entry(newfile);
+		unmap_entry(orig);
+	}
+	return (find_identical_file(orig->child, newfile) ||
+		find_identical_file(orig->next, newfile));
+}
+
+static void eliminate_doubles(struct entry *root, struct entry *orig) {
+	if (orig) {
+		if (orig->size && (orig->path || orig->uncompressed))
+			find_identical_file(root, orig);
+		eliminate_doubles(root, orig->child);
+		eliminate_doubles(root, orig->next);
+	}
+}
+
+/*
+ * We define our own sorting function instead of using alphasort which
+ * uses strcoll and changes ordering based on locale information.
+ */
+static int cramsort (const void *a, const void *b)
+{
+	return strcmp ((*(const struct dirent **) a)->d_name,
+		       (*(const struct dirent **) b)->d_name);
+}
+
+static unsigned int parse_directory(struct entry *root_entry, const char *name, struct entry **prev, loff_t *fslen_ub)
+{
+	struct dirent **dirlist;
+	int totalsize = 0, dircount, dirindex;
+	char *path, *endpath;
+	size_t len = strlen(name);
+
+	/* Set up the path. */
+	/* TODO: Reuse the parent's buffer to save memcpy'ing and duplication. */
+	path = malloc(len + 1 + MAX_INPUT_NAMELEN + 1);
+	if (!path) {
+		die(MKFS_ERROR, 1, "malloc failed");
+	}
+	memcpy(path, name, len);
+	endpath = path + len;
+	*endpath = '/';
+	endpath++;
+
+	/* read in the directory and sort */
+	dircount = scandir(name, &dirlist, 0, cramsort);
+
+	if (dircount < 0) {
+		die(MKFS_ERROR, 1, "scandir failed: %s", name);
+	}
+
+	/* process directory */
+	for (dirindex = 0; dirindex < dircount; dirindex++) {
+		struct dirent *dirent;
+		struct entry *entry;
+		struct stat st;
+		int size;
+		size_t namelen;
+
+		dirent = dirlist[dirindex];
+
+		/* Ignore "." and ".." - we won't be adding them to the archive */
+		if (dirent->d_name[0] == '.') {
+			if (dirent->d_name[1] == '\0')
+				continue;
+			if (dirent->d_name[1] == '.') {
+				if (dirent->d_name[2] == '\0')
+					continue;
+			}
+		}
+		namelen = strlen(dirent->d_name);
+		if (namelen > MAX_INPUT_NAMELEN) {
+			die(MKFS_ERROR, 0,
+				"very long (%u bytes) filename found: %s\n"
+				"please increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile",
+				namelen, dirent->d_name);
+		}
+		memcpy(endpath, dirent->d_name, namelen + 1);
+
+		if (lstat(path, &st) < 0) {
+			warn_skip = 1;
+			continue;
+		}
+		entry = calloc(1, sizeof(struct entry));
+		if (!entry) {
+			die(MKFS_ERROR, 1, "calloc failed");
+		}
+		entry->name = strdup(dirent->d_name);
+		if (!entry->name) {
+			die(MKFS_ERROR, 1, "strdup failed");
+		}
+		/* truncate multi-byte UTF-8 filenames on character boundary */
+		if (namelen > CRAMFS_MAXPATHLEN) {
+			namelen = CRAMFS_MAXPATHLEN;
+			warn_namelen = 1;
+			/* the first lost byte must not be a trail byte */
+			while ((entry->name[namelen] & 0xc0) == 0x80) {
+				namelen--;
+				/* are we reasonably certain it was UTF-8 ? */
+				if (entry->name[namelen] < 0x80 || !namelen) {
+					die(MKFS_ERROR, 0, "cannot truncate filenames not encoded in UTF-8");
+				}
+			}
+			entry->name[namelen] = '\0';
+		}
+		entry->mode = st.st_mode;
+		entry->size = st.st_size;
+		entry->uid = st.st_uid;
+		if (entry->uid >= 1 << CRAMFS_UID_WIDTH)
+			warn_uid = 1;
+		entry->gid = st.st_gid;
+		if (entry->gid >= 1 << CRAMFS_GID_WIDTH)
+			/* TODO: We ought to replace with a default
+			   gid instead of truncating; otherwise there
+			   are security problems.  Maybe mode should
+			   be &= ~070.  Same goes for uid once Linux
+			   supports >16-bit uids. */
+			warn_gid = 1;
+		size = sizeof(struct cramfs_inode) + ((namelen + 3) & ~3);
+		*fslen_ub += size;
+		if (S_ISDIR(st.st_mode)) {
+			entry->size = parse_directory(root_entry, path, &entry->child, fslen_ub);
+		} else if (S_ISREG(st.st_mode)) {
+			if (entry->size) {
+				if (access(path, R_OK) < 0) {
+					warn_skip = 1;
+					continue;
+				}
+				entry->path = strdup(path);
+				if (!entry->path) {
+					die(MKFS_ERROR, 1, "strdup failed");
+				}
+				if ((entry->size >= 1 << CRAMFS_SIZE_WIDTH)) {
+					warn_size = 1;
+					entry->size = (1 << CRAMFS_SIZE_WIDTH) - 1;
+				}
+			}
+		} else if (S_ISLNK(st.st_mode)) {
+			entry->uncompressed = malloc(entry->size);
+			if (!entry->uncompressed) {
+				die(MKFS_ERROR, 1, "malloc failed");
+			}
+			if (readlink(path, entry->uncompressed, entry->size) < 0) {
+				warn_skip = 1;
+				continue;
+			}
+		} else if (S_ISFIFO(st.st_mode) || S_ISSOCK(st.st_mode)) {
+			/* maybe we should skip sockets */
+			entry->size = 0;
+		} else if (S_ISCHR(st.st_mode) || S_ISBLK(st.st_mode)) {
+			entry->size = st.st_rdev;
+			if (entry->size & -(1<<CRAMFS_SIZE_WIDTH))
+				warn_dev = 1;
+		} else {
+			die(MKFS_ERROR, 0, "bogus file type: %s", entry->name);
+		}
+
+		if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
+			int blocks = ((entry->size - 1) / blksize + 1);
+
+			/* block pointers & data expansion allowance + data */
+			if (entry->size)
+				*fslen_ub += (4+26)*blocks + entry->size + 3;
+		}
+
+		/* Link it into the list */
+		*prev = entry;
+		prev = &entry->next;
+		totalsize += size;
+	}
+	free(path);
+	free(dirlist);		/* allocated by scandir() with malloc() */
+	return totalsize;
+}
+
+/* Returns sizeof(struct cramfs_super), which includes the root inode. */
+static unsigned int write_superblock(struct entry *root, char *base, int size)
+{
+	struct cramfs_super *super = (struct cramfs_super *) base;
+	unsigned int offset = sizeof(struct cramfs_super) + image_length;
+
+	offset += opt_pad;	/* 0 if no padding */
+
+	super->magic = CRAMFS_32(CRAMFS_MAGIC);
+	super->flags = CRAMFS_FLAG_FSID_VERSION_2 | CRAMFS_FLAG_SORTED_DIRS;
+	if (opt_holes)
+		super->flags |= CRAMFS_FLAG_HOLES;
+	if (image_length > 0)
+		super->flags |= CRAMFS_FLAG_SHIFTED_ROOT_OFFSET;
+	super->flags = CRAMFS_32(super->flags);
+	super->size = CRAMFS_32(size);
+	memcpy(super->signature, CRAMFS_SIGNATURE, sizeof(super->signature));
+
+	super->fsid.crc = CRAMFS_32(crc32(0L, Z_NULL, 0));
+	super->fsid.edition = CRAMFS_32(opt_edition);
+	super->fsid.blocks = CRAMFS_32(total_blocks);
+	super->fsid.files = CRAMFS_32(total_nodes);
+
+	memset(super->name, 0x00, sizeof(super->name));
+	if (opt_name)
+		strncpy(super->name, opt_name, sizeof(super->name));
+	else
+		strncpy(super->name, "Compressed", sizeof(super->name));
+
+	super->root.mode = CRAMFS_16(root->mode);
+	super->root.uid = CRAMFS_16(root->uid);
+	super->root.gid = root->gid;
+	super->root.size = CRAMFS_24(root->size);
+	CRAMFS_SET_OFFSET(&(super->root), offset >> 2);
+
+	return offset;
+}
+
+static void set_data_offset(struct entry *entry, char *base, unsigned long offset)
+{
+	struct cramfs_inode *inode = (struct cramfs_inode *) (base + entry->dir_offset);
+
+	if ((offset & 3) != 0) {
+		die(MKFS_ERROR, 0, "illegal offset of %lu bytes", offset);
+	}
+	if (offset >= (1 << (2 + CRAMFS_OFFSET_WIDTH))) {
+		die(MKFS_ERROR, 0, "filesystem too big");
+	}
+	CRAMFS_SET_OFFSET(inode, offset >> 2);
+}
+
+/*
+ * TODO: Does this work for chars >= 0x80?  Most filesystems use UTF-8
+ * encoding for filenames, whereas the console is a single-byte
+ * character set like iso-latin-1.
+ */
+static void print_node(struct entry *e)
+{
+	char info[10];
+	char type = '?';
+
+	if (S_ISREG(e->mode)) type = 'f';
+	else if (S_ISDIR(e->mode)) type = 'd';
+	else if (S_ISLNK(e->mode)) type = 'l';
+	else if (S_ISCHR(e->mode)) type = 'c';
+	else if (S_ISBLK(e->mode)) type = 'b';
+	else if (S_ISFIFO(e->mode)) type = 'p';
+	else if (S_ISSOCK(e->mode)) type = 's';
+
+	if (S_ISCHR(e->mode) || (S_ISBLK(e->mode))) {
+		/* major/minor numbers can be as high as 2^12 or 4096 */
+		snprintf(info, 10, "%4d,%4d", major(e->size), minor(e->size));
+	}
+	else {
+		/* size be as high as 2^24 or 16777216 */
+		snprintf(info, 10, "%9d", e->size);
+	}
+
+	printf("%c %04o %s %5d:%-3d %s\n",
+	       type, e->mode & ~S_IFMT, info, e->uid, e->gid, e->name);
+}
+
+/*
+ * We do a width-first printout of the directory
+ * entries, using a stack to remember the directories
+ * we've seen.
+ */
+static unsigned int write_directory_structure(struct entry *entry, char *base, unsigned int offset)
+{
+	int stack_entries = 0;
+	int stack_size = 64;
+	struct entry **entry_stack;
+
+	entry_stack = malloc(stack_size * sizeof(struct entry *));
+	if (!entry_stack) {
+		die(MKFS_ERROR, 1, "malloc failed");
+	}
+
+	if (opt_verbose) {
+		printf("root:\n");
+	}
+
+	for (;;) {
+		int dir_start = stack_entries;
+		while (entry) {
+			struct cramfs_inode *inode = (struct cramfs_inode *) (base + offset);
+			size_t len = strlen(entry->name);
+
+			entry->dir_offset = offset;
+
+			inode->mode = CRAMFS_16(entry->mode);
+			inode->uid = CRAMFS_16(entry->uid);
+			inode->gid = entry->gid;
+			inode->size = CRAMFS_24(entry->size);
+			inode->offset = 0;
+			/* Non-empty directories, regfiles and symlinks will
+			   write over inode->offset later. */
+
+			offset += sizeof(struct cramfs_inode);
+			total_nodes++;	/* another node */
+			memcpy(base + offset, entry->name, len);
+			/* Pad up the name to a 4-byte boundary */
+			while (len & 3) {
+				*(base + offset + len) = '\0';
+				len++;
+			}
+			CRAMFS_SET_NAMELEN(inode, len >> 2);
+			offset += len;
+
+			if (opt_verbose)
+				print_node(entry);
+
+			if (entry->child) {
+				if (stack_entries >= stack_size) {
+					stack_size *= 2;
+					entry_stack = realloc(entry_stack, stack_size * sizeof(struct entry *));
+					if (!entry_stack) {
+						die(MKFS_ERROR, 1, "realloc failed");
+					}
+				}
+				entry_stack[stack_entries] = entry;
+				stack_entries++;
+			}
+			entry = entry->next;
+		}
+
+		/*
+		 * Reverse the order the stack entries pushed during
+		 * this directory, for a small optimization of disk
+		 * access in the created fs.  This change makes things
+		 * `ls -UR' order.
+		 */
+		{
+			struct entry **lo = entry_stack + dir_start;
+			struct entry **hi = entry_stack + stack_entries;
+			struct entry *tmp;
+
+			while (lo < --hi) {
+				tmp = *lo;
+				*lo++ = *hi;
+				*hi = tmp;
+			}
+		}
+
+		/* Pop a subdirectory entry from the stack, and recurse. */
+		if (!stack_entries)
+			break;
+		stack_entries--;
+		entry = entry_stack[stack_entries];
+
+		set_data_offset(entry, base, offset);
+		if (opt_verbose) {
+			printf("%s:\n", entry->name);
+		}
+		entry = entry->child;
+	}
+	free(entry_stack);
+	return offset;
+}
+
+static int is_zero(char const *begin, unsigned len)
+{
+	/* Returns non-zero iff the first LEN bytes from BEGIN are all NULs. */
+	return (len-- == 0 ||
+		(begin[0] == '\0' &&
+		 (len-- == 0 ||
+		  (begin[1] == '\0' &&
+		   (len-- == 0 ||
+		    (begin[2] == '\0' &&
+		     (len-- == 0 ||
+		      (begin[3] == '\0' &&
+		       memcmp(begin, begin + 4, len) == 0))))))));
+}
+
+/*
+ * One 4-byte pointer per block and then the actual blocked
+ * output. The first block does not need an offset pointer,
+ * as it will start immediately after the pointer block;
+ * so the i'th pointer points to the end of the i'th block
+ * (i.e. the start of the (i+1)'th block or past EOF).
+ *
+ * Note that size > 0, as a zero-sized file wouldn't ever
+ * have gotten here in the first place.
+ */
+static unsigned int do_compress(char *base, unsigned int offset, char const *name, char *uncompressed, unsigned int size)
+{
+	unsigned long original_size = size;
+	unsigned long original_offset = offset;
+	unsigned long new_size;
+	unsigned long blocks = (size - 1) / blksize + 1;
+	unsigned long curr = offset + 4 * blocks;
+	int change;
+
+	total_blocks += blocks;
+
+	do {
+		unsigned long len = 2 * blksize;
+		unsigned int input = size;
+		int err;
+
+		if (input > blksize)
+			input = blksize;
+		size -= input;
+		if (!(opt_holes && is_zero (uncompressed, input))) {
+			err = compress2(base + curr, &len, uncompressed, input, Z_BEST_COMPRESSION);
+			if (err != Z_OK) {
+				die(MKFS_ERROR, 0, "compression error: %s", zError(err));
+			}
+			curr += len;
+		}
+		uncompressed += input;
+
+		if (len > blksize*2) {
+			/* (I don't think this can happen with zlib.) */
+			die(MKFS_ERROR, 0, "AIEEE: block \"compressed\" to > 2*blocklength (%ld)", len);
+		}
+
+		*(u32 *) (base + offset) = CRAMFS_32(curr);
+		offset += 4;
+	} while (size);
+
+	curr = (curr + 3) & ~3;
+	new_size = curr - original_offset;
+	/* TODO: Arguably, original_size in these 2 lines should be
+	   st_blocks * 512.  But if you say that then perhaps
+	   administrative data should also be included in both. */
+	change = new_size - original_size;
+	if (opt_verbose > 1) {
+		printf("%6.2f%% (%+d bytes)\t%s\n",
+		       (change * 100) / (double) original_size, change, name);
+	}
+
+	return curr;
+}
+
+
+/*
+ * Traverse the entry tree, writing data for every item that has
+ * non-null entry->path (i.e. every non-empty regfile) and non-null
+ * entry->uncompressed (i.e. every symlink).
+ */
+static unsigned int write_data(struct entry *entry, char *base, unsigned int offset)
+{
+	do {
+		if (entry->path || entry->uncompressed) {
+			if (entry->same) {
+				set_data_offset(entry, base, entry->same->offset);
+				entry->offset = entry->same->offset;
+			}
+			else {
+				set_data_offset(entry, base, offset);
+				entry->offset = offset;
+				map_entry(entry);
+				offset = do_compress(base, offset, entry->name, entry->uncompressed, entry->size);
+				unmap_entry(entry);
+			}
+		}
+		else if (entry->child)
+			offset = write_data(entry->child, base, offset);
+		entry=entry->next;
+	} while (entry);
+	return offset;
+}
+
+static unsigned int write_file(char *file, char *base, unsigned int offset)
+{
+	int fd;
+	char *buf;
+
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		die(MKFS_ERROR, 1, "open failed: %s", file);
+	}
+	buf = mmap(NULL, image_length, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (buf == MAP_FAILED) {
+		die(MKFS_ERROR, 1, "mmap failed");
+	}
+	memcpy(base + offset, buf, image_length);
+	munmap(buf, image_length);
+	close (fd);
+	/* Pad up the image_length to a 4-byte boundary */
+	while (image_length & 3) {
+		*(base + offset + image_length) = '\0';
+		image_length++;
+	}
+	return (offset + image_length);
+}
+
+int main(int argc, char **argv)
+{
+	struct stat st;		/* used twice... */
+	struct entry *root_entry;
+	char *rom_image;
+	ssize_t offset, written;
+	int fd;
+	/* initial guess (upper-bound) of required filesystem size */
+	loff_t fslen_ub = sizeof(struct cramfs_super);
+	char const *dirname, *outfile;
+	u32 crc;
+	int c;			/* for getopt */
+	char *ep;		/* for strtoul */
+
+	total_blocks = 0;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hEe:i:n:psvz")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(MKFS_OK);
+		case 'E':
+			opt_errors = 1;
+			break;
+		case 'e':
+			errno = 0;
+			opt_edition = strtoul(optarg, &ep, 10);
+			if (errno || optarg[0] == '\0' || *ep != '\0')
+				usage(MKFS_USAGE);
+			break;
+		case 'i':
+			opt_image = optarg;
+			if (lstat(opt_image, &st) < 0) {
+				die(MKFS_ERROR, 1, "lstat failed: %s", opt_image);
+			}
+			image_length = st.st_size; /* may be padded later */
+			fslen_ub += (image_length + 3); /* 3 is for padding */
+			break;
+		case 'n':
+			opt_name = optarg;
+			break;
+		case 'p':
+			opt_pad = PAD_SIZE;
+			fslen_ub += PAD_SIZE;
+			break;
+		case 's':
+			/* old option, ignored */
+			break;
+		case 'v':
+			opt_verbose++;
+			break;
+		case 'z':
+			opt_holes = 1;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 2)
+		usage(MKFS_USAGE);
+	dirname = argv[optind];
+	outfile = argv[optind + 1];
+
+	if (stat(dirname, &st) < 0) {
+		die(MKFS_USAGE, 1, "stat failed: %s", dirname);
+	}
+	fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+	if (fd < 0) {
+		die(MKFS_USAGE, 1, "open failed: %s", outfile);
+	}
+
+	root_entry = calloc(1, sizeof(struct entry));
+	if (!root_entry) {
+		die(MKFS_ERROR, 1, "calloc failed");
+	}
+	root_entry->mode = st.st_mode;
+	root_entry->uid = st.st_uid;
+	root_entry->gid = st.st_gid;
+
+	root_entry->size = parse_directory(root_entry, dirname, &root_entry->child, &fslen_ub);
+
+	/* always allocate a multiple of blksize bytes because that's
+	   what we're going to write later on */
+	fslen_ub = ((fslen_ub - 1) | (blksize - 1)) + 1;
+
+	if (fslen_ub > MAXFSLEN) {
+		fprintf(stderr,
+			"warning: estimate of required size (upper bound) is %LdMB, but maximum image size is %uMB, we might die prematurely\n",
+			fslen_ub >> 20,
+			MAXFSLEN >> 20);
+		fslen_ub = MAXFSLEN;
+	}
+
+	/* find duplicate files. TODO: uses the most inefficient algorithm
+	   possible. */
+	eliminate_doubles(root_entry, root_entry);
+
+	/* TODO: Why do we use a private/anonymous mapping here
+	   followed by a write below, instead of just a shared mapping
+	   and a couple of ftruncate calls?  Is it just to save us
+	   having to deal with removing the file afterwards?  If we
+	   really need this huge anonymous mapping, we ought to mmap
+	   in smaller chunks, so that the user doesn't need nn MB of
+	   RAM free.  If the reason is to be able to write to
+	   un-mmappable block devices, then we could try shared mmap
+	   and revert to anonymous mmap if the shared mmap fails. */
+	rom_image = mmap(NULL, fslen_ub?fslen_ub:1, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+
+	if (rom_image == MAP_FAILED) {
+		die(MKFS_ERROR, 1, "mmap failed");
+	}
+
+	/* Skip the first opt_pad bytes for boot loader code */
+	offset = opt_pad;
+	memset(rom_image, 0x00, opt_pad);
+
+	/* Skip the superblock and come back to write it later. */
+	offset += sizeof(struct cramfs_super);
+
+	/* Insert a file image. */
+	if (opt_image) {
+		printf("Including: %s\n", opt_image);
+		offset = write_file(opt_image, rom_image, offset);
+	}
+
+	offset = write_directory_structure(root_entry->child, rom_image, offset);
+	printf("Directory data: %d bytes\n", offset);
+
+	offset = write_data(root_entry, rom_image, offset);
+
+	/* We always write a multiple of blksize bytes, so that
+	   losetup works. */
+	offset = ((offset - 1) | (blksize - 1)) + 1;
+	printf("Everything: %d kilobytes\n", offset >> 10);
+
+	/* Write the superblock now that we can fill in all of the fields. */
+	write_superblock(root_entry, rom_image+opt_pad, offset);
+	printf("Super block: %d bytes\n", sizeof(struct cramfs_super));
+
+	/* Put the checksum in. */
+	crc = crc32(0L, Z_NULL, 0);
+	crc = crc32(crc, (rom_image+opt_pad), (offset-opt_pad));
+	((struct cramfs_super *) (rom_image+opt_pad))->fsid.crc = CRAMFS_32(crc);
+	printf("CRC: %x\n", crc);
+
+	/* Check to make sure we allocated enough space. */
+	if (fslen_ub < offset) {
+		die(MKFS_ERROR, 0, "not enough space allocated for ROM image (%Ld allocated, %d used)", fslen_ub, offset);
+	}
+
+	written = write(fd, rom_image, offset);
+	if (written < 0) {
+		die(MKFS_ERROR, 1, "write failed");
+	}
+	if (offset != written) {
+		die(MKFS_ERROR, 0, "ROM image write failed (wrote %d of %d bytes)", written, offset);
+	}
+
+	/* (These warnings used to come at the start, but they scroll off the
+	   screen too quickly.) */
+	if (warn_namelen)
+		fprintf(stderr, /* bytes, not chars: think UTF-8. */
+			"warning: filenames truncated to %d bytes (possibly less if multi-byte UTF-8)\n",
+			CRAMFS_MAXPATHLEN);
+	if (warn_skip)
+		fprintf(stderr, "warning: files were skipped due to errors\n");
+	if (warn_size)
+		fprintf(stderr,
+			"warning: file sizes truncated to %luMB (minus 1 byte)\n",
+			1L << (CRAMFS_SIZE_WIDTH - 20));
+	if (warn_uid) /* (not possible with current Linux versions) */
+		fprintf(stderr,
+			"warning: uids truncated to %u bits (this may be a security concern)\n",
+			CRAMFS_UID_WIDTH);
+	if (warn_gid)
+		fprintf(stderr,
+			"warning: gids truncated to %u bits (this may be a security concern)\n",
+			CRAMFS_GID_WIDTH);
+	if (warn_dev)
+		fprintf(stderr,
+			"WARNING: device numbers truncated to %u bits (this almost certainly means\n"
+			"that some device files will be wrong)\n",
+			CRAMFS_OFFSET_WIDTH);
+	if (opt_errors &&
+	    (warn_namelen||warn_skip||warn_size||warn_uid||warn_gid||warn_dev))
+		exit(MKFS_ERROR);
+
+	exit(MKFS_OK);
+}
+
+/*
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
--- linux/include/linux/fb.h.old	2002-12-28 21:38:02.000000000 +0100
+++ linux/include/linux/fb.h	2002-12-28 21:40:53.000000000 +0100
@@ -110,6 +110,10 @@
 #define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
 
 
+#define FB_ACCEL_CCUBE_AVIA_GTX	120	/* C-Cube AViA GTX		*/
+#define FB_ACCEL_CCUBE_AVIA_ENX	121	/* C-Cube AViA eNX		*/
+
+
 struct fb_fix_screeninfo {
 	char id[16];			/* identification string eg "TT Builtin" */
 	unsigned long smem_start;	/* Start of frame buffer mem */
diff -Naur linux-2.4.33.orig/arch/ppc/config.in linux-2.4.33/arch/ppc/config.in
--- linux-2.4.33.orig/arch/ppc/config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.33/arch/ppc/config.in	2006-08-11 20:17:15.000000000 +0200
@@ -459,6 +459,8 @@
   source drivers/zorro/Config.in
 fi
 
+bool 'Work around bad spots in RAM' CONFIG_BADRAM
+
 endmenu
 source drivers/mtd/Config.in
 source drivers/pnp/Config.in
diff -Naur linux-2.4.33.orig/arch/ppc/defconfig linux-2.4.33/arch/ppc/defconfig
--- linux-2.4.33.orig/arch/ppc/defconfig	2005-01-19 15:09:36.000000000 +0100
+++ linux-2.4.33/arch/ppc/defconfig	2006-08-11 20:17:15.000000000 +0200
@@ -63,6 +63,7 @@
 # CONFIG_OOM_KILLER is not set
 CONFIG_PCI_NAMES=y
 CONFIG_HOTPLUG=y
+# CONFIG_BADRAM is not set
 
 #
 # PCMCIA/CardBus support
diff -Naur linux-2.4.33.orig/arch/ppc/mm/init.c linux-2.4.33/arch/ppc/mm/init.c
--- linux-2.4.33.orig/arch/ppc/mm/init.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.33/arch/ppc/mm/init.c	2006-08-11 20:17:15.000000000 +0200
@@ -144,6 +144,9 @@
 void show_mem(void)
 {
 	int i,free = 0,total = 0,reserved = 0;
+#ifdef CONFIG_BADRAM
+  	int badram = 0;
+#endif /* CONFIG_BADRAM */
 	int shared = 0, cached = 0;
 	struct task_struct *p;
 	int highmem = 0;
@@ -156,6 +159,10 @@
 		total++;
 		if (PageHighMem(mem_map+i))
 			highmem++;
+#ifdef CONFIG_BADRAM
+		if (PageBad(mem_map+i))
+			badram++;
+#endif /* CONFIG_BADRAM */
 		if (PageReserved(mem_map+i))
 			reserved++;
 		else if (PageSwapCache(mem_map+i))
@@ -169,6 +176,9 @@
 	printk("%d pages of HIGHMEM\n", highmem);
 	printk("%d free pages\n",free);
 	printk("%d reserved pages\n",reserved);
+#ifdef CONFIG_BADRAM
+	printk("%d pages of BadRAM\n",badram);
+#endif /* CONFIG_BADRAM */
 	printk("%d pages shared\n",shared);
 	printk("%d pages swap cached\n",cached);
 	printk("%d pages in page table cache\n",(int)pgtable_cache_size);
@@ -466,6 +476,7 @@
 	free_area_init(zones_size);
 }
 
+
 void __init mem_init(void)
 {
 	unsigned long addr;
@@ -536,18 +547,42 @@
 			ClearPageReserved(page);
 			set_bit(PG_highmem, &page->flags);
 			atomic_set(&page->count, 1);
+#ifdef CONFIG_BADRAM
+			if (!PageBad(page))
+#endif /* CONFIG_BADRAM */
+			{
 			__free_page(page);
 			totalhigh_pages++;
+			}
 		}
 		totalram_pages += totalhigh_pages;
 	}
 #endif /* CONFIG_HIGHMEM */
 
+#ifdef CONFIG_BADRAM
+        int badRamPages = 0;
+	int mp = max_mapnr;
+	while (mp-- > 0) {
+	if (PageBad(mem_map+mp))
+          {
+	   badRamPages++;
+           if (PageReserved(mem_map+mp))
+             printk("BADMEM: Iiee... Bad memory in a reserved area (page %i); please swap modules or try another module...",mp);
+          }
+	}
+        printk(KERN_INFO "Memory: %luk available (%dk kernel code, %dk data, %dk init, %ldk highmem, %ldk BadRAM)\n",
+	       (unsigned long)nr_free_pages()<< (PAGE_SHIFT-10),
+	       codepages<< (PAGE_SHIFT-10), datapages<< (PAGE_SHIFT-10),
+	       initpages<< (PAGE_SHIFT-10),
+	       (unsigned long) (totalhigh_pages << (PAGE_SHIFT-10)),
+               (unsigned long) (badRamPages << (PAGE_SHIFT-10)));
+#else
         printk(KERN_INFO "Memory: %luk available (%dk kernel code, %dk data, %dk init, %ldk highmem)\n",
 	       (unsigned long)nr_free_pages()<< (PAGE_SHIFT-10),
 	       codepages<< (PAGE_SHIFT-10), datapages<< (PAGE_SHIFT-10),
 	       initpages<< (PAGE_SHIFT-10),
 	       (unsigned long) (totalhigh_pages << (PAGE_SHIFT-10)));
+#endif /* CONFIG_BADRAM */
 	if (sysmap)
 		printk("System.map loaded at 0x%08x for debugger, size: %ld bytes\n",
 			(unsigned int)sysmap, sysmap_size);
diff -Naur linux-2.4.33.orig/CREDITS linux-2.4.33/CREDITS
--- linux-2.4.33.orig/CREDITS	2006-08-11 06:18:20.000000000 +0200
+++ linux-2.4.33/CREDITS	2006-08-11 20:17:15.000000000 +0200
@@ -2553,6 +2553,14 @@
 S: Malvern, Pennsylvania 19355
 S: USA
 
+N: Rick van Rein
+E: rick@vanrein.org
+W: http://rick.vanrein.org/
+D: Memory, the BadRAM subsystem dealing with statically challanged RAM modules.
+S: Binnenes 67
+S: 9407 CX Assen
+S: The Netherlands
+
 N: Stefan Reinauer
 E: stepan@linux.de
 W: http://www.freiburg.linux.de/~stepan/
diff -Naur linux-2.4.33.orig/Documentation/badram.txt linux-2.4.33/Documentation/badram.txt
--- linux-2.4.33.orig/Documentation/badram.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.33/Documentation/badram.txt	2006-08-11 20:17:15.000000000 +0200
@@ -0,0 +1,266 @@
+
+INFORMATION ON USING BAD RAM MODULES
+====================================
+
+Introduction
+	RAM is getting smaller and smaller, and as a result, also more and more
+	vulnerable. This makes the manufacturing of hardware more expensive,
+	since an excessive amount of RAM chips must be discarded on account of
+	a single cell that is wrong. Similarly, static discharge may damage a
+	RAM module forever, which is usually remedied by replacing it
+	entirely.
+
+	This is not necessary, as the BadRAM code shows: By informing the Linux
+	kernel which addresses in a RAM are damaged, the kernel simply avoids
+	ever allocating such addresses but makes all the rest available.
+
+Reasons for this feature
+	There are many reasons why this kernel feature is useful:
+	- Chip manufacture is resource intensive; waste less and sleep better
+	- It's another chance to promote Linux as "the flexible OS"
+	- Some laptops have their RAM soldered in... and then it fails!
+	- It's plain cool ;-)
+
+Running example
+	To run this project, I was given two DIMMs, 32 MB each. One, that we
+	shall use as a running example in this text, contained 512 faulty bits,
+	spread over 1/4 of the address range in a regular pattern. Some tricks
+	with a RAM tester and a few binary calculations were sufficient to
+	write these faults down in 2 longword numbers.
+
+	The kernel recognised the correct number of pages with faults and did
+	not give them out for allocation. The allocation routines could
+	therefore progress as normally, without any adaption.
+	So, I gained 30 MB of DIMM which would otherwise have been thrown
+	away. After booting the kernel, the kernel behaved exactly as it
+	always had.
+
+Initial checks
+	If you experience RAM trouble, first read /usr/src/linux/memory.txt
+	and try out the mem=4M trick to see if at least some initial parts
+	of your RAM work well. The BadRAM routines halt the kernel in panic
+	if the reserved area of memory (containing kernel stuff) contains
+	a faulty address.
+
+Running a RAM checker
+	The memory checker is not built into the kernel, to avoid delays at
+	runtime. If you experience problems that may be caused by RAM, run
+	a good RAM checker, such as
+		http://reality.sgi.com/cbrady_denver/memtest86
+	The output of a RAM checker provides addresses that went wrong. In
+	the 32 MB chip with 512 faulty bits mentioned above, the errors were
+	found in the 8MB-16MB range (the DIMM was in slot #0) at addresses
+		xxx42f4
+		xxx62f4
+		xxxc2f4
+		xxxe2f4
+	and the error was a "sticky 1 bit", a memory bit that stayed "1" no
+	matter what was written to it. The regularity of this pattern
+	suggests the death of a buffer at the output stages of a row on one of
+	the chips. I expect such regularity to be commonplace. Finding this
+	regularity currently is human effort, but it should not be hard to
+	alter a RAM checker to capture it in some sort of pattern, possibly
+	the BadRAM patterns described below.
+
+	By the way, if you manage to get hold of memtest86 version 2.3 or
+	beyond, you can configure the printing mode to produce BadRAM patterns,
+	which find out exactly what you must enter on the LILO: commandline,
+	except that you shouldn't mention the added spacing. That means that
+	you can skip the following step, which saves you a *lot* of work.
+
+	Also by the way, if your machine has the ISA memory gap in the 15M-16M
+	range unstoppable, Linux can get in trouble. One way of handling that
+	situation is by specifying the total memory size to Linux with a boot
+	parameter mem=... and then to tell it to treat the 15M-16M range as
+	faulty with an additional boot parameter, for instance:
+		mem=24M badram=0x00f00000,0xfff00000
+	if you installed 24MB of RAM in total.
+
+Capturing errors in a pattern
+	Instead of manually providing all 512 errors to the kernel, it's nicer
+	to generate a pattern. Since the regularity is based on address decoding
+	software, which generally takes certain bits into account and ignores
+	others, we shall provide a faulty address F, together with a bit mask M
+	that specifies which bits must be equal to F. In C code, an address A
+	is faulty if and only if
+		(F & M) == (A & M)
+	or alternately (closer to a hardware implementation):
+		~((F ^ A) & M)
+	In the example 32 MB chip, we had the faulty addresses in 8MB-16MB:
+		xxx42f4         ....0100....
+		xxx62f4         ....0110....
+		xxxc2f4         ....1100....
+		xxxe2f4         ....1110....
+	The second column represents the alternating hex digit in binary form.
+	Apperantly, the first and one-but last binary digit can be anything,
+	so the binary mask for that part is 0101. The mask for the part after
+	this is 0xfff, and the part before should select anything in the range
+	8MB-16MB, or 0x00800000-0x01000000; this is done with a bitmask
+	0xff80xxxx. Combining these partial masks, we get:
+		F=0x008042f4    M=0xff805fff
+	That covers everything for this DIMM; for more complicated failing
+	DIMMs, or for a combination of multiple failing DIMMs, it can be
+	necessary to set up a number of such F/M pairs.
+
+Rebooting Linux
+	Now that these patterns are known (and double-checked, the calculations
+	are highly error-prone... it would be neat to test them in the RAM
+	checker...) we simply restart Linux with these F/M pairs as a parameter.
+	If you normally boot as follows:
+	       LILO: linux
+	you should now boot with
+	       LILO: linux badram=0x008042f4,0xff805fff
+	or perhaps by mentioning more F/M pairs in an order F0,M0,F1,M1,...
+	When you provide an odd number of arguments to badram, the default mask
+	0xffffffff (only one address matched) is applied to the pattern.
+
+	Beware of the commandline length. At least up to LILO version 0.21,
+	the commandline is cut off after the 78th character; later versions
+	may go as far as the kernel goes, namely 255 characters. In no way is
+	it possible to enter more than 10 numbers to the badram boot option.
+
+	When the kernel now boots, it should not give any trouble with RAM.
+	Mind you, this is under the assumption that the kernel and its data
+	storage do not overlap an erroneous part. If this happens, and the
+	kernel does not choke on it right away, it will stop with a panic.
+	You will need to provide a RAM where the initial, say 2MB, is faultless.
+
+	Now look up your memory status with
+	       dmesg | grep ^Memory:
+	which prints a single line with information like
+		Memory: 158524k/163840k available
+			(940k kernel code,
+			412k reserved,
+			1856k data,
+			60k init,
+			0k highmem,
+			2048k BadRAM)
+	The latter entry, the badram, is 2048k to represent the loss of 2MB
+	of general purpose RAM due to the errors. Or, positively rephrased,
+	instead of throwing out 32MB as useless, you only throw out 2MB.
+
+	If the system is stable (try compiling a few kernels, and do a few
+	finds in / or so) you may add the boot parameter to /etc/lilo.conf
+	as a line to _all_ the kernels that handle this trouble with a line
+		append="badram=0x008042f4,0xff805fff"
+	after which you run "lilo".
+	Warning: Don't experiment with these settings on your only boot image.
+	If the BadRAM overlays kernel code, data, init, or other reserved
+	memory, the kernel will halt in panic. Try settings on a test boot
+	image first, and if you get a panic you should change the order of
+	your DIMMs [which may involve buying a new one just to be able to
+	change the order].
+
+	You are allowed to enter any number of BadRAM patterns in all the
+	places documented in this file. They will all apply. It is even
+	possible to mention several BadRAM patterns in a single place. The
+	completion of an odd number of arguments with the default mask is
+	done separately for each badram=... option.
+
+Kernel Customisation
+	Some people prefer to enter their badram patterns in the kernel, and
+	this is also possible. In mm/page_alloc.c there is an array of unsigned
+	long integers into which the parameters can be entered, prefixed with
+	the number of integers (twice the number of patterns). The array is
+	named badram_custom and it will be added to the BadRAM list whenever an
+	option 'badram' is provided on the commandline when booting, either
+	with or without additional patterns.
+
+	For the previous example, the code would become
+
+	static unsigned long __initdata badram_custom[] = {
+		2,	// Number of longwords that follow, as F/M pairs
+		0x008042f4L, 0xff805fffL,
+	};
+
+	Even on this place you may assume the default mask to be filled in
+	when you enter an odd number of longwords. Specify the number of
+	longwords to be 0 to avoid influence of this custom BadRAM list.
+
+BadRAM classification
+	This technique may start a lively market for "dead" RAM. It is important
+	to realise that some RAMs are more dead than others. So, instead of
+	just providing a RAM size, it is also important to know the BadRAM
+	class, which is defined as follows:
+
+		A BadRAM class N means that at most 2^N bytes have a problem,
+		and that all problems with the RAMs are persistent: They
+		are predictable and always show up.
+
+	The DIMM that serves as an example here was of class 9, since 512=2^9
+	errors were found. Higher classes are worse, "correct" RAM is of class
+	-1 (or even less, at your choice).
+	Class N also means that the bitmask for your chip (if there's just one,
+	that is) counts N bits "0" and it means that (if no faults fall in the
+	same page) an amount of 2^N*PAGESIZE memory is lost, in the example on
+	an i386 architecture that would be 2^9*4k=2MB, which accounts for the
+	initial claim of 30MB RAM gained with this DIMM.
+
+	Note that this scheme has deliberately been defined to be independent
+	of memory technology and of computer architecture.
+
+Known Bugs
+	LILO is known to cut off commandlines which are too long. For the
+	lilo-0.21 distribution, a commandline may not exceed 78 characters,
+	while actually, 255 would be possible [on i386, kernel 2.2.16].
+	LILO does _not_ report too-long commandlines, but the error will
+	show up as either a panic at boot time, stating
+		panic: BadRAM page in initial area
+	or the dmesg line starting with Memory: will mention an unpredicted
+	number of kilobytes. (Note that the latter number only includes
+	errors in accessed memory.)
+
+Future Possibilities
+	It would be possible to use even more of the faulty RAMs by employing
+	them for slabs. The smaller allocation granularity of slabs makes it
+	possible to throw out just, say, 32 bytes surrounding an error. This
+	would mean that the example DIMM only looses 16kB instead of 2MB.
+	It might even be possible to allocate the slabs in such a way that,
+	where possible, the remaining bytes in a slab structure are allocated
+	around the error, reducing the RAM loss to 0 in the optimal situation!
+
+	However, this yield is somewhat faked: It is possible to provide 512
+	pages of 32-byte slabs, but it is not certain that anyone would use
+	that many 32-byte slabs at any time.
+
+	A better solution might be to alter the page allocation for a slab to
+	have a preference for BadRAM pages, and given those a special treatment.
+	This way, the BadRAM would be spread over all the slabs, which seems
+	more likely to be a `true' pay-off. This would yield more overhead at
+	slab allocation time, but on the other hand, by the nature of slabs,
+	such allocations are made as rare as possible, so it might not matter
+	that much. I am uncertain where to go.
+
+	Many suggestions have been made to insert a RAM checker at boot time;
+	since this would leave the time to do only very meager checking, it
+	is not a reasonable option; we already have a BIOS doing that in most
+	systems!
+
+	It would be interesting to integrate this functionality with the
+	self-verifying nature of ECC RAM. These memories can even distinguish
+	between recorable and unrecoverable errors! Such memory has been
+	handled in older operating systems by `testing' once-failed memory
+	blocks for a while, by placing only (reloadable) program code in it.
+	Unfortunately, I possess no faulty ECC modules to work this out.
+
+Names and Places
+	The home page of this project is on
+		http://rick.vanrein.org/linux/badram
+	This page also links to Nico Schmoigl's experimental extensions to
+	this patch (with debugging and a few other fancy things).
+
+	In case you have experiences with the BadRAM software which differ from
+	the test reportings on that site, I hope you will mail me with that
+	new information.
+
+	The BadRAM project is an idea and implementation by
+		Rick van Rein
+		Binnenes 67
+		9407 CX Assen
+		The Netherlands
+		rick@vanrein.org
+	If you like it, a postcard would be much appreciated ;-)
+
+
+	                                                       Enjoy,
+	                                                        -Rick.
diff -Naur linux-2.4.33.orig/Documentation/Configure.help linux-2.4.33/Documentation/Configure.help
--- linux-2.4.33.orig/Documentation/Configure.help	2006-08-11 06:18:20.000000000 +0200
+++ linux-2.4.33/Documentation/Configure.help	2006-08-11 20:17:15.000000000 +0200
@@ -23453,6 +23453,21 @@
   This option allows you to run the kernel with data cache disabled.
   Say Y if you experience CPM lock-ups.
 
+Work around bad spots in RAM
+CONFIG_BADRAM
+  This small kernel extension makes it possible to use memory chips
+  which are not entirely correct. It works by never allocating the
+  places that are wrong. Those places are specified with the badram
+  boot option to LILO. Read /usr/src/linux/Documentation/badram.txt
+  and/or visit http://home.zonnet.nl/vanrein/badram for information.
+  
+  This option co-operates well with a second boot option from LILO
+  that starts memtest86, which is able to automatically produce the
+  patterns for the commandline in case of memory trouble.
+
+  It is safe to say 'Y' here, and it is advised because there is no
+  performance impact.
+
 #
 # m68k-specific kernel options
 # Documented by Chris Lawrence <mailto:quango@themall.net> et al.
@@ -29390,7 +29405,7 @@
 # LocalWords:  CramFs Cramfs uid cramfs AVM's kernelcapi PCIV cdrdao Cdparanoia
 # LocalWords:  DMX Domex dmx wellington ftdi sio Accton Billington Corega FEter
 # LocalWords:  MELCO LUA PNA Linksys SNC chkdsk AWACS Webcam RAMFS Ramfs ramfs
-# LocalWords:  ramfiles MAKEDEV pty WDTPCI APA apa
+# LocalWords:  ramfiles MAKEDEV pty WDTPCI APA apa BadRAM badram vanrein zonnet
 #
 # The following sets edit modes for GNU EMACS
 # Local Variables:
diff -Naur linux-2.4.33.orig/Documentation/kernel-parameters.txt linux-2.4.33/Documentation/kernel-parameters.txt
--- linux-2.4.33.orig/Documentation/kernel-parameters.txt	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.33/Documentation/kernel-parameters.txt	2006-08-11 20:17:15.000000000 +0200
@@ -14,6 +14,7 @@
 	APIC	APIC support is enabled.
 	APM 	Advanced Power Management support is enabled.
 	AX25	Appropriate AX.25 support is enabled.
+	BADRAM	Support for faulty RAM chips is enabled.
 	CD	Appropriate CD support is enabled.
 	DEVFS   devfs support is enabled. 
 	DRM	Direct Rendering Management support is enabled. 
@@ -127,6 +128,8 @@
  
 	aztcd=		[HW,CD] Aztec CD driver.
 
+	badram=		[BADRAM] Avoid allocating faulty RAM addresses.
+
 	baycom_epp=	[HW,AX25]
  
 	baycom_par= 	[HW,AX25] BayCom Parallel Port AX.25 Modem.
diff -Naur linux-2.4.33.orig/Documentation/memory.txt linux-2.4.33/Documentation/memory.txt
--- linux-2.4.33.orig/Documentation/memory.txt	2001-11-09 22:58:02.000000000 +0100
+++ linux-2.4.33/Documentation/memory.txt	2006-08-11 20:17:15.000000000 +0200
@@ -18,6 +18,13 @@
 	   as you add more memory.  Consider exchanging your 
            motherboard.
 
+	4) A static discharge or production fault causes a RAM module
+	   to have (predictable) errors, usually meaning that certain
+	   bits cannot be set or reset. Instead of throwing away your
+	   RAM module, you may read /usr/src/linux/Documentation/badram.txt
+	   to learn how to detect, locate and circuimvent such errors
+	   in your RAM module.
+
 All of these problems can be addressed with the "mem=XXXM" boot option
 (where XXX is the size of RAM to use in megabytes).  
 It can also tell Linux to use less memory than is actually installed.
@@ -45,6 +52,8 @@
 
 	* Try passing the "mem=4M" option to the kernel to limit
 	  Linux to using a very small amount of memory.
+	  If this helps, read /usr/src/linux/Documentation/badram.txt
+	  to learn how to find and circuimvent memory errors.
 
 
 Other tricks:
diff -Naur linux-2.4.33.orig/include/asm-ppc/page.h linux-2.4.33/include/asm-ppc/page.h
--- linux-2.4.33.orig/include/asm-ppc/page.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.33/include/asm-ppc/page.h	2006-08-11 20:17:15.000000000 +0200
@@ -148,6 +148,7 @@
 
 #define MAP_PAGE_RESERVED	(1<<15)
 #define virt_to_page(kaddr)	(mem_map + (((unsigned long)(kaddr)-PAGE_OFFSET) >> PAGE_SHIFT))
+#define phys_to_page(x)		(mem_map + ((unsigned long)(x) >> PAGE_SHIFT))
 #define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
 
 extern unsigned long get_zero_page_fast(void);
diff -Naur linux-2.4.33.orig/include/linux/mm.h linux-2.4.33/include/linux/mm.h
--- linux-2.4.33.orig/include/linux/mm.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.33/include/linux/mm.h	2006-08-11 20:17:15.000000000 +0200
@@ -305,6 +305,7 @@
 #define PG_reserved		14
 #define PG_launder		15	/* written out by VM pressure.. */
 #define PG_fs_1			16	/* Filesystem specific */
+#define PG_badram		17
 
 #ifndef arch_set_page_uptodate
 #define arch_set_page_uptodate(page)
@@ -403,6 +404,9 @@
 #define PageSlab(page)		test_bit(PG_slab, &(page)->flags)
 #define PageSetSlab(page)	set_bit(PG_slab, &(page)->flags)
 #define PageClearSlab(page)	clear_bit(PG_slab, &(page)->flags)
+#define PageBad(page)		test_bit(PG_badram, &(page)->flags)
+#define PageSetBad(page)	set_bit(PG_badram, &(page)->flags)
+#define PageTestandSetBad(page)	test_and_set_bit(PG_badram, &(page)->flags)
 #define PageReserved(page)	test_bit(PG_reserved, &(page)->flags)
 
 #define PageActive(page)	test_bit(PG_active, &(page)->flags)
diff -Naur linux-2.4.33.orig/mm/bootmem.c linux-2.4.33/mm/bootmem.c
--- linux-2.4.33.orig/mm/bootmem.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.33/mm/bootmem.c	2006-08-11 20:17:15.000000000 +0200
@@ -257,8 +257,15 @@
 		if (!test_bit(i, bdata->node_bootmem_map)) {
 			count++;
 			ClearPageReserved(page);
+#ifdef CONFIG_BADRAM
+			if (!PageBad(page)) {
+				set_page_count(page, 1);
+				__free_page(page);
+			}
+#else
 			set_page_count(page, 1);
 			__free_page(page);
+#endif
 		}
 	}
 	total += count;
@@ -272,8 +279,15 @@
 	for (i = 0; i < ((bdata->node_low_pfn-(bdata->node_boot_start >> PAGE_SHIFT))/8 + PAGE_SIZE-1)/PAGE_SIZE; i++,page++) {
 		count++;
 		ClearPageReserved(page);
+#ifdef CONFIG_BADRAM
+		if (!PageBad(page)) {
+			set_page_count(page, 1);
+			__free_page(page);
+		}
+#else
 		set_page_count(page, 1);
 		__free_page(page);
+#endif
 	}
 	total += count;
 	bdata->node_bootmem_map = NULL;
diff -Naur linux-2.4.33.orig/mm/page_alloc.c linux-2.4.33/mm/page_alloc.c
--- linux-2.4.33.orig/mm/page_alloc.c	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.33/mm/page_alloc.c	2006-08-11 20:17:15.000000000 +0200
@@ -10,6 +10,7 @@
  *  Reshaped it to be a zoned allocator, Ingo Molnar, Red Hat, 1999
  *  Discontiguous memory support, Kanoj Sarcar, SGI, Nov 1999
  *  Zone balancing, Kanoj Sarcar, SGI, Jan 2000
+ *  BadRAM handling, Rick van Rein, Feb 2001
  */
 
 #include <linux/config.h>
@@ -967,3 +968,92 @@
 }
 
 __setup("lower_zone_reserve=", setup_lower_zone_reserve);
+
+
+#ifdef CONFIG_BADRAM
+
+/* Given a pointed-at address and a mask, increment the page so that the
+ * mask hides the increment. Return 0 if no increment is possible.
+ */
+static int __init next_masked_address (unsigned long *addrp, unsigned long mask)
+{
+        unsigned long inc=1;
+        unsigned long newval = *addrp;
+	while (inc & mask)
+		inc += inc;
+        while (inc != 0) {
+		newval += inc;
+		newval &= ~mask;
+		newval |= ((*addrp) & mask);
+		if (newval > *addrp) {
+			*addrp = newval;
+			return 1;
+		}
+		do {
+			inc += inc;
+		} while (inc & ~mask);
+		while (inc & mask)
+			inc += inc;
+        }
+        return 0;
+}
+
+
+void __init badram_markpages (int argc, unsigned long *argv) {
+	unsigned long addr, mask;
+        while (argc-- > 0) {
+                addr = *argv++;
+                mask = (argc-- > 0) ? *argv++ : ~0L;
+                mask |= ~PAGE_MASK;	// Optimalisation
+		addr &= mask;		//  Normalisation
+                do {
+			struct page *pg = phys_to_page(addr);
+			printk ("%05lx ", __pa(__va(addr)) >> PAGE_SHIFT);
+			printk ("=%05lx/%05lx ", pg-mem_map, max_mapnr);
+			// if (VALID_PAGE(pg)) {
+				if (PageTestandSetBad (pg)) {
+					reserve_bootmem (addr, PAGE_SIZE);
+					printk ("BAD\n");
+				} else printk ("BFR\n");
+			// } else printk ("INV ");
+                } while (next_masked_address (&addr,mask));
+        }
+}
+
+
+/*********** CONFIG_BADRAM: CUSTOMISABLE SECTION STARTS HERE ******************/
+
+
+// Enter your custom BadRAM patterns here as pairs of unsigned long integers.
+// For more information on these F/M pairs, refer to Documentation/badram.txt
+
+
+static unsigned long __initdata badram_custom[] = {
+	4,	// Number of longwords that follow, as F/M pairs
+		0x01b19ffcL, 0xFFFFE003L, 0x0185c00cL, 0xFFFFE003L,
+};
+
+
+/*********** CONFIG_BADRAM: CUSTOMISABLE SECTION ENDS HERE ********************/
+
+
+static int __init badram_setup (char *str)
+{
+	unsigned long opts[3];
+	if (!mem_map) BUG();
+	printk ("PAGE_OFFSET=0x%08lx\n", PAGE_OFFSET);
+	printk ("BadRAM option is %s\n", str);
+	if (*str++ == '=')
+		while (str=get_options (str, 3, (int *) opts), *opts) {
+			printk ("   --> marking 0x%08lx, 0x%08lx  [%ld]\n", opts[1], opts[2], opts[0]);
+			badram_markpages (*opts, opts+1);
+			if (*opts==1)
+				break;
+		};
+	badram_markpages (*badram_custom, badram_custom+1);
+	return 0;
+}
+
+__setup("badram", badram_setup);
+
+#endif /* CONFIG_BADRAM */
diff -Naur linux-2.4.33.3/arch/ppc/kernel/m8xx_setup.c linux-2.4.33.3-ide/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.33.3/arch/ppc/kernel/m8xx_setup.c	2006-08-31 19:03:20.000000000 +0200
+++ linux-2.4.33.3-ide/arch/ppc/kernel/m8xx_setup.c	2006-09-19 00:05:28.000000000 +0200
@@ -410,7 +410,9 @@
 	ppc_md.kbd_init_hw		= NULL;
 	ppc_md.ppc_kbd_sysrq_xlate	= NULL;
 
+#if defined(CONFIG_BLK_DEV_MPC8xx_IDE)
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
 	m8xx_ide_init();
 #endif
+#endif
 }
diff -Naur linux-2.4.33.3/include/asm-ppc/pgtable.h linux-2.4.33.3-ide/include/asm-ppc/pgtable.h
--- linux-2.4.33.3/include/asm-ppc/pgtable.h	2006-11-08 19:35:25.064659104 +0000
+++ linux-2.4.33.3-ide/include/asm-ppc/pgtable.h	2006-11-08 19:35:01.237107868 +0000
@@ -629,11 +629,11 @@
  * must not include the _PAGE_PRESENT bit, or the _PAGE_HASHPTE bit
  * (if used).  -- paulus
  */
-#define SWP_TYPE(entry)			((entry).val & 0x3f)
-#define SWP_OFFSET(entry)		((entry).val >> 6)
-#define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 6) })
-#define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 2 })
-#define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#define SWP_TYPE(entry)			((entry).val & 0x1f)
+#define SWP_OFFSET(entry)		((entry).val >> 5)
+#define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 5) })
+#define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 8 })
+#define swp_entry_to_pte(x)		((pte_t) { (x).val << 8 })
 
 /* CONFIG_APUS */
 /* For virtual address to physical address conversion */
diff -Naur linux-2.4.36.2/arch/ppc/8xx_io/enet.c linux-2.4.36.2_new/arch/ppc/8xx_io/enet.c
--- linux-2.4.36.2/arch/ppc/8xx_io/enet.c	2008-02-24 21:38:03.000000000 +0100
+++ linux-2.4.36.2_new/arch/ppc/8xx_io/enet.c	2008-04-16 01:51:47.000000000 +0200
@@ -84,6 +84,12 @@
  * All functions are directly controlled using I/O pins.  See <asm/commproc.h>.
  */
 
+//The full-duplex part-1-start
+//to activate /var/tuxbox/config/boot.conf insert dbox_duplex=1
+//http://wiki.dbox2-tuning.net/wiki/index.php/FullDuplexUmbau
+static int duplex_mode=0;
+//The full-duplex part-1-end
+
 /* The transmitter timeout
  */
 #define TX_TIMEOUT	(2*HZ)
@@ -703,6 +709,13 @@
 #error Exactly ONE pair of PA_ENET_[RT]XD, PB_ENET_[RT]XD must be defined
 #endif
 
+#if defined(PA_ENET_LBK)
+	/* Disable Loopback */
+	immap->im_ioport.iop_papar &= ~PA_ENET_LBK;
+	immap->im_ioport.iop_padir |=  PA_ENET_LBK;
+	immap->im_ioport.iop_padat &= ~PA_ENET_LBK;
+#endif /* PA_ENET_LBK */
+
 #if defined(PC_ENET_LBK)
 	/* Configure port C pins to disable External Loopback
 	 */
@@ -714,7 +727,15 @@
 
 	/* Configure port C pins to enable CLSN and RENA.
 	*/
-	immap->im_ioport.iop_pcpar &= ~(PC_ENET_CLSN | PC_ENET_RENA);
+	if (duplex_mode==2)
+	{
+		immap->im_ioport.iop_pcpar &= ~PC_ENET_RENA;
+		immap->im_ioport.iop_pcpar |=  PC_ENET_CLSN; // Disable CLSN pin
+	}
+	else
+	{
+		immap->im_ioport.iop_pcpar &= ~(PC_ENET_CLSN | PC_ENET_RENA);
+	}
 	immap->im_ioport.iop_pcdir &= ~(PC_ENET_CLSN | PC_ENET_RENA);
 	immap->im_ioport.iop_pcso  |=  (PC_ENET_CLSN | PC_ENET_RENA);
 
@@ -890,7 +911,22 @@
 	/* Set processing mode.  Use Ethernet CRC, catch broadcast, and
 	 * start frame search 22 bit times after RENA.
 	 */
-	sccp->scc_pmsr = (SCC_PMSR_ENCRC | SCC_PMSR_NIB22);
+	//The full-duplex part-2-start
+	//sccp->scc_pmsr = (SCC_PMSR_ENCRC | SCC_PMSR_NIB22);
+	if (duplex_mode==0)
+	{
+		sccp->scc_pmsr = (SCC_PMSR_ENCRC | SCC_PMSR_NIB22);
+		printk(KERN_INFO "half-duplex mode enabled\n");
+	}
+	else
+	{
+		sccp->scc_pmsr = (SCC_PMSR_ENCRC | SCC_PMSR_NIB22 | SCC_PMSR_LPB | SCC_PMSR_FDE);
+		if (duplex_mode==2)
+			printk(KERN_INFO "forced full-duplex mode enabled\n");
+		else
+			printk(KERN_INFO "full-duplex mode enabled\n");
+	}
+	//The full-duplex part-2-end
 
 	/* It is now OK to enable the Ethernet transmitter.
 	 * Unfortunately, there are board implementation differences here.
@@ -961,3 +997,15 @@
 
 	return 0;
 }
+
+//The full-duplex part-3-start
+#ifndef MODULE
+static int __init duplex_mode_setup(char *str)
+{
+	duplex_mode = simple_strtol(str, NULL, 0);
+	return 1;
+}
+
+	__setup("dbox_duplex=", duplex_mode_setup);
+#endif
+//The full-duplex part-3-end
diff -Naur linux-2.4.36.2/include/asm-ppc/commproc.h linux-2.4.36.2_new/include/asm-ppc/commproc.h
--- linux-2.4.36.2/include/asm-ppc/commproc.h	2008-02-24 21:38:03.000000000 +0100
+++ linux-2.4.36.2_new/include/asm-ppc/commproc.h	2008-04-16 01:52:53.000000000 +0200
@@ -473,6 +473,7 @@
 #define PA_ENET_RXD	((ushort)0x0004)
 #define PA_ENET_TXD	((ushort)0x0008)
 #define PA_ENET_RCLK	((ushort)0x0200)
+#define PA_ENET_LBK	((ushort)0x0400)
 #define PA_ENET_TCLK	((ushort)0x0800)
 
 #define PC_ENET_TENA	((ushort)0x0002)
Index: b/kernel/timer.c
===================================================================
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -33,11 +33,14 @@ long tick = (1000000 + HZ/2) / HZ;	/* ti
 
 /* The current time */
 struct timeval xtime __attribute__ ((aligned (16)));
 
 /* Don't completely fail for HZ > 500.  */
-int tickadj = 500/HZ ? : 1;		/* microsecs */
+/* due to the dbox inexact timer, we allow more than
+   500 microsecs per tick Orignal would correct up to
+   0.5%, change it to 2%... */
+int tickadj = 2000/HZ ? : 1;		/* microsecs */
 
 DECLARE_TASK_QUEUE(tq_timer);
 DECLARE_TASK_QUEUE(tq_immediate);
 
 /*
