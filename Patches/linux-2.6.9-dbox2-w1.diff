diff -Nru a/drivers/w1/Kconfig b/drivers/w1/Kconfig
--- a/drivers/w1/Kconfig	2005-01-18 22:16:49 +01:00
+++ b/drivers/w1/Kconfig	2005-01-18 22:16:49 +01:00
@@ -11,6 +11,16 @@
 	  This W1 support can also be built as a module.  If so, the module
 	  will be called wire.ko.
 
+config W1_DBOX2
+	tristate "dbox2 transport layer for 1-wire"
+	depends on W1 && DBOX2
+	help
+	  Say Y here if you want to communicate with your 1-wire devices
+	  using GPIO pins of your dbox2.
+
+	  This driver may also be built as a module. If so, the module
+	  will be called dbox2_w1.ko
+
 config W1_MATROX
 	tristate "Matrox G400 transport layer for 1-wire"
 	depends on W1 && PCI
diff -Nru a/drivers/w1/Makefile b/drivers/w1/Makefile
--- a/drivers/w1/Makefile	2005-01-18 22:16:49 +01:00
+++ b/drivers/w1/Makefile	2005-01-18 22:16:49 +01:00
@@ -5,6 +5,7 @@
 obj-$(CONFIG_W1)	+= wire.o
 wire-objs		:= w1.o w1_int.o w1_family.o w1_netlink.o w1_io.o
 
+obj-$(CONFIG_W1_DBOX2)		+= dbox2_w1.o
 obj-$(CONFIG_W1_MATROX)		+= matrox_w1.o
 obj-$(CONFIG_W1_THERM)		+= w1_therm.o
 obj-$(CONFIG_W1_SMEM)		+= w1_smem.o
diff -Nru a/drivers/w1/dbox2_w1.c b/drivers/w1/dbox2_w1.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/w1/dbox2_w1.c	2005-01-18 22:16:49 +01:00
@@ -0,0 +1,60 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/commproc.h>
+#include "w1.h"
+#include "w1_int.h"
+
+static struct w1_bus_master *bus_master;
+static volatile cpm8xx_t *cpm;
+
+static u8 dbox2_w1_read_bit(unsigned long data)
+{
+	return (cpm->cp_pbdat & 0x04) >> 2;
+}
+
+static void dbox2_w1_write_bit(unsigned long data, u8 bit)
+{
+	if (bit) {
+		cpm->cp_pbdir &= ~0x04;
+	} else {
+		cpm->cp_pbdat &= ~0x04;
+		cpm->cp_pbdir |= 0x04;
+	}
+}
+
+static int __init dbox2_w1_init(void)
+{
+	volatile immap_t *immap;
+	int ret;
+
+	bus_master = kmalloc(sizeof(struct w1_bus_master), GFP_KERNEL);
+	if (!bus_master)
+		return -ENOMEM;
+	memset(bus_master,0,sizeof(struct w1_bus_master));
+
+	immap = (volatile immap_t *)IMAP_ADDR;
+	cpm = &immap->im_cpm;
+
+	cpm->cp_pbpar &= ~0x04;
+	cpm->cp_pbodr |= 0x04;
+
+	bus_master->data = 0;
+	bus_master->read_bit = dbox2_w1_read_bit;
+	bus_master->write_bit = dbox2_w1_write_bit;
+
+	ret = w1_add_master_device(bus_master);
+	if (ret)
+		kfree(bus_master);
+
+	return ret;
+}
+
+static void __exit dbox2_w1_exit(void)
+{
+	w1_remove_master_device(bus_master);
+	kfree(bus_master);
+}
+
+module_init(dbox2_w1_init);
+module_exit(dbox2_w1_exit);
