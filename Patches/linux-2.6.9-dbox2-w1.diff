diff -Nru a/drivers/w1/Kconfig b/drivers/w1/Kconfig
--- a/drivers/w1/Kconfig	2005-01-28 15:39:06 +01:00
+++ b/drivers/w1/Kconfig	2005-01-28 15:39:06 +01:00
@@ -11,6 +11,16 @@
 	  This W1 support can also be built as a module.  If so, the module
 	  will be called wire.ko.
 
+config W1_DBOX2
+	tristate "dbox2 transport layer for 1-wire"
+	depends on W1 && DBOX2
+	help
+	  Say Y here if you want to communicate with your 1-wire devices
+	  using GPIO pins of your dbox2.
+
+	  This driver may also be built as a module. If so, the module
+	  will be called dbox2_w1.ko
+
 config W1_MATROX
 	tristate "Matrox G400 transport layer for 1-wire"
 	depends on W1 && PCI
diff -Nru a/drivers/w1/Makefile b/drivers/w1/Makefile
--- a/drivers/w1/Makefile	2005-01-28 15:39:06 +01:00
+++ b/drivers/w1/Makefile	2005-01-28 15:39:06 +01:00
@@ -5,6 +5,7 @@
 obj-$(CONFIG_W1)	+= wire.o
 wire-objs		:= w1.o w1_int.o w1_family.o w1_netlink.o w1_io.o
 
+obj-$(CONFIG_W1_DBOX2)		+= dbox2_w1.o
 obj-$(CONFIG_W1_MATROX)		+= matrox_w1.o
 obj-$(CONFIG_W1_THERM)		+= w1_therm.o
 obj-$(CONFIG_W1_SMEM)		+= w1_smem.o
diff -Nru a/drivers/w1/dbox2_w1.c b/drivers/w1/dbox2_w1.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/w1/dbox2_w1.c	2005-01-28 15:39:06 +01:00
@@ -0,0 +1,60 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/commproc.h>
+#include "w1.h"
+#include "w1_int.h"
+
+static struct w1_bus_master *bus_master;
+static volatile cpm8xx_t *cpm;
+
+static u8 dbox2_w1_read_bit(unsigned long data)
+{
+	return (cpm->cp_pbdat & 0x04) >> 2;
+}
+
+static void dbox2_w1_write_bit(unsigned long data, u8 bit)
+{
+	if (bit) {
+		cpm->cp_pbdir &= ~0x04;
+	} else {
+		cpm->cp_pbdat &= ~0x04;
+		cpm->cp_pbdir |= 0x04;
+	}
+}
+
+static int __init dbox2_w1_init(void)
+{
+	volatile immap_t *immap;
+	int ret;
+
+	bus_master = kmalloc(sizeof(struct w1_bus_master), GFP_KERNEL);
+	if (!bus_master)
+		return -ENOMEM;
+	memset(bus_master,0,sizeof(struct w1_bus_master));
+
+	immap = (volatile immap_t *)IMAP_ADDR;
+	cpm = &immap->im_cpm;
+
+	cpm->cp_pbpar &= ~0x04;
+	cpm->cp_pbodr |= 0x04;
+
+	bus_master->data = 0;
+	bus_master->read_bit = dbox2_w1_read_bit;
+	bus_master->write_bit = dbox2_w1_write_bit;
+
+	ret = w1_add_master_device(bus_master);
+	if (ret)
+		kfree(bus_master);
+
+	return ret;
+}
+
+static void __exit dbox2_w1_exit(void)
+{
+	w1_remove_master_device(bus_master);
+	kfree(bus_master);
+}
+MODULE_LICENSE("GPL");
+module_init(dbox2_w1_init);
+module_exit(dbox2_w1_exit);
diff -Nru a/drivers/w1/w1.c b/drivers/w1/w1.c
--- a/drivers/w1/w1.c	2005-01-28 15:39:06 +01:00
+++ b/drivers/w1/w1.c	2005-01-28 15:39:06 +01:00
@@ -20,6 +20,7 @@
  */
 
 #include <asm/atomic.h>
+#include <asm/byteorder.h>
 
 #include <linux/delay.h>
 #include <linux/kernel.h>
@@ -463,6 +464,9 @@
 static void w1_search(struct w1_master *dev)
 {
 	u64 last, rn, tmp;
+#ifdef __BIG_ENDIAN
+	struct w1_reg_num _tmp;
+#endif
 	int i, count = 0, slave_count;
 	int last_family_desc, last_zero, last_device;
 	int search_bit, id_bit, comp_bit, desc_bit;
@@ -540,6 +544,13 @@
 
 		}
 #endif
+		
+#ifdef __BIG_ENDIAN
+		__cpu_to_le64s(&rn);
+		_tmp.family = (rn>>56)&0xff;
+		_tmp.id = (rn>>8)&0xffffffffffffLL;
+		_tmp.crc = rn&0xff;
+#endif
 
 		if (desc_bit == last_zero)
 			last_device = 1;
@@ -550,8 +561,12 @@
 		list_for_each(ent, &dev->slist) {
 			struct w1_reg_num *tmp;
 
+#ifdef __BIG_ENDIAN
+			tmp = &_tmp;
+#else
 			tmp = (struct w1_reg_num *) &rn;
-
+#endif
+			
 			sl = list_entry(ent, struct w1_slave, w1_slave_entry);
 
 			if (sl->reg_num.family == tmp->family &&
@@ -569,8 +584,13 @@
 		}
 
 		if (slave_count == dev->slave_count &&
+#ifdef __BIG_ENDIAN
+		    (rn & 0xff) == w1_calc_crc8((u8 *)&rn, 7)) {
+			w1_attach_slave_device(dev, &_tmp);
+#else
 		    ((rn >> 56) & 0xff) == w1_calc_crc8((u8 *)&rn, 7)) {
 			w1_attach_slave_device(dev, (struct w1_reg_num *) &rn);
+#endif
 		}
 	}
 }
