diff -Naur linux-2.4.32/Documentation/filesystems/cramfs.txt linux-2.4.32-cramfs/Documentation/filesystems/cramfs.txt
--- linux-2.4.32/Documentation/filesystems/cramfs.txt	2002-08-03 02:39:42.000000000 +0200
+++ linux-2.4.32-cramfs/Documentation/filesystems/cramfs.txt	2005-12-18 17:44:43.000000000 +0100
@@ -37,12 +37,11 @@
 the update lasts only as long as the inode is cached in memory, after
 which the timestamp reverts to 1970, i.e. moves backwards in time.
 
-Currently, cramfs must be written and read with architectures of the
-same endianness, and can be read only by kernels with PAGE_CACHE_SIZE
-== 4096.  At least the latter of these is a bug, but it hasn't been
-decided what the best fix is.  For the moment if you have larger pages
-you can just change the #define in mkcramfs.c, so long as you don't
-mind the filesystem becoming unreadable to future kernels.
+Currently, cramfs can be read only by kernels with PAGE_CACHE_SIZE ==
+4096.  This is a bug, but it hasn't been decided what the best fix is.
+For the moment if you have larger pages you can just change the
+#define in mkcramfs.c, so long as you don't mind the filesystem
+becoming unreadable to future kernels.
 
 
 For /usr/share/magic
diff -Naur linux-2.4.32/fs/cramfs/README linux-2.4.32-cramfs/fs/cramfs/README
--- linux-2.4.32/fs/cramfs/README	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.32-cramfs/fs/cramfs/README	2005-12-18 17:44:43.000000000 +0100
@@ -6,8 +6,8 @@
 swapped around (though it does care that directory entries (inodes) in
 a given directory are contiguous, as this is used by readdir).
 
-All data is currently in host-endian format; neither mkcramfs nor the
-kernel ever do swabbing.  (See section `Block Size' below.)
+All data is in little-endian format; user-space tools and the kernel do
+swabbing on big-endian systems.  (See section `Byte Order' below.)
 
 <filesystem>:
 	<superblock>
@@ -71,6 +71,27 @@
 with -z if you want it to create files that can have holes in them.
 
 
+Byte Order
+----------
+
+When defining the cramfs filesystem, the two options for byte order were
+`always use little-endian' (like ext2fs) or `writer chooses endianness;
+kernel adapts at runtime'.  Little-endian wins because of code
+simplicity and little CPU overhead even on big-endian machines.
+
+While cramfs has always been defined to be little-endian, this
+implementation originally required that cramfs filesystems be written
+and read with architectures of the same endianness; big-endian machines
+would write and read cramfs filesystems with big-endian byte order (the
+"incorrect" byte order for cramfs filesystems).
+
+Now, only little-endian cramfs filesystems are supported for both
+little-endian and big-endian machines.  If you need to support
+big-endian cramfs filesystems for a legacy application on a big-endian
+machine, you could remove the byte-swapping, but it would probably be
+better to write a one-time byte order conversion program.
+
+
 Tools
 -----
 
@@ -108,17 +129,8 @@
 PAGE_CACHE_SIZE is subject to change between kernel versions
 (currently possible with arm and ia64).
 
-The remaining options try to make cramfs more sharable.
-
-One part of that is addressing endianness.  The two options here are
-`always use little-endian' (like ext2fs) or `writer chooses
-endianness; kernel adapts at runtime'.  Little-endian wins because of
-code simplicity and little CPU overhead even on big-endian machines.
-
-The cost of swabbing is changing the code to use the le32_to_cpu
-etc. macros as used by ext2fs.  We don't need to swab the compressed
-data, only the superblock, inodes and block pointers.
-
+The remaining options try to make cramfs more sharable by choosing a
+block size.  The options are:
 
 The other part of making cramfs more sharable is choosing a block
 size.  The options are:
@@ -153,7 +165,6 @@
 will disagree.  (If it is implemented, then I'll re-use that code in
 e2compr.)
 
-
 Another cost of 2 and 3 over 1 is making mkcramfs use a different
 block size, but that just means adding and parsing a -b option.
 
diff -Naur linux-2.4.32/fs/cramfs/inode.c linux-2.4.32-cramfs/fs/cramfs/inode.c
--- linux-2.4.32/fs/cramfs/inode.c	2004-08-08 01:26:05.000000000 +0200
+++ linux-2.4.32-cramfs/fs/cramfs/inode.c	2005-12-18 17:44:43.000000000 +0100
@@ -1,13 +1,18 @@
 /*
- * Compressed rom filesystem for Linux.
+ * inode.c
  *
- * Copyright (C) 1999 Linus Torvalds.
+ * Copyright (C) 1999 Linus Torvalds
+ * Copyright (C) 2000-2002 Transmeta Corporation
  *
- * This file is released under the GPL.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * Compressed ROM filesystem for Linux.
  */
 
 /*
- * These are the VFS interfaces to the compressed rom filesystem.
+ * These are the VFS interfaces to the compressed ROM filesystem.
  * The actual compression is based on zlib, see the other files.
  */
 
@@ -39,7 +44,7 @@
 
 /* These two macros may change in future, to provide better st_ino
    semantics. */
-#define CRAMINO(x)	((x)->offset?(x)->offset<<2:1)
+#define CRAMINO(x)	(CRAMFS_GET_OFFSET(x) ? CRAMFS_GET_OFFSET(x)<<2 : 1)
 #define OFFSET(x)	((x)->i_ino)
 
 static struct inode *get_cramfs_inode(struct super_block *sb, struct cramfs_inode * cramfs_inode)
@@ -47,16 +52,16 @@
 	struct inode * inode = new_inode(sb);
 
 	if (inode) {
-		inode->i_mode = cramfs_inode->mode;
-		inode->i_uid = cramfs_inode->uid;
-		inode->i_size = cramfs_inode->size;
-		inode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;
+		inode->i_mode = CRAMFS_16(cramfs_inode->mode);
+		inode->i_uid = CRAMFS_16(cramfs_inode->uid);
+		inode->i_size = CRAMFS_24(cramfs_inode->size);
+		inode->i_blocks = (CRAMFS_24(cramfs_inode->size) - 1)/512 + 1;
 		inode->i_blksize = PAGE_CACHE_SIZE;
 		inode->i_gid = cramfs_inode->gid;
 		inode->i_ino = CRAMINO(cramfs_inode);
 		/* inode->i_nlink is left 1 - arguably wrong for directories,
 		   but it's the best we can do without reading the directory
-	           contents.  1 yields the right result in GNU find, even
+		   contents.  1 yields the right result in GNU find, even
 		   without -noleaf option. */
 		insert_inode_hash(inode);
 		if (S_ISREG(inode->i_mode)) {
@@ -70,7 +75,7 @@
 			inode->i_data.a_ops = &cramfs_aops;
 		} else {
 			inode->i_size = 0;
-			init_special_inode(inode, inode->i_mode, cramfs_inode->size);
+			init_special_inode(inode, inode->i_mode, CRAMFS_24(cramfs_inode->size));
 		}
 	}
 	return inode;
@@ -78,7 +83,7 @@
 
 /*
  * We have our own block cache: don't fill up the buffer cache
- * with the rom-image, because the way the filesystem is set
+ * with the ROM image, because the way the filesystem is set
  * up the accesses should be fairly regular and cached in the
  * page cache and dentry tree anyway..
  *
@@ -211,15 +216,18 @@
 	up(&read_mutex);
 
 	/* Do sanity checks on the superblock */
-	if (super.magic != CRAMFS_MAGIC) {
+	if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
 		/* check at 512 byte offset */
 		memcpy(&super, cramfs_read(sb, 512, sizeof(super)), sizeof(super));
-		if (super.magic != CRAMFS_MAGIC) {
+		if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
 			printk(KERN_ERR "cramfs: wrong magic\n");
 			goto out;
 		}
 	}
 
+	/* flags is reused several times, so swab it once */
+	super.flags = CRAMFS_32(super.flags);
+
 	/* get feature flags first */
 	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
 		printk(KERN_ERR "cramfs: unsupported filesystem features\n");
@@ -227,22 +235,22 @@
 	}
 
 	/* Check that the root inode is in a sane state */
-	if (!S_ISDIR(super.root.mode)) {
+	if (!S_ISDIR(CRAMFS_16(super.root.mode))) {
 		printk(KERN_ERR "cramfs: root is not a directory\n");
 		goto out;
 	}
-	root_offset = super.root.offset << 2;
+	root_offset = CRAMFS_GET_OFFSET(&(super.root)) << 2;
 	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
-		sb->CRAMFS_SB_SIZE=super.size;
-		sb->CRAMFS_SB_BLOCKS=super.fsid.blocks;
-		sb->CRAMFS_SB_FILES=super.fsid.files;
+		sb->CRAMFS_SB_SIZE = CRAMFS_32(super.size);
+		sb->CRAMFS_SB_BLOCKS = CRAMFS_32(super.fsid.blocks);
+		sb->CRAMFS_SB_FILES = CRAMFS_32(super.fsid.files);
 	} else {
-		sb->CRAMFS_SB_SIZE=1<<28;
-		sb->CRAMFS_SB_BLOCKS=0;
-		sb->CRAMFS_SB_FILES=0;
+		sb->CRAMFS_SB_SIZE = 1 << 28;
+		sb->CRAMFS_SB_BLOCKS = 0;
+		sb->CRAMFS_SB_FILES = 0;
 	}
-	sb->CRAMFS_SB_MAGIC=super.magic;
-	sb->CRAMFS_SB_FLAGS=super.flags;
+	sb->CRAMFS_SB_MAGIC = CRAMFS_MAGIC;
+	sb->CRAMFS_SB_FLAGS = super.flags;
 	if (root_offset == 0)
 		printk(KERN_INFO "cramfs: empty filesystem");
 	else if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&
@@ -309,7 +317,7 @@
 		 * and the name padded out to 4-byte boundaries
 		 * with zeroes.
 		 */
-		namelen = de->namelen << 2;
+		namelen = CRAMFS_GET_NAMELEN(de) << 2;
 		nextoffset = offset + sizeof(*de) + namelen;
 		for (;;) {
 			if (!namelen)
@@ -318,7 +326,7 @@
 				break;
 			namelen--;
 		}
-		error = filldir(dirent, name, namelen, offset, CRAMINO(de), de->mode >> 12);
+		error = filldir(dirent, name, namelen, offset, CRAMINO(de), CRAMFS_16(de->mode) >> 12);
 		if (error)
 			break;
 
@@ -351,7 +359,7 @@
 		if (sorted && (dentry->d_name.name[0] < name[0]))
 			break;
 
-		namelen = de->namelen << 2;
+		namelen = CRAMFS_GET_NAMELEN(de) << 2;
 		offset += sizeof(*de) + namelen;
 
 		/* Quick check that the name is roughly the right length */
@@ -398,8 +406,8 @@
 		start_offset = OFFSET(inode) + maxblock*4;
 		down(&read_mutex);
 		if (page->index)
-			start_offset = *(u32 *) cramfs_read(sb, blkptr_offset-4, 4);
-		compr_len = (*(u32 *) cramfs_read(sb, blkptr_offset, 4) - start_offset);
+			start_offset = CRAMFS_32(*(u32 *) cramfs_read(sb, blkptr_offset-4, 4));
+		compr_len = CRAMFS_32(*(u32 *) cramfs_read(sb, blkptr_offset, 4)) - start_offset;
 		up(&read_mutex);
 		pgdata = kmap(page);
 		if (compr_len == 0)
diff -Naur linux-2.4.32/fs/cramfs/uncompress.c linux-2.4.32-cramfs/fs/cramfs/uncompress.c
--- linux-2.4.32/fs/cramfs/uncompress.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.32-cramfs/fs/cramfs/uncompress.c	2005-12-18 17:44:43.000000000 +0100
@@ -1,7 +1,12 @@
 /*
  * uncompress.c
  *
- * (C) Copyright 1999 Linus Torvalds
+ * Copyright (C) 1999 Linus Torvalds
+ * Copyright (C) 2000-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
  *
  * cramfs interfaces to the uncompression library. There's really just
  * three entrypoints:
diff -Naur linux-2.4.32/include/linux/cramfs_fs.h linux-2.4.32-cramfs/include/linux/cramfs_fs.h
--- linux-2.4.32/include/linux/cramfs_fs.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.32-cramfs/include/linux/cramfs_fs.h	2005-12-18 17:44:43.000000000 +0100
@@ -1,13 +1,25 @@
-#ifndef __CRAMFS_H
-#define __CRAMFS_H
+#ifndef __CRAMFS_FS_H
+#define __CRAMFS_FS_H
 
-#ifndef __KERNEL__
+#ifdef __KERNEL__
+
+#include <asm/byteorder.h>
+
+/* Uncompression interfaces to the underlying zlib */
+int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen);
+int cramfs_uncompress_init(void);
+int cramfs_uncompress_exit(void);
+
+#else /* not __KERNEL__ */
+
+#include <byteswap.h>
+#include <endian.h>
 
 typedef unsigned char u8;
 typedef unsigned short u16;
 typedef unsigned int u32;
 
-#endif
+#endif /* not __KERNEL__ */
 
 #define CRAMFS_MAGIC		0x28cd3d45	/* some random number */
 #define CRAMFS_SIGNATURE	"Compressed ROMFS"
@@ -90,9 +102,50 @@
 				| CRAMFS_FLAG_WRONG_SIGNATURE \
 				| CRAMFS_FLAG_SHIFTED_ROOT_OFFSET )
 
-/* Uncompression interfaces to the underlying zlib */
-int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen);
-int cramfs_uncompress_init(void);
-int cramfs_uncompress_exit(void);
+/*
+ * Since cramfs is little-endian, provide macros to swab the bitfields.
+ */
+
+#ifndef __BYTE_ORDER
+#if defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN) && !defined(__LITTLE_ENDIAN)
+#define __BYTE_ORDER __BIG_ENDIAN
+#else
+#error "unable to define __BYTE_ORDER"
+#endif
+#endif /* not __BYTE_ORDER */
 
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#warning  "__BYTE_ORDER == __LITTLE_ENDIAN"
+#define CRAMFS_16(x)	(x)
+#define CRAMFS_24(x)	(x)
+#define CRAMFS_32(x)	(x)
+#define CRAMFS_GET_NAMELEN(x)	((x)->namelen)
+#define CRAMFS_GET_OFFSET(x)	((x)->offset)
+#define CRAMFS_SET_OFFSET(x,y)	((x)->offset = (y))
+#define CRAMFS_SET_NAMELEN(x,y)	((x)->namelen = (y))
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#warning "__BYTE_ORDER == __BIG_ENDIAN"
+#ifdef __KERNEL__
+#define CRAMFS_16(x)	swab16(x)
+#define CRAMFS_24(x)	((swab32(x)) >> 8)
+#define CRAMFS_32(x)	swab32(x)
+#else /* not __KERNEL__ */
+#define CRAMFS_16(x)	bswap_16(x)
+#define CRAMFS_24(x)	((bswap_32(x)) >> 8)
+#define CRAMFS_32(x)	bswap_32(x)
+#endif /* not __KERNEL__ */
+#define CRAMFS_GET_NAMELEN(x)	(((u8*)(x))[8] & 0x3f)
+#define CRAMFS_GET_OFFSET(x)	((CRAMFS_24(((u32*)(x))[2] & 0xffffff) << 2) |\
+				 ((((u32*)(x))[2] & 0xc0000000) >> 30))
+#define CRAMFS_SET_NAMELEN(x,y)	(((u8*)(x))[8] = (((0x3f & (y))) | \
+						  (0xc0 & ((u8*)(x))[8])))
+#define CRAMFS_SET_OFFSET(x,y)	(((u32*)(x))[2] = (((y) & 3) << 30) | \
+				 CRAMFS_24((((y) & 0x03ffffff) >> 2)) | \
+				 (((u32)(((u8*)(x))[8] & 0x3f)) << 24))
+#else
+#error "__BYTE_ORDER must be __LITTLE_ENDIAN or __BIG_ENDIAN"
 #endif
+
+#endif /* not __CRAMFS_FS_H */
diff -Naur linux-2.4.32/scripts/cramfs/GNUmakefile linux-2.4.32-cramfs/scripts/cramfs/GNUmakefile
--- linux-2.4.32/scripts/cramfs/GNUmakefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-cramfs/scripts/cramfs/GNUmakefile	2005-12-18 17:44:43.000000000 +0100
@@ -0,0 +1,12 @@
+CC = gcc
+CFLAGS = -W -Wall -O2 -g
+CPPFLAGS = -I../../include
+LDLIBS = -lz
+PROGS = mkcramfs cramfsck
+
+all: $(PROGS)
+
+distclean clean:
+	rm -f $(PROGS)
+
+.PHONY: all clean
diff -Naur linux-2.4.32/scripts/cramfs/Makefile linux-2.4.32-cramfs/scripts/cramfs/Makefile
--- linux-2.4.32/scripts/cramfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-cramfs/scripts/cramfs/Makefile	2005-12-18 17:44:43.000000000 +0100
@@ -0,0 +1,12 @@
+CC = gcc
+CFLAGS = -W -Wall -O2 -g
+CPPFLAGS = -I../../include
+LDLIBS = -lz
+PROGS = mkcramfs cramfsck
+
+all: $(PROGS)
+
+distclean clean:
+	rm -f $(PROGS)
+
+.PHONY: all clean
diff -Naur linux-2.4.32/scripts/cramfs/cramfsck.c linux-2.4.32-cramfs/scripts/cramfs/cramfsck.c
--- linux-2.4.32/scripts/cramfs/cramfsck.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-cramfs/scripts/cramfs/cramfsck.c	2005-12-18 17:44:43.000000000 +0100
@@ -0,0 +1,718 @@
+/*
+ * cramfsck - check a cramfs file system
+ *
+ * Copyright (C) 2000-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * 1999/12/03: Linus Torvalds (cramfs tester and unarchive program)
+ * 2000/06/03: Daniel Quinlan (CRC and length checking program)
+ * 2000/06/04: Daniel Quinlan (merged programs, added options, support
+ *                            for special files, preserve permissions and
+ *                            ownership, cramfs superblock v2, bogus mode
+ *                            test, pathname length test, etc.)
+ * 2000/06/06: Daniel Quinlan (support for holes, pretty-printing,
+ *                            symlink size test)
+ * 2000/07/11: Daniel Quinlan (file length tests, start at offset 0 or 512,
+ *                            fsck-compatible exit codes)
+ * 2000/07/15: Daniel Quinlan (initial support for block devices)
+ * 2002/01/10: Daniel Quinlan (additional checks, test more return codes,
+ *                            use read if mmap fails, standardize messages)
+ * 2002/02/22: Brad Bozarth   (add support for big-endian systems)
+ */
+
+/* compile-time options */
+#define INCLUDE_FS_TESTS	/* include cramfs checking and extraction */
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/sysmacros.h>
+#include <utime.h>
+#include <sys/ioctl.h>
+#define _LINUX_STRING_H_
+#include <linux/fs.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+/* Exit codes used by fsck-type programs */
+#define FSCK_OK          0	/* No errors */
+#define FSCK_NONDESTRUCT 1	/* File system errors corrected */
+#define FSCK_REBOOT      2	/* System should be rebooted */
+#define FSCK_UNCORRECTED 4	/* File system errors left uncorrected */
+#define FSCK_ERROR       8	/* Operational error */
+#define FSCK_USAGE       16	/* Usage or syntax error */
+#define FSCK_LIBRARY     128	/* Shared library error */
+
+#define PAD_SIZE 512
+#define PAGE_CACHE_SIZE (4096)
+
+static const char *progname = "cramfsck";
+
+static int fd;			/* ROM image file descriptor */
+static char *filename;		/* ROM image filename */
+struct cramfs_super super;	/* just find the cramfs superblock once */
+static int opt_verbose = 0;	/* 1 = verbose (-v), 2+ = very verbose (-vv) */
+#ifdef INCLUDE_FS_TESTS
+static int opt_extract = 0;		/* extract cramfs (-x) */
+static char *extract_dir = "root";	/* extraction directory (-x) */
+static uid_t euid;			/* effective UID */
+
+/* (cramfs_super + start) <= start_dir < end_dir <= start_data <= end_data */
+static unsigned long start_dir = ~0UL;	/* start of first non-root inode */
+static unsigned long end_dir = 0;	/* end of the directory structure */
+static unsigned long start_data = ~0UL;	/* start of the data (256 MB = max) */
+static unsigned long end_data = 0;	/* end of the data */
+
+/* Guarantee access to at least 8kB at a time */
+#define ROMBUFFER_BITS	13
+#define ROMBUFFERSIZE	(1 << ROMBUFFER_BITS)
+#define ROMBUFFERMASK	(ROMBUFFERSIZE-1)
+static char read_buffer[ROMBUFFERSIZE * 2];
+static unsigned long read_buffer_block = ~0UL;
+
+/* Uncompressing data structures... */
+static char outbuffer[PAGE_CACHE_SIZE*2];
+static z_stream stream;
+
+/* Prototypes */
+static void expand_fs(char *, struct cramfs_inode *);
+#endif /* INCLUDE_FS_TESTS */
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-hv] [-x dir] file\n"
+		" -h         print this help\n"
+		" -x dir     extract into dir\n"
+		" -v         be more verbose\n"
+		" file       file to test\n", progname);
+
+	exit(status);
+}
+
+static void die(int status, int syserr, const char *fmt, ...)
+{
+	va_list arg_ptr;
+	int save = errno;
+
+	fflush(0);
+	va_start(arg_ptr, fmt);
+	fprintf(stderr, "%s: ", progname);
+	vfprintf(stderr, fmt, arg_ptr);
+	if (syserr) {
+		fprintf(stderr, ": %s", strerror(save));
+	}
+	fprintf(stderr, "\n");
+	va_end(arg_ptr);
+	exit(status);
+}
+
+static void test_super(int *start, size_t *length) {
+	struct stat st;
+
+	/* find the physical size of the file or block device */
+	if (stat(filename, &st) < 0) {
+		die(FSCK_ERROR, 1, "stat failed: %s", filename);
+	}
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		die(FSCK_ERROR, 1, "open failed: %s", filename);
+	}
+	if (S_ISBLK(st.st_mode)) {
+		if (ioctl(fd, BLKGETSIZE, length) < 0) {
+			die(FSCK_ERROR, 1, "ioctl failed: unable to determine device size: %s", filename);
+		}
+		*length = *length * 512;
+	}
+	else if (S_ISREG(st.st_mode)) {
+		*length = st.st_size;
+	}
+	else {
+		die(FSCK_ERROR, 0, "not a block device or file: %s", filename);
+	}
+
+	if (*length < sizeof(struct cramfs_super)) {
+		die(FSCK_UNCORRECTED, 0, "file length too short");
+	}
+
+	/* find superblock */
+	if (read(fd, &super, sizeof(super)) != sizeof(super)) {
+		die(FSCK_ERROR, 1, "read failed: %s", filename);
+	}
+	if (super.magic == CRAMFS_32(CRAMFS_MAGIC)) {
+		*start = 0;
+	}
+	else if (*length >= (PAD_SIZE + sizeof(super))) {
+		lseek(fd, PAD_SIZE, SEEK_SET);
+		if (read(fd, &super, sizeof(super)) != sizeof(super)) {
+			die(FSCK_ERROR, 1, "read failed: %s", filename);
+		}
+		if (super.magic == CRAMFS_32(CRAMFS_MAGIC)) {
+			*start = PAD_SIZE;
+		}
+	}
+
+	/* superblock tests */
+	if (super.magic != CRAMFS_32(CRAMFS_MAGIC)) {
+		die(FSCK_UNCORRECTED, 0, "superblock magic not found");
+	}
+#if __BYTE_ORDER == __BIG_ENDIAN
+	super.size = CRAMFS_32(super.size);
+	super.flags = CRAMFS_32(super.flags);
+	super.future = CRAMFS_32(super.future);
+	super.fsid.crc = CRAMFS_32(super.fsid.crc);
+	super.fsid.edition = CRAMFS_32(super.fsid.edition);
+	super.fsid.blocks = CRAMFS_32(super.fsid.blocks);
+	super.fsid.files = CRAMFS_32(super.fsid.files);
+#endif /* __BYTE_ORDER == __BIG_ENDIAN */
+	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {
+		die(FSCK_ERROR, 0, "unsupported filesystem features");
+	}
+	if (super.size < PAGE_CACHE_SIZE) {
+		die(FSCK_UNCORRECTED, 0, "superblock size (%d) too small", super.size);
+	}
+	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		if (super.fsid.files == 0) {
+			die(FSCK_UNCORRECTED, 0, "zero file count");
+		}
+		if (*length < super.size) {
+			die(FSCK_UNCORRECTED, 0, "file length too short");
+		}
+		else if (*length > super.size) {
+			fprintf(stderr, "warning: file extends past end of filesystem\n");
+		}
+	}
+	else {
+		fprintf(stderr, "warning: old cramfs format\n");
+	}
+}
+
+static void test_crc(int start)
+{
+	void *buf;
+	u32 crc;
+
+	if (!(super.flags & CRAMFS_FLAG_FSID_VERSION_2)) {
+#ifdef INCLUDE_FS_TESTS
+		return;
+#else /* not INCLUDE_FS_TESTS */
+		die(FSCK_USAGE, 0, "unable to test CRC: old cramfs format");
+#endif /* not INCLUDE_FS_TESTS */
+	}
+
+	crc = crc32(0L, Z_NULL, 0);
+
+	buf = mmap(NULL, super.size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+	if (buf == MAP_FAILED) {
+		buf = mmap(NULL, super.size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+		if (buf != MAP_FAILED) {
+			lseek(fd, 0, SEEK_SET);
+			read(fd, buf, super.size);
+		}
+	}
+	if (buf != MAP_FAILED) {
+		((struct cramfs_super *) (buf+start))->fsid.crc = crc32(0L, Z_NULL, 0);
+		crc = crc32(crc, buf+start, super.size-start);
+		munmap(buf, super.size);
+	}
+	else {
+		int retval;
+		size_t length = 0;
+
+		buf = malloc(4096);
+		if (!buf) {
+			die(FSCK_ERROR, 1, "malloc failed");
+		}
+		lseek(fd, start, SEEK_SET);
+		for (;;) {
+			retval = read(fd, buf, 4096);
+			if (retval < 0) {
+				die(FSCK_ERROR, 1, "read failed: %s", filename);
+			}
+			else if (retval == 0) {
+				break;
+			}
+			if (length == 0) {
+				((struct cramfs_super *) buf)->fsid.crc = crc32(0L, Z_NULL, 0);
+			}
+			length += retval;
+			if (length > (super.size-start)) {
+				crc = crc32(crc, buf, retval - (length - (super.size-start)));
+				break;
+			}
+			crc = crc32(crc, buf, retval);
+		}
+		free(buf);
+	}
+
+	if (crc != super.fsid.crc) {
+		die(FSCK_UNCORRECTED, 0, "crc error");
+	}
+}
+
+#ifdef INCLUDE_FS_TESTS
+static void print_node(char type, struct cramfs_inode *i, char *name)
+{
+	char info[10];
+
+	if (S_ISCHR(i->mode) || (S_ISBLK(i->mode))) {
+		/* major/minor numbers can be as high as 2^12 or 4096 */
+		snprintf(info, 10, "%4d,%4d", major(i->size), minor(i->size));
+	}
+	else {
+		/* size be as high as 2^24 or 16777216 */
+		snprintf(info, 10, "%9d", i->size);
+	}
+
+	printf("%c %04o %s %5d:%-3d %s\n",
+	       type, i->mode & ~S_IFMT, info, i->uid, i->gid, name);
+}
+
+/*
+ * Create a fake "blocked" access
+ */
+static void *romfs_read(unsigned long offset)
+{
+	unsigned int block = offset >> ROMBUFFER_BITS;
+	if (block != read_buffer_block) {
+		read_buffer_block = block;
+		lseek(fd, block << ROMBUFFER_BITS, SEEK_SET);
+		read(fd, read_buffer, ROMBUFFERSIZE * 2);
+	}
+	return read_buffer + (offset & ROMBUFFERMASK);
+}
+
+static struct cramfs_inode *cramfs_iget(struct cramfs_inode *i)
+{
+	struct cramfs_inode *inode = malloc(sizeof(struct cramfs_inode));
+
+	if (!inode) {
+		die(FSCK_ERROR, 1, "malloc failed");
+	}
+#if __BYTE_ORDER == __BIG_ENDIAN
+	inode->mode = CRAMFS_16(i->mode);
+	inode->uid = CRAMFS_16(i->uid);
+	inode->size = CRAMFS_24(i->size);
+	inode->gid = i->gid;
+	inode->namelen = CRAMFS_GET_NAMELEN(i);
+	inode->offset = CRAMFS_GET_OFFSET(i);
+#else /* not __BYTE_ORDER == __BIG_ENDIAN */
+	*inode = *i;
+#endif /* not __BYTE_ORDER == __BIG_ENDIAN */
+	return inode;
+}
+
+static struct cramfs_inode *iget(unsigned int ino)
+{
+	return cramfs_iget(romfs_read(ino));
+}
+
+static void iput(struct cramfs_inode *inode)
+{
+	free(inode);
+}
+
+static int uncompress_block(void *src, int len)
+{
+	int err;
+
+	stream.next_in = src;
+	stream.avail_in = len;
+
+	stream.next_out = (unsigned char *) outbuffer;
+	stream.avail_out = PAGE_CACHE_SIZE*2;
+
+	inflateReset(&stream);
+
+	if (len > PAGE_CACHE_SIZE*2) {
+		die(FSCK_UNCORRECTED, 0, "data block too large");
+	}
+	err = inflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END) {
+		die(FSCK_UNCORRECTED, 0, "decompression error %p(%d): %s",
+		    zError(err), src, len);
+	}
+	return stream.total_out;
+}
+
+static void do_uncompress(char *path, int fd, unsigned long offset, unsigned long size)
+{
+	unsigned long curr = offset + 4 * ((size + PAGE_CACHE_SIZE - 1) / PAGE_CACHE_SIZE);
+
+	do {
+		unsigned long out = PAGE_CACHE_SIZE;
+		unsigned long next = CRAMFS_32(*(u32 *) romfs_read(offset));
+
+		if (next > end_data) {
+			end_data = next;
+		}
+
+		offset += 4;
+		if (curr == next) {
+			if (opt_verbose > 1) {
+				printf("  hole at %ld (%d)\n", curr, PAGE_CACHE_SIZE);
+			}
+			if (size < PAGE_CACHE_SIZE)
+				out = size;
+			memset(outbuffer, 0x00, out);
+		}
+		else {
+			if (opt_verbose > 1) {
+				printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+			}
+			out = uncompress_block(romfs_read(curr), next - curr);
+		}
+		if (size >= PAGE_CACHE_SIZE) {
+			if (out != PAGE_CACHE_SIZE) {
+				die(FSCK_UNCORRECTED, 0, "non-block (%ld) bytes", out);
+			}
+		} else {
+			if (out != size) {
+				die(FSCK_UNCORRECTED, 0, "non-size (%ld vs %ld) bytes", out, size);
+			}
+		}
+		size -= out;
+		if (opt_extract) {
+			if (write(fd, outbuffer, out) < 0) {
+				die(FSCK_ERROR, 1, "write failed: %s", path);
+			}
+		}
+		curr = next;
+	} while (size);
+}
+
+static void change_file_status(char *path, struct cramfs_inode *i)
+{
+	struct utimbuf epoch = { 0, 0 };
+
+	if (euid == 0) {
+		if (lchown(path, i->uid, i->gid) < 0) {
+			die(FSCK_ERROR, 1, "lchown failed: %s", path);
+		}
+		if (S_ISLNK(i->mode))
+			return;
+		if ((S_ISUID | S_ISGID) & i->mode) {
+			if (chmod(path, i->mode) < 0) {
+				die(FSCK_ERROR, 1, "chown failed: %s", path);
+			}
+		}
+	}
+	if (S_ISLNK(i->mode))
+		return;
+	if (utime(path, &epoch) < 0) {
+		die(FSCK_ERROR, 1, "utime failed: %s", path);
+	}
+}
+
+static void do_directory(char *path, struct cramfs_inode *i)
+{
+	int pathlen = strlen(path);
+	int count = i->size;
+	unsigned long offset = i->offset << 2;
+	char *newpath = malloc(pathlen + 256);
+
+	if (!newpath) {
+		die(FSCK_ERROR, 1, "malloc failed");
+	}
+	if (offset == 0 && count != 0) {
+		die(FSCK_UNCORRECTED, 0, "directory inode has zero offset and non-zero size: %s", path);
+	}
+	if (offset != 0 && offset < start_dir) {
+		start_dir = offset;
+	}
+	/* TODO: Do we need to check end_dir for empty case? */
+	memcpy(newpath, path, pathlen);
+	newpath[pathlen] = '/';
+	pathlen++;
+	if (opt_verbose) {
+		print_node('d', i, path);
+	}
+	if (opt_extract) {
+		if (mkdir(path, i->mode) < 0) {
+			die(FSCK_ERROR, 1, "mkdir failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+	while (count > 0) {
+		struct cramfs_inode *child = iget(offset);
+		int size;
+		int newlen = child->namelen << 2;
+
+		size = sizeof(struct cramfs_inode) + newlen;
+		count -= size;
+
+		offset += sizeof(struct cramfs_inode);
+
+		memcpy(newpath + pathlen, romfs_read(offset), newlen);
+		newpath[pathlen + newlen] = 0;
+		if (newlen == 0) {
+			die(FSCK_UNCORRECTED, 0, "filename length is zero");
+		}
+		if ((pathlen + newlen) - strlen(newpath) > 3) {
+			die(FSCK_UNCORRECTED, 0, "bad filename length");
+		}
+		expand_fs(newpath, child);
+
+		offset += newlen;
+
+		if (offset <= start_dir) {
+			die(FSCK_UNCORRECTED, 0, "bad inode offset");
+		}
+		if (offset > end_dir) {
+			end_dir = offset;
+		}
+		iput(child); /* free(child) */
+	}
+	free(newpath);
+}
+
+static void do_file(char *path, struct cramfs_inode *i)
+{
+	unsigned long offset = i->offset << 2;
+	int fd = 0;
+
+	if (offset == 0 && i->size != 0) {
+		die(FSCK_UNCORRECTED, 0, "file inode has zero offset and non-zero size");
+	}
+	if (i->size == 0 && offset != 0) {
+		die(FSCK_UNCORRECTED, 0, "file inode has zero size and non-zero offset");
+	}
+	if (offset != 0 && offset < start_data) {
+		start_data = offset;
+	}
+	if (opt_verbose) {
+		print_node('f', i, path);
+	}
+	if (opt_extract) {
+		fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, i->mode);
+		if (fd < 0) {
+			die(FSCK_ERROR, 1, "open failed: %s", path);
+		}
+	}
+	if (i->size) {
+		do_uncompress(path, fd, offset, i->size);
+	}
+	if (opt_extract) {
+		close(fd);
+		change_file_status(path, i);
+	}
+}
+
+static void do_symlink(char *path, struct cramfs_inode *i)
+{
+	unsigned long offset = i->offset << 2;
+	unsigned long curr = offset + 4;
+	unsigned long next = CRAMFS_32(*(u32 *) romfs_read(offset));
+	unsigned long size;
+
+	if (offset == 0) {
+		die(FSCK_UNCORRECTED, 0, "symbolic link has zero offset");
+	}
+	if (i->size == 0) {
+		die(FSCK_UNCORRECTED, 0, "symbolic link has zero size");
+	}
+
+	if (offset < start_data) {
+		start_data = offset;
+	}
+	if (next > end_data) {
+		end_data = next;
+	}
+
+	size = uncompress_block(romfs_read(curr), next - curr);
+	if (size != i->size) {
+		die(FSCK_UNCORRECTED, 0, "size error in symlink: %s", path);
+	}
+	outbuffer[size] = 0;
+	if (opt_verbose) {
+		char *str;
+
+		asprintf(&str, "%s -> %s", path, outbuffer);
+		print_node('l', i, str);
+		if (opt_verbose > 1) {
+			printf("  uncompressing block at %ld to %ld (%ld)\n", curr, next, next - curr);
+		}
+		free(str);
+	}
+	if (opt_extract) {
+		if (symlink(outbuffer, path) < 0) {
+			die(FSCK_ERROR, 1, "symlink failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+}
+
+static void do_special_inode(char *path, struct cramfs_inode *i)
+{
+	dev_t devtype = 0;
+	char type;
+
+	if (i->offset) {	/* no need to shift offset */
+		die(FSCK_UNCORRECTED, 0, "special file has non-zero offset: %s", path);
+	}
+	if (S_ISCHR(i->mode)) {
+		devtype = i->size;
+		type = 'c';
+	}
+	else if (S_ISBLK(i->mode)) {
+		devtype = i->size;
+		type = 'b';
+	}
+	else if (S_ISFIFO(i->mode)) {
+		if (i->size != 0) {
+			die(FSCK_UNCORRECTED, 0, "fifo has non-zero size: %s", path);
+		}
+		type = 'p';
+	}
+	else if (S_ISSOCK(i->mode)) {
+		if (i->size != 0) {
+			die(FSCK_UNCORRECTED, 0, "socket has non-zero size: %s", path);
+		}
+		type = 's';
+	}
+	else {
+		die(FSCK_UNCORRECTED, 0, "bogus mode: %s (%o)", path, i->mode);
+		return;		/* not reached */
+	}
+
+	if (opt_verbose) {
+		print_node(type, i, path);
+	}
+
+	if (opt_extract) {
+		if (mknod(path, i->mode, devtype) < 0) {
+			die(FSCK_ERROR, 1, "mknod failed: %s", path);
+		}
+		change_file_status(path, i);
+	}
+}
+
+static void expand_fs(char *path, struct cramfs_inode *inode)
+{
+	if (S_ISDIR(inode->mode)) {
+		do_directory(path, inode);
+	}
+	else if (S_ISREG(inode->mode)) {
+		do_file(path, inode);
+	}
+	else if (S_ISLNK(inode->mode)) {
+		do_symlink(path, inode);
+	}
+	else {
+		do_special_inode(path, inode);
+	}
+}
+
+static void test_fs(int start)
+{
+	struct cramfs_inode *root;
+	unsigned long root_offset;
+
+	root = cramfs_iget(&super.root);
+	root_offset = root->offset << 2;
+	if (!S_ISDIR(root->mode))
+		die(FSCK_UNCORRECTED, 0, "root inode is not directory");
+	if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&
+	    ((root_offset != sizeof(struct cramfs_super)) &&
+	     (root_offset != PAD_SIZE + sizeof(struct cramfs_super))))
+	{
+		die(FSCK_UNCORRECTED, 0, "bad root offset (%lu)", root_offset);
+	}
+	umask(0);
+	euid = geteuid();
+	stream.next_in = NULL;
+	stream.avail_in = 0;
+	inflateInit(&stream);
+	expand_fs(extract_dir, root);
+	inflateEnd(&stream);
+	if (start_data != ~0UL) {
+		if (start_data < (sizeof(struct cramfs_super) + start)) {
+			die(FSCK_UNCORRECTED, 0, "directory data start (%ld) < sizeof(struct cramfs_super) + start (%ld)", start_data, sizeof(struct cramfs_super) + start);
+		}
+		if (end_dir != start_data) {
+			die(FSCK_UNCORRECTED, 0, "directory data end (%ld) != file data start (%ld)", end_dir, start_data);
+		}
+	}
+	if (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {
+		if (end_data > super.size) {
+			die(FSCK_UNCORRECTED, 0, "invalid file data offset");
+		}
+	}
+	iput(root);		/* free(root) */
+}
+#endif /* INCLUDE_FS_TESTS */
+
+int main(int argc, char **argv)
+{
+	int c;			/* for getopt */
+	int start = 0;
+	size_t length;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hx:v")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(FSCK_OK);
+		case 'x':
+#ifdef INCLUDE_FS_TESTS
+			opt_extract = 1;
+			extract_dir = optarg;
+			break;
+#else /* not INCLUDE_FS_TESTS */
+			die(FSCK_USAGE, 0, "compiled without -x support");
+#endif /* not INCLUDE_FS_TESTS */
+		case 'v':
+			opt_verbose++;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 1)
+		usage(FSCK_USAGE);
+	filename = argv[optind];
+
+	test_super(&start, &length);
+	test_crc(start);
+#ifdef INCLUDE_FS_TESTS
+	test_fs(start);
+#endif /* INCLUDE_FS_TESTS */
+
+	if (opt_verbose) {
+		printf("%s: OK\n", filename);
+	}
+
+	exit(FSCK_OK);
+}
+
+/*
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
diff -Naur linux-2.4.32/scripts/cramfs/mkcramfs.c linux-2.4.32-cramfs/scripts/cramfs/mkcramfs.c
--- linux-2.4.32/scripts/cramfs/mkcramfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-cramfs/scripts/cramfs/mkcramfs.c	2005-12-18 17:44:43.000000000 +0100
@@ -0,0 +1,879 @@
+/*
+ * mkcramfs - make a cramfs file system
+ *
+ * Copyright (C) 1999-2002 Transmeta Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * If you change the disk format of cramfs, please update fs/cramfs/README.
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <stdarg.h>
+#include <linux/cramfs_fs.h>
+#include <zlib.h>
+
+/* Exit codes used by mkfs-type programs */
+#define MKFS_OK          0	/* No errors */
+#define MKFS_ERROR       8	/* Operational error */
+#define MKFS_USAGE       16	/* Usage or syntax error */
+
+/* The kernel only supports PAD_SIZE of 0 and 512. */
+#define PAD_SIZE 512
+
+/* The kernel assumes PAGE_CACHE_SIZE as block size. */
+#define PAGE_CACHE_SIZE (4096)
+
+/*
+ * The longest filename component to allow for in the input directory tree.
+ * ext2fs (and many others) allow up to 255 bytes.  A couple of filesystems
+ * allow longer (e.g. smbfs 1024), but there isn't much use in supporting
+ * >255-byte names in the input directory tree given that such names get
+ * truncated to CRAMFS_MAXPATHLEN (252 bytes) when written to cramfs.
+ *
+ * Old versions of mkcramfs generated corrupted filesystems if any input
+ * filenames exceeded CRAMFS_MAXPATHLEN (252 bytes), however old
+ * versions of cramfsck seem to have been able to detect the corruption.
+ */
+#define MAX_INPUT_NAMELEN 255
+
+/*
+ * Maximum size fs you can create is roughly 256MB.  (The last file's
+ * data must begin within 256MB boundary but can extend beyond that.)
+ *
+ * Note that if you want it to fit in a ROM then you're limited to what the
+ * hardware and kernel can support.
+ */
+#define MAXFSLEN ((((1 << CRAMFS_OFFSET_WIDTH) - 1) << 2) /* offset */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) - 1 /* filesize */ \
+		  + (1 << CRAMFS_SIZE_WIDTH) * 4 / PAGE_CACHE_SIZE /* block pointers */ )
+
+static const char *progname = "mkcramfs";
+static unsigned int blksize = PAGE_CACHE_SIZE;
+static long total_blocks = 0, total_nodes = 1; /* pre-count the root node */
+static int image_length = 0;
+
+/*
+ * If opt_holes is set, then mkcramfs can create explicit holes in the
+ * data, which saves 26 bytes per hole (which is a lot smaller a
+ * saving than most most filesystems).
+ *
+ * Note that kernels up to at least 2.3.39 don't support cramfs holes,
+ * which is why this is turned off by default.
+ *
+ * If opt_verbose is 1, be verbose.  If it is higher, be even more verbose.
+ */
+static u32 opt_edition = 0;
+static int opt_errors = 0;
+static int opt_holes = 0;
+static int opt_pad = 0;
+static int opt_verbose = 0;
+static char *opt_image = NULL;
+static char *opt_name = NULL;
+
+static int warn_dev, warn_gid, warn_namelen, warn_skip, warn_size, warn_uid;
+
+/* In-core version of inode / directory entry. */
+struct entry {
+	/* stats */
+	unsigned char *name;
+	unsigned int mode, size, uid, gid;
+
+	/* these are only used for non-empty files */
+	char *path;		/* always null except non-empty files */
+	int fd;			/* temporarily open files while mmapped */
+
+	/* FS data */
+	void *uncompressed;
+	/* points to other identical file */
+	struct entry *same;
+	unsigned int offset;		/* pointer to compressed data in archive */
+	unsigned int dir_offset;	/* Where in the archive is the directory entry? */
+
+	/* organization */
+	struct entry *child; /* null for non-directories and empty directories */
+	struct entry *next;
+};
+
+/* Input status of 0 to print help and exit without an error. */
+static void usage(int status)
+{
+	FILE *stream = status ? stderr : stdout;
+
+	fprintf(stream, "usage: %s [-h] [-e edition] [-i file] [-n name] dirname outfile\n"
+		" -h         print this help\n"
+		" -E         make all warnings errors (non-zero exit status)\n"
+		" -e edition set edition number (part of fsid)\n"
+		" -i file    insert a file image into the filesystem (requires >= 2.4.0)\n"
+		" -n name    set name of cramfs filesystem\n"
+		" -p         pad by %d bytes for boot code\n"
+		" -s         sort directory entries (old option, ignored)\n"
+		" -v         be more verbose\n"
+		" -z         make explicit holes (requires >= 2.3.39)\n"
+		" dirname    root of the directory tree to be compressed\n"
+		" outfile    output file\n", progname, PAD_SIZE);
+
+	exit(status);
+}
+
+static void die(int status, int syserr, const char *fmt, ...)
+{
+	va_list arg_ptr;
+	int save = errno;
+
+	fflush(0);
+	va_start(arg_ptr, fmt);
+	fprintf(stderr, "%s: ", progname);
+	vfprintf(stderr, fmt, arg_ptr);
+	if (syserr) {
+		fprintf(stderr, ": %s", strerror(save));
+	}
+	fprintf(stderr, "\n");
+	va_end(arg_ptr);
+	exit(status);
+}
+
+static void map_entry(struct entry *entry)
+{
+	if (entry->path) {
+		entry->fd = open(entry->path, O_RDONLY);
+		if (entry->fd < 0) {
+			die(MKFS_ERROR, 1, "open failed: %s", entry->path);
+		}
+		entry->uncompressed = mmap(NULL, entry->size, PROT_READ, MAP_PRIVATE, entry->fd, 0);
+		if (entry->uncompressed == MAP_FAILED) {
+			die(MKFS_ERROR, 1, "mmap failed: %s", entry->path);
+		}
+	}
+}
+
+static void unmap_entry(struct entry *entry)
+{
+	if (entry->path) {
+		if (munmap(entry->uncompressed, entry->size) < 0) {
+			die(MKFS_ERROR, 1, "munmap failed: %s", entry->path);
+		}
+		close(entry->fd);
+	}
+}
+
+static int find_identical_file(struct entry *orig, struct entry *newfile)
+{
+	if (orig == newfile)
+		return 1;
+	if (!orig)
+		return 0;
+	if (orig->size == newfile->size && (orig->path || orig->uncompressed))
+	{
+		map_entry(orig);
+		map_entry(newfile);
+		if (!memcmp(orig->uncompressed, newfile->uncompressed, orig->size))
+		{
+			newfile->same = orig;
+			unmap_entry(newfile);
+			unmap_entry(orig);
+			return 1;
+		}
+		unmap_entry(newfile);
+		unmap_entry(orig);
+	}
+	return (find_identical_file(orig->child, newfile) ||
+		find_identical_file(orig->next, newfile));
+}
+
+static void eliminate_doubles(struct entry *root, struct entry *orig) {
+	if (orig) {
+		if (orig->size && (orig->path || orig->uncompressed))
+			find_identical_file(root, orig);
+		eliminate_doubles(root, orig->child);
+		eliminate_doubles(root, orig->next);
+	}
+}
+
+/*
+ * We define our own sorting function instead of using alphasort which
+ * uses strcoll and changes ordering based on locale information.
+ */
+static int cramsort (const void *a, const void *b)
+{
+	return strcmp ((*(const struct dirent **) a)->d_name,
+		       (*(const struct dirent **) b)->d_name);
+}
+
+static unsigned int parse_directory(struct entry *root_entry, const char *name, struct entry **prev, loff_t *fslen_ub)
+{
+	struct dirent **dirlist;
+	int totalsize = 0, dircount, dirindex;
+	char *path, *endpath;
+	size_t len = strlen(name);
+
+	/* Set up the path. */
+	/* TODO: Reuse the parent's buffer to save memcpy'ing and duplication. */
+	path = malloc(len + 1 + MAX_INPUT_NAMELEN + 1);
+	if (!path) {
+		die(MKFS_ERROR, 1, "malloc failed");
+	}
+	memcpy(path, name, len);
+	endpath = path + len;
+	*endpath = '/';
+	endpath++;
+
+	/* read in the directory and sort */
+	dircount = scandir(name, &dirlist, 0, cramsort);
+
+	if (dircount < 0) {
+		die(MKFS_ERROR, 1, "scandir failed: %s", name);
+	}
+
+	/* process directory */
+	for (dirindex = 0; dirindex < dircount; dirindex++) {
+		struct dirent *dirent;
+		struct entry *entry;
+		struct stat st;
+		int size;
+		size_t namelen;
+
+		dirent = dirlist[dirindex];
+
+		/* Ignore "." and ".." - we won't be adding them to the archive */
+		if (dirent->d_name[0] == '.') {
+			if (dirent->d_name[1] == '\0')
+				continue;
+			if (dirent->d_name[1] == '.') {
+				if (dirent->d_name[2] == '\0')
+					continue;
+			}
+		}
+		namelen = strlen(dirent->d_name);
+		if (namelen > MAX_INPUT_NAMELEN) {
+			die(MKFS_ERROR, 0,
+				"very long (%u bytes) filename found: %s\n"
+				"please increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile",
+				namelen, dirent->d_name);
+		}
+		memcpy(endpath, dirent->d_name, namelen + 1);
+
+		if (lstat(path, &st) < 0) {
+			warn_skip = 1;
+			continue;
+		}
+		entry = calloc(1, sizeof(struct entry));
+		if (!entry) {
+			die(MKFS_ERROR, 1, "calloc failed");
+		}
+		entry->name = strdup(dirent->d_name);
+		if (!entry->name) {
+			die(MKFS_ERROR, 1, "strdup failed");
+		}
+		/* truncate multi-byte UTF-8 filenames on character boundary */
+		if (namelen > CRAMFS_MAXPATHLEN) {
+			namelen = CRAMFS_MAXPATHLEN;
+			warn_namelen = 1;
+			/* the first lost byte must not be a trail byte */
+			while ((entry->name[namelen] & 0xc0) == 0x80) {
+				namelen--;
+				/* are we reasonably certain it was UTF-8 ? */
+				if (entry->name[namelen] < 0x80 || !namelen) {
+					die(MKFS_ERROR, 0, "cannot truncate filenames not encoded in UTF-8");
+				}
+			}
+			entry->name[namelen] = '\0';
+		}
+		entry->mode = st.st_mode;
+		entry->size = st.st_size;
+		entry->uid = st.st_uid;
+		if (entry->uid >= 1 << CRAMFS_UID_WIDTH)
+			warn_uid = 1;
+		entry->gid = st.st_gid;
+		if (entry->gid >= 1 << CRAMFS_GID_WIDTH)
+			/* TODO: We ought to replace with a default
+			   gid instead of truncating; otherwise there
+			   are security problems.  Maybe mode should
+			   be &= ~070.  Same goes for uid once Linux
+			   supports >16-bit uids. */
+			warn_gid = 1;
+		size = sizeof(struct cramfs_inode) + ((namelen + 3) & ~3);
+		*fslen_ub += size;
+		if (S_ISDIR(st.st_mode)) {
+			entry->size = parse_directory(root_entry, path, &entry->child, fslen_ub);
+		} else if (S_ISREG(st.st_mode)) {
+			if (entry->size) {
+				if (access(path, R_OK) < 0) {
+					warn_skip = 1;
+					continue;
+				}
+				entry->path = strdup(path);
+				if (!entry->path) {
+					die(MKFS_ERROR, 1, "strdup failed");
+				}
+				if ((entry->size >= 1 << CRAMFS_SIZE_WIDTH)) {
+					warn_size = 1;
+					entry->size = (1 << CRAMFS_SIZE_WIDTH) - 1;
+				}
+			}
+		} else if (S_ISLNK(st.st_mode)) {
+			entry->uncompressed = malloc(entry->size);
+			if (!entry->uncompressed) {
+				die(MKFS_ERROR, 1, "malloc failed");
+			}
+			if (readlink(path, entry->uncompressed, entry->size) < 0) {
+				warn_skip = 1;
+				continue;
+			}
+		} else if (S_ISFIFO(st.st_mode) || S_ISSOCK(st.st_mode)) {
+			/* maybe we should skip sockets */
+			entry->size = 0;
+		} else if (S_ISCHR(st.st_mode) || S_ISBLK(st.st_mode)) {
+			entry->size = st.st_rdev;
+			if (entry->size & -(1<<CRAMFS_SIZE_WIDTH))
+				warn_dev = 1;
+		} else {
+			die(MKFS_ERROR, 0, "bogus file type: %s", entry->name);
+		}
+
+		if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
+			int blocks = ((entry->size - 1) / blksize + 1);
+
+			/* block pointers & data expansion allowance + data */
+			if (entry->size)
+				*fslen_ub += (4+26)*blocks + entry->size + 3;
+		}
+
+		/* Link it into the list */
+		*prev = entry;
+		prev = &entry->next;
+		totalsize += size;
+	}
+	free(path);
+	free(dirlist);		/* allocated by scandir() with malloc() */
+	return totalsize;
+}
+
+/* Returns sizeof(struct cramfs_super), which includes the root inode. */
+static unsigned int write_superblock(struct entry *root, char *base, int size)
+{
+	struct cramfs_super *super = (struct cramfs_super *) base;
+	unsigned int offset = sizeof(struct cramfs_super) + image_length;
+
+	offset += opt_pad;	/* 0 if no padding */
+
+	super->magic = CRAMFS_32(CRAMFS_MAGIC);
+	super->flags = CRAMFS_FLAG_FSID_VERSION_2 | CRAMFS_FLAG_SORTED_DIRS;
+	if (opt_holes)
+		super->flags |= CRAMFS_FLAG_HOLES;
+	if (image_length > 0)
+		super->flags |= CRAMFS_FLAG_SHIFTED_ROOT_OFFSET;
+	super->flags = CRAMFS_32(super->flags);
+	super->size = CRAMFS_32(size);
+	memcpy(super->signature, CRAMFS_SIGNATURE, sizeof(super->signature));
+
+	super->fsid.crc = CRAMFS_32(crc32(0L, Z_NULL, 0));
+	super->fsid.edition = CRAMFS_32(opt_edition);
+	super->fsid.blocks = CRAMFS_32(total_blocks);
+	super->fsid.files = CRAMFS_32(total_nodes);
+
+	memset(super->name, 0x00, sizeof(super->name));
+	if (opt_name)
+		strncpy(super->name, opt_name, sizeof(super->name));
+	else
+		strncpy(super->name, "Compressed", sizeof(super->name));
+
+	super->root.mode = CRAMFS_16(root->mode);
+	super->root.uid = CRAMFS_16(root->uid);
+	super->root.gid = root->gid;
+	super->root.size = CRAMFS_24(root->size);
+	CRAMFS_SET_OFFSET(&(super->root), offset >> 2);
+
+	return offset;
+}
+
+static void set_data_offset(struct entry *entry, char *base, unsigned long offset)
+{
+	struct cramfs_inode *inode = (struct cramfs_inode *) (base + entry->dir_offset);
+
+	if ((offset & 3) != 0) {
+		die(MKFS_ERROR, 0, "illegal offset of %lu bytes", offset);
+	}
+	if (offset >= (1 << (2 + CRAMFS_OFFSET_WIDTH))) {
+		die(MKFS_ERROR, 0, "filesystem too big");
+	}
+	CRAMFS_SET_OFFSET(inode, offset >> 2);
+}
+
+/*
+ * TODO: Does this work for chars >= 0x80?  Most filesystems use UTF-8
+ * encoding for filenames, whereas the console is a single-byte
+ * character set like iso-latin-1.
+ */
+static void print_node(struct entry *e)
+{
+	char info[10];
+	char type = '?';
+
+	if (S_ISREG(e->mode)) type = 'f';
+	else if (S_ISDIR(e->mode)) type = 'd';
+	else if (S_ISLNK(e->mode)) type = 'l';
+	else if (S_ISCHR(e->mode)) type = 'c';
+	else if (S_ISBLK(e->mode)) type = 'b';
+	else if (S_ISFIFO(e->mode)) type = 'p';
+	else if (S_ISSOCK(e->mode)) type = 's';
+
+	if (S_ISCHR(e->mode) || (S_ISBLK(e->mode))) {
+		/* major/minor numbers can be as high as 2^12 or 4096 */
+		snprintf(info, 10, "%4d,%4d", major(e->size), minor(e->size));
+	}
+	else {
+		/* size be as high as 2^24 or 16777216 */
+		snprintf(info, 10, "%9d", e->size);
+	}
+
+	printf("%c %04o %s %5d:%-3d %s\n",
+	       type, e->mode & ~S_IFMT, info, e->uid, e->gid, e->name);
+}
+
+/*
+ * We do a width-first printout of the directory
+ * entries, using a stack to remember the directories
+ * we've seen.
+ */
+static unsigned int write_directory_structure(struct entry *entry, char *base, unsigned int offset)
+{
+	int stack_entries = 0;
+	int stack_size = 64;
+	struct entry **entry_stack;
+
+	entry_stack = malloc(stack_size * sizeof(struct entry *));
+	if (!entry_stack) {
+		die(MKFS_ERROR, 1, "malloc failed");
+	}
+
+	if (opt_verbose) {
+		printf("root:\n");
+	}
+
+	for (;;) {
+		int dir_start = stack_entries;
+		while (entry) {
+			struct cramfs_inode *inode = (struct cramfs_inode *) (base + offset);
+			size_t len = strlen(entry->name);
+
+			entry->dir_offset = offset;
+
+			inode->mode = CRAMFS_16(entry->mode);
+			inode->uid = CRAMFS_16(entry->uid);
+			inode->gid = entry->gid;
+			inode->size = CRAMFS_24(entry->size);
+			inode->offset = 0;
+			/* Non-empty directories, regfiles and symlinks will
+			   write over inode->offset later. */
+
+			offset += sizeof(struct cramfs_inode);
+			total_nodes++;	/* another node */
+			memcpy(base + offset, entry->name, len);
+			/* Pad up the name to a 4-byte boundary */
+			while (len & 3) {
+				*(base + offset + len) = '\0';
+				len++;
+			}
+			CRAMFS_SET_NAMELEN(inode, len >> 2);
+			offset += len;
+
+			if (opt_verbose)
+				print_node(entry);
+
+			if (entry->child) {
+				if (stack_entries >= stack_size) {
+					stack_size *= 2;
+					entry_stack = realloc(entry_stack, stack_size * sizeof(struct entry *));
+					if (!entry_stack) {
+						die(MKFS_ERROR, 1, "realloc failed");
+					}
+				}
+				entry_stack[stack_entries] = entry;
+				stack_entries++;
+			}
+			entry = entry->next;
+		}
+
+		/*
+		 * Reverse the order the stack entries pushed during
+		 * this directory, for a small optimization of disk
+		 * access in the created fs.  This change makes things
+		 * `ls -UR' order.
+		 */
+		{
+			struct entry **lo = entry_stack + dir_start;
+			struct entry **hi = entry_stack + stack_entries;
+			struct entry *tmp;
+
+			while (lo < --hi) {
+				tmp = *lo;
+				*lo++ = *hi;
+				*hi = tmp;
+			}
+		}
+
+		/* Pop a subdirectory entry from the stack, and recurse. */
+		if (!stack_entries)
+			break;
+		stack_entries--;
+		entry = entry_stack[stack_entries];
+
+		set_data_offset(entry, base, offset);
+		if (opt_verbose) {
+			printf("%s:\n", entry->name);
+		}
+		entry = entry->child;
+	}
+	free(entry_stack);
+	return offset;
+}
+
+static int is_zero(char const *begin, unsigned len)
+{
+	/* Returns non-zero iff the first LEN bytes from BEGIN are all NULs. */
+	return (len-- == 0 ||
+		(begin[0] == '\0' &&
+		 (len-- == 0 ||
+		  (begin[1] == '\0' &&
+		   (len-- == 0 ||
+		    (begin[2] == '\0' &&
+		     (len-- == 0 ||
+		      (begin[3] == '\0' &&
+		       memcmp(begin, begin + 4, len) == 0))))))));
+}
+
+/*
+ * One 4-byte pointer per block and then the actual blocked
+ * output. The first block does not need an offset pointer,
+ * as it will start immediately after the pointer block;
+ * so the i'th pointer points to the end of the i'th block
+ * (i.e. the start of the (i+1)'th block or past EOF).
+ *
+ * Note that size > 0, as a zero-sized file wouldn't ever
+ * have gotten here in the first place.
+ */
+static unsigned int do_compress(char *base, unsigned int offset, char const *name, char *uncompressed, unsigned int size)
+{
+	unsigned long original_size = size;
+	unsigned long original_offset = offset;
+	unsigned long new_size;
+	unsigned long blocks = (size - 1) / blksize + 1;
+	unsigned long curr = offset + 4 * blocks;
+	int change;
+
+	total_blocks += blocks;
+
+	do {
+		unsigned long len = 2 * blksize;
+		unsigned int input = size;
+		int err;
+
+		if (input > blksize)
+			input = blksize;
+		size -= input;
+		if (!(opt_holes && is_zero (uncompressed, input))) {
+			err = compress2(base + curr, &len, uncompressed, input, Z_BEST_COMPRESSION);
+			if (err != Z_OK) {
+				die(MKFS_ERROR, 0, "compression error: %s", zError(err));
+			}
+			curr += len;
+		}
+		uncompressed += input;
+
+		if (len > blksize*2) {
+			/* (I don't think this can happen with zlib.) */
+			die(MKFS_ERROR, 0, "AIEEE: block \"compressed\" to > 2*blocklength (%ld)", len);
+		}
+
+		*(u32 *) (base + offset) = CRAMFS_32(curr);
+		offset += 4;
+	} while (size);
+
+	curr = (curr + 3) & ~3;
+	new_size = curr - original_offset;
+	/* TODO: Arguably, original_size in these 2 lines should be
+	   st_blocks * 512.  But if you say that then perhaps
+	   administrative data should also be included in both. */
+	change = new_size - original_size;
+	if (opt_verbose > 1) {
+		printf("%6.2f%% (%+d bytes)\t%s\n",
+		       (change * 100) / (double) original_size, change, name);
+	}
+
+	return curr;
+}
+
+
+/*
+ * Traverse the entry tree, writing data for every item that has
+ * non-null entry->path (i.e. every non-empty regfile) and non-null
+ * entry->uncompressed (i.e. every symlink).
+ */
+static unsigned int write_data(struct entry *entry, char *base, unsigned int offset)
+{
+	do {
+		if (entry->path || entry->uncompressed) {
+			if (entry->same) {
+				set_data_offset(entry, base, entry->same->offset);
+				entry->offset = entry->same->offset;
+			}
+			else {
+				set_data_offset(entry, base, offset);
+				entry->offset = offset;
+				map_entry(entry);
+				offset = do_compress(base, offset, entry->name, entry->uncompressed, entry->size);
+				unmap_entry(entry);
+			}
+		}
+		else if (entry->child)
+			offset = write_data(entry->child, base, offset);
+		entry=entry->next;
+	} while (entry);
+	return offset;
+}
+
+static unsigned int write_file(char *file, char *base, unsigned int offset)
+{
+	int fd;
+	char *buf;
+
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		die(MKFS_ERROR, 1, "open failed: %s", file);
+	}
+	buf = mmap(NULL, image_length, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (buf == MAP_FAILED) {
+		die(MKFS_ERROR, 1, "mmap failed");
+	}
+	memcpy(base + offset, buf, image_length);
+	munmap(buf, image_length);
+	close (fd);
+	/* Pad up the image_length to a 4-byte boundary */
+	while (image_length & 3) {
+		*(base + offset + image_length) = '\0';
+		image_length++;
+	}
+	return (offset + image_length);
+}
+
+int main(int argc, char **argv)
+{
+	struct stat st;		/* used twice... */
+	struct entry *root_entry;
+	char *rom_image;
+	ssize_t offset, written;
+	int fd;
+	/* initial guess (upper-bound) of required filesystem size */
+	loff_t fslen_ub = sizeof(struct cramfs_super);
+	char const *dirname, *outfile;
+	u32 crc;
+	int c;			/* for getopt */
+	char *ep;		/* for strtoul */
+
+	total_blocks = 0;
+
+	if (argc)
+		progname = argv[0];
+
+	/* command line options */
+	while ((c = getopt(argc, argv, "hEe:i:n:psvz")) != EOF) {
+		switch (c) {
+		case 'h':
+			usage(MKFS_OK);
+		case 'E':
+			opt_errors = 1;
+			break;
+		case 'e':
+			errno = 0;
+			opt_edition = strtoul(optarg, &ep, 10);
+			if (errno || optarg[0] == '\0' || *ep != '\0')
+				usage(MKFS_USAGE);
+			break;
+		case 'i':
+			opt_image = optarg;
+			if (lstat(opt_image, &st) < 0) {
+				die(MKFS_ERROR, 1, "lstat failed: %s", opt_image);
+			}
+			image_length = st.st_size; /* may be padded later */
+			fslen_ub += (image_length + 3); /* 3 is for padding */
+			break;
+		case 'n':
+			opt_name = optarg;
+			break;
+		case 'p':
+			opt_pad = PAD_SIZE;
+			fslen_ub += PAD_SIZE;
+			break;
+		case 's':
+			/* old option, ignored */
+			break;
+		case 'v':
+			opt_verbose++;
+			break;
+		case 'z':
+			opt_holes = 1;
+			break;
+		}
+	}
+
+	if ((argc - optind) != 2)
+		usage(MKFS_USAGE);
+	dirname = argv[optind];
+	outfile = argv[optind + 1];
+
+	if (stat(dirname, &st) < 0) {
+		die(MKFS_USAGE, 1, "stat failed: %s", dirname);
+	}
+	fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+	if (fd < 0) {
+		die(MKFS_USAGE, 1, "open failed: %s", outfile);
+	}
+
+	root_entry = calloc(1, sizeof(struct entry));
+	if (!root_entry) {
+		die(MKFS_ERROR, 1, "calloc failed");
+	}
+	root_entry->mode = st.st_mode;
+	root_entry->uid = st.st_uid;
+	root_entry->gid = st.st_gid;
+
+	root_entry->size = parse_directory(root_entry, dirname, &root_entry->child, &fslen_ub);
+
+	/* always allocate a multiple of blksize bytes because that's
+	   what we're going to write later on */
+	fslen_ub = ((fslen_ub - 1) | (blksize - 1)) + 1;
+
+	if (fslen_ub > MAXFSLEN) {
+		fprintf(stderr,
+			"warning: estimate of required size (upper bound) is %LdMB, but maximum image size is %uMB, we might die prematurely\n",
+			fslen_ub >> 20,
+			MAXFSLEN >> 20);
+		fslen_ub = MAXFSLEN;
+	}
+
+	/* find duplicate files. TODO: uses the most inefficient algorithm
+	   possible. */
+	eliminate_doubles(root_entry, root_entry);
+
+	/* TODO: Why do we use a private/anonymous mapping here
+	   followed by a write below, instead of just a shared mapping
+	   and a couple of ftruncate calls?  Is it just to save us
+	   having to deal with removing the file afterwards?  If we
+	   really need this huge anonymous mapping, we ought to mmap
+	   in smaller chunks, so that the user doesn't need nn MB of
+	   RAM free.  If the reason is to be able to write to
+	   un-mmappable block devices, then we could try shared mmap
+	   and revert to anonymous mmap if the shared mmap fails. */
+	rom_image = mmap(NULL, fslen_ub?fslen_ub:1, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+
+	if (rom_image == MAP_FAILED) {
+		die(MKFS_ERROR, 1, "mmap failed");
+	}
+
+	/* Skip the first opt_pad bytes for boot loader code */
+	offset = opt_pad;
+	memset(rom_image, 0x00, opt_pad);
+
+	/* Skip the superblock and come back to write it later. */
+	offset += sizeof(struct cramfs_super);
+
+	/* Insert a file image. */
+	if (opt_image) {
+		printf("Including: %s\n", opt_image);
+		offset = write_file(opt_image, rom_image, offset);
+	}
+
+	offset = write_directory_structure(root_entry->child, rom_image, offset);
+	printf("Directory data: %d bytes\n", offset);
+
+	offset = write_data(root_entry, rom_image, offset);
+
+	/* We always write a multiple of blksize bytes, so that
+	   losetup works. */
+	offset = ((offset - 1) | (blksize - 1)) + 1;
+	printf("Everything: %d kilobytes\n", offset >> 10);
+
+	/* Write the superblock now that we can fill in all of the fields. */
+	write_superblock(root_entry, rom_image+opt_pad, offset);
+	printf("Super block: %d bytes\n", sizeof(struct cramfs_super));
+
+	/* Put the checksum in. */
+	crc = crc32(0L, Z_NULL, 0);
+	crc = crc32(crc, (rom_image+opt_pad), (offset-opt_pad));
+	((struct cramfs_super *) (rom_image+opt_pad))->fsid.crc = CRAMFS_32(crc);
+	printf("CRC: %x\n", crc);
+
+	/* Check to make sure we allocated enough space. */
+	if (fslen_ub < offset) {
+		die(MKFS_ERROR, 0, "not enough space allocated for ROM image (%Ld allocated, %d used)", fslen_ub, offset);
+	}
+
+	written = write(fd, rom_image, offset);
+	if (written < 0) {
+		die(MKFS_ERROR, 1, "write failed");
+	}
+	if (offset != written) {
+		die(MKFS_ERROR, 0, "ROM image write failed (wrote %d of %d bytes)", written, offset);
+	}
+
+	/* (These warnings used to come at the start, but they scroll off the
+	   screen too quickly.) */
+	if (warn_namelen)
+		fprintf(stderr, /* bytes, not chars: think UTF-8. */
+			"warning: filenames truncated to %d bytes (possibly less if multi-byte UTF-8)\n",
+			CRAMFS_MAXPATHLEN);
+	if (warn_skip)
+		fprintf(stderr, "warning: files were skipped due to errors\n");
+	if (warn_size)
+		fprintf(stderr,
+			"warning: file sizes truncated to %luMB (minus 1 byte)\n",
+			1L << (CRAMFS_SIZE_WIDTH - 20));
+	if (warn_uid) /* (not possible with current Linux versions) */
+		fprintf(stderr,
+			"warning: uids truncated to %u bits (this may be a security concern)\n",
+			CRAMFS_UID_WIDTH);
+	if (warn_gid)
+		fprintf(stderr,
+			"warning: gids truncated to %u bits (this may be a security concern)\n",
+			CRAMFS_GID_WIDTH);
+	if (warn_dev)
+		fprintf(stderr,
+			"WARNING: device numbers truncated to %u bits (this almost certainly means\n"
+			"that some device files will be wrong)\n",
+			CRAMFS_OFFSET_WIDTH);
+	if (opt_errors &&
+	    (warn_namelen||warn_skip||warn_size||warn_uid||warn_gid||warn_dev))
+		exit(MKFS_ERROR);
+
+	exit(MKFS_OK);
+}
+
+/*
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
