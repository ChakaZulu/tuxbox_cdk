diff -Naur glibc-2.2.5/Makerules glibc-2.2.5-patched/Makerules
--- glibc-2.2.5/Makerules	Fri Nov 16 02:02:19 2001
+++ glibc-2.2.5-patched/Makerules	Sat Aug  3 13:37:53 2002
@@ -848,8 +848,8 @@
 	(echo '/* GNU ld script';\
 	 echo '   Use the shared library, but some functions are only in';\
 	 echo '   the static library, so try that secondarily.  */';\
-	 echo 'GROUP ( $(slibdir)/libc.so$(libc.so-version)' \
-	      '$(libdir)/$(patsubst %,$(libtype.oS),$(libprefix)$(libc-name))'\
+	 echo 'GROUP ( $(inst_libdir)/libc.so$(libc.so-version)' \
+	      '$(inst_libdir)/$(patsubst %,$(libtype.oS),$(libprefix)$(libc-name)) '\
 	      ')' \
 	) > $@.new
 	mv -f $@.new $@
diff -Naur glibc-2.2.5/resolv/nss_dns/dns-network.c glibc-2.2.5-patched/resolv/nss_dns/dns-network.c
--- glibc-2.2.5/resolv/nss_dns/dns-network.c	Fri Jul  6 06:55:39 2001
+++ glibc-2.2.5-patched/resolv/nss_dns/dns-network.c	Sat Aug  3 13:36:20 2002
@@ -328,7 +328,9 @@
 	    }
 	  cp += n;
 	  *alias_pointer++ = bp;
-	  bp += strlen (bp) + 1;
+	  n = strlen(bp) + 1;
+	  bp += n;
+	  linebuflen -= n;
 	  result->n_addrtype = class == C_IN ? AF_INET : AF_UNSPEC;
 	  ++have_answer;
 	}
diff -Naur glibc-2.2.5/sysdeps/powerpc/Dist glibc-2.2.5-patched/sysdeps/powerpc/Dist
--- glibc-2.2.5/sysdeps/powerpc/Dist	Sat Jul  1 08:30:21 2000
+++ glibc-2.2.5-patched/sysdeps/powerpc/Dist	Sat Aug  3 13:37:53 2002
@@ -1,9 +1,6 @@
 dl-machine.c
 dl-start.S
 ppc-mcount.S
-fe_nomask.c
-fprrest.S
-fprsave.S
 gprsave1.S
 gprsave0.S
 gprrest1.S
diff -Naur glibc-2.2.5/sysdeps/powerpc/Makefile glibc-2.2.5-patched/sysdeps/powerpc/Makefile
--- glibc-2.2.5/sysdeps/powerpc/Makefile	Tue Nov 28 00:32:47 2000
+++ glibc-2.2.5-patched/sysdeps/powerpc/Makefile	Sat Aug  3 13:37:53 2002
@@ -3,16 +3,12 @@
 +cflags += -mnew-mnemonics -Wa,-mppc -mpowerpc
 asm-CPPFLAGS += -Wa,-mppc
 
-ifeq ($(subdir),math)
-libm-support += fenv_const fe_nomask
-endif
-
 ifeq ($(subdir),gmon)
 sysdep_routines += ppc-mcount
 endif
 
 ifeq ($(subdir),misc)
-sysdep_routines += gprsave0 gprrest0 gprsave1 gprrest1 fprsave fprrest
+sysdep_routines += gprsave0 gprrest0 gprsave1 gprrest1
 endif
 
 # On PPC, -fpic works until the GOT contains 2^15 bytes, and possibly
diff -Naur glibc-2.2.5/sysdeps/powerpc/__longjmp.S glibc-2.2.5-patched/sysdeps/powerpc/__longjmp.S
--- glibc-2.2.5/sysdeps/powerpc/__longjmp.S	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/__longjmp.S	Sat Aug  3 13:37:53 2002
@@ -31,44 +31,26 @@
 	lwz r2,(JB_GPR2*4)(r3)
 	lwz r0,(JB_LR*4)(r3)
 	lwz r14,((JB_GPRS+0)*4)(r3)
-	lfd fp14,((JB_FPRS+0*2)*4)(r3)
 	lwz r15,((JB_GPRS+1)*4)(r3)
-	lfd fp15,((JB_FPRS+1*2)*4)(r3)
 	lwz r16,((JB_GPRS+2)*4)(r3)
-	lfd fp16,((JB_FPRS+2*2)*4)(r3)
 	lwz r17,((JB_GPRS+3)*4)(r3)
-	lfd fp17,((JB_FPRS+3*2)*4)(r3)
 	lwz r18,((JB_GPRS+4)*4)(r3)
-	lfd fp18,((JB_FPRS+4*2)*4)(r3)
 	lwz r19,((JB_GPRS+5)*4)(r3)
-	lfd fp19,((JB_FPRS+5*2)*4)(r3)
 	lwz r20,((JB_GPRS+6)*4)(r3)
-	lfd fp20,((JB_FPRS+6*2)*4)(r3)
 	mtlr r0
 	lwz r21,((JB_GPRS+7)*4)(r3)
-	lfd fp21,((JB_FPRS+7*2)*4)(r3)
 	lwz r22,((JB_GPRS+8)*4)(r3)
-	lfd fp22,((JB_FPRS+8*2)*4)(r3)
 	lwz r0,(JB_CR*4)(r3)
 	lwz r23,((JB_GPRS+9)*4)(r3)
-	lfd fp23,((JB_FPRS+9*2)*4)(r3)
 	lwz r24,((JB_GPRS+10)*4)(r3)
-	lfd fp24,((JB_FPRS+10*2)*4)(r3)
 	lwz r25,((JB_GPRS+11)*4)(r3)
-	lfd fp25,((JB_FPRS+11*2)*4)(r3)
 	mtcrf 0xFF,r0
 	lwz r26,((JB_GPRS+12)*4)(r3)
-	lfd fp26,((JB_FPRS+12*2)*4)(r3)
 	lwz r27,((JB_GPRS+13)*4)(r3)
-	lfd fp27,((JB_FPRS+13*2)*4)(r3)
 	lwz r28,((JB_GPRS+14)*4)(r3)
-	lfd fp28,((JB_FPRS+14*2)*4)(r3)
 	lwz r29,((JB_GPRS+15)*4)(r3)
-	lfd fp29,((JB_FPRS+15*2)*4)(r3)
 	lwz r30,((JB_GPRS+16)*4)(r3)
-	lfd fp30,((JB_FPRS+16*2)*4)(r3)
 	lwz r31,((JB_GPRS+17)*4)(r3)
-	lfd fp31,((JB_FPRS+17*2)*4)(r3)
 	mr r3,r4
 	blr
 END (BP_SYM (__longjmp))
diff -Naur glibc-2.2.5/sysdeps/powerpc/fclrexcpt.c glibc-2.2.5-patched/sysdeps/powerpc/fclrexcpt.c
--- glibc-2.2.5/sysdeps/powerpc/fclrexcpt.c	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/fclrexcpt.c	Thu Jan  1 01:00:00 1970
@@ -1,48 +0,0 @@
-/* Clear given exceptions in current floating-point environment.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-#undef feclearexcept
-int
-__feclearexcept (int excepts)
-{
-  fenv_union_t u;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Clear the relevant bits.  */
-  u.l[1] = u.l[1] & ~((-(excepts >> (31 - FPSCR_VX) & 1) & FE_ALL_INVALID)
-		      | (excepts & FPSCR_STICKY_BITS));
-
-  /* Put the new state in effect.  */
-  fesetenv_register (u.fenv);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__feclearexcept, __old_feclearexcept)
-compat_symbol (libm, __old_feclearexcept, feclearexcept, GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, __feclearexcept, feclearexcept, GLIBC_2_2);
diff -Naur glibc-2.2.5/sysdeps/powerpc/fe_nomask.c glibc-2.2.5-patched/sysdeps/powerpc/fe_nomask.c
--- glibc-2.2.5/sysdeps/powerpc/fe_nomask.c	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/fe_nomask.c	Thu Jan  1 01:00:00 1970
@@ -1,32 +0,0 @@
-/* Procedure definition for FE_NOMASK_ENV.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv.h>
-#include <errno.h>
-
-/* This is presently a stub, until it's decided how the kernels should
-   support this.  */
-
-const fenv_t *
-__fe_nomask_env(void)
-{
-  __set_errno (ENOSYS);
-  return FE_ENABLED_ENV;
-}
-stub_warning (__fe_nomask_env)
diff -Naur glibc-2.2.5/sysdeps/powerpc/fprrest.S glibc-2.2.5-patched/sysdeps/powerpc/fprrest.S
--- glibc-2.2.5/sysdeps/powerpc/fprrest.S	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/fprrest.S	Thu Jan  1 01:00:00 1970
@@ -1,94 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
-    Floating Point Registers (FPRs) restore routine
-*/
-
-#include <sysdep.h>
-
-ENTRY(_restfpr_all)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf14)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_14)
-C_TEXT(_restf14):
-C_TEXT(_restfpr_14):	lfd	fp14,-144(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf15)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_15)
-C_TEXT(_restf15):
-C_TEXT(_restfpr_15):	lfd	fp15,-136(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf16)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_16)
-C_TEXT(_restf16):
-C_TEXT(_restfpr_16):	lfd	fp16,-128(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf17)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_17)
-C_TEXT(_restf17):
-C_TEXT(_restfpr_17):	lfd	fp17,-120(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf18)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_18)
-C_TEXT(_restf18):
-C_TEXT(_restfpr_18):	lfd	fp18,-112(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf19)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_19)
-C_TEXT(_restf19):
-C_TEXT(_restfpr_19):	lfd	fp19,-104(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf20)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_20)
-C_TEXT(_restf20):
-C_TEXT(_restfpr_20):	lfd	fp20,-96(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf21)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_21)
-C_TEXT(_restf21):
-C_TEXT(_restfpr_21):	lfd	fp21,-88(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf22)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_22)
-C_TEXT(_restf22):
-C_TEXT(_restfpr_22):	lfd	fp22,-80(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf23)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_23)
-C_TEXT(_restf23):
-C_TEXT(_restfpr_23):	lfd	fp23,-72(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf24)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_24)
-C_TEXT(_restf24):
-C_TEXT(_restfpr_24):	lfd	fp24,-64(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf25)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_25)
-C_TEXT(_restf25):
-C_TEXT(_restfpr_25):	lfd	fp25,-56(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf26)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_26)
-C_TEXT(_restf26):
-C_TEXT(_restfpr_26):	lfd	fp26,-48(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf27)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_27)
-C_TEXT(_restf27):
-C_TEXT(_restfpr_27):	lfd	fp27,-40(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf28)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_28)
-C_TEXT(_restf28):
-C_TEXT(_restfpr_28):	lfd	fp28,-32(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf29)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_29)
-C_TEXT(_restf29):
-C_TEXT(_restfpr_29):	lwz	r0,8(r1)	#get return address from frame
-			lfd	fp29,-24(r1)    #restore f29
-			mtlr	r0		#move return address to LR
-			lfd	fp30,-16(r1)	#restore f30
-			lfd	fp31,-8(r1)	#restore f31
-			blr			#return
diff -Naur glibc-2.2.5/sysdeps/powerpc/fprsave.S glibc-2.2.5-patched/sysdeps/powerpc/fprsave.S
--- glibc-2.2.5/sysdeps/powerpc/fprsave.S	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/fprsave.S	Thu Jan  1 01:00:00 1970
@@ -1,93 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
-    Floating Point Registers (FPRs) save routine
-*/
-
-#include <sysdep.h>
-
-ENTRY(_savefpr_all)
-                ASM_GLOBAL_DIRECTIVE C_TEXT(_savef14)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_14)
-C_TEXT(_savef14):
-C_TEXT(_savefpr_14):	stfd	fp14,-144(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef15)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_15)
-C_TEXT(_savef15):
-C_TEXT(_savefpr_15):	stfd	fp15,-136(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef16)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_16)
-C_TEXT(_savef16):
-C_TEXT(_savefpr_16):	stfd	fp16,-128(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef17)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_17)
-C_TEXT(_savef17):
-C_TEXT(_savefpr_17):	stfd	fp17,-120(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef18)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_18)
-C_TEXT(_savef18):
-C_TEXT(_savefpr_18):	stfd	fp18,-112(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef19)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_19)
-C_TEXT(_savef19):
-C_TEXT(_savefpr_19):	stfd	fp19,-104(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef20)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_20)
-C_TEXT(_savef20):
-C_TEXT(_savefpr_20):	stfd	fp20,-96(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef21)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_21)
-C_TEXT(_savef21):
-C_TEXT(_savefpr_21):	stfd	fp21,-88(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef22)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_22)
-C_TEXT(_savef22):
-C_TEXT(_savefpr_22):	stfd	fp22,-80(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef23)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_23)
-C_TEXT(_savef23):
-C_TEXT(_savefpr_23):	stfd	fp23,-72(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef24)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_24)
-C_TEXT(_savef24):
-C_TEXT(_savefpr_24):	stfd	fp24,-64(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef25)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_25)
-C_TEXT(_savef25):
-C_TEXT(_savefpr_25):	stfd	fp25,-56(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef26)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_26)
-C_TEXT(_savef26):
-C_TEXT(_savefpr_26):	stfd	fp26,-48(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef27)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_27)
-C_TEXT(_savef27):
-C_TEXT(_savefpr_27):	stfd	fp27,-40(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef28)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_28)
-C_TEXT(_savef28):
-C_TEXT(_savefpr_28):	stfd	fp28,-32(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef29)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_29)
-C_TEXT(_savef29):
-C_TEXT(_savefpr_29):	stfd	fp29,-24(r1)	#save f29
-			stfd	fp30,-16(r1)	#save f30
-			stfd	fp31,-8(r1)	#save f31
-			stw	r0,8(r1)	#save LR in callers frame
-			blr			#return
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/Dist glibc-2.2.5-patched/sysdeps/powerpc/fpu/Dist
--- glibc-2.2.5/sysdeps/powerpc/fpu/Dist	Thu Jan 27 02:48:02 2000
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/Dist	Sat Aug  3 13:37:53 2002
@@ -1,3 +1,6 @@
 fenv_const.c
 fenv_libc.h
 t_sqrt.c
+fe_nomask.c
+fprrest.S
+faprsave.S
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/Makefile glibc-2.2.5-patched/sysdeps/powerpc/fpu/Makefile
--- glibc-2.2.5/sysdeps/powerpc/fpu/Makefile	Tue Oct 12 00:29:00 1999
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/Makefile	Sat Aug  3 13:37:53 2002
@@ -1,3 +1,7 @@
 ifeq ($(subdir),math)
 libm-support += fenv_const fe_nomask t_sqrt
 endif
+
+ifeq ($(subdir),misc)
+sysdep_routines += fprsave fprrest
+endif
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/fclrexcpt.c glibc-2.2.5-patched/sysdeps/powerpc/fpu/fclrexcpt.c
--- glibc-2.2.5/sysdeps/powerpc/fpu/fclrexcpt.c	Thu Jan  1 01:00:00 1970
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/fclrexcpt.c	Sat Aug  3 13:37:53 2002
@@ -0,0 +1,48 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+#undef feclearexcept
+int
+__feclearexcept (int excepts)
+{
+  fenv_union_t u;
+
+  /* Get the current state.  */
+  u.fenv = fegetenv_register ();
+
+  /* Clear the relevant bits.  */
+  u.l[1] = u.l[1] & ~((-(excepts >> (31 - FPSCR_VX) & 1) & FE_ALL_INVALID)
+		      | (excepts & FPSCR_STICKY_BITS));
+
+  /* Put the new state in effect.  */
+  fesetenv_register (u.fenv);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feclearexcept, __old_feclearexcept)
+compat_symbol (libm, __old_feclearexcept, feclearexcept, GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, __feclearexcept, feclearexcept, GLIBC_2_2);
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/fe_nomask.c glibc-2.2.5-patched/sysdeps/powerpc/fpu/fe_nomask.c
--- glibc-2.2.5/sysdeps/powerpc/fpu/fe_nomask.c	Thu Jan  1 01:00:00 1970
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/fe_nomask.c	Sat Aug  3 13:37:53 2002
@@ -0,0 +1,32 @@
+/* Procedure definition for FE_NOMASK_ENV.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <errno.h>
+
+/* This is presently a stub, until it's decided how the kernels should
+   support this.  */
+
+const fenv_t *
+__fe_nomask_env(void)
+{
+  __set_errno (ENOSYS);
+  return FE_ENABLED_ENV;
+}
+stub_warning (__fe_nomask_env)
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/fprrest.S glibc-2.2.5-patched/sysdeps/powerpc/fpu/fprrest.S
--- glibc-2.2.5/sysdeps/powerpc/fpu/fprrest.S	Thu Jan  1 01:00:00 1970
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/fprrest.S	Sat Aug  3 13:37:53 2002
@@ -0,0 +1,94 @@
+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+    Floating Point Registers (FPRs) restore routine
+*/
+
+#include <sysdep.h>
+
+ENTRY(_restfpr_all)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf14)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_14)
+C_TEXT(_restf14):
+C_TEXT(_restfpr_14):	lfd	fp14,-144(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf15)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_15)
+C_TEXT(_restf15):
+C_TEXT(_restfpr_15):	lfd	fp15,-136(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf16)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_16)
+C_TEXT(_restf16):
+C_TEXT(_restfpr_16):	lfd	fp16,-128(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf17)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_17)
+C_TEXT(_restf17):
+C_TEXT(_restfpr_17):	lfd	fp17,-120(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf18)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_18)
+C_TEXT(_restf18):
+C_TEXT(_restfpr_18):	lfd	fp18,-112(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf19)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_19)
+C_TEXT(_restf19):
+C_TEXT(_restfpr_19):	lfd	fp19,-104(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf20)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_20)
+C_TEXT(_restf20):
+C_TEXT(_restfpr_20):	lfd	fp20,-96(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf21)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_21)
+C_TEXT(_restf21):
+C_TEXT(_restfpr_21):	lfd	fp21,-88(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf22)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_22)
+C_TEXT(_restf22):
+C_TEXT(_restfpr_22):	lfd	fp22,-80(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf23)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_23)
+C_TEXT(_restf23):
+C_TEXT(_restfpr_23):	lfd	fp23,-72(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf24)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_24)
+C_TEXT(_restf24):
+C_TEXT(_restfpr_24):	lfd	fp24,-64(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf25)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_25)
+C_TEXT(_restf25):
+C_TEXT(_restfpr_25):	lfd	fp25,-56(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf26)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_26)
+C_TEXT(_restf26):
+C_TEXT(_restfpr_26):	lfd	fp26,-48(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf27)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_27)
+C_TEXT(_restf27):
+C_TEXT(_restfpr_27):	lfd	fp27,-40(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf28)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_28)
+C_TEXT(_restf28):
+C_TEXT(_restfpr_28):	lfd	fp28,-32(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf29)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_29)
+C_TEXT(_restf29):
+C_TEXT(_restfpr_29):	lwz	r0,8(r1)	#get return address from frame
+			lfd	fp29,-24(r1)    #restore f29
+			mtlr	r0		#move return address to LR
+			lfd	fp30,-16(r1)	#restore f30
+			lfd	fp31,-8(r1)	#restore f31
+			blr			#return
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/fprsave.S glibc-2.2.5-patched/sysdeps/powerpc/fpu/fprsave.S
--- glibc-2.2.5/sysdeps/powerpc/fpu/fprsave.S	Thu Jan  1 01:00:00 1970
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/fprsave.S	Sat Aug  3 13:37:53 2002
@@ -0,0 +1,93 @@
+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+    Floating Point Registers (FPRs) save routine
+*/
+
+#include <sysdep.h>
+
+ENTRY(_savefpr_all)
+                ASM_GLOBAL_DIRECTIVE C_TEXT(_savef14)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_14)
+C_TEXT(_savef14):
+C_TEXT(_savefpr_14):	stfd	fp14,-144(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef15)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_15)
+C_TEXT(_savef15):
+C_TEXT(_savefpr_15):	stfd	fp15,-136(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef16)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_16)
+C_TEXT(_savef16):
+C_TEXT(_savefpr_16):	stfd	fp16,-128(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef17)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_17)
+C_TEXT(_savef17):
+C_TEXT(_savefpr_17):	stfd	fp17,-120(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef18)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_18)
+C_TEXT(_savef18):
+C_TEXT(_savefpr_18):	stfd	fp18,-112(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef19)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_19)
+C_TEXT(_savef19):
+C_TEXT(_savefpr_19):	stfd	fp19,-104(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef20)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_20)
+C_TEXT(_savef20):
+C_TEXT(_savefpr_20):	stfd	fp20,-96(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef21)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_21)
+C_TEXT(_savef21):
+C_TEXT(_savefpr_21):	stfd	fp21,-88(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef22)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_22)
+C_TEXT(_savef22):
+C_TEXT(_savefpr_22):	stfd	fp22,-80(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef23)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_23)
+C_TEXT(_savef23):
+C_TEXT(_savefpr_23):	stfd	fp23,-72(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef24)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_24)
+C_TEXT(_savef24):
+C_TEXT(_savefpr_24):	stfd	fp24,-64(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef25)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_25)
+C_TEXT(_savef25):
+C_TEXT(_savefpr_25):	stfd	fp25,-56(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef26)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_26)
+C_TEXT(_savef26):
+C_TEXT(_savefpr_26):	stfd	fp26,-48(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef27)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_27)
+C_TEXT(_savef27):
+C_TEXT(_savefpr_27):	stfd	fp27,-40(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef28)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_28)
+C_TEXT(_savef28):
+C_TEXT(_savefpr_28):	stfd	fp28,-32(r1)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef29)
+		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_29)
+C_TEXT(_savef29):
+C_TEXT(_savefpr_29):	stfd	fp29,-24(r1)	#save f29
+			stfd	fp30,-16(r1)	#save f30
+			stfd	fp31,-8(r1)	#save f31
+			stw	r0,8(r1)	#save LR in callers frame
+			blr			#return
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu/fpu_control.h glibc-2.2.5-patched/sysdeps/powerpc/fpu/fpu_control.h
--- glibc-2.2.5/sysdeps/powerpc/fpu/fpu_control.h	Thu Jan  1 01:00:00 1970
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu/fpu_control.h	Sat Aug  3 13:37:53 2002
@@ -0,0 +1,67 @@
+/* FPU control word definitions.  PowerPC version.
+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x00   /* RECOMMENDED */
+#define _FPU_RC_DOWN    0x03
+#define _FPU_RC_UP      0x02
+#define _FPU_RC_ZERO    0x01
+
+#define _FPU_MASK_NI  0x04 /* non-ieee mode */
+
+/* masking of interrupts */
+#define _FPU_MASK_ZM  0x10 /* zero divide */
+#define _FPU_MASK_OM  0x40 /* overflow */
+#define _FPU_MASK_UM  0x20 /* underflow */
+#define _FPU_MASK_XM  0x08 /* inexact */
+#define _FPU_MASK_IM  0x80 /* invalid operation */
+
+#define _FPU_RESERVED 0xffffff00 /* These bits are reserved are not changed. */
+
+/* The fdlibm code requires no interrupts for exceptions.  */
+#define _FPU_DEFAULT  0x00000000 /* Default value.  */
+
+/* IEEE:  same as above, but (some) exceptions;
+   we leave the 'inexact' exception off.
+ */
+#define _FPU_IEEE     0x000000f0
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) ( { \
+  union { double d; fpu_control_t cw[2]; } tmp __attribute__ ((__aligned__(8))); \
+  __asm__ ("mffs 0; stfd%U0 0,%0" : "=m" (tmp.d) : : "fr0"); \
+  (cw)=tmp.cw[1]; \
+  tmp.cw[1]; } )
+#define _FPU_SETCW(cw) { \
+  union { double d; fpu_control_t cw[2]; } tmp __attribute__ ((__aligned__(8))); \
+  tmp.cw[0] = 0xFFF80000; /* More-or-less arbitrary; this is a QNaN. */ \
+  tmp.cw[1] = cw; \
+  __asm__ ("lfd%U0 0,%0; mtfsf 255,0" : : "m" (tmp.d) : "fr0"); \
+}
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif /* _FPU_CONTROL_H */
diff -Naur glibc-2.2.5/sysdeps/powerpc/fpu_control.h glibc-2.2.5-patched/sysdeps/powerpc/fpu_control.h
--- glibc-2.2.5/sysdeps/powerpc/fpu_control.h	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/fpu_control.h	Thu Jan  1 01:00:00 1970
@@ -1,67 +0,0 @@
-/* FPU control word definitions.  PowerPC version.
-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _FPU_CONTROL_H
-#define _FPU_CONTROL_H
-
-/* rounding control */
-#define _FPU_RC_NEAREST 0x00   /* RECOMMENDED */
-#define _FPU_RC_DOWN    0x03
-#define _FPU_RC_UP      0x02
-#define _FPU_RC_ZERO    0x01
-
-#define _FPU_MASK_NI  0x04 /* non-ieee mode */
-
-/* masking of interrupts */
-#define _FPU_MASK_ZM  0x10 /* zero divide */
-#define _FPU_MASK_OM  0x40 /* overflow */
-#define _FPU_MASK_UM  0x20 /* underflow */
-#define _FPU_MASK_XM  0x08 /* inexact */
-#define _FPU_MASK_IM  0x80 /* invalid operation */
-
-#define _FPU_RESERVED 0xffffff00 /* These bits are reserved are not changed. */
-
-/* The fdlibm code requires no interrupts for exceptions.  */
-#define _FPU_DEFAULT  0x00000000 /* Default value.  */
-
-/* IEEE:  same as above, but (some) exceptions;
-   we leave the 'inexact' exception off.
- */
-#define _FPU_IEEE     0x000000f0
-
-/* Type of the control word.  */
-typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
-
-/* Macros for accessing the hardware control word.  */
-#define _FPU_GETCW(cw) ( { \
-  union { double d; fpu_control_t cw[2]; } tmp __attribute__ ((__aligned__(8))); \
-  __asm__ ("mffs 0; stfd%U0 0,%0" : "=m" (tmp.d) : : "fr0"); \
-  (cw)=tmp.cw[1]; \
-  tmp.cw[1]; } )
-#define _FPU_SETCW(cw) { \
-  union { double d; fpu_control_t cw[2]; } tmp __attribute__ ((__aligned__(8))); \
-  tmp.cw[0] = 0xFFF80000; /* More-or-less arbitrary; this is a QNaN. */ \
-  tmp.cw[1] = cw; \
-  __asm__ ("lfd%U0 0,%0; mtfsf 255,0" : : "m" (tmp.d) : "fr0"); \
-}
-
-/* Default control word set at startup.  */
-extern fpu_control_t __fpu_control;
-
-#endif /* _FPU_CONTROL_H */
diff -Naur glibc-2.2.5/sysdeps/powerpc/memset.S glibc-2.2.5-patched/sysdeps/powerpc/memset.S
--- glibc-2.2.5/sysdeps/powerpc/memset.S	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/memset.S	Thu Jan  1 01:00:00 1970
@@ -1,229 +0,0 @@
-/* Optimized memset implementation for PowerPC.
-   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#include <bp-sym.h>
-#include <bp-asm.h>
-
-/* __ptr_t [r3] memset (__ptr_t s [r3], int c [r4], size_t n [r5]));
-   Returns 's'.
-
-   The memset is done in three sizes: byte (8 bits), word (32 bits),
-   cache line (256 bits). There is a special case for setting cache lines
-   to 0, to take advantage of the dcbz instruction.  */
-
-EALIGN (BP_SYM (memset), 5, 1)
-
-#define rTMP	r0
-#define rRTN	r3	/* initial value of 1st argument */
-#if __BOUNDED_POINTERS__
-# define rMEMP0	r4	/* original value of 1st arg */
-# define rCHR	r5	/* char to set in each byte */
-# define rLEN	r6	/* length of region to set */
-# define rMEMP	r10	/* address at which we are storing */
-#else
-# define rMEMP0	r3	/* original value of 1st arg */
-# define rCHR	r4	/* char to set in each byte */
-# define rLEN	r5	/* length of region to set */
-# define rMEMP	r6	/* address at which we are storing */
-#endif
-#define rALIGN	r7	/* number of bytes we are setting now (when aligning) */
-#define rMEMP2	r8
-
-#define rPOS32	r7	/* constant +32 for clearing with dcbz */
-#define rNEG64	r8	/* constant -64 for clearing with dcbz */
-#define rNEG32	r9	/* constant -32 for clearing with dcbz */
-
-#if __BOUNDED_POINTERS__
-	cmplwi	cr1, rRTN, 0
-	CHECK_BOUNDS_BOTH_WIDE (rMEMP0, rTMP, rTMP2, rLEN)
-	beq	cr1, L(b0)
-	STORE_RETURN_VALUE (rMEMP0)
-	STORE_RETURN_BOUNDS (rTMP, rTMP2)
-L(b0):
-#endif
-
-/* take care of case for size <= 4  */
-	cmplwi	cr1, rLEN, 4
-	andi.	rALIGN, rMEMP0, 3
-	mr	rMEMP, rMEMP0
-	ble-	cr1, L(small)
-/* align to word boundary  */
-	cmplwi	cr5, rLEN, 31
-	rlwimi	rCHR, rCHR, 8, 16, 23
-	beq+	L(aligned)	/* 8th instruction from .align */
-	mtcrf	0x01, rMEMP0
-	subfic	rALIGN, rALIGN, 4
-	add	rMEMP, rMEMP, rALIGN
-	sub	rLEN, rLEN, rALIGN
-	bf+	31, L(g0)
-	stb	rCHR, 0(rMEMP0)
-	bt	30, L(aligned)
-L(g0):	sth	rCHR, -2(rMEMP)	/* 16th instruction from .align */
-/* take care of case for size < 31 */
-L(aligned):
-	mtcrf	0x01, rLEN
-	rlwimi	rCHR, rCHR, 16, 0, 15
-	ble	cr5, L(medium)
-/* align to cache line boundary...  */
-	andi.	rALIGN, rMEMP, 0x1C
-	subfic	rALIGN, rALIGN, 0x20
-	beq	L(caligned)
-	mtcrf	0x01, rALIGN
-	add	rMEMP, rMEMP, rALIGN
-	sub	rLEN, rLEN, rALIGN
-	cmplwi	cr1, rALIGN, 0x10
-	mr	rMEMP2, rMEMP
-	bf	28, L(a1)
-	stw	rCHR, -4(rMEMP2)
-	stwu	rCHR, -8(rMEMP2)
-L(a1):	blt	cr1, L(a2)
-	stw	rCHR, -4(rMEMP2) /* 32nd instruction from .align */
-	stw	rCHR, -8(rMEMP2)
-	stw	rCHR, -12(rMEMP2)
-	stwu	rCHR, -16(rMEMP2)
-L(a2):	bf	29, L(caligned)
-	stw	rCHR, -4(rMEMP2)
-/* now aligned to a cache line.  */
-L(caligned):
-	cmplwi	cr1, rCHR, 0
-	clrrwi.	rALIGN, rLEN, 5
-	mtcrf	0x01, rLEN	/* 40th instruction from .align */
-	beq	cr1, L(zloopstart) /* special case for clearing memory using dcbz */
-	srwi	rTMP, rALIGN, 5
-	mtctr	rTMP
-	beq	L(medium)	/* we may not actually get to do a full line */
-	clrlwi.	rLEN, rLEN, 27
-	add	rMEMP, rMEMP, rALIGN
-	li	rNEG64, -0x40
-	bdz	L(cloopdone)	/* 48th instruction from .align */
-
-L(c3):	dcbz	rNEG64, rMEMP
-	stw	rCHR, -4(rMEMP)
-	stw	rCHR, -8(rMEMP)
-	stw	rCHR, -12(rMEMP)
-	stw	rCHR, -16(rMEMP)
-	nop			/* let 601 fetch last 4 instructions of loop */
-	stw	rCHR, -20(rMEMP)
-	stw	rCHR, -24(rMEMP) /* 56th instruction from .align */
-	nop			/* let 601 fetch first 8 instructions of loop */
-	stw	rCHR, -28(rMEMP)
-	stwu	rCHR, -32(rMEMP)
-	bdnz	L(c3)
-L(cloopdone):
-	stw	rCHR, -4(rMEMP)
-	stw	rCHR, -8(rMEMP)
-	stw	rCHR, -12(rMEMP)
-	stw	rCHR, -16(rMEMP) /* 64th instruction from .align */
-	stw	rCHR, -20(rMEMP)
-	cmplwi	cr1, rLEN, 16
-	stw	rCHR, -24(rMEMP)
-	stw	rCHR, -28(rMEMP)
-	stwu	rCHR, -32(rMEMP)
-	beqlr
-	add	rMEMP, rMEMP, rALIGN
-	b	L(medium_tail2)	/* 72nd instruction from .align */
-
-	.align 5
-	nop
-/* Clear lines of memory in 128-byte chunks.  */
-L(zloopstart):
-	clrlwi	rLEN, rLEN, 27
-	mtcrf	0x02, rALIGN
-	srwi.	rTMP, rALIGN, 7
-	mtctr	rTMP
-	li	rPOS32, 0x20
-	li	rNEG64, -0x40
-	cmplwi	cr1, rLEN, 16	/* 8 */
-	bf	26, L(z0)
-	dcbz	0, rMEMP
-	addi	rMEMP, rMEMP, 0x20
-L(z0):	li	rNEG32, -0x20
-	bf	25, L(z1)
-	dcbz	0, rMEMP
-	dcbz	rPOS32, rMEMP
-	addi	rMEMP, rMEMP, 0x40 /* 16 */
-L(z1):	cmplwi	cr5, rLEN, 0
-	beq	L(medium)
-L(zloop):
-	dcbz	0, rMEMP
-	dcbz	rPOS32, rMEMP
-	addi	rMEMP, rMEMP, 0x80
-	dcbz	rNEG64, rMEMP
-	dcbz	rNEG32, rMEMP
-	bdnz	L(zloop)
-	beqlr	cr5
-	b	L(medium_tail2)
-
-	.align 5
-L(small):
-/* Memset of 4 bytes or less.  */
-	cmplwi	cr5, rLEN, 1
-	cmplwi	cr1, rLEN, 3
-	bltlr	cr5
-	stb	rCHR, 0(rMEMP)
-	beqlr	cr5
-	nop
-	stb	rCHR, 1(rMEMP)
-	bltlr	cr1
-	stb	rCHR, 2(rMEMP)
-	beqlr	cr1
-	nop
-	stb	rCHR, 3(rMEMP)
-	blr
-
-/* Memset of 0-31 bytes.  */
-	.align 5
-L(medium):
-	cmplwi	cr1, rLEN, 16
-L(medium_tail2):
-	add	rMEMP, rMEMP, rLEN
-L(medium_tail):
-	bt-	31, L(medium_31t)
-	bt-	30, L(medium_30t)
-L(medium_30f):
-	bt-	29, L(medium_29t)
-L(medium_29f):
-	bge-	cr1, L(medium_27t)
-	bflr-	28
-	stw	rCHR, -4(rMEMP)	/* 8th instruction from .align */
-	stw	rCHR, -8(rMEMP)
-	blr
-
-L(medium_31t):
-	stbu	rCHR, -1(rMEMP)
-	bf-	30, L(medium_30f)
-L(medium_30t):
-	sthu	rCHR, -2(rMEMP)
-	bf-	29, L(medium_29f)
-L(medium_29t):
-	stwu	rCHR, -4(rMEMP)
-	blt-	cr1, L(medium_27f) /* 16th instruction from .align */
-L(medium_27t):
-	stw	rCHR, -4(rMEMP)
-	stw	rCHR, -8(rMEMP)
-	stw	rCHR, -12(rMEMP)
-	stwu	rCHR, -16(rMEMP)
-L(medium_27f):
-	bflr-	28
-L(medium_28t):
-	stw	rCHR, -4(rMEMP)
-	stw	rCHR, -8(rMEMP)
-	blr
-END (BP_SYM (memset))
diff -Naur glibc-2.2.5/sysdeps/powerpc/setjmp.S glibc-2.2.5-patched/sysdeps/powerpc/setjmp.S
--- glibc-2.2.5/sysdeps/powerpc/setjmp.S	Fri Jul  6 06:56:01 2001
+++ glibc-2.2.5-patched/sysdeps/powerpc/setjmp.S	Sat Aug  3 13:37:53 2002
@@ -31,43 +31,25 @@
 	mflr r0
 	stw  r2,(JB_GPR2*4)(3)
 	stw  r14,((JB_GPRS+0)*4)(3)
-	stfd fp14,((JB_FPRS+0*2)*4)(3)
 	stw  r0,(JB_LR*4)(3)
 	stw  r15,((JB_GPRS+1)*4)(3)
-	stfd fp15,((JB_FPRS+1*2)*4)(3)
 	mfcr r0
 	stw  r16,((JB_GPRS+2)*4)(3)
-	stfd fp16,((JB_FPRS+2*2)*4)(3)
 	stw  r0,(JB_CR*4)(3)
 	stw  r17,((JB_GPRS+3)*4)(3)
-	stfd fp17,((JB_FPRS+3*2)*4)(3)
 	stw  r18,((JB_GPRS+4)*4)(3)
-	stfd fp18,((JB_FPRS+4*2)*4)(3)
 	stw  r19,((JB_GPRS+5)*4)(3)
-	stfd fp19,((JB_FPRS+5*2)*4)(3)
 	stw  r20,((JB_GPRS+6)*4)(3)
-	stfd fp20,((JB_FPRS+6*2)*4)(3)
 	stw  r21,((JB_GPRS+7)*4)(3)
-	stfd fp21,((JB_FPRS+7*2)*4)(3)
 	stw  r22,((JB_GPRS+8)*4)(3)
-	stfd fp22,((JB_FPRS+8*2)*4)(3)
 	stw  r23,((JB_GPRS+9)*4)(3)
-	stfd fp23,((JB_FPRS+9*2)*4)(3)
 	stw  r24,((JB_GPRS+10)*4)(3)
-	stfd fp24,((JB_FPRS+10*2)*4)(3)
 	stw  r25,((JB_GPRS+11)*4)(3)
-	stfd fp25,((JB_FPRS+11*2)*4)(3)
 	stw  r26,((JB_GPRS+12)*4)(3)
-	stfd fp26,((JB_FPRS+12*2)*4)(3)
 	stw  r27,((JB_GPRS+13)*4)(3)
-	stfd fp27,((JB_FPRS+13*2)*4)(3)
 	stw  r28,((JB_GPRS+14)*4)(3)
-	stfd fp28,((JB_FPRS+14*2)*4)(3)
 	stw  r29,((JB_GPRS+15)*4)(3)
-	stfd fp29,((JB_FPRS+15*2)*4)(3)
 	stw  r30,((JB_GPRS+16)*4)(3)
-	stfd fp30,((JB_FPRS+16*2)*4)(3)
 	stw  r31,((JB_GPRS+17)*4)(3)
-	stfd fp31,((JB_FPRS+17*2)*4)(3)
 	b JUMPTARGET (BP_SYM (__sigjmp_save))
 END (BP_SYM (__sigsetjmp))
diff -Naur glibc-2.2.5/sysdeps/unix/sysv/linux/errlist.c glibc-2.2.5-patched/sysdeps/unix/sysv/linux/errlist.c
--- glibc-2.2.5/sysdeps/unix/sysv/linux/errlist.c	Fri Jul  6 06:56:12 2001
+++ glibc-2.2.5-patched/sysdeps/unix/sysv/linux/errlist.c	Sat Aug  3 13:37:53 2002
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.

    The GNU C Library is free software; you can redistribute it and/or
@@ -38,10 +38,9 @@
 const int __old_sys_nerr = OLD_ERRLIST_SIZE;

 strong_alias (__old_sys_nerr, _old_sys_nerr);
-weak_alias (__old_sys_nerr, _old_sys_nerr)
 compat_symbol (libc, __old_sys_nerr, _sys_nerr, GLIBC_2_0);
 compat_symbol (libc, _old_sys_nerr, sys_nerr, GLIBC_2_0);
-weak_alias (__old_sys_errlist, _old_sys_errlist);
+strong_alias (__old_sys_errlist, _old_sys_errlist);
 compat_symbol (libc, __old_sys_errlist, _sys_errlist, GLIBC_2_0);
 compat_symbol (libc, _old_sys_errlist, sys_errlist, GLIBC_2_0);
 #endif
diff -u -r1.5 -r1.5.2.1
--- glibc-2.2.5/sunrpc/xdr_array.c	2001/08/17 04:48:31	1.5
+++ glibc-2.2.5/sunrpc/xdr_array.c	2002/08/02 01:35:39	1.5.2.1
@@ -45,6 +45,7 @@
 #include <rpc/types.h>
 #include <rpc/xdr.h>
 #include <libintl.h>
+#include <limits.h>

 #ifdef USE_IN_LIBIO
 # include <wchar.h>
@@ -81,7 +82,11 @@
       return FALSE;
     }
   c = *sizep;
-  if ((c > maxsize) && (xdrs->x_op != XDR_FREE))
+  /*
+   * XXX: Let the overflow possibly happen with XDR_FREE because mem_free()
+   * doesn't actually use its second argument anyway.
+   */
+  if ((c > maxsize || c > UINT_MAX / elsize) && (xdrs->x_op != XDR_FREE))
     {
       return FALSE;
     }
diff -uNr glibc-2.2.5.orig/malloc/malloc.c glibc-2.2.5/malloc/malloc.c
--- glibc-2.2.5.orig/malloc/malloc.c	2001-09-19 13:23:27.000000000 +1000
+++ glibc-2.2.5/malloc/malloc.c	2002-08-10 09:15:32.000000000 +1000
@@ -3795,14 +3795,26 @@
 {
   arena *ar_ptr;
   mchunkptr p, oldtop;
-  INTERNAL_SIZE_T sz, csz, oldtopsize;
+  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;
   Void_t* mem;
 
 #if defined _LIBC || defined MALLOC_HOOKS
   __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, __const __malloc_ptr_t)) =
     __malloc_hook;
+
+  /* size_t is unsigned so the behavior on overflow is defined.  */
+    bytes = n * elem_size;
+#define HALF_INTERNAL_SIZE_T \
+  (((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))
+  if (__builtin_expect ((n | elem_size) >= HALF_INTERNAL_SIZE_T, 0)) {
+    if (elem_size != 0 && bytes / elem_size != n) {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+  }
+
   if (hook != NULL) {
-    sz = n * elem_size;
+    sz = bytes;
 #if defined __GNUC__ && __GNUC__ >= 2
     mem = (*hook)(sz, RETURN_ADDRESS (0));
 #else
@@ -3819,7 +3831,7 @@
   }
 #endif
 
-  if(request2size(n * elem_size, sz))
+  if(request2size(bytes, sz))
     return 0;
   arena_get(ar_ptr, sz);
   if(!ar_ptr)
@@ -3862,7 +3874,7 @@
     }
     if (p == 0) return 0;
   }
-  mem = BOUNDED_N(chunk2mem(p), n * elem_size);
+  mem = BOUNDED_N(chunk2mem(p), bytes);
 
   /* Two optional cases in which clearing not necessary */
 
diff -uNr glibc-2.2.5.orig/iconv/skeleton.c glibc-2.2.5/iconv/skeleton.c
--- glibc-2.2.5.orig/iconv/skeleton.c	2001-07-06 14:54:47.000000000 +1000
+++ glibc-2.2.5/iconv/skeleton.c	2002-08-09 20:28:32.000000000 +1000
@@ -193,15 +193,20 @@
    character set we can define RESET_INPUT_BUFFER in a very fast way.  */
 #if !defined RESET_INPUT_BUFFER && !defined SAVE_RESET_STATE
 # if MIN_NEEDED_FROM == MAX_NEEDED_FROM && MIN_NEEDED_TO == MAX_NEEDED_TO
-/* We have to use these `if's here since the compiler cannot know that
-   (outbuf - outerr) is always divisible by MIN_NEEDED_TO.  */
-#  define RESET_INPUT_BUFFER \
-  if (MIN_NEEDED_FROM % MIN_NEEDED_TO == 0)				      \
-    *inptrp -= (outbuf - outerr) * (MIN_NEEDED_FROM / MIN_NEEDED_TO);	      \
-  else if (MIN_NEEDED_TO % MIN_NEEDED_FROM == 0)			      \
-    *inptrp -= (outbuf - outerr) / (MIN_NEEDED_TO / MIN_NEEDED_FROM);	      \
-  else									      \
-    *inptrp -= ((outbuf - outerr) / MIN_NEEDED_TO) * MIN_NEEDED_FROM
+/* We have to use these `#if's here since the compiler cannot know that
+   (outbuf - outerr) is always divisible by MIN_NEEDED_TO.  We have to
+   use preprocessor arithmetic and no C code because gcc 3.2 complains
+   about division by zero even in obviously dead code.  */
+#  if MIN_NEEDED_FROM % MIN_NEEDED_TO == 0
+#   define RESET_INPUT_BUFFER \
+  *inptrp -= (outbuf - outerr) * (MIN_NEEDED_FROM / MIN_NEEDED_TO)
+#  elif MIN_NEEDED_TO % MIN_NEEDED_FROM == 0
+#   define RESET_INPUT_BUFFER \
+  *inptrp -= (outbuf - outerr) / (MIN_NEEDED_TO / MIN_NEEDED_FROM)
+#  else
+#   define RESET_INPUT_BUFFER \
+  *inptrp -= ((outbuf - outerr) / MIN_NEEDED_TO) * MIN_NEEDED_FROM
+#  endif
 # endif
 #endif
 
diff -uNr glibc-2.2.5.orig/sysdeps/i386/fpu/libm-test-ulps glibc-2.2.5/sysdeps/i386/fpu/libm-test-ulps
--- glibc-2.2.5.orig/sysdeps/i386/fpu/libm-test-ulps	2001-08-27 23:55:13.000000000 +1000
+++ glibc-2.2.5/sysdeps/i386/fpu/libm-test-ulps	2002-07-12 11:44:05.000000000 +1000
@@ -96,9 +96,9 @@
 # cacosh
 Test "Real part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
 double: 1
-float: 4
+float: 9
 idouble: 1
-ifloat: 4
+ifloat: 9
 ildouble: 6
 ldouble: 6
 Test "Imaginary part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
@@ -1234,9 +1234,9 @@
 
 Function: Real part of "cacosh":
 double: 1
-float: 4
+float: 9
 idouble: 1
-ifloat: 4
+ifloat: 9
 ildouble: 328
 ldouble: 328
 
diff -uNr glibc-2.2.5.orig/posix/regex.h glibc-2.2.5/posix/regex.h
--- glibc-2.2.5.orig/posix/regex.h	2001-07-06 14:55:38.000000000 +1000
+++ glibc-2.2.5/posix/regex.h	2002-08-09 20:06:19.000000000 +1000
@@ -529,10 +529,14 @@
 #  endif
 # endif
 #endif
-/* For now unconditionally define __restrict_arr to expand to nothing.
-   Ideally we would have a test for the compiler which allows defining
-   it to restrict.  */
-#define __restrict_arr
+/* gcc 3.1 and up support the [restrict] syntax.  */
+#ifndef __restrict_arr
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
+#  define __restrict_arr __restrict
+# else
+#  define __restrict_arr
+# endif
+#endif
 
 /* POSIX compatibility.  */
 extern int regcomp _RE_ARGS ((regex_t *__restrict __preg,
diff -uNr glibc-2.2.5.orig/linuxthreads/signals.c glibc-2.2.5/linuxthreads/signals.c
--- glibc-2.2.5.orig/linuxthreads/signals.c	2002-01-21 14:21:16.000000000 +1100
+++ glibc-2.2.5/linuxthreads/signals.c	2002-07-26 20:30:40.000000000 +1000
@@ -198,7 +198,7 @@
         s != __pthread_sig_cancel &&
         s != __pthread_sig_debug) {
       sigdelset(&mask, s);
-      if (sighandler[s].old == NULL ||
+      if (sighandler[s].old == (arch_sighandler_t) SIG_ERR ||
           sighandler[s].old == (arch_sighandler_t) SIG_DFL ||
           sighandler[s].old == (arch_sighandler_t) SIG_IGN) {
         sa.sa_handler = pthread_null_sighandler;
diff -uNr glibc-2.2.5.orig/sysdeps/i386/Makefile glibc-2.2.5/sysdeps/i386/Makefile
--- glibc-2.2.5.orig/sysdeps/i386/Makefile	1999-09-18 02:59:13.000000000 +1000
+++ glibc-2.2.5/sysdeps/i386/Makefile	2002-03-01 06:39:16.000000000 +1100
@@ -9,6 +9,12 @@
 # On i686 we must avoid generating the trampoline functions generated
 # to get the GOT pointer.
 CFLAGS-initfini.s += -march=i386 -mcpu=i386
+
+ifeq (yes,$(build-shared))
+# Compatibility
+sysdep_routines += divdi3
+shared-only-routines += divdi3
+endif
 endif
 
 ifeq ($(subdir),db2)
diff -uNr glibc-2.2.5.orig/sysdeps/m68k/Makefile glibc-2.2.5/sysdeps/m68k/Makefile
--- glibc-2.2.5.orig/sysdeps/m68k/Makefile	2001-07-06 14:55:55.000000000 +1000
+++ glibc-2.2.5/sysdeps/m68k/Makefile	2002-03-01 06:39:18.000000000 +1100
@@ -33,6 +33,14 @@
 # The 68k `long double' is a distinct type we support.
 long-double-fcts = yes
 
+ifeq ($(subdir),csu)
+ifeq (yes,$(build-shared))
+# Compatibility
+sysdep_routines += divdi3
+shared-only-routines += divdi3
+endif
+endif
+
 ifeq ($(subdir),elf)
 CFLAGS-rtld.c += -Wno-uninitialized -Wno-unused
 endif
diff -uNr glibc-2.2.5.orig/sysdeps/s390/s390-32/Makefile glibc-2.2.5/sysdeps/s390/s390-32/Makefile
--- glibc-2.2.5.orig/sysdeps/s390/s390-32/Makefile	2001-03-16 19:59:44.000000000 +1100
+++ glibc-2.2.5/sysdeps/s390/s390-32/Makefile	2002-03-01 06:39:19.000000000 +1100
@@ -1,5 +1,13 @@
 pic-ccflag = -fpic
 
+ifeq ($(subdir),csu)
+ifeq (yes,$(build-shared))
+# Compatibility
+sysdep_routines += divdi3
+shared-only-routines += divdi3
+endif
+endif
+
 ifeq ($(subdir),gmon)
 sysdep_routines += s390-mcount
 endif
diff -uNr glibc-2.2.5.orig/sysdeps/wordsize-32/divdi3.c glibc-2.2.5/sysdeps/wordsize-32/divdi3.c
--- glibc-2.2.5.orig/sysdeps/wordsize-32/divdi3.c	1970-01-01 10:00:00.000000000 +1000
+++ glibc-2.2.5/sysdeps/wordsize-32/divdi3.c	2002-05-31 09:59:11.000000000 +1000
@@ -0,0 +1,324 @@
+/* 64-bit multiplication and division
+   Copyright (C) 1989, 1992-1999, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <endian.h>
+#include <stdlib.h>
+#include <bits/wordsize.h>
+
+#if __WORDSIZE != 32
+#error This is for 32-bit targets only
+#endif
+
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef          int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef          int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+#define Wtype SItype
+#define HWtype SItype
+#define DWtype DItype
+#define UWtype USItype
+#define UHWtype USItype
+#define UDWtype UDItype
+#define W_TYPE_SIZE 32
+
+#include <stdlib/longlong.h>
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+struct DWstruct { Wtype high, low;};
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+struct DWstruct { Wtype low, high;};
+#else
+#error Unhandled endianity
+#endif
+typedef union { struct DWstruct s; DWtype ll; } DWunion;
+
+static UDWtype
+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
+{
+  DWunion ww;
+  DWunion nn, dd;
+  DWunion rr;
+  UWtype d0, d1, n0, n1, n2;
+  UWtype q0, q1;
+  UWtype b, bm;
+
+  nn.ll = n;
+  dd.ll = d;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n0 = nn.s.low;
+  n1 = nn.s.high;
+
+#if !UDIV_NEEDS_NORMALIZATION
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  udiv_qrnnd (q1, n1, 0, n1, d0);
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+
+#else /* UDIV_NEEDS_NORMALIZATION */
+
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm != 0)
+	    {
+	      /* Normalize, i.e. make the most significant bit of the
+		 denominator set.  */
+
+	      d0 = d0 << bm;
+	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
+	      n0 = n0 << bm;
+	    }
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0 >> bm.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d0) /\ (the most significant bit of d0 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 leading quotient digit q1 = 1).
+
+		 This special case is necessary, not an optimization.
+		 (Shifts counts of W_TYPE_SIZE are undefined.)  */
+
+	      n1 -= d0;
+	      q1 = 1;
+	    }
+	  else
+	    {
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q1, n1, n2, n1, d0);
+	    }
+
+	  /* n1 != d0...  */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0 >> bm.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0 >> bm;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+#endif /* UDIV_NEEDS_NORMALIZATION */
+
+  else
+    {
+      if (d1 > n1)
+	{
+	  /* 00 = nn / DD */
+
+	  q0 = 0;
+	  q1 = 0;
+
+	  /* Remainder in n1n0.  */
+	  if (rp != 0)
+	    {
+	      rr.s.low = n0;
+	      rr.s.high = n1;
+	      *rp = rr.ll;
+	    }
+	}
+      else
+	{
+	  /* 0q = NN / dd */
+
+	  count_leading_zeros (bm, d1);
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 quotient digit q0 = 0 or 1).
+
+		 This special case is necessary, not an optimization.  */
+
+	      /* The condition on the next line takes advantage of that
+		 n1 >= d1 (true due to program flow).  */
+	      if (n1 > d1 || n0 >= d0)
+		{
+		  q0 = 1;
+		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
+		}
+	      else
+		q0 = 0;
+
+	      q1 = 0;
+
+	      if (rp != 0)
+		{
+		  rr.s.low = n0;
+		  rr.s.high = n1;
+		  *rp = rr.ll;
+		}
+	    }
+	  else
+	    {
+	      UWtype m1, m0;
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d1 = (d1 << bm) | (d0 >> b);
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q0, n1, n2, n1, d1);
+	      umul_ppmm (m1, m0, q0, d0);
+
+	      if (m1 > n1 || (m1 == n1 && m0 > n0))
+		{
+		  q0--;
+		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
+		}
+
+	      q1 = 0;
+
+	      /* Remainder in (n1n0 - m1m0) >> bm.  */
+	      if (rp != 0)
+		{
+		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
+		  rr.s.low = (n1 << b) | (n0 >> bm);
+		  rr.s.high = n1 >> bm;
+		  *rp = rr.ll;
+		}
+	    }
+	}
+    }
+
+  ww.s.low = q0;
+  ww.s.high = q1;
+  return ww.ll;
+}
+
+DWtype
+__divdi3 (DWtype u, DWtype v)
+{
+  Wtype c = 0;
+  DWtype w;
+
+  if (u < 0)
+    {
+      c = ~c;
+      u = -u;
+    }
+  if (v < 0)
+    {
+      c = ~c;
+      v = -v;
+    }
+  w = __udivmoddi4 (u, v, NULL);
+  if (c)
+    w = -w;
+  return w;
+}
+
+DWtype
+__moddi3 (DWtype u, DWtype v)
+{
+  Wtype c = 0;
+  DWtype w;
+
+  if (u < 0)
+    {
+      c = ~c;
+      u = -u;
+    }
+  if (v < 0)
+    v = -v;
+  __udivmoddi4 (u, v, &w);
+  if (c)
+    w = -w;
+  return w;
+}
+
+UDWtype
+__udivdi3 (UDWtype u, UDWtype v)
+{
+  return __udivmoddi4 (u, v, NULL);
+}
+
+UDWtype
+__umoddi3 (UDWtype u, UDWtype v)
+{
+  UDWtype w;
+
+  __udivmoddi4 (u, v, &w);
+  return w;
+}
diff -urN glibc-2.2.5/linuxthreads/internals.h glibc-2.2.5-s390/linuxthreads/internals.h
--- glibc-2.2.5/linuxthreads/internals.h	Thu Nov 29 08:44:16 2001
+++ glibc-2.2.5-s390/linuxthreads/internals.h	Mon Jul  8 14:20:45 2002
@@ -552,7 +552,7 @@
 /* Prototypes for compatibility functions.  */
 extern int __pthread_attr_init_2_1 (pthread_attr_t *__attr);
 extern int __pthread_attr_init_2_0 (pthread_attr_t *__attr);
-extern int __pthread_create_2_1 (pthread_t *__restrict __thread,
+extern int __pthread_create_2_1 (pthread_t *__restrict __thr,
 				 const pthread_attr_t *__attr,
 				 void *(*__start_routine) (void *),
 				 void *__restrict __arg);
diff -urN glibc-2.2.5/linuxthreads/sysdeps/pthread/pthread.h glibc-2.2.5-s390/linuxthreads/sysdeps/pthread/pthread.h
--- glibc-2.2.5/linuxthreads/sysdeps/pthread/pthread.h	Thu Mar 15 22:12:31 2001
+++ glibc-2.2.5-s390/linuxthreads/sysdeps/pthread/pthread.h	Mon Jul  8 14:20:45 2002
@@ -160,7 +160,7 @@
 /* Create a thread with given attributes ATTR (or default attributes
    if ATTR is NULL), and call function START_ROUTINE with given
    arguments ARG.  */
-extern int pthread_create (pthread_t *__restrict __thread,
+extern int pthread_create (pthread_t *__restrict __thr,
 			   __const pthread_attr_t *__restrict __attr,
 			   void *(*__start_routine) (void *),
 			   void *__restrict __arg) __THROW;
@@ -588,7 +588,7 @@
 extern int pthread_setcanceltype (int __type, int *__oldtype) __THROW;
 
 /* Cancel THREAD immediately or at the next possibility.  */
-extern int pthread_cancel (pthread_t __thread) __THROW;
+extern int pthread_cancel (pthread_t __thr) __THROW;
 
 /* Test for pending cancellation for the current thread and terminate
    the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
diff -urN glibc-2.2.5/linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h glibc-2.2.5-s390/linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h
--- glibc-2.2.5/linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h	Mon Aug 21 08:48:03 2000
+++ glibc-2.2.5-s390/linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h	Mon Jul  8 14:20:45 2002
@@ -33,6 +33,6 @@
 			    __sigset_t *__restrict __oldmask)__THROW;
 
 /* Send signal SIGNO to the given thread. */
-extern int pthread_kill (pthread_t __thread, int __signo) __THROW;
+extern int pthread_kill (pthread_t __thr, int __signo) __THROW;
 
 #endif	/* bits/sigthread.h */
--- glibc-2.2.5/stdio-common/sprintf.c.old	2003-05-24 20:08:52.000000000 +0200
+++ glibc-2.2.5/stdio-common/sprintf.c	2003-05-24 20:06:11.000000000 +0200
@@ -27,9 +27,7 @@
 /* Write formatted output into S, according to the format string FORMAT.  */
 /* VARARGS2 */
 int
-sprintf (s, format)
-     char *s;
-     const char *format;
+sprintf (char *s, const char *format, ...)
 {
   va_list arg;
   int done;
--- glibc-2.2.5/stdio-common/sscanf.c.old	2003-05-24 20:17:45.000000000 +0200
+++ glibc-2.2.5/stdio-common/sscanf.c	2003-05-24 20:18:22.000000000 +0200
@@ -27,9 +27,7 @@
 /* Read formatted input from S, according to the format string FORMAT.  */
 /* VARARGS2 */
 int
-sscanf (s, format)
-     const char *s;
-     const char *format;
+sscanf (const char *s, const char *format, ...)
 {
   va_list arg;
   int done;
