diff -Naur vdr-1.2.0.orig/dvbdevice.c vdr-1.2.0/dvbdevice.c
--- vdr-1.2.0.orig/dvbdevice.c	2003-05-24 15:23:51.000000000 +0200
+++ vdr-1.2.0/dvbdevice.c	2003-06-01 16:04:37.000000000 +0200
@@ -70,7 +70,7 @@
   int fd_frontend;
   int cardIndex;
   fe_type_t frontendType;
-  cCiHandler *ciHandler;
+  /*cCiHandler *ciHandler;*/
   cChannel channel;
   const char *diseqcCommands;
   bool active;
@@ -80,20 +80,22 @@
   cCondVar newSet;
   bool SetFrontend(void);
   virtual void Action(void);
+  void SetVoltage(const fe_sec_voltage voltage, const uint32_t ms);
+  void SetTone(const fe_sec_tone_mode_t toneMode, const uint32_t ms);
 public:
-  cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType, cCiHandler *CiHandler);
+  cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType/*, cCiHandler *CiHandler*/);
   virtual ~cDvbTuner();
   bool IsTunedTo(const cChannel *Channel) const;
   void Set(const cChannel *Channel, bool Tune);
   bool Locked(void) { return tunerStatus == tsLocked; }
   };
 
-cDvbTuner::cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType, cCiHandler *CiHandler)
+cDvbTuner::cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType/*, cCiHandler *CiHandler*/)
 {
   fd_frontend = Fd_Frontend;
   cardIndex = CardIndex;
   frontendType = FrontendType;
-  ciHandler = CiHandler;
+  /*ciHandler = CiHandler;*/
   diseqcCommands = NULL;
   active = false;
   tunerStatus = tsIdle;
@@ -135,6 +137,20 @@
   return f;
 }
 
+void cDvbTuner::SetVoltage(const fe_sec_voltage voltage, const uint32_t ms)
+{
+	if (ioctl( fd_frontend,FE_SET_VOLTAGE, voltage) == 0) {
+		usleep(1000 * ms);
+	}
+}
+
+void cDvbTuner::SetTone(const fe_sec_tone_mode_t toneMode, const uint32_t ms)
+{
+	if (ioctl(fd_frontend,FE_SET_TONE,toneMode) == 0) {
+		usleep(1000 * ms);
+	}
+}
+
 bool cDvbTuner::SetFrontend(void)
 {
   dvb_frontend_parameters Frontend;
@@ -154,10 +170,10 @@
                   for (char *CurrentAction = NULL; (da = diseqc->Execute(&CurrentAction)) != cDiseqc::daNone; ) {
                       switch (da) {
                         case cDiseqc::daNone:      break;
-                        case cDiseqc::daToneOff:   CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF)); break;
-                        case cDiseqc::daToneOn:    CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_ON)); break;
-                        case cDiseqc::daVoltage13: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); break;
-                        case cDiseqc::daVoltage18: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_18)); break;
+                        case cDiseqc::daToneOff:   SetTone(SEC_TONE_OFF,15); break;
+                        case cDiseqc::daToneOn:    SetTone(SEC_TONE_ON,15); break;
+                        case cDiseqc::daVoltage13: SetVoltage(SEC_VOLTAGE_13,15); break;
+                        case cDiseqc::daVoltage18: SetVoltage(SEC_VOLTAGE_18,15); break;
                         case cDiseqc::daMiniA:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_A)); break;
                         case cDiseqc::daMiniB:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_B)); break;
                         case cDiseqc::daCodes: {
@@ -194,8 +210,8 @@
                tone = SEC_TONE_ON;
                }
             int volt = (channel.Polarization() == 'v' || channel.Polarization() == 'V') ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18;
-            CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, volt));
-            CHECK(ioctl(fd_frontend, FE_SET_TONE, tone));
+	    SetVoltage(fe_sec_voltage(volt),15);
+	    SetTone(fe_sec_tone_mode(tone),15);
             }
 
          frequency = abs(frequency); // Allow for C-band, where the frequency is less than the LOF
@@ -235,6 +251,12 @@
          esyslog("ERROR: attempt to set channel with unknown DVB frontend type");
          return false;
     }
+
+  struct dvb_frontend_event event;
+  if (errno !=0)
+    errno = 0;
+  while ((errno == 0) || (errno == EOVERFLOW))
+    ioctl(fd_frontend,FE_GET_EVENT, &event);
   if (ioctl(fd_frontend, FE_SET_FRONTEND, &Frontend) < 0) {
      esyslog("ERROR: frontend %d: %m", cardIndex);
      return false;
@@ -265,8 +287,9 @@
                  continue;
                  }
               }
-           if (tunerStatus >= tsLocked) {
-              if (ciHandler) {
+	     if (tunerStatus >= tsLocked) tunerStatus = tsLocked;
+           /*if (tunerStatus >= tsLocked) {
+             if (ciHandler) {
                  if (ciHandler->Process()) {
                     if (tunerStatus != tsCam) {//XXX TODO update in case the CA descriptors have changed
                        for (int Slot = 0; Slot < ciHandler->NumSlots(); Slot++) {
@@ -294,10 +317,10 @@
                  else
                     tunerStatus = tsLocked;
                  }
-              }
+              }*/
            }
         // in the beginning we loop more often to let the CAM connection start up fast
-        newSet.TimedWait(mutex, (ciHandler && (time(NULL) - startTime < 20)) ? 100 : 1000);
+       newSet.TimedWait(mutex,   (time(NULL) - startTime < 20) ? 100 : 1000);
         }
   dsyslog("tuner thread ended on device %d (pid=%d)", cardIndex + 1, getpid());
 }
@@ -337,8 +360,8 @@
      siProcessor = new cSIProcessor(DvbName(DEV_DVB_DEMUX, n));
      if (ioctl(fd_frontend, FE_GET_INFO, &feinfo) >= 0) {
         frontendType = feinfo.type;
-        ciHandler = cCiHandler::CreateCiHandler(DvbName(DEV_DVB_CA, n));
-        dvbTuner = new cDvbTuner(fd_frontend, CardIndex(), frontendType, ciHandler);
+        /*ciHandler = cCiHandler::CreateCiHandler(DvbName(DEV_DVB_CA, n));*/
+        dvbTuner = new cDvbTuner(fd_frontend, CardIndex(), frontendType/*, ciHandler*/);
         }
      else
         LOG_ERROR;
@@ -401,8 +424,8 @@
 
 void cDvbDevice::MakePrimaryDevice(bool On)
 {
-  if (HasDecoder())
-     cDvbOsd::SetDvbDevice(On ? this : NULL);
+  //if (HasDecoder())
+    // cDvbOsd::SetDvbDevice(On ? this : NULL);
 }
 
 bool cDvbDevice::HasDecoder(void) const
@@ -541,29 +564,32 @@
            }
         pesFilterParams.pid     = Handle->pid;
         pesFilterParams.input   = DMX_IN_FRONTEND;
-        pesFilterParams.output  = (Type <= ptTeletext && Handle->used <= 1) ? DMX_OUT_DECODER : DMX_OUT_TS_TAP;
-        pesFilterParams.pes_type= PesTypes[Type < ptOther ? Type : ptOther];
-        pesFilterParams.flags   = DMX_IMMEDIATE_START;
+        pesFilterParams.output  = DMX_OUT_DECODER;//(Type <= ptTeletext && Handle->used <= 1) ? DMX_OUT_DECODER : DMX_OUT_TS_TAP;
+       	pesFilterParams.pes_type= PesTypes[Type]; //PesTypes[Type < ptOther ? Type : ptOther];
+	pesFilterParams.flags = DMX_IMMEDIATE_START;
         if (ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams) < 0) {
            LOG_ERROR;
            return false;
            }
         }
-     else if (!Handle->used) {
-        CHECK(ioctl(Handle->handle, DMX_STOP));
-        if (Type <= ptTeletext) {
-           pesFilterParams.pid     = 0x1FFF;
+     else
+     	{
+		CHECK(ioctl(Handle->handle,DMX_STOP));
+		 if (!Handle->used) {
+        /*if (Type <= ptTeletext) {
+          /* pesFilterParams.pid     = 0x1FFF;
            pesFilterParams.input   = DMX_IN_FRONTEND;
            pesFilterParams.output  = DMX_OUT_DECODER;
            pesFilterParams.pes_type= PesTypes[Type];
-           pesFilterParams.flags   = DMX_IMMEDIATE_START;
+	   pesFilterParams.flags   = DMX_IMMEDIATE_START;
            CHECK(ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams));
-           if (PesTypes[Type] == DMX_PES_VIDEO) // let's only do this once
-              SetPlayMode(pmNone); // necessary to switch a PID from DMX_PES_VIDEO/AUDIO to DMX_PES_OTHER
-           }
+        //   if (PesTypes[Type] == DMX_PES_VIDEO) // let's only do this once
+          //    SetPlayMode(pmNone); // necessary to switch a PID from DMX_PES_VIDEO/AUDIO to DMX_PES_OTHER
+           }*/
         close(Handle->handle);
         Handle->handle = -1;
         }
+	}
      }
   return true;
 }
@@ -573,17 +599,16 @@
   // Avoid noise while switching:
 
   CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
-  CHECK(ioctl(fd_video, VIDEO_SET_BLANK, true));
-  CHECK(ioctl(fd_audio, AUDIO_CLEAR_BUFFER));
-  CHECK(ioctl(fd_video, VIDEO_CLEAR_BUFFER));
+  CHECK(ioctl(fd_video,VIDEO_SET_BLANK));
+  CHECK(ioctl(fd_audio,AUDIO_STOP));
+  CHECK(ioctl(fd_video,VIDEO_STOP));
 
   // Turn off live PIDs:
-
-  DelPid(pidHandles[ptAudio].pid);
-  DelPid(pidHandles[ptVideo].pid);
-  DelPid(pidHandles[ptPcr].pid, ptPcr);
-  DelPid(pidHandles[ptTeletext].pid);
-  DelPid(pidHandles[ptDolby].pid);
+  		DelPid(pidHandles[ptTeletext].pid);
+  		DelPid(pidHandles[ptVideo].pid);
+  		DelPid(pidHandles[ptAudio].pid);
+  		DelPid(pidHandles[ptPcr].pid, ptPcr);
+  		DelPid(pidHandles[ptDolby].pid);
 }
 
 bool cDvbDevice::ProvidesSource(int Source) const
@@ -610,8 +635,9 @@
            if (!HasPid(Channel->Vpid())) {
 #ifdef DO_MULTIPLE_RECORDINGS
               if (Channel->Ca() > CACONFBASE)
-                 needsDetachReceivers = !ciHandler // only LL-firmware can do non-live CA channels
-                                        || Ca() != Channel->Ca();
+                 /*needsDetachReceivers = !ciHandler // only LL-firmware can do non-live CA channels
+                                        || Ca() != Channel->Ca();*/
+		needsDetachReceivers = Ca()!=Channel->Ca();
               else if (!IsPrimaryDevice())
                  result = true;
 #ifdef DO_REC_AND_PLAY_ON_PRIMARY_DEVICE
@@ -632,7 +658,7 @@
 
 bool cDvbDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
 {
-  bool IsEncrypted = Channel->Ca() > CACONFBASE && !ciHandler; // only LL-firmware can do non-live CA channels
+  bool IsEncrypted = Channel->Ca() > CACONFBASE; //==101;// 101 = Premiere // > CACONFBASE && !ciHandler; // only LL-firmware can do non-live CA channels
 
   bool DoTune = !dvbTuner->IsTunedTo(Channel);
 
@@ -678,19 +704,58 @@
 
   dvbTuner->Set(Channel, DoTune);
 
+  // this is needed for the dbox2...
+  // otherwise we don't get a picture sometimes or the tv picture looks like
+  // a replay :)
+  // not really perfect, but it works better than without it. If you switch to fast
+  // tv picture still gets stuck...
+  #define LOCKWAITTIME 10000
+  #define MAXCOUNT 20000
+  int lcounter = 0;
+  do
+  	{
+		lcounter++;
+		usleep(LOCKWAITTIME);
+	}
+  while ((!dvbTuner->Locked()) && (lcounter < MAXCOUNT));
+
+  usleep(LOCKWAITTIME);
+
   // PID settings:
 
   if (TurnOnLivePIDs) {
      aPid1 = Channel->Apid1();
      aPid2 = Channel->Apid2();
      int pPid = Channel->Ppid() ? Channel->Ppid() : Channel->Vpid();
-     if (!(AddPid(pPid, ptPcr) && AddPid(Channel->Apid1(), ptAudio) && AddPid(Channel->Vpid(), ptVideo))) {//XXX+ dolby dpid1!!! (if audio plugins are attached)
+    /* if (!(AddPid(pPid, ptPcr) && AddPid(Channel->Apid1(), ptAudio) && AddPid(Channel->Vpid(), ptVideo))) {//XXX+ dolby dpid1!!! (if audio plugins are attached)
         esyslog("ERROR: failed to set PIDs for channel %d on device %d", Channel->Number(), CardIndex() + 1);
         return false;
         }
      if (IsPrimaryDevice())
-        AddPid(Channel->Tpid(), ptTeletext);
+        AddPid(Channel->Tpid(), ptTeletext);*/
+
+	if (pPid!=0)
+		{
+			AddPid(pPid,ptPcr);
+		}
+	if (Channel->Apid1()!=0)
+		{
+			AddPid(Channel->Apid1(),ptAudio);
+		}
+	if (Channel->Vpid()!=0)
+		{
+			AddPid(Channel->Vpid(),ptVideo);
+		}
+	if (Channel->Tpid()!=0)
+		{
+			AddPid(Channel->Tpid(),ptTeletext);
+		}
+     CHECK(ioctl(fd_video,VIDEO_SELECT_SOURCE,VIDEO_SOURCE_DEMUX));
+     CHECK(ioctl(fd_video,VIDEO_PLAY));
+     CHECK(ioctl(fd_audio, AUDIO_SELECT_SOURCE,AUDIO_SOURCE_DEMUX));
      CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE,false));
+     CHECK(ioctl(fd_audio, AUDIO_PLAY));
      }
   else if (StartTransferMode)
      cControl::Launch(new cTransferControl(this, Channel->Vpid(), Channel->Apid1(), Channel->Apid2(), Channel->Dpid1(), Channel->Dpid2()));
@@ -751,7 +816,7 @@
   if (Receiving())
      return false;
 #endif
-  return cDevice::CanReplay() && (Ca() <= MAXDEVICES || ciHandler); // with non-LL-firmware we can only replay if there is no CA recording going on
+  return cDevice::CanReplay() && (Ca() <= MAXDEVICES);// || ciHandler); // with non-LL-firmware we can only replay if there is no CA recording going on
 }
 
 bool cDvbDevice::SetPlayMode(ePlayMode PlayMode)
@@ -766,18 +831,14 @@
   switch (PlayMode) {
     case pmNone:
          // special handling to return from PCM replay:
-         CHECK(ioctl(fd_video, VIDEO_SET_BLANK, true));
-         CHECK(ioctl(fd_video, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY));
-         CHECK(ioctl(fd_video, VIDEO_PLAY));
-
-         CHECK(ioctl(fd_video, VIDEO_STOP, true));
-         CHECK(ioctl(fd_audio, AUDIO_STOP, true));
-         CHECK(ioctl(fd_video, VIDEO_CLEAR_BUFFER));
-         CHECK(ioctl(fd_audio, AUDIO_CLEAR_BUFFER));
+	 CHECK(ioctl(fd_video,VIDEO_STOP));
+	 CHECK(ioctl(fd_audio,AUDIO_STOP));
          CHECK(ioctl(fd_video, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX));
+	 CHECK(ioctl(fd_video,VIDEO_PLAY));
          CHECK(ioctl(fd_audio, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_DEMUX));
          CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
          CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, false));
+	 CHECK(ioctl(fd_audio,AUDIO_PLAY));
          if (siProcessor)
             siProcessor->SetStatus(true);
          break;
diff -Naur vdr-1.2.0.orig/dvbosd.c vdr-1.2.0/dvbosd.c
--- vdr-1.2.0.orig/dvbosd.c	2003-04-12 14:10:12.000000000 +0200
+++ vdr-1.2.0/dvbosd.c	2003-06-01 16:06:02.000000000 +0200
@@ -13,14 +13,18 @@
 #include <sys/unistd.h>
 #include "tools.h"
 
-const cDvbDevice *cDvbOsd::dvbDevice = NULL;
+//const cDvbDevice *cDvbOsd::dvbDevice = NULL;
 
 cDvbOsd::cDvbOsd(int x, int y)
 :cOsdBase(x, y)
 {
-  osdDev = dvbDevice ? dvbDevice->OsdDeviceHandle() : -1;
-  if (dvbDevice && osdDev < 0)
-     esyslog("ERROR: illegal OSD device handle (%d)!", osdDev);
+  // framebuffer wrapper class, singleton
+  pFBOsd = cFBOsd::getInstance();
+  if (!pFBOsd)
+  	esyslog("ERROR: can't create framebuffer OSD!");
+  //osdDev = dvbDevice ? dvbDevice->OsdDeviceHandle() : -1;
+  //if (dvbDevice && osdDev < 0)
+    // esyslog("ERROR: illegal OSD device handle (%d)!", osdDev);
 }
 
 cDvbOsd::~cDvbOsd()
@@ -29,10 +33,10 @@
       CloseWindow(GetWindowNr(i));
 }
 
-void cDvbOsd::SetDvbDevice(const cDvbDevice *DvbDevice)
-{
-  dvbDevice = DvbDevice;
-}
+//void cDvbOsd::SetDvbDevice(const cDvbDevice *DvbDevice)
+//{
+//  dvbDevice = DvbDevice;
+//}
 
 bool cDvbOsd::SetWindow(cWindow *Window)
 {
@@ -51,7 +55,7 @@
 
 void cDvbOsd::Cmd(OSD_Command cmd, int color, int x0, int y0, int x1, int y1, const void *data)
 {
-  if (osdDev >= 0) {
+ // if (osdDev >= 0) {
      osd_cmd_t dc;
      dc.cmd   = cmd;
      dc.color = color;
@@ -60,8 +64,11 @@
      dc.x1    = x1;
      dc.y1    = y1;
      dc.data  = (void *)data;
-     ioctl(osdDev, OSD_SEND_CMD, &dc);
-     }
+
+    // no driver, no ioctl, instead use the wrapper class cFBOsd
+    // ioctl(osdDev, OSD_SEND_CMD, &dc);
+      pFBOsd->Cmd(&dc);
+   //  }
 }
 
 bool cDvbOsd::OpenWindow(cWindow *Window)
@@ -92,7 +99,11 @@
 void cDvbOsd::ShowWindow(cWindow *Window)
 {
   if (SetWindow(Window))
+  {
+ 	// set Show... the window will not be painted to framebuffer without this
+     Cmd(OSD_Show,0);  
      Cmd(OSD_MoveWindow, 0, X0() + Window->X0(), Y0() + Window->Y0());
+  }
 }
 
 void cDvbOsd::HideWindow(cWindow *Window, bool Hide)
diff -Naur vdr-1.2.0.orig/dvbosd.h vdr-1.2.0/dvbosd.h
--- vdr-1.2.0.orig/dvbosd.h	2002-11-01 11:05:47.000000000 +0100
+++ vdr-1.2.0/dvbosd.h	2003-06-01 16:05:20.000000000 +0200
@@ -11,13 +11,16 @@
 #define __DVBOSD_H
 
 #include <linux/dvb/osd.h>
-#include "dvbdevice.h"
+//#include "dvbdevice.h"
 #include "osdbase.h"
+#include "fbosd.h"
 
 class cDvbOsd : public cOsdBase {
 private:
-  static const cDvbDevice *dvbDevice;
-  int osdDev;
+  //static const cDvbDevice *dvbDevice;
+  // cFBOsd: framebuffer OSD for DBox
+  cFBOsd* pFBOsd;
+  //int osdDev;
   bool SetWindow(cWindow *Window);
   void Cmd(OSD_Command cmd, int color = 0, int x0 = 0, int y0 = 0, int x1 = 0, int y1 = 0, const void *data = NULL);
 protected:
@@ -30,7 +33,7 @@
 public:
   cDvbOsd(int x, int y);
   virtual ~cDvbOsd();
-  static void SetDvbDevice(const cDvbDevice *DvbDevice);
+  //static void SetDvbDevice(const cDvbDevice *DvbDevice);
   };
 
 #endif //__DVBOSD_H
diff -Naur vdr-1.2.0.orig/fbosd.c vdr-1.2.0/fbosd.c
--- vdr-1.2.0.orig/fbosd.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/fbosd.c	2003-06-02 12:03:35.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ * fbosd.c replaces hardware osd driver
+ *
+ * (C) 2003 Alexander Olk <xenomorph2@onlinehome.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include "fbosd.h"
+#include "tools.h"
+
+cFBOsd* cFBOsd::mpFBOsd = NULL;
+
+CFBWindow::CFBWindow( const int _x, const int _y, const int _dx, const int _dy, int ibpp )
+{
+	x  = _x ;
+	y  = _y ;
+	dx = _dx;
+	dy = _dy;
+	bpp = ibpp;
+	showhide = false;
+	Block = NULL;
+	frameBuffer = NULL;
+	palette = NULL;
+	frameBuffer = CFrameBuffer::getInstance();
+
+	Block = new unsigned char [_dx * _dy];
+
+	// create a new palette for the window
+	// bpp = 2, palette size 4
+	// bpp = 4, palette size 16
+	// bpp = 8, palette size 256
+	palette = new unsigned char [1 << bpp];
+
+	for ( int i = 0 ; i < (1 << bpp) ; i++ )
+		palette[i] = i;
+}
+
+CFBWindow::~CFBWindow( void )
+{
+	if ( Block != NULL )
+	{
+		if ( frameBuffer != NULL )
+			{
+				frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+				frameBuffer = NULL;
+			}
+		delete Block;
+		Block = NULL;
+	}
+	if ( palette != NULL )
+		{
+			delete palette;
+			palette = NULL;
+		}
+}
+
+void CFBWindow::ShowHide( bool sh )
+{
+	if ( !sh && showhide )
+		if ( frameBuffer != NULL )
+			frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+	showhide = sh;
+
+}
+
+void CFBWindow::Show()
+{
+	if ( showhide )
+		if ( ( Block != NULL ) && (frameBuffer != NULL ) )
+			frameBuffer->RestoreScreen( x, y, dx, dy, Block );
+}
+
+void CFBWindow::MoveWindow( int nx, int ny )
+{
+	if ( ( nx != x ) || ( ny != y ) )
+		{
+			if ( frameBuffer != NULL )
+				frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+			x = nx;
+			y = ny;
+		}
+	if ( showhide ) Show();
+}
+
+void CFBWindow::paletteSetColor( int nr, int acol )
+{
+	if ( palette != NULL )
+		palette[nr] = acol;
+}
+
+void CFBWindow::paletteSet()
+{
+	if ( Block != NULL )
+		{
+			unsigned char colfill = 0;
+			if ( palette != NULL )
+				colfill = ( palette[0] == 0 ) ? 0 : 1;
+			memset( Block, colfill, dx * dy );
+		}
+}
+
+int CFBWindow::SetBlock( osd_cmd_t *dc )
+{
+	if ( Block != NULL )
+		{
+       			uint w, h;
+
+		        w = dc->x1 - dc->x0 + 1; h = dc->y1 - dc->y0 + 1;
+        		if ( dc->color <= 0 )
+                		dc->color = w;
+        		if ( w <= 0 || w > 720 || h <= 0 || h > 576 )
+                		return -1;  // out of range...
+
+			unsigned char *pin = (unsigned char *) dc->data;
+			unsigned char *pout = Block != NULL ? Block : NULL;
+
+			//far from perfect ;) but it works...
+
+			for ( int _y = 0; _y < h; _y++ )
+			{
+				for ( int _x = 0; _x < w; _x++ )
+					{
+						pout[( _x + dc->x0 ) + dx* ( _y + dc->y0 )] = palette[( (unsigned char *) dc->data ) [_y * dc->color + _x]];
+					}
+			}
+			if ( showhide ) ShowBlock( dc, w, h );
+		}
+}
+
+void CFBWindow::ShowBlock( osd_cmd_t *dc, uint w, uint h )
+{
+	if ( frameBuffer == NULL ) return;
+
+	unsigned int stride = frameBuffer != NULL ? frameBuffer->getStride() : 0;
+	unsigned char *fbpos = frameBuffer->getFrameBufferPointer() + x + dc->x0 + stride * ( y + dc->y0 );
+	unsigned char *pin = Block + dc->x0 + dx * dc->y0;
+
+	for ( int i = 0; i < h ; i++ )
+		{
+			memcpy( fbpos, pin, w - 1 );
+			fbpos += stride;
+			pin += dx;
+		}
+}
+
+//=========================================================================0
+
+cFBOsd::cFBOsd()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	// setup framebuffer - from neutrino src
+
+	frameBuffer->init();
+	if ( frameBuffer->setMode( 720, 576, 8 ) )
+		{
+			esyslog("Error while setting framebuffer mode");
+			exit( -1 );
+		}
+
+	// set the framebuffer palette with the colours of vdr
+
+	frameBuffer->ClearFrameBuffer();
+
+	/*frameBuffer->paletteSetColor(0,0x00000000,0xffff);
+	frameBuffer->paletteSetColor(1,0x7F000000,0x7fff);
+	frameBuffer->paletteSetColor(2,0xFF000000,0);
+	frameBuffer->paletteSetColor(3,0xFF1414FC,0);
+	frameBuffer->paletteSetColor(4,0xFF24FC24,0);
+	frameBuffer->paletteSetColor(5,0xFF24C0FC,0);
+	frameBuffer->paletteSetColor(6,0xFFFC00B0,0);
+	frameBuffer->paletteSetColor(7,0xFFFC0000,0);
+	frameBuffer->paletteSetColor(8,0xFFFCFC00,0);
+	frameBuffer->paletteSetColor(9,0xFFFCFCFC,0);
+	frameBuffer->paletteSet();*/
+}
+
+cFBOsd::~cFBOsd()
+{
+	if ( frameBuffer != NULL )
+		{
+			for(int x=0;x<256;x++)
+				frameBuffer->paletteSetColor(x, 0x000000, 0xffff);
+			frameBuffer->paletteSet();
+
+			delete frameBuffer;
+		}
+
+	for ( int i = 0 ; i <= MAXNUMWINDOWS; i++ )
+		if ( win[i] ) delete win[i];
+}
+
+cFBOsd *cFBOsd::getInstance()
+{
+	if ( !mpFBOsd )
+		{
+			mpFBOsd = new cFBOsd();
+		}
+	return mpFBOsd;
+}
+
+void cFBOsd::Cmd( osd_cmd_t *dc )
+{
+	switch ( dc->cmd )
+		{
+			case OSD_Close:
+				//closes window "whandle"
+				if ( win[whandle] != NULL )
+					delete win[whandle];
+				win[whandle] = NULL;
+				return;
+			case OSD_Open:
+				// create a new window without showing it
+				win[whandle] = new CFBWindow (dc->x0, dc->y0, dc->x1, dc->y1, dc->color );
+				return;
+			case OSD_Show:
+				// set Show
+				if ( win[whandle] != NULL )
+					win[whandle]->ShowHide( true );
+				return;
+			case OSD_Hide:
+				// set Hide
+				if ( win[whandle] != NULL )
+					win[whandle]->ShowHide( false );
+				return;
+			case OSD_SetPalette:
+				// convert vdr cWindow palette to CFBWindow palette
+				int len;
+				len = dc->x0 - dc->color + 1;
+				__u32 *colors;
+				int acol;
+				colors = ( __u32 * ) dc->data;
+				for ( int i = 0; i<len; i++ )
+					{
+						switch ( colors[i] )
+							{
+								case 0x00000000:
+									acol = 0;
+									break;
+								case 0x0000007F:
+								case 0x7F000000:
+									acol = 1;
+									break;
+								case 0x000000FF:
+								case 0xFF000000:
+									acol = 2;
+									break;
+								case 0xFC1414FF:
+								case 0xFF1414FC:
+									acol = 3;
+									break;
+								case 0x24FC24FF:
+								case 0xFF24FC24:
+									acol = 4;
+									break;
+								case 0xFCC024FF:
+								case 0xFF24C0FC:
+									acol = 5;
+									break;
+								case 0xB000FCFF:
+								case 0xFFFC00B0:
+									acol = 6;
+									break;
+								case 0x0000FCFF:
+								case 0xFFFC0000:
+									acol = 7;
+									break;
+								case 0x00FCFCFF:
+								case 0xFFFCFC00:
+									acol = 8;
+									break;
+								case 0xFCFCFCFF:
+								case 0xFFFCFCFC:
+									acol = 9;
+									break;
+							}
+						if ( win[whandle] != NULL )
+							win[whandle]->paletteSetColor( i, acol );
+					}
+				if ( win[whandle] != NULL )
+					win[whandle]->paletteSet();
+				return;
+			case OSD_MoveWindow:
+				// Move OSD window to new position and show it
+				if ( win[whandle] != NULL )
+					win[whandle]->MoveWindow( dc->x0, dc->y0 );
+				return;
+			case OSD_SetBlock:
+				// fills CFBWindow Block with vdr cWindow data (dc->data)
+				// dc->x0,y0,x1,y1 are the coordinates where dc->data will be written inside Block
+				if ( win[whandle] != NULL )
+					win[whandle]->SetBlock( dc );
+				return;
+			case OSD_SetWindow:
+				if ( dc->x0 < 1 || dc->x0 > 7 ) return;
+				whandle = dc->x0;
+				return;
+			default:
+				return;
+		}
+};
+
+
+
+
diff -Naur vdr-1.2.0.orig/fbosd.h vdr-1.2.0/fbosd.h
--- vdr-1.2.0.orig/fbosd.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/fbosd.h	2003-06-02 15:08:16.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ * fbosd.h
+ *
+ * (C) 2003 Alexander Olk <xenomorph2@onlinehome.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __FBOSD_H
+#define __FBOSD_H
+
+#include <linux/dvb/osd.h>
+#include "osdbase.h"
+#include "framebuffer.h"
+
+// CFBWindow class, taken from neutrino fbwindow source and modified a little bit :)
+class CFBWindow {
+
+ private:
+	int bpp; 				// bits per pixel, needed for palette
+	unsigned char *palette;	// holds the palette for the window
+						// global framebuffer palette is set in cFBOsd class
+	bool showhide;			// show or hide the window...
+	unsigned char *Block;		// holds data being sent from osd/osdbase
+	CFrameBuffer *frameBuffer;
+
+ public:
+	int x, y;   /* upper left corner */
+	int dx, dy; /* dimension         */
+
+	CFBWindow( const int _x, const int _y, const int _dx, const int _dy, int ibpp );
+	~CFBWindow();
+
+	// set showhide
+	void ShowHide( bool sh );
+	// moves window to a new position and shows it
+	void MoveWindow( int nx, int ny );
+	// fill Block with data from vdr cWindow
+	// dc has x0,y0,x1,y1 positions where dc->data should be put in Block
+	int SetBlock( osd_cmd_t *dc );
+	// set entry nr in window palette to colour acol
+	void paletteSetColor( int nr, int acol );
+	// fills Block with background colour according to first palette entry
+	// if palette[0]=1, background will be clrBackground (50%gray), else clrTransparent
+	void paletteSet();
+
+ private:
+ 	// writes (restores) contents of Block to framebuffer, called from MoveWindow
+ 	void Show();
+	// special for SetBlock, paints only updated area...
+	void ShowBlock( osd_cmd_t *dc, uint w, uint h );
+};
+
+// singleton...
+class cFBOsd {
+public:
+	cFBOsd();
+	~cFBOsd();
+
+	static cFBOsd* mpFBOsd;
+	static cFBOsd *getInstance();
+	// Cmd replaces ioctl of a real hardware driver
+	void Cmd( osd_cmd_t *dc );
+private:
+	CFrameBuffer		*frameBuffer;
+	int whandle; // handle which window ??
+	CFBWindow *win[MAXNUMWINDOWS];
+};
+
+
+#endif
+
+
diff -Naur vdr-1.2.0.orig/framebuffer.c vdr-1.2.0/framebuffer.c
--- vdr-1.2.0.orig/framebuffer.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/framebuffer.c	2003-06-02 11:46:03.000000000 +0200
@@ -0,0 +1,414 @@
+/*
+	Neutrino-GUI  -   DBoxII-Project
+
+	Copyright (C) 2001 Steffen Hehn 'McClean'
+                      2003 thegoodguy
+		      changes for vdr Alexander Olk
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <memory.h>
+
+#include <linux/kd.h>
+
+#include <stdint.h>
+#include <dbox/fb.h>
+#include "tools.h"
+
+#include "framebuffer.h"
+
+#define BACKGROUNDIMAGEWIDTH 720
+
+#define COL_BACKGROUND 		255
+
+static uint8_t * virtual_fb = NULL;
+
+CFrameBuffer::CFrameBuffer()
+: active ( true )
+{
+	available  = 0;
+	cmap.start = 0;
+	cmap.len = 256;
+	cmap.red = red;
+	cmap.green = green;
+	cmap.blue  = blue;
+	cmap.transp = trans;
+	backgroundColor = 0;
+	fd  = 0;
+	tty = 0;
+}
+
+CFrameBuffer* CFrameBuffer::getInstance()
+{
+	static CFrameBuffer* frameBuffer = NULL;
+
+	if(!frameBuffer)
+		{
+			frameBuffer = new CFrameBuffer();
+			isyslog("frameBuffer Instance created");
+		}
+	return frameBuffer;
+}
+
+void CFrameBuffer::init(std::string fbDevice)
+{
+	fd=open(fbDevice.c_str(), O_RDWR);
+	if (fd<0)
+	{
+		perror(fbDevice.c_str());
+		goto nolfb;
+	}
+
+	if (ioctl(fd, FBIOGET_VSCREENINFO, &screeninfo)<0)
+	{
+		perror("FBIOGET_VSCREENINFO");
+		goto nolfb;
+	}
+
+	memcpy(&oldscreen, &screeninfo, sizeof(screeninfo));
+
+	fb_fix_screeninfo fix;
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &fix)<0)
+	{
+		perror("FBIOGET_FSCREENINFO");
+		goto nolfb;
+	}
+
+	available=fix.smem_len;
+	isyslog("%dk video mem\n", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fd, 0);
+
+	if (!lfb)
+	{
+		perror("mmap");
+		goto nolfb;
+	}
+
+	if ((tty=open("/dev/vc/0", O_RDWR))<0)
+	{
+		perror("open (tty)");
+		goto nolfb;
+	}
+
+	struct sigaction act;
+
+	memset(&act,0,sizeof(act));
+	act.sa_handler  = switch_signal;
+	sigemptyset(&act.sa_mask);
+	sigaction(SIGUSR1,&act,NULL);
+	sigaction(SIGUSR2,&act,NULL);
+
+	struct vt_mode mode;
+
+	if (-1 == ioctl(tty,KDGETMODE, &kd_mode)) {
+		perror("ioctl KDGETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,VT_GETMODE, &vt_mode)) {
+      		perror("ioctl VT_GETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,VT_GETMODE, &mode)) {
+      		perror("ioctl VT_GETMODE");
+		goto nolfb;
+	}
+
+	mode.mode   = VT_PROCESS;
+	mode.waitv  = 0;
+	mode.relsig = SIGUSR1;
+	mode.acqsig = SIGUSR2;
+
+	if (-1 == ioctl(tty,VT_SETMODE, &mode)) {
+		perror("ioctl VT_SETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,KDSETMODE, KD_GRAPHICS)) {
+		perror("ioctl KDSETMODE");
+		goto nolfb;
+	}
+
+	return;
+
+nolfb:
+	esyslog("framebuffer not available.\n");
+	lfb=0;
+}
+
+
+CFrameBuffer::~CFrameBuffer()
+{
+#ifdef RETURN_FROM_GRAPHICS_MODE
+	if (-1 == ioctl(tty,KDSETMODE, kd_mode))
+		perror("ioctl KDSETMODE");
+#endif
+
+	if (-1 == ioctl(tty,VT_SETMODE, &vt_mode))
+		perror("ioctl VT_SETMODE");
+
+	/*
+	if (available)
+		ioctl(fd, FBIOPUT_VSCREENINFO, &oldscreen);
+	if (lfb)
+		munmap(lfb, available);
+		*/
+
+	if (virtual_fb == NULL)
+		delete[] virtual_fb;
+}
+
+int CFrameBuffer::getFileHandle()
+{
+	return fd;
+}
+
+unsigned int CFrameBuffer::getStride()
+{
+	return stride;
+}
+
+unsigned char* CFrameBuffer::getFrameBufferPointer()
+{
+	if (active || (virtual_fb == NULL))
+		return lfb;
+	else
+		return virtual_fb;
+}
+
+bool CFrameBuffer::getActive()
+{
+	return (active || (virtual_fb != NULL));
+}
+
+t_fb_var_screeninfo *CFrameBuffer::getScreenInfo()
+{
+	return &screeninfo;
+}
+
+int CFrameBuffer::setMode(unsigned int nxRes, unsigned int nyRes, unsigned int nbpp)
+{
+	if (!available&&!active)
+		return -1;
+
+	screeninfo.xres_virtual=screeninfo.xres=nxRes;
+	screeninfo.yres_virtual=screeninfo.yres=nyRes;
+	screeninfo.bits_per_pixel=nbpp;
+
+	if (ioctl(fd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
+	{
+		perror("FBIOPUT_VSCREENINFO");
+		return -1;
+	}
+
+	if ((screeninfo.xres!=nxRes) && (screeninfo.yres!=nyRes) && (screeninfo.bits_per_pixel!=nbpp))
+	{
+		esyslog("SetMode failed: wanted: %dx%dx%d, got %dx%dx%d\n",
+		       nxRes, nyRes, nbpp,
+		       screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
+		return -1;
+	}
+
+	xRes = screeninfo.xres;
+	yRes = screeninfo.yres;
+	bpp  = screeninfo.bits_per_pixel;
+	fb_fix_screeninfo fix;
+
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &fix)<0)
+	{
+		perror("FBIOGET_FSCREENINFO");
+		return -1;
+	}
+
+	stride=fix.line_length;
+	memset(getFrameBufferPointer(), 0, stride*yRes);
+	return 0;
+}
+
+
+void CFrameBuffer::paletteFade(int i, __u32 rgb1, __u32 rgb2, int level)
+{
+	__u16 *r = cmap.red+i;
+	__u16 *g = cmap.green+i;
+	__u16 *b = cmap.blue+i;
+	*r= ((rgb2&0xFF0000)>>16)*level;
+	*g= ((rgb2&0x00FF00)>>8 )*level;
+	*b= ((rgb2&0x0000FF)    )*level;
+	*r+=((rgb1&0xFF0000)>>16)*(255-level);
+	*g+=((rgb1&0x00FF00)>>8 )*(255-level);
+	*b+=((rgb1&0x0000FF)    )*(255-level);
+}
+
+void CFrameBuffer::setTransparency( int tr )
+{
+	if (!active)
+		return;
+
+	if (tr> 8)
+		tr= 8;
+
+	int val = (tr << 8) | tr;
+	if (ioctl(fd, AVIA_GT_GV_SET_BLEV, val ))
+		perror("AVIA_GT_GV_SET_BLEV");
+}
+
+void CFrameBuffer::setAlphaFade(int in, int num, int tr)
+{
+	for (int i=0; i<num; i++)
+	{
+		cmap.transp[in+i]=tr;
+		//tr++;
+	}
+}
+
+void CFrameBuffer::paletteGenFade(int in, __u32 rgb1, __u32 rgb2, int num, int tr)
+{
+	for (int i=0; i<num; i++)
+	{
+		paletteFade(in+i, rgb1, rgb2, i*(255/(num-1)));
+		cmap.transp[in+i]=tr;
+		tr++;
+	}
+}
+
+void CFrameBuffer::paletteSetColor(int i, __u32 rgb, int tr)
+{
+	cmap.red[i]    =(rgb&0xFF0000)>>8;
+	cmap.green[i]  =(rgb&0x00FF00)   ;
+	cmap.blue[i]   =(rgb&0x0000FF)<<8;
+	cmap.transp[i] =tr;
+}
+
+void CFrameBuffer::paletteSet(struct fb_cmap *map)
+{
+	if (!active)
+		return;
+	
+	if(map == NULL)
+		map = &cmap;
+
+	ioctl(fd, FBIOPUTCMAP, map);
+}
+
+
+void CFrameBuffer::paintBoxRel(int x, int y, int dx, int dy, unsigned char col)
+{
+	if (!getActive())
+		return;
+
+	unsigned char* pos = getFrameBufferPointer() + x + stride*y;
+	for(int count=0;count<dy;count++)
+	{
+		memset(pos, col, dx);
+		pos += stride;
+	}
+}
+
+void CFrameBuffer::setBackgroundColor(int color)
+{
+	backgroundColor = color;
+}
+
+void CFrameBuffer::paintBackgroundBoxRel(int x, int y, int dx, int dy)
+{
+	if (!getActive())
+		return;
+	paintBoxRel(x, y, dx, dy, backgroundColor);
+}
+
+void CFrameBuffer::RestoreScreen(int x, int y, int dx, int dy, unsigned char* memp)
+{
+	if (!getActive())
+		return;
+
+	unsigned char *fbpos = getFrameBufferPointer() + x + stride*y;
+	unsigned char *bkpos = memp;
+	for(int count=0;count<dy;count++)
+	{
+		memcpy(fbpos, bkpos, dx);
+		fbpos += stride;
+		bkpos += dx;
+	}
+}
+
+void CFrameBuffer::switch_signal (int signal)
+{
+	CFrameBuffer * thiz = CFrameBuffer::getInstance();
+	if (signal == SIGUSR1) {
+		if (virtual_fb == NULL)
+			delete[] virtual_fb;
+		virtual_fb = new uint8_t[thiz->stride * thiz->yRes];
+		thiz->active = false;
+		if (virtual_fb != NULL)
+			memcpy(virtual_fb, thiz->lfb, thiz->stride * thiz->yRes);
+		ioctl(thiz->tty, VT_RELDISP, 1);
+		isyslog ("release display\n");
+	}
+	else if (signal == SIGUSR2) {
+		ioctl(thiz->tty, VT_RELDISP, VT_ACKACQ);
+		thiz->active = true;
+		isyslog ("acquire display\n");
+		thiz->paletteSet(NULL);
+		if (virtual_fb != NULL)
+			memcpy(thiz->lfb, virtual_fb, thiz->stride * thiz->yRes);
+		else
+			memset(thiz->lfb, 0, thiz->stride*thiz->yRes);
+	}
+}
+
+void CFrameBuffer::ClearFrameBuffer()
+{
+	setBackgroundColor(COL_BACKGROUND);
+
+	//background
+	paletteSetColor(COL_BACKGROUND, 0x000000, 0xffff);
+
+	// vdr colors
+	paletteSetColor(0,0x00000000,0xffff);
+	paletteSetColor(1,0x7F000000,0x7fff);
+	paletteSetColor(2,0xFF000000,0);
+	paletteSetColor(3,0xFF1414FC,0);
+	paletteSetColor(4,0xFF24FC24,0);
+	paletteSetColor(5,0xFF24C0FC,0);
+	paletteSetColor(6,0xFFFC00B0,0);
+	paletteSetColor(7,0xFFFC0000,0);
+	paletteSetColor(8,0xFFFCFC00,0);
+	paletteSetColor(9,0xFFFCFCFC,0);
+
+	paletteSetColor(10, 0x000000, 0);
+	paletteSetColor(11, 0x000000, 0);
+	paletteSetColor(12, 0x000000, 0);
+	paletteSetColor(13, 0x000000, 0);
+	paletteSetColor(14, 0x000000, 0);
+	paletteSetColor(15, 0x000000, 0);
+	paletteSetColor(16, 0x000000, 0);
+
+	paletteSet();
+}
diff -Naur vdr-1.2.0.orig/framebuffer.h vdr-1.2.0/framebuffer.h
--- vdr-1.2.0.orig/framebuffer.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/framebuffer.h	2003-06-02 11:35:09.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+	Neutrino-GUI  -   DBoxII-Project
+
+	Copyright (C) 2001 Steffen Hehn 'McClean'
+	Homepage: http://dbox.cyberphoria.org/
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#ifndef __framebuffer__
+#define __framebuffer__
+
+
+#include <linux/fb.h>
+#include <linux/vt.h>
+
+#include <stdint.h>
+#include <string>
+
+typedef struct fb_var_screeninfo t_fb_var_screeninfo;
+
+/** Ausführung als Singleton */
+class CFrameBuffer
+{
+	private:
+
+		CFrameBuffer();
+
+		struct rgbData
+		{
+			uint8_t r;
+			uint8_t g;
+			uint8_t b;
+		} __attribute__ ((packed));
+
+		struct rawHeader
+		{
+			uint8_t width_lo;
+			uint8_t width_hi;
+			uint8_t height_lo;
+			uint8_t height_hi;
+			uint8_t transp;
+		} __attribute__ ((packed));
+
+		int             fd, tty;
+		unsigned char * lfb;
+		int		available;
+		int             backgroundColor;
+		unsigned int	xRes, yRes, stride, bpp;
+		t_fb_var_screeninfo screeninfo, oldscreen;
+		fb_cmap cmap;
+		__u16 red[256], green[256], blue[256], trans[256];
+
+		void paletteFade(int i, __u32 rgb1, __u32 rgb2, int level);
+
+		int 	kd_mode;
+		struct	vt_mode vt_mode;
+		bool	active;
+		static	void switch_signal (int);
+
+	public:
+
+		~CFrameBuffer();
+
+		static CFrameBuffer* getInstance();
+
+		void init(std::string fbDevice="/dev/fb/0");
+		int setMode(unsigned int xRes, unsigned int yRes, unsigned int bpp);
+
+
+		int getFileHandle(); //only used for plugins (games) !!
+		t_fb_var_screeninfo *getScreenInfo();
+
+		unsigned char* getFrameBufferPointer(); //pointer to framebuffer
+		unsigned int getStride(); //stride (anzahl bytes die eine Zeile im Framebuffer belegt)
+		bool getActive(); //is framebuffer active
+
+		void setTransparency( int tr = 0 );
+
+		//Palette stuff
+		void setAlphaFade(int in, int num, int tr);
+		void paletteGenFade(int in, __u32 rgb1, __u32 rgb2, int num, int tr=0);
+		void paletteSetColor(int i, __u32 rgb, int tr);
+		void paletteSet(struct fb_cmap *map = NULL);
+
+		void paintBoxRel(int x, int y, int dx, int dy, unsigned char col);
+
+		int getBackgroundColor() { return backgroundColor;}
+		void setBackgroundColor(int color);
+		void paintBackgroundBoxRel(int x, int y, int dx, int dy);
+
+		void RestoreScreen(int x, int y, int dx, int dy, unsigned char* memp);
+
+		void ClearFrameBuffer();
+
+};
+
+
+#endif
diff -Naur vdr-1.2.0.orig/Makefile vdr-1.2.0/Makefile
--- vdr-1.2.0.orig/Makefile	2003-01-06 13:28:09.000000000 +0100
+++ vdr-1.2.0/Makefile	2003-06-01 16:23:34.000000000 +0200
@@ -14,33 +14,34 @@
 CXX      ?= g++
 CXXFLAGS ?= -g -O2 -Wall -Woverloaded-virtual
 
-DVBDIR   = ../DVB
 DTVDIR   = ./libdtv
-MANDIR   = /usr/local/man
-BINDIR   = /usr/local/bin
 
 PLUGINDIR= ./PLUGINS
 
-VIDEODIR = /video
 
 DOXYGEN  = /usr/bin/doxygen
 DOXYFILE = Doxyfile
 
 -include Make.config
 
-INCLUDES = -I$(DVBDIR)/include
+INCLUDES = -I$(DVBDIR)/include -I$(DRIVERDIR)/include
 
 DTVLIB   = $(DTVDIR)/libdtv.a
 
+#NDLIB = $(APPSDIR)/tuxbox/neutrino/src/driver/libneutrino_driver.a
+
 OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbosd.o\
        dvbplayer.o dvbspu.o eit.o eitscan.o font.o i18n.o interface.o keys.o\
        lirc.o menu.o menuitems.o osdbase.o osd.o player.o plugin.o rcu.o\
        receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sources.o\
-       spu.o status.o svdrp.o thread.o timers.o tools.o transfer.o vdr.o videodir.o
+       spu.o status.o svdrp.o thread.o timers.o tools.o transfer.o vdr.o videodir.o fbosd.o\
+       framebuffer.o
 
 OSDFONT = -adobe-helvetica-medium-r-normal--23-*-100-100-p-*-iso8859-1
 FIXFONT = -adobe-courier-bold-r-normal--25-*-100-100-m-*-iso8859-1
 
+NO_KBD = 1
+
 ifndef NO_KBD
 DEFINES += -DREMOTE_KBD
 endif
@@ -108,7 +109,8 @@
 # Plugins:
 
 plugins: include-dir
-	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" all; done
+	@rm -f $(PLUGINDIR)/src/dbox2/libvdr-dbox2.so
+	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" PPREFIX=$(PREFIX) DDIR=$(DRIVERDIR) all; done
 
 plugins-clean:
 	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" clean; done
@@ -124,6 +126,11 @@
             mkdir $(VIDEODIR);\
             cp *.conf $(VIDEODIR);\
             fi
+	@if [ ! -d $(PLUGINIDIR) ]; then\
+		 mkdir -p $(PLUGINIDIR);\
+		 fi
+	cp $(PLUGINDIR)/lib/libvdr-remote.so.* $(PLUGINIDIR)
+	cp $(PLUGINDIR)/lib/libvdr-dbox2.so* $(PLUGINIDIR);
 
 # Source documentation:
 
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/ccam.c vdr-1.2.0/PLUGINS/src/dbox2/ccam.c
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/ccam.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/ccam.c	2003-06-02 15:01:58.000000000 +0200
@@ -0,0 +1,170 @@
+/*
+ * ccam.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include "ccam.h"
+#include <vdr/channels.h>
+#include <vdr/eit.h>
+#include <vdr/ci.h>
+#include <connection/basicclient.h>
+#include <vdr/tools.h>
+
+#define CAMD_UDS_NAME  "/tmp/camd.socket"
+
+class CCaPmt : public CBasicClient {
+	private:
+		int 		length;
+		int 		esInfoLengthPos;
+		uint8_t 	capmt[2048];
+	protected:
+		virtual const unsigned char   	getVersion   () const { return 0x9F; };
+		virtual const          char * 		getSocketName() const { return CAMD_UDS_NAME; };
+	public:
+		CCaPmt( int ProgramNumber );
+		void 		AddPid( int Pid );
+		void 		AddCaDescriptor( int Length, uint8_t *Data );
+		bool 		sendData();
+
+};
+
+#define CPCI_OK_DESCRAMBLING  	0x01
+#define CPLM_ONLY				0x03
+#define CPLM_TS				0x04
+
+CCaPmt::CCaPmt( int ProgramNumber )
+{
+	length = 0;
+  	capmt[length++] = CPLM_ONLY; // FIXME: Do we need Transponderchange -> 0x04
+  	capmt[length++] = ( ProgramNumber >> 8 ) & 0xFF;
+  	capmt[length++] =  ProgramNumber       & 0xFF;
+  	capmt[length++] = 0x01; // version_number, current_next_indicator - apparently vn doesn't matter, but cni must be 1
+  	esInfoLengthPos = length;
+  	capmt[length++] = 0x00; // program_info_length H (at program level)
+  	capmt[length++] = 0x00; // program_info_length L
+}
+
+void CCaPmt::AddPid( int Pid )
+{
+  	capmt[length++] = 0x00; //XXX stream_type (apparently doesn't matter)
+  	capmt[length++] = ( Pid >> 8 ) & 0xFF;
+  	capmt[length++] =  Pid       & 0xFF;
+  	esInfoLengthPos = length;
+  	capmt[length++] = 0x00; // ES_info_length H (at ES level)
+  	capmt[length++] = 0x00; // ES_info_length L
+}
+
+void CCaPmt::AddCaDescriptor( int Length, uint8_t *Data )
+{
+  	if ( esInfoLengthPos )
+		{
+     			if ( length + Length < int ( sizeof( capmt ) ) )
+				{
+        				capmt[length++] = CPCI_OK_DESCRAMBLING;
+        				memcpy( capmt + length, Data, Length );
+        				length += Length;
+        				int l = length - esInfoLengthPos - 2;
+        				capmt[esInfoLengthPos]     = ( l >> 8 ) & 0xFF;
+        				capmt[esInfoLengthPos + 1] =  l       & 0xFF;
+        			}
+     			else
+        			esyslog( "ERROR: buffer overflow in CA descriptor" );
+
+     			esInfoLengthPos = 0;
+     		}
+  	else
+     		esyslog( "ERROR: adding CA descriptor without Pid!" );
+}
+
+#define SIZE_INDICATOR 0x80
+
+static uint8_t *SetLength( uint8_t *Data, int Length )
+{
+  	uint8_t *p = Data;
+  	if ( Length < 128 )
+     		*p++ = Length;
+  	else
+		{
+     			int n = sizeof( Length );
+     			for ( int i = n - 1; i >= 0; i-- )
+				{
+         				int b = ( Length >> ( 8 * i ) ) & 0xFF;
+         				if ( p != Data || b )
+            				*++p = b;
+         			}
+     			*Data = ( p - Data ) | SIZE_INDICATOR;
+     			p++;
+     		}
+  return p;
+}
+
+bool CCaPmt::sendData()
+{
+	if ( !open_connection() )
+		return false;
+	uint8_t buffer[2048];
+	uint8_t *p = buffer;
+	*p++ = 0x9F;
+	*p++ = 0x80;
+  	*p++ = 0x32;
+
+	p = SetLength( p,length );
+
+	if ( p - buffer + length < int ( sizeof( buffer ) ) )
+		{
+			memcpy( p, capmt, length );
+			p += length;
+		}
+	bool return_value = send_data( (const char*)buffer, p-buffer );
+
+	close_connection();
+	return return_value;
+}
+
+
+CCam::CCam(void)
+{
+ 	channel=NULL;
+}
+
+void CCam::setCaPmt(cChannel *channel)
+{
+	uchar buffer[2048];
+	unsigned short CaSystemlds[3] = { 5890, 5922, 5986 }; // FIXME... need to get ids another way
+	int length = 0;
+	int count = 0;
+
+	// we need this...
+	// vdr needs some time to filter the ca descriptors
+	// the routine tries MAXCACOUNT times (my Nokia Sat box needs about 50-70 tries)
+	// FIXME: if you switch to a Premiere channel, you do not have subsribed, switching takes to long,
+	// because the routine then tries MAXCACOUNT times
+	#define MAXCACOUNT	100
+	#define TIMETOWAIT	10000
+	do
+		{
+			count++;
+			usleep( TIMETOWAIT );
+			length = cSIProcessor::GetCaDescriptors( channel->Source(), channel->Frequency(), channel->Sid(), CaSystemlds, sizeof( buffer ), buffer );
+		} while ( ( length == 0 ) && ( count<MAXCACOUNT ) );
+
+	if ( length > 0 )
+		{
+			CCaPmt CaPmt( channel->Sid() );
+			CaPmt.AddCaDescriptor( length, buffer );
+			if ( channel->Vpid() )
+				CaPmt.AddPid( channel->Vpid() );
+			if ( channel->Apid1() )
+				CaPmt.AddPid( channel->Apid1() );
+			if ( channel->Apid2() )
+				CaPmt.AddPid( channel->Apid2() );
+			if ( channel->Dpid1() )
+				CaPmt.AddPid( channel->Dpid1() );
+			CaPmt.sendData();
+		}
+}
+
+
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/ccam.h vdr-1.2.0/PLUGINS/src/dbox2/ccam.h
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/ccam.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/ccam.h	2003-06-02 15:02:28.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * ccam.h: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#ifndef _CCAM_H_
+#define _CCAM_H_
+
+#include <vdr/channels.h>
+
+#define CAMD_UDS_NAME  "/tmp/camd.socket"
+
+class CCam {
+	public:
+		CCam( void );
+		void 		setCaPmt( cChannel *inchannel );
+
+	private:
+		cChannel 	*channel;
+};
+
+#endif
+
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/COPYING vdr-1.2.0/PLUGINS/src/dbox2/COPYING
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/COPYING	2003-05-16 21:01:33.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/dbox2.c vdr-1.2.0/PLUGINS/src/dbox2/dbox2.c
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/dbox2.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/dbox2.c	2003-06-02 15:05:42.000000000 +0200
@@ -0,0 +1,136 @@
+/*
+ * dbox2.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include <vdr/plugin.h>
+#include <vdr/status.h>
+#include <vdr/channels.h>
+#include "ccam.h"
+#include "lcddisplay.h"
+
+static const char *VERSION        = "0.0.1";
+static const char *DESCRIPTION    = "DBox2 handling";
+static const char *MAINMENUENTRY  = "Dbox2";
+
+// cMyStatusMonitor..
+
+class cMyStatusMonitor : public cStatus {
+	public:
+		cMyStatusMonitor( CCam *incam );
+	private:
+		CCam 		*cam;
+		cChannel		*channel;
+	protected:
+  		virtual void 	ChannelSwitch( const cDevice *Device, int ChannelNumber );
+  };
+
+cMyStatusMonitor::cMyStatusMonitor( CCam *incam )
+{
+	cam = incam;
+}
+
+void cMyStatusMonitor::ChannelSwitch( const cDevice *Device, int ChannelNumber )
+{
+	// ChannelNumber=0 before Channel is switched... >0 channel that has beend switched to
+  if ( ChannelNumber )
+  	{
+		channel = NULL;
+		channel = Channels.GetByNumber( ChannelNumber );
+		if ( channel != NULL )
+			if ( channel->Ca() == 101 )  // 101 = Premiere
+				{
+					cam->setCaPmt( channel );
+				}
+
+		// show service name on lcd display
+		cLcdDisplay::getInstance()->ShowServiceName( channel->Name() );
+	}
+}
+
+
+class cPluginDbox2 : public cPlugin {
+private:
+  // Add any member variables or functions you may need here.
+  cMyStatusMonitor 	*statusMonitor;
+  CCam 			*cam;
+public:
+  cPluginDbox2( void );
+  virtual ~cPluginDbox2();
+  virtual const char *Version( void ) { return VERSION; }
+  virtual const char *Description( void ) { return DESCRIPTION; }
+  virtual const char *CommandLineHelp( void );
+  virtual bool ProcessArgs( int argc, char *argv[] );
+  virtual bool Start( void );
+  virtual void Housekeeping( void );
+  virtual const char *MainMenuEntry( void ) { return MAINMENUENTRY; }
+  virtual cOsdObject *MainMenuAction( void );
+  virtual cMenuSetupPage *SetupMenu( void );
+  virtual bool SetupParse( const char *Name, const char *Value );
+  };
+
+cPluginDbox2::cPluginDbox2( void )
+{
+  // Initialize any member variables here.
+  // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
+  // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
+  statusMonitor = NULL;
+  cam = NULL;
+}
+
+cPluginDbox2::~cPluginDbox2()
+{
+  // Clean up after yourself!
+  cLcdDisplay::getInstance()->ShowServiceName( "Goodbye" );
+  delete statusMonitor;
+  delete cam;
+}
+
+const char *cPluginDbox2::CommandLineHelp( void )
+{
+  // Return a string that describes all known command line options.
+  return NULL;
+}
+
+bool cPluginDbox2::ProcessArgs( int argc, char *argv[] )
+{
+  // Implement command line argument processing here if applicable.
+  return true;
+}
+
+bool cPluginDbox2::Start( void )
+{
+  // Start any background activities the plugin shall perform.
+  cam = new CCam();
+  statusMonitor = new cMyStatusMonitor( cam );
+  cLcdDisplay::getInstance();
+  return true;
+}
+
+void cPluginDbox2::Housekeeping( void )
+{
+  // Perform any cleanup or other regular tasks.
+}
+
+cOsdObject *cPluginDbox2::MainMenuAction( void )
+{
+  // Perform the action when selected from the main VDR menu.
+  return NULL;
+}
+
+cMenuSetupPage *cPluginDbox2::SetupMenu( void )
+{
+  // Return a setup menu in case the plugin supports one.
+  return NULL;
+}
+
+bool cPluginDbox2::SetupParse( const char *Name, const char *Value )
+{
+  // Parse your own setup parameters and store their values.
+  return false;
+}
+
+VDRPLUGINCREATOR( cPluginDbox2 ); // Don't touch this!
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/HISTORY vdr-1.2.0/PLUGINS/src/dbox2/HISTORY
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/HISTORY	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/HISTORY	2003-05-30 19:49:55.000000000 +0200
@@ -0,0 +1,6 @@
+VDR Plugin 'dbox2' Revision History
+------------------------------------
+
+2003-05-16: Version 0.0.1
+
+- Initial revision.
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/lcddisplay.c vdr-1.2.0/PLUGINS/src/dbox2/lcddisplay.c
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/lcddisplay.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/lcddisplay.c	2003-06-02 14:51:30.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+ * lcddisplay.h: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+ // this is only the first attempt for accessing the dbox lcd display... it uses the lcddisplay library and the fonts implemented
+ // in vdr (to be honest, those fonts are a little bit to big :) but for the first implementation it works)
+ // TODO: 	- if channelname is to long and there is a <space> in the channel name, start new line
+ //		- new method for center messages
+ //		- and a lot of other changes.
+
+#include "lcddisplay.h"
+#include <vdr/tools.h>
+#include <vdr/font.h>
+
+cLcdDisplay *cLcdDisplay::mpLcdDisplay = NULL;
+
+cLcdDisplay *cLcdDisplay::getInstance( void )
+{
+	if ( mpLcdDisplay == NULL )
+		{
+			mpLcdDisplay = new cLcdDisplay();
+		}
+	return mpLcdDisplay;
+}
+
+cLcdDisplay::cLcdDisplay( void )
+{
+	if ( !lcd.isAvailable() )
+		{
+			esyslog( "No lcd support\n" );
+		}
+
+	pFont = NULL;
+	pFont = new cFont( fontOsd );
+
+	ShowServiceName( "vdr" );
+}
+
+cLcdDisplay::~cLcdDisplay( void )
+{
+	delete pFont;
+}
+
+void cLcdDisplay::ShowServiceName( const char *name )
+{
+	lcd.draw_fill_rect( 2, 2, LCD_COLS, 54, CLCDDisplay::PIXEL_OFF );
+
+	int x = 2;
+	int y = 2;
+
+	for ( const char *p = name; *p; p++ )
+		{
+			const cFont::tCharData *cd = pFont->CharData( *p );
+
+			for ( int row = 0; row < pFont->Height( *p ); row++ )
+				{
+					cFont::tPixelData PixelData = cd->lines[row];
+					for ( int col = cd->width; col-- > 0; )
+						{
+							lcd.draw_point( x + col, y + row, ( PixelData & 1 ) ? CLCDDisplay::PIXEL_ON : CLCDDisplay::PIXEL_OFF );
+							PixelData >>= 1;
+						}
+				}
+			x += pFont->Width( *p );
+			if ( x > LCD_COLS )
+				{
+					x = 2;
+					y += pFont->Height( *p );
+					if ( y > 40 ) break;
+				}
+		}
+
+	lcd.update();
+}
+
+
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/lcddisplay.h vdr-1.2.0/PLUGINS/src/dbox2/lcddisplay.h
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/lcddisplay.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/lcddisplay.h	2003-06-02 15:06:11.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ * lcddisplay.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#ifndef __LCDDISPLAY_H__
+#define __LCDDISPLAY_H_
+
+#include <lcddisplay/lcddisplay.h>
+#include <vdr/font.h>
+
+class cLcdDisplay {
+
+	private:
+
+		CLCDDisplay	lcd;
+		cFont		*pFont;
+
+ 	public:
+
+		static cLcdDisplay 		*getInstance( void );
+		static cLcdDisplay 		*mpLcdDisplay;
+		cLcdDisplay( void );
+		~cLcdDisplay( void );
+
+		void ShowServiceName( const char *name );
+};
+
+#endif
+
+
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/Makefile vdr-1.2.0/PLUGINS/src/dbox2/Makefile
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/Makefile	2003-06-01 18:08:45.000000000 +0200
@@ -0,0 +1,85 @@
+#
+# Makefile for a Video Disk Recorder plugin
+#
+# $Id$
+
+# The official name of this plugin.
+# This name will be used in the '-P...' option of VDR to load the plugin.
+# By default the main source file also carries this name.
+#
+PLUGIN = dbox2
+
+LCDLIB = -L$(PPREFIX)/cdkroot/lib -llcddisplay -lfreetype
+CONLIB = $(PPREFIX)/cdkroot/lib/libtuxbox-connection.a
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+### The C++ compiler and options:
+
+CXX      = powerpc-tuxbox-linux-gnu-g++
+CXXFLAGS ?=  -msoft-float -mmultiple -mstring -meabi -O3 -g
+
+### The directory environment:
+
+DVBDIR = ../../../../DVB
+VDRDIR = ../../..
+LIBDIR = ../../lib
+TMPDIR = /tmp
+
+### Allow user defined options to overwrite defaults:
+
+-include $(VDRDIR)/Make.config
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include -I$(PPREFIX)/cdkroot/include/tuxbox -I$(DDIR)/include
+
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+
+### The object files (add further files here):
+
+OBJS = $(PLUGIN).o ccam.o lcddisplay.o
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
+
+# Dependencies:
+
+MAKEDEP = g++ -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+### Targets:
+
+all: libvdr-$(PLUGIN).so
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LCDLIB) $(CONLIB) -o $@
+	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
+
+dist: clean
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Naur vdr-1.2.0.orig/PLUGINS/src/dbox2/README vdr-1.2.0/PLUGINS/src/dbox2/README
--- vdr-1.2.0.orig/PLUGINS/src/dbox2/README	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/dbox2/README	2003-05-30 19:47:01.000000000 +0200
@@ -0,0 +1,11 @@
+This is a "plugin" for the Video Disk Recorder (VDR).
+
+Written by:                  Alexander Olk <xenomorph2l@onlinehome.de>
+
+Project's homepage:          -n/a-
+
+Latest version available at: -n/a-
+
+See the file COPYING for license information.
+
+Description: Dbox2 plugin
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/COPYING vdr-1.2.0/PLUGINS/src/remote/COPYING
--- vdr-1.2.0.orig/PLUGINS/src/remote/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/COPYING	2002-10-11 00:31:25.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/FAQ vdr-1.2.0/PLUGINS/src/remote/FAQ
--- vdr-1.2.0.orig/PLUGINS/src/remote/FAQ	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/FAQ	2003-03-31 01:11:22.000000000 +0200
@@ -0,0 +1,111 @@
+Remote Control Mini-FAQ (En, 2003-03-31)
+========================================
+
+Q: Which hardware is supported?
+A: Configurations which have been reported to work:
+
+type          connector         ir protocol
+-------------------------------------------
+Activy 300                      RCMM
+DVB-S 1.3[1]  J2                RC5
+DVB-S 1.5[1]  ???               ???
+DVB-S 1.6[1]  CI module         RC5
+DVB-S 2.1     ir connector      RC5
+DVB-S 2.2     ir connector      RC5
+
+[1] Probably DVB-S board revisions 1.3/1.5/1.6 work with:
+- J2 connector (if no CI module has been connected)
+- ir receiver connected to the CI module
+
+Please report if you have a working configuration not listed here. Thx.
+
+------------------------------------------------------------------------------
+
+Q: What is the expected behavior of evtest?
+A: You should see something like this:
+
+./evtest /dev/input/event0
+Input driver version is 1.0.0
+Input device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0
+Input device name: "DVB on-card IR receiver"
+Supported events:
+  Event type 1 (Key)
+    Event code 2 (1)
+    Event code 3 (2)
+    Event code 4 (3)
+    Event code 5 (4)
+    Event code 6 (5)
+    Event code 7 (6)
+    Event code 8 (7)
+    Event code 9 (8)
+    Event code 10 (9)
+    Event code 11 (0)
+    Event code 113 (Mute)
+    Event code 114 (VolumeDown)
+    Event code 115 (VolumeUp)
+    Event code 154 (CycleWindows)
+    Event code 353 (Select)
+    Event code 360 (Vendor)
+    Event code 375 (Screen)
+    Event code 377 (TV)
+    Event code 385 (Radio)
+    Event code 402 (ChannelUp)
+    Event code 403 (ChannelDown)
+Testing ... (interrupt to exit)
+Event: time 1047342384.790038, type 1 (Key), code 402 (ChannelUp), value 1
+Event: time 1047342385.290630, type 1 (Key), code 402 (ChannelUp), value 0
+
+'DVB on-card IR receiver' indicates that you are using the correct device.
+'Event:' lines are the result of pressing the 'Up' key on the remote control.
+
+------------------------------------------------------------------------------
+
+Q: evtest does not show any events.
+A: Try this checklist:
+
+0. compile everything:
+   cd DVB/driver
+   make
+   makedev.napi
+   cd DVB/apps/av7110_loadkeys
+   make
+
+1. load the driver
+   cd DVB/driver
+   make insmod
+
+2. load the keymap [see note below]
+   cd DVB/apps/av7110_loadkeys
+   ./av7110_loadkeys hauppauge.rc5 > /proc/av7110_ir
+
+3. run evtest
+   ./evtest /dev/input/event0
+
+If this does not work, try
+   ./evtest /dev/input/event1
+   ./evtest /dev/input/event2
+   ./evtest /dev/input/event3
+   ...
+
+One of these should work. (If your device is not '/dev/input/event0', 
+you have to specify this device with the '-i' command line option of
+the remote control plugin.)
+
+Note:
+   The keymap above works for the RC5 remote of a DVB-S Nexus 2.1 card.
+   For RCMM receivers, use a .rcmm keymap, i.e. 'activy.rcmm'.
+   If unsure, you might also try
+   ./av7110_loadkeys -i hauppauge.rc5 > /proc/av7110_ir
+   ./av7110_loadkeys activy.rcmm > /proc/av7110_ir
+   ./av7110_loadkeys -i activy.rcmm > /proc/av7110_ir
+
+------------------------------------------------------------------------------
+
+Q: It still doesn't work. Any other idea?
+A: Verify that the plug of the remote control receiver is connected properly.
+   :)
+
+------------------------------------------------------------------------------
+
+Q: How do I have to modify 'runvdr' to load the keymap?
+A: Take a look at the script 'runvdr.remote' in sub-directory 'misc'.
\ Kein Zeilenumbruch am Dateiende.
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/HISTORY vdr-1.2.0/PLUGINS/src/remote/HISTORY
--- vdr-1.2.0.orig/PLUGINS/src/remote/HISTORY	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/HISTORY	2003-03-30 23:16:55.000000000 +0200
@@ -0,0 +1,13 @@
+VDR Plugin 'remote' Revision History
+------------------------------------
+
+2002-10-14: Version 0.0.1
+
+- Initial revision.
+
+
+2002-03-31: Version 0.1.0
+
+- Support autorepeat on /dev/input/eventX with following API-3 drivers:
+  o DVB HEAD (2003-03-31 and later)
+  o dvb kernel (2003-03-31 and later)
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/Makefile vdr-1.2.0/PLUGINS/src/remote/Makefile
--- vdr-1.2.0.orig/PLUGINS/src/remote/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/Makefile	2003-05-12 17:07:22.000000000 +0200
@@ -0,0 +1,85 @@
+#
+# Makefile for a Video Disk Recorder plugin
+#
+# $Id$
+
+# The official name of this plugin.
+# This name will be used in the '-P...' option of VDR to load the plugin.
+# By default the main source file also carries this name.
+#
+PLUGIN = remote
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+### The directory environment:
+
+ifdef NEWSTRUCT
+DVBDIR = ../../../../DVB/include
+DEFINES += -DNEWSTRUCT
+else
+DVBDIR = ../../../../DVB/ost/include
+endif
+VDRDIR = ../../..
+VDRINC = $(VDRDIR)/include
+LIBDIR = ../../lib
+TMPDIR = /tmp
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+### Includes and Defines (add further entries here):
+
+INCLUDES = -I$(VDRINC) -I$(DVBDIR)
+
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+
+### The object files (add further files here):
+
+OBJS = $(PLUGIN).o
+
+### The C++ compiler and options:
+
+CXX      = powerpc-tuxbox-linux-gnu-g++
+#CXXFLAGS = -O3 -Wall -Woverloaded-virtual -msoft-float
+CXXFLAGS = -msoft-float -mmultiple -mstring -meabi -O3 -g -DREMOTE_ -D_GNU_SOURCE
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+### Targets:
+
+all: libvdr-$(PLUGIN).so
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
+
+dist: clean
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/README vdr-1.2.0/PLUGINS/src/remote/README
--- vdr-1.2.0.orig/PLUGINS/src/remote/README	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/README	2003-03-30 23:03:13.000000000 +0200
@@ -0,0 +1,113 @@
+remote - a remote control plugin for the Video Disk Recorder (VDR)
+==================================================================
+
+Written by:                   Oliver Endriss <o.endriss@gmx.de>
+
+Latest version available at:  http://endriss.escape.bei.t-online.de/vdr
+
+Requirements:                 VDR 1.1.13 or later
+
+Distributed under GPL, see the file COPYING for license information.
+
+
+Description:
+------------
+This plugin supports the built-in remote control port of the DVB-S Rev. 2.1/2.2
+(and the J2 or CAM connectors of some other boards, see file FAQ).
+It is primarily intended for use with the new DVB driver (NEWSTRUCT and later,
+i.e. API versions 2 and 3), but may be used with the old driver, too.
+
+When the plugin is loaded for the first time, vdr will prompt you to learn
+the keys of the remote control. It is possible to use several devices at the
+same time, but this is not very important right now...
+
+Supported kernel devices:
+- new DVB driver (API-2, API-3): /dev/input/eventX
+- old DVB driver (API-1): /dev/lirc
+- keyboard: /dev/console, /dev/ttyX
+
+
+Installation:
+-------------
+The remote plugin is installed as usual:
+- cd VDR/PLUGINS/src
+- tar xfz vdr-remote-0.1.0.tgz
+- ln -s remote-0.1.0 remote
+- cd ../..
+- make plugins
+
+
+API-3 driver (version 1.0.0, CVS HEAD, CVS dvb-kernel) 
+------------------------------------------------------
+Remote control events are passed through '/device/input/eventX'.
+Since the /dev/input protocol is standardized in the kernel, there is a
+chance that this plugin will work with other /dev/input devices, too.
+However, this has not been tested yet...
+The -i option allows you to specify the name of the /dev/input device.
+
+Before submitting a bug report, please verify that driver and remote control
+are working properly. You may do this using the 'evtest' tool supplied
+with the driver (directory 'DVB/apps/av7110_loadkeys').
+Verify that the device node exists and you have read access rights.
+You have to select the correct remote control type, inversion setting and
+keymap using the tool 'av7110_loadkeys'. Please read the file README in
+the directory 'DVB/apps/av7110_loadkeys'.
+If you still have problems, take a look on the checklist in file 'FAQ'.
+
+If you'd like to use autorepeat, you have to use CVS HEAD, CVS dvb-kernel
+2003-03-31 or later (or the next 1.0.0 release, of course).
+The feature is automatically detected and used.
+
+BTW, these drivers might also be useful, if the remote control of your
+TV set interferes with the remote control of your DVB-S. See the file
+'DVB/apps/av7110_loadkeys/README' for information how to enable 
+checking of the device address.
+
+
+API-2 (CVS NEWSTRUCT)
+---------------------
+Since the NEWSTRUCT branch is obsolete, there is no reason to use this
+driver anymore. See API-3 above.
+
+
+API-1 (old driver, version 0.9.4)
+---------------------------------
+The old DVB driver provides a module (DVB/driver/lirc/lirc_dvb.o) which
+connects to the LIRC device ('/dev/lirc', lirc_dev.o).
+Using the -l option, it is possible to use '/dev/lirc' as a direct input
+device, i.e. lircd is *not* needed. However, the lirc_dev.o driver
+supplied by the LIRC package is still required (and must be loaded).
+If you use this option, you should know what you are doing. :-)
+
+
+TTY devices
+-----------
+The -t option may be used to specify a virtual console as an input device.
+This is useful, if you haven't compiled keyboard support into your VDR.
+
+
+Summary of command line options:
+--------------------------------
+-i dev, --input dev   select device which supports the /dev/input protocol
+-l dev, --lirc dev    select device which uses the /dev/lirc protocol
+-t dev, --tty dev     select terminal device
+
+
+Examples:
+---------
+vdr -Premote
+    use default device, same as '-i /dev/input/event0'
+
+vdr -P"remote -i /dev/input/event2"
+    use specified input device '/dev/input/event2'
+
+vdr -P"remote -l /dev/lirc"
+    use lirc kernel device
+
+vdr -P"remote -i /dev/input/event0 -i /dev/input/event2 -t /dev/tty10"
+    use multiple devices
+
+
+Have fun,
+
+Oliver
diff -Naur vdr-1.2.0.orig/PLUGINS/src/remote/remote.c vdr-1.2.0/PLUGINS/src/remote/remote.c
--- vdr-1.2.0.orig/PLUGINS/src/remote/remote.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.2.0/PLUGINS/src/remote/remote.c	2003-03-30 07:05:45.000000000 +0200
@@ -0,0 +1,411 @@
+/*
+ * remote.c: Remote Control plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include <vdr/plugin.h>
+#include <vdr/remote.h>
+#include <vdr/thread.h>
+#include <stdio.h>
+#include <sys/fcntl.h>
+#include <getopt.h>
+#include <termios.h>
+#include <linux/input.h>
+
+#define NUMREMOTES      5         // maximum number of remote control devices
+
+static const char *VERSION        = "0.1.0";
+static const char *DESCRIPTION    = "Remote control";
+
+//#define DEBUG
+
+#ifdef DEBUG
+#define DSYSLOG(x...)    dsyslog(x)
+#else
+#define DSYSLOG(x...)
+#endif
+
+//------------------------------------------------------------------------------
+
+class cRemoteGeneric : protected cRemote, protected cThread
+{
+protected:
+  static const uint64 INVALID_KEY = (uint64) -1;
+  int fh;
+  char *device;
+  int polldelay;
+  int repeatdelay;
+  int repeatfreq;
+  int repeattimeout;
+  cRemoteGeneric(const char *name, int f, char *d);
+  virtual ~cRemoteGeneric();
+  virtual uint64 getKey(void) = 0;
+  virtual bool keyPressed(uint64 code) = 0;
+  virtual void Action(void);
+};
+
+cRemoteGeneric::cRemoteGeneric(const char *name, int f, char *d)
+:cRemote(name)
+{
+    fh = f;
+    device = d;
+    polldelay     = 40;   // ms
+    repeatdelay   = 350;  // ms
+    repeatfreq    = 100;  // ms
+    repeattimeout = 500;  // ms
+}
+
+cRemoteGeneric::~cRemoteGeneric()
+{
+    Cancel();
+}
+
+void cRemoteGeneric::Action(void)
+{
+    int now, first = 0, last = 0;
+    uint64 code, lastcode = INVALID_KEY;
+    bool repeat = false;
+
+    for (;;)
+    {
+        if (polldelay)
+            delay_ms(polldelay);
+
+        code = getKey();
+        if (code == INVALID_KEY)
+        {
+            esyslog("error reading '%s'\n", device);
+            delay_ms(100*polldelay);
+            continue;
+        }
+
+        now = time_ms();
+
+        if (keyPressed(code))
+        {
+            // key down
+            if (now - last > repeattimeout)
+            {
+                if (repeat)
+                {
+                    Put(lastcode,false,true);
+                    DSYSLOG("%s: timeout %016llx\n", device, code);
+                    repeat = false;
+                }
+                lastcode = INVALID_KEY;
+            }
+
+            if (code != lastcode)
+            {
+                Put(code);
+                DSYSLOG("%s: press %016llx\n", device, code);
+                lastcode = code;
+                last = first = now;
+                repeat = false;
+            }
+            else
+            {
+                if (now - first < repeatdelay || now - last < repeatfreq)
+                    continue;
+                Put(code,true);
+                DSYSLOG("%s: repeat %016llx\n", device, code);
+                last = now;
+                repeat = true;
+            }
+        }
+        else
+        {
+            // key up
+            if (repeat)
+            {
+                Put(lastcode,false,true);
+                DSYSLOG("%s: release %016llx\n", device, lastcode);
+                repeat = false;
+            }
+            lastcode = INVALID_KEY;
+        }
+    }/* for */
+}
+
+//------------------------------------------------------------------------------
+
+class cRemoteDevInput : protected cRemoteGeneric
+{
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevInput(const char *name, int f, char *d);
+};
+
+cRemoteDevInput::cRemoteDevInput(const char *name, int f, char *d)
+:cRemoteGeneric(name, f, d)
+{
+    unsigned long data[EV_MAX];
+ 
+    Start();
+
+    memset (data, 0, sizeof data);
+    ioctl(f, EVIOCGBIT(0,EV_MAX), data); 
+
+#define BITS_PER_LONG	(sizeof(unsigned long) * 8)
+
+    if ( data[EV_REP/BITS_PER_LONG] & (1 << EV_REP%BITS_PER_LONG) )
+    {
+        // autorepeat driver
+        DSYSLOG("%s: supports autorepeat!", d);
+        polldelay = 0;
+    }
+    else
+    {
+        // non-autorepeat drivers
+        polldelay = repeatdelay = repeatfreq = repeattimeout = 0;
+    }
+}
+
+uint64 cRemoteDevInput::getKey(void)
+{
+    struct input_event ev;
+    int n;
+    uint64 code;
+
+    n = read(fh, &ev, sizeof ev);
+    if (n == sizeof ev)
+    {
+        if (ev.value)
+            ev.value = 1;
+        code = ((uint64)ev.value << 32) | ((uint64)ev.type << 16) | (uint64)ev.code;
+    }
+    else
+        code = INVALID_KEY;
+    return code;
+}
+
+bool cRemoteDevInput::keyPressed(uint64 code)
+{
+    return (code & 0xFFFF00000000ULL);
+}
+
+//------------------------------------------------------------------------------
+
+class cRemoteDevLirc : protected cRemoteGeneric
+{
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevLirc(const char *name, int f, char *d)
+  :cRemoteGeneric(name, f, d) { Start(); }
+};
+
+uint64 cRemoteDevLirc::getKey(void)
+{
+    unsigned long code;
+    int n;
+
+    n = read(fh, &code, sizeof code);
+    if (n != sizeof code)
+        return INVALID_KEY;
+    else
+        return (uint64)code;
+}
+
+bool cRemoteDevLirc::keyPressed(uint64 code)
+{
+    return (code & 0x80);
+}
+
+//------------------------------------------------------------------------------
+
+class cRemoteDevTty : protected cRemoteGeneric
+{
+private:
+  struct termios tm;
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevTty(const char *name, int f, char *d);
+  virtual ~cRemoteDevTty(); 
+};
+
+cRemoteDevTty::cRemoteDevTty(const char *name, int f, char *d)
+:cRemoteGeneric(name, f, d)
+{
+    struct termios t;
+
+    if (!tcgetattr(f, &tm))
+    {
+        t = tm;   
+        t.c_lflag &= ~(ICANON | ECHO);
+        tcsetattr(f, TCSANOW, &t);
+    }
+    polldelay     = 0;
+    repeattimeout = 80;
+    Start();
+}
+
+cRemoteDevTty::~cRemoteDevTty()
+{
+    tcsetattr(fh, TCSANOW, &tm);
+}
+
+uint64 cRemoteDevTty::getKey(void)
+{
+    int n;
+    uint64 code = 0;
+
+    n = read(fh, &code, sizeof code);
+    return (n > 0) ? code : INVALID_KEY;
+}
+
+bool cRemoteDevTty::keyPressed(uint64 code)
+{
+    return true;
+}
+
+//------------------------------------------------------------------------------
+
+class cPluginRemote : public cPlugin
+{
+private:
+  int  devcnt;
+  char devtyp[NUMREMOTES];
+  char *devnam[NUMREMOTES];
+  int  fh[NUMREMOTES];
+public:
+  cPluginRemote(void);
+  virtual ~cPluginRemote();
+  virtual const char *Version(void) { return VERSION; }
+  virtual const char *Description(void) { return DESCRIPTION; }
+  virtual const char *CommandLineHelp(void);
+  virtual bool ProcessArgs(int argc, char *argv[]);
+  virtual bool Start(void);
+};
+
+cPluginRemote::cPluginRemote(void)
+{
+    for (int i = 0; i < NUMREMOTES; i++)
+    {
+        devtyp[i] = '\0';
+        devnam[i] = NULL;
+        fh[i] = -1;
+    }
+    devcnt = 0;
+}
+
+cPluginRemote::~cPluginRemote()
+{
+    // must not delete any remotes, see PLUGINS.html!
+
+    for (int i = 0; i < devcnt; i++)
+    {
+        if (fh[i] >= 0)
+            close(fh[i]);
+        fh[i] = -1;
+    }
+    devcnt = 0;
+}
+
+const char *cPluginRemote::CommandLineHelp(void)
+{
+    return "  -i dev,   --input=dev    kernel input device (/dev/input/...)\n"
+           "  -l dev,   --lirc=dev     kernel lirc device (/dev/lirc)\n"
+           "  -t dev,   --tty=dev      tty device\n";
+}
+
+bool cPluginRemote::ProcessArgs(int argc, char *argv[])
+{
+    static struct option long_options[] =
+            { { "input", required_argument, NULL, 'i' },
+              { "lirc",  required_argument, NULL, 'l' },
+              { "tty",   required_argument, NULL, 't' },
+              { NULL } };
+    int c;
+
+    while ((c = getopt_long(argc, argv, "i:l:t:", long_options, NULL)) != -1)
+    {
+        switch (c)
+        {
+          case 'i':
+          case 'l':
+          case 't':
+              if (devcnt >= NUMREMOTES)
+              {
+                  esyslog("%s: too many remotes", Name());
+                  return false;
+              }
+              devtyp[devcnt] = c;
+              devnam[devcnt] = optarg;
+	      devcnt++;
+              break;
+
+          default:
+              esyslog("%s: invalid argument", Name());
+              return false;
+        }
+    }
+
+    return true;
+}
+
+bool cPluginRemote::Start(void)
+{
+    char nam[25];
+    bool ok = false;
+
+    // defaults
+    if (devcnt == 0)
+    {
+        devtyp[0] = 'i';
+        devnam[0] = "/dev/input/event0";
+        devcnt = 1;
+    }
+
+    for (int i = 0; i < devcnt; i++)
+    {
+        fh[i] = open(devnam[i], O_RDONLY);
+        if (fh[i] < 0)
+        {
+            esyslog("%s: unable to open '%s'", Name(), devnam[i]);
+            continue;
+        }
+	
+        // at least, one device opened successfully
+        ok = true;
+        dsyslog("%s: using '%s'", Name(), devnam[i]);
+
+        // build name for remote.conf
+        char *cp = strrchr(devnam[i], '/');
+	if (cp)
+            sprintf (nam, "%s-%s", Name(), cp+1);
+        else
+            sprintf (nam, "%s-%u", Name(), i);
+
+	switch (devtyp[i])
+        {
+            case 'i':
+                new cRemoteDevInput(nam,fh[i],devnam[i]);
+                break;
+
+            case 'l':
+                new cRemoteDevLirc(nam,fh[i],devnam[i]);
+                break;
+
+            case 't':
+                new cRemoteDevTty(nam,fh[i],devnam[i]);
+                break;
+        }
+    }
+    
+    if (!ok)
+        esyslog("%s: fatal error - unable to open input device", Name());
+    return ok;
+}
+
+//------------------------------------------------------------------------------
+
+VDRPLUGINCREATOR(cPluginRemote); // Don't touch this!
