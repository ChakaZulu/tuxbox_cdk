diff -Nur vdr-1.2.6.orig/Makefile vdr-1.2.6/Makefile
--- vdr-1.2.6.orig/Makefile	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/Makefile	2004-02-17 16:52:52.000000000 +0100
@@ -14,10 +14,7 @@
 CXX      ?= g++
 CXXFLAGS ?= -g -O2 -Wall -Woverloaded-virtual
 
-DVBDIR   = ../DVB
 DTVDIR   = ./libdtv
-MANDIR   = /usr/local/man
-BINDIR   = /usr/local/bin
 
 PLUGINDIR= ./PLUGINS
 PLUGINLIBDIR= $(PLUGINDIR)/lib
@@ -29,19 +26,24 @@
 
 -include Make.config
 
-INCLUDES = -I$(DVBDIR)/include
+INCLUDES = -I$(DVBDIR)/include -I$(DRIVERDIR)/include
 
 DTVLIB   = $(DTVDIR)/libdtv.a
 
+#NDLIB = $(APPSDIR)/tuxbox/neutrino/src/driver/libneutrino_driver.a
+
 OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbosd.o\
        dvbplayer.o dvbspu.o eit.o eitscan.o font.o i18n.o interface.o keys.o\
        lirc.o menu.o menuitems.o osdbase.o osd.o player.o plugin.o rcu.o\
        receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sources.o\
-       spu.o status.o svdrp.o thread.o timers.o tools.o transfer.o vdr.o videodir.o
+       spu.o status.o svdrp.o thread.o timers.o tools.o transfer.o vdr.o videodir.o \
+       fbosd.o framebuffer.o
 
 OSDFONT = -adobe-helvetica-medium-r-normal--23-*-100-100-p-*-iso8859-1
 FIXFONT = -adobe-courier-bold-r-normal--25-*-100-100-m-*-iso8859-1
 
+NO_KBD=1
+
 ifndef NO_KBD
 DEFINES += -DREMOTE_KBD
 endif
@@ -112,7 +114,8 @@
 # Plugins:
 
 plugins: include-dir
-	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" all; done
+	@rm -f $(PLUGINDIR)/src/dbox2/libvdr-dbox2.so
+	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" PPREFIX=$(PREFIX) DDIR=$(DRIVERDIR) all; done
 
 plugins-clean:
 	@for i in `ls $(PLUGINDIR)/src | grep -v '[^a-z0-9]'`; do $(MAKE) -C "$(PLUGINDIR)/src/$$i" clean; done
@@ -128,6 +131,10 @@
             mkdir $(VIDEODIR);\
             cp *.conf $(VIDEODIR);\
             fi
+	@if [ ! -d $(PLUGINIDIR) ]; then\
+		 mkdir -p $(PLUGINIDIR);\
+		 fi
+	cp $(PLUGINDIR)/lib/libvdr* $(PLUGINIDIR)
 
 # Source documentation:
 
@@ -147,4 +154,3 @@
 fontclean:
 	-rm -f fontfix.c fontosd.c
 CLEAN: clean fontclean
-
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/COPYING vdr-1.2.6/PLUGINS/src/dbox2/COPYING
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/COPYING	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/COPYING	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/HISTORY vdr-1.2.6/PLUGINS/src/dbox2/HISTORY
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/HISTORY	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/HISTORY	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,6 @@
+VDR Plugin 'dbox2' Revision History
+------------------------------------
+
+2003-05-16: Version 0.0.1
+
+- Initial revision.
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/Makefile vdr-1.2.6/PLUGINS/src/dbox2/Makefile
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/Makefile	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/Makefile	2004-02-11 15:24:09.000000000 +0100
@@ -0,0 +1,85 @@
+#
+# Makefile for a Video Disk Recorder plugin
+#
+# $Id$
+
+# The official name of this plugin.
+# This name will be used in the '-P...' option of VDR to load the plugin.
+# By default the main source file also carries this name.
+#
+PLUGIN = dbox2
+
+LCDLIB = -L$(PPREFIX)/cdkroot/lib -llcddisplay -lfreetype
+CONLIB = $(PPREFIX)/cdkroot/lib/libtuxbox-connection.a
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+### The C++ compiler and options:
+
+CXX      = powerpc-tuxbox-linux-gnu-g++
+CXXFLAGS ?= -mcpu=823  -msoft-float -mmultiple -mstring -meabi -O3 -g -D_GNU_SOURCE
+
+### The directory environment:
+
+DVBDIR = ../../../../DVB
+VDRDIR = ../../..
+LIBDIR = ../../lib
+TMPDIR = /tmp
+
+### Allow user defined options to overwrite defaults:
+
+-include $(VDRDIR)/Make.config
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(PPREFIX)/cdkroot/include/tuxbox -I$(DDIR)/include -I$(DDIR)/dvb/include
+
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"' -DPREFIX='"$(PPREFIX)"'
+
+### The object files (add further files here):
+
+OBJS = $(PLUGIN).o ccam.o lcddisplay.o plugins.o 
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+### Targets:
+
+all: libvdr-$(PLUGIN).so
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LCDLIB) $(CONLIB) -lpng -lz -o $@
+	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
+
+dist: clean
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/README vdr-1.2.6/PLUGINS/src/dbox2/README
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/README	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/README	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,11 @@
+This is a "plugin" for the Video Disk Recorder (VDR).
+
+Written by:                  Alexander Olk <xenomorph2l@onlinehome.de>
+
+Project's homepage:          -n/a-
+
+Latest version available at: -n/a-
+
+See the file COPYING for license information.
+
+Description: Dbox2 plugin
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/ccam.c vdr-1.2.6/PLUGINS/src/dbox2/ccam.c
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/ccam.c	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/ccam.c	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,172 @@
+/*
+ * ccam.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include "ccam.h"
+#include <vdr/channels.h>
+#include <vdr/eit.h>
+#include <vdr/ci.h>
+#include <connection/basicclient.h>
+#include <vdr/tools.h>
+
+#define CAMD_UDS_NAME  "/tmp/camd.socket"
+
+class CCaPmt : public CBasicClient 
+{
+	private:
+		int 		length;
+		int 		esInfoLengthPos;
+		uint8_t 	capmt[2048];
+	protected:
+		virtual const unsigned char   	getVersion   () const { return 0x9F; };
+		virtual const          char * 		getSocketName() const { return CAMD_UDS_NAME; };
+	public:
+		CCaPmt( int ProgramNumber );
+		void 		AddPid( int Pid );
+		void 		AddCaDescriptor( int Length, uint8_t *Data );
+		bool 		sendData();
+
+};
+
+#define CPCI_OK_DESCRAMBLING  	0x01
+#define CPLM_ONLY				0x03
+#define CPLM_TS					0x04
+
+CCaPmt::CCaPmt( int ProgramNumber )
+{
+	length = 0;
+  	capmt[length++] = CPLM_ONLY; // FIXME: Do we need Transponderchange -> 0x04
+  	capmt[length++] = ( ProgramNumber >> 8 ) & 0xFF;
+  	capmt[length++] =  ProgramNumber & 0xFF;
+  	capmt[length++] = 0x01; // version_number, current_next_indicator - apparently vn doesn't matter, but cni must be 1
+  	esInfoLengthPos = length;
+  	capmt[length++] = 0x00; // program_info_length H (at program level)
+  	capmt[length++] = 0x00; // program_info_length L
+}
+
+void CCaPmt::AddPid( int Pid )
+{
+  	capmt[length++] = 0x00; //XXX stream_type (apparently doesn't matter)
+  	capmt[length++] = ( Pid >> 8 ) & 0xFF;
+  	capmt[length++] = Pid & 0xFF;
+  	esInfoLengthPos = length;
+  	capmt[length++] = 0x00; // ES_info_length H (at ES level)
+  	capmt[length++] = 0x00; // ES_info_length L
+}
+
+void CCaPmt::AddCaDescriptor( int Length, uint8_t *Data )
+{
+  	if ( esInfoLengthPos )
+		{
+     			if ( length + Length < int ( sizeof( capmt ) ) )
+					{
+        				capmt[length++] = CPCI_OK_DESCRAMBLING;
+        				memcpy( capmt + length, Data, Length );
+        				length += Length;
+        				int l = length - esInfoLengthPos - 2;
+        				capmt[esInfoLengthPos]     = ( l >> 8 ) & 0xFF;
+        				capmt[esInfoLengthPos + 1] =  l & 0xFF;
+        			}
+     			else
+        			esyslog( "ERROR: buffer overflow in CA descriptor" );
+
+     			esInfoLengthPos = 0;
+     		}
+  	else
+     		esyslog( "ERROR: adding CA descriptor without Pid!" );
+}
+
+#define SIZE_INDICATOR 0x80
+
+static uint8_t *SetLength( uint8_t *Data, int Length )
+{
+  	uint8_t *p = Data;
+	
+  	if ( Length < 128 )
+		*p++ = Length;
+  	else
+		{
+     			int n = sizeof( Length );
+     			for ( int i = n - 1; i >= 0; i-- )
+					{
+         				int b = ( Length >> ( 8 * i ) ) & 0xFF;
+         				if ( p != Data || b )
+            				*++p = b;
+         			}
+     			*Data = ( p - Data ) | SIZE_INDICATOR;
+     			p++;
+     		}
+  return p;
+}
+
+bool CCaPmt::sendData()
+{
+	if ( !open_connection() )
+		return false;
+	
+	uint8_t buffer[2048];
+	uint8_t *p = buffer;
+	
+	*p++ = 0x9F;
+	*p++ = 0x80;
+  	*p++ = 0x32;
+
+	p = SetLength( p,length );
+
+	if ( p - buffer + length < int ( sizeof( buffer ) ) )
+		{
+			memcpy( p, capmt, length );
+			p += length;
+		}
+	bool return_value = send_data( (const char*)buffer, p-buffer );
+
+	close_connection();
+	return return_value;
+}
+
+
+CCam::CCam(void)
+{
+ 	channel=NULL;
+}
+
+void CCam::setCaPmt(cChannel *channel)
+{
+	uchar buffer[2048];
+	int length = 0;
+	int count = 0;
+
+	// we need this...
+	// vdr needs some time to filter the ca descriptors
+	// the routine tries MAXCACOUNT times (my Nokia Sat box needs about 50-70 tries)
+	// FIXME: if you switch to a Premiere channel, you do not have subsribed, switching takes to long,
+	// because the routine then tries MAXCACOUNT times
+	// hmm, need to find a better way...
+	#define MAXCACOUNT	100
+	#define TIMETOWAIT	10000
+	do
+		{
+			count++;
+			usleep( TIMETOWAIT );
+			length = cSIProcessor::GetCaDescriptors( channel->Source(), channel->Frequency(), channel->Sid(), NULL, sizeof( buffer ), buffer );
+		} while ( ( length == 0 ) && ( count<MAXCACOUNT ) );
+
+	if ( length > 0 )
+		{
+			CCaPmt CaPmt( channel->Sid() );
+			CaPmt.AddCaDescriptor( length, buffer );
+			if ( channel->Vpid() )
+				CaPmt.AddPid( channel->Vpid() );
+			if ( channel->Apid1() )
+				CaPmt.AddPid( channel->Apid1() );
+			if ( channel->Apid2() )
+				CaPmt.AddPid( channel->Apid2() );
+			if ( channel->Dpid1() )
+				CaPmt.AddPid( channel->Dpid1() );
+			CaPmt.sendData();
+		}
+}
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/ccam.h vdr-1.2.6/PLUGINS/src/dbox2/ccam.h
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/ccam.h	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/ccam.h	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,26 @@
+/*
+ * ccam.h: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#ifndef _CCAM_H_
+#define _CCAM_H_
+
+#include <vdr/channels.h>
+
+#define CAMD_UDS_NAME  "/tmp/camd.socket"
+
+class CCam 
+{
+	public:
+		CCam( void );
+		void 		setCaPmt( cChannel *inchannel );
+
+	private:
+		cChannel 	*channel;
+};
+
+#endif
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/dbox2.c vdr-1.2.6/PLUGINS/src/dbox2/dbox2.c
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/dbox2.c	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/dbox2.c	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,147 @@
+/*
+ * dbox2.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include <vdr/plugin.h>
+#include <vdr/status.h>
+#include <vdr/channels.h>
+#include "ccam.h"
+#include "lcddisplay.h"
+#include "plugins.h"
+
+static const char *VERSION        = "0.0.1";
+static const char *DESCRIPTION    = "DBox2 handling";
+static const char *MAINMENUENTRY  = "DBox2";
+
+// cMyStatusMonitor..
+
+class cMyStatusMonitor : public cStatus 
+{
+	public:
+		cMyStatusMonitor( CCam *incam );
+	private:
+		CCam 			*cam;
+		cChannel		*channel;
+	protected:
+  		virtual void 	ChannelSwitch( const cDevice *Device, int ChannelNumber );
+  };
+
+cMyStatusMonitor::cMyStatusMonitor( CCam *incam )
+{
+	cam = incam;
+}
+
+void cMyStatusMonitor::ChannelSwitch( const cDevice *Device, int ChannelNumber )
+{
+	// ChannelNumber=0 before Channel is switched... >0 channel that has beend switched to
+	if ( ChannelNumber )
+  		{
+			channel = NULL;
+			channel = Channels.GetByNumber( ChannelNumber );
+			if ( channel != NULL )
+				if ( channel->Ca() == 101 )  // 101 = Premiere
+					{
+						cam->setCaPmt( channel );
+					}
+
+		// show service name on lcd display
+		cLcdDisplay::getInstance()->ShowServiceName( channel->Name() );
+	}
+}
+
+//--------------------------------------------------------
+
+class cPluginDbox2 : public cPlugin 
+{
+	private:
+  		// Add any member variables or functions you may need here.
+  		cMyStatusMonitor 	*statusMonitor;
+  		CCam 			*cam;
+	public:
+  		cPluginDbox2( void );
+  		virtual ~cPluginDbox2();
+  		virtual const char *Version( void ) { return VERSION; }
+  		virtual const char *Description( void ) { return DESCRIPTION; }
+  		virtual const char *CommandLineHelp( void );
+  		virtual bool ProcessArgs( int argc, char *argv[] );
+  		virtual bool Start( void );
+  		virtual void Housekeeping( void );
+  		virtual const char *MainMenuEntry( void ) { return MAINMENUENTRY; }
+  		virtual cOsdObject *MainMenuAction( void );
+  		virtual cMenuSetupPage *SetupMenu( void );
+  		virtual bool SetupParse( const char *Name, const char *Value );
+  		virtual void *GetSetData( int what );
+};
+
+cPluginDbox2::cPluginDbox2( void )
+{
+	// Initialize any member variables here.
+	// DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
+	// VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
+	statusMonitor = NULL;
+	cam = NULL;
+}
+
+cPluginDbox2::~cPluginDbox2()
+{
+	// Clean up after yourself!
+	cLcdDisplay::getInstance()->ShowServiceName( "Goodbye" );
+	delete statusMonitor;
+	delete cam;
+}
+
+const char *cPluginDbox2::CommandLineHelp( void )
+{
+	// Return a string that describes all known command line options.
+	return NULL;
+}
+
+bool cPluginDbox2::ProcessArgs( int argc, char *argv[] )
+{
+	// Implement command line argument processing here if applicable.
+	return true;
+}
+
+bool cPluginDbox2::Start( void )
+{
+  	// Start any background activities the plugin shall perform.
+  	cam = new CCam();
+  	statusMonitor = new cMyStatusMonitor( cam );
+  	cLcdDisplay::getInstance();
+  	return true;
+}
+
+void cPluginDbox2::Housekeeping( void )
+{
+	// Perform any cleanup or other regular tasks.
+}
+
+cOsdObject *cPluginDbox2::MainMenuAction( void )
+{
+  	// Perform the action when selected from the main VDR menu.
+  	cDbox2PluginMenu *db2pmenu = new cDbox2PluginMenu();
+	return db2pmenu;
+}
+
+cMenuSetupPage *cPluginDbox2::SetupMenu( void )
+{
+  	// Return a setup menu in case the plugin supports one.
+	return NULL;
+}
+
+bool cPluginDbox2::SetupParse( const char *Name, const char *Value )
+{
+  	// Parse your own setup parameters and store their values.
+	return false;
+}
+
+void *cPluginDbox2::GetSetData( int what )
+{
+	return NULL;
+}
+
+VDRPLUGINCREATOR( cPluginDbox2 ); // Don't touch this!
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/lcddisplay.c vdr-1.2.6/PLUGINS/src/dbox2/lcddisplay.c
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/lcddisplay.c	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/lcddisplay.c	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,80 @@
+/*
+ * lcddisplay.h: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+ // this is only the first attempt for accessing the dbox lcd display... it uses the lcddisplay library and the fonts implemented
+ // in vdr (to be honest, those fonts are a little bit to big :) but for the first implementation it works)
+ // TODO: 	- if channelname is to long and there is a <space> in the channel name, start new line
+ //		- new method for center messages
+ //		- and a lot of other changes.
+
+#include "lcddisplay.h"
+#include <vdr/tools.h>
+#include <vdr/font.h>
+
+cLcdDisplay *cLcdDisplay::mpLcdDisplay = NULL;
+
+cLcdDisplay *cLcdDisplay::getInstance( void )
+{
+	if ( mpLcdDisplay == NULL )
+		{
+			mpLcdDisplay = new cLcdDisplay();
+		}
+	return mpLcdDisplay;
+}
+
+cLcdDisplay::cLcdDisplay( void )
+{
+	if ( !lcd.isAvailable() )
+		{
+			esyslog( "No lcd support\n" );
+		}
+
+	pFont = NULL;
+	pFont = new cFont( fontOsd );
+
+	ShowServiceName( "vdr" );
+}
+
+cLcdDisplay::~cLcdDisplay( void )
+{
+	delete pFont;
+}
+
+void cLcdDisplay::ShowServiceName( const char *name )
+{
+	lcd.draw_fill_rect( 2, 2, LCD_COLS, 54, CLCDDisplay::PIXEL_OFF );
+
+	int x = 2;
+	int y = 2;
+
+	for ( const char *p = name; *p; p++ )
+		{
+			const cFont::tCharData *cd = pFont->CharData( *p );
+
+			for ( int row = 0; row < pFont->Height( *p ); row++ )
+				{
+					cFont::tPixelData PixelData = cd->lines[row];
+					for ( int col = cd->width; col-- > 0; )
+						{
+							lcd.draw_point( x + col, y + row, ( PixelData & 1 ) ? CLCDDisplay::PIXEL_ON : CLCDDisplay::PIXEL_OFF );
+							PixelData >>= 1;
+						}
+				}
+			x += pFont->Width( *p );
+			if ( x > LCD_COLS )
+				{
+					x = 2;
+					y += pFont->Height( *p );
+					if ( y > 40 ) break;
+				}
+		}
+
+	lcd.update();
+}
+
+
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/lcddisplay.h vdr-1.2.6/PLUGINS/src/dbox2/lcddisplay.h
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/lcddisplay.h	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/lcddisplay.h	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * lcddisplay.c: A plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#ifndef __LCDDISPLAY_H__
+#define __LCDDISPLAY_H_
+
+#include <lcddisplay/lcddisplay.h>
+#include <vdr/font.h>
+
+class cLcdDisplay 
+{
+	private:
+
+		CLCDDisplay	lcd;
+		cFont		*pFont;
+
+ 	public:
+
+		static cLcdDisplay 		*getInstance( void );
+		static cLcdDisplay 		*mpLcdDisplay;
+		cLcdDisplay( void );
+		~cLcdDisplay( void );
+
+		void ShowServiceName( const char *name );
+};
+
+#endif
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/plugins.c vdr-1.2.6/PLUGINS/src/dbox2/plugins.c
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/plugins.c	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/plugins.c	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,415 @@
+/*
+ * plugins.c: for dbox2 plugin
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+ 
+// TODO: 	- clear lcd after plugin ends
+// 			- fix rc (!?!)
+//			- halt siprocessor thread during plugin execution (eats to much system capacity)
+//			- some other fixes :)
+
+#include <dirent.h>
+#include "plugins.h"
+#include <string>
+//#include <stdio.h>
+#include <stdlib.h>
+#include <plugin.h>
+#include <vdr/framebuffer.h>
+#include <vdr/tools.h>
+#include <vdr/channels.h>
+#include <vdr/device.h>
+#include <dlfcn.h>
+#include "../remote/remote.h"
+#include <vdr/plugin.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <vdr/device.h>
+#include "lcddisplay.h"
+#include <vdr/dvbdevice.h>
+
+class cPOsdItem : public cOsdItem
+{
+	public:
+		cPOsdItem( const char *text, int mitem, cDbox2Plugin *inp ) : cOsdItem( text ) { menu_item = mitem; pPlugin = inp; }
+		virtual void Set( void ) { }
+		eOSState ProcessKey( eKeys Key )
+			{
+				if ( Key == kOk )
+					{
+						cPlugin *vdrplugin = cPluginManager::GetPlugin( "remote" );
+						if ( vdrplugin != NULL )
+							vdrplugin->GetSetData( RSTOPREMOTE ); // stops remote thread
+						cDvbDevice *dvbdevice = cDvbDevice::getInstance();
+						
+						if ( dvbdevice != NULL )  // stop filtering // 
+							dvbdevice->SiP(false);
+						
+						pPlugin->startPlugin( menu_item );
+						
+						if ( dvbdevice != NULL ) // start filtering again
+							dvbdevice->SiP(true); 
+						if ( vdrplugin != NULL )
+							vdrplugin->GetSetData( RSTARTREMOTE ); // starts remote thread
+						vdrplugin = NULL;
+					}
+				return Key == kOk ? osEnd : cOsdItem::ProcessKey( Key );
+			};
+
+	protected:
+		int menu_item;
+
+	private:
+		cDbox2Plugin *pPlugin;
+};
+
+cDbox2PluginMenu::cDbox2PluginMenu( void ) :
+cOsdMenu( "DBox2 Plugins" )
+{
+	cDbox2Plugin *pPlugin = new cDbox2Plugin();
+
+	Clear();
+	SetHasHotkeys();
+
+	int numPlugins = pPlugin->getPlugins();
+
+	for ( int i = 0; i < numPlugins; i++)
+		{
+			Add(new cPOsdItem( hk ( pPlugin->getPname( i ).c_str() ), i , pPlugin ) );
+		}
+}
+
+cDbox2Plugin::cDbox2Plugin( void )
+{
+}
+
+cDbox2Plugin::~cDbox2Plugin( void )
+{
+	the_plugins.clear();
+}
+
+void cDbox2Plugin::readSpecs( std::string fname )
+{
+	FILE *infile = fopen( fname.c_str(), "r" );
+
+	char buf[128];
+	structplugin sp;
+
+	sp.soname = fname.substr( 0, fname.find( ".cfg" ) ) + ".so";
+
+	while ( fgets( buf, 127, infile ))
+		{
+			std::string parsestring = buf;
+			std::string command( parsestring, 0, parsestring.find( "=" ) );
+			std::string param( parsestring, parsestring.find( "=" ) +1, parsestring.length() );
+
+			if ( command == "pluginversion" )
+				{
+					sp.version = atoi( param.c_str() );
+					continue;
+				}
+
+			if ( command == "name" )
+				{
+					sp.name = param;
+					continue;
+				}
+			if ( command == "desc" )
+				{
+					sp.desc = param;
+					continue;
+				}
+			if ( command == "depend" )
+				{
+					sp.depend = param;
+					continue;
+				}
+			if ( command == "needfb" )
+				{
+					sp.needfb = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+			if ( command == "needrc" )
+				{
+					sp.needrc = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+			if ( command == "needlcd" )
+				{
+					sp.needlcd = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+			if ( command == "needvtxtpid" )
+				{
+					sp.needvtxtpid = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+			if ( command == "pigon" )
+				{
+					sp.pigon = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+			if ( command == "needoffsets" )
+				{
+					sp.needoffsets = atoi( param.c_str() ) ? true : false;
+					continue;
+				}
+		}
+
+	the_plugins.push_back( sp );
+	fclose( infile );
+}
+
+int cDbox2Plugin::getPlugins( void )
+{
+	std::string  sdir = DBPLUGINDIR "/" ;
+	struct dirent **namelist;
+
+	int anzahl = 0;
+	int num = scandir(  sdir.c_str(), &namelist, 0, alphasort );
+
+	if ( num < 0 )
+		{
+			// scandir error...
+			esyslog("plugin.c cannot scan dir");
+			return 0;
+		}
+
+	for ( int i; i < num; i++)
+		{
+			std::string pname = namelist[i]->d_name;
+
+			if ( pname.find( ".cfg" ) != std::string::npos )
+				{
+					anzahl++;
+					readSpecs( sdir + pname );
+				}
+			free( namelist[i] );
+		}
+	free( namelist );
+
+	sort( the_plugins.begin(), the_plugins.end() );
+
+	return anzahl;
+}
+
+void cDbox2Plugin::startPlugin( int num )
+{
+	PluginExec execPlugin;
+	char depstring[129];
+	char			*argv[20];
+	void			*libhandle[20];
+	int			argc, i, lcd_fd =-1;
+	char			*p;
+	char			*np;
+	void			*handle;
+	char			*error;
+	int			tpid = 0;
+
+	PluginParam *startparam;
+	PluginParam *tmpparam;
+
+	startparam = 0;
+	tmpparam = startparam;
+
+	setfb( CFrameBuffer::getInstance()->getFileHandle() );
+
+	if ( the_plugins[num].needfb )
+		startparam = makeParam( P_ID_FBUFFER, startparam );
+
+	if ( the_plugins[num].needrc )
+		{
+			cPlugin *vdrplugin = cPluginManager::GetPlugin( "remote" );
+			int *rcfh = ( int *) vdrplugin->GetSetData( RDATAFILEHANDLE );
+			setrc( *rcfh );
+			vdrplugin = NULL;
+			//addParm( P_ID_RCBLK_ANF, g_settings.repeat_genericblocker );
+			//addParm( P_ID_RCBLK_REP, g_settings.repeat_blocker );
+
+			startparam = makeParam( P_ID_RCINPUT, startparam );
+			//startparam = makeParam( P_ID_RCBLK_ANF, startparam );
+			//startparam = makeParam( P_ID_RCBLK_REP, startparam );
+		}
+	if ( the_plugins[num].needlcd )
+		{
+			if( ( lcd_fd=open("/dev/dbox/lcd0", O_RDWR ) ) < 0 )
+				setlcd( 0 );
+			else
+				setlcd( lcd_fd );
+
+			startparam = makeParam( P_ID_LCD, startparam );
+		}
+	if ( the_plugins[num].needvtxtpid )
+		{
+			cChannel *channel = Channels.GetByNumber( cDevice::CurrentChannel() );
+			tpid = channel->Tpid();
+			if ( tpid )
+				setvtxtpid( tpid );
+			else
+				setvtxtpid( 0 );
+			channel = NULL;
+			startparam = makeParam( P_ID_VTXTPID, startparam );
+
+			// stop vtxt
+			if ( tpid )
+				{
+					cDevice::PrimaryDevice()-> vtxtPid( false );
+					usleep( 1000 );
+				}
+		}
+	if ( the_plugins[num].needoffsets )
+		{
+			//addParm( P_ID_VFORMAT, g_settings.video_Format );
+			addParm( P_ID_OFF_X, 0 );
+			addParm( P_ID_OFF_Y, 0 );
+			addParm( P_ID_END_X, 720 );
+			addParm( P_ID_END_Y, 576 );
+
+			//startparam = makeParam( P_ID_VFORMAT, startparam );
+			startparam = makeParam( P_ID_OFF_X, startparam );
+			startparam = makeParam( P_ID_OFF_Y, startparam );
+			startparam = makeParam( P_ID_END_X, startparam );
+			startparam = makeParam( P_ID_END_Y, startparam );
+		}
+
+	PluginParam *par = startparam;
+
+	std::string pluginname = the_plugins[num].soname;
+
+	strcpy( depstring, the_plugins[num].depend.c_str() );
+
+	argc=0;
+	if ( depstring[0] )
+		{
+			p = depstring;
+			while( 1 )
+				{
+					argv[ argc ] = p;
+					argc++;
+					np = strchr( p, ',' );
+					if ( !np )
+						break;
+
+					*np = 0;
+					p = np+1;
+					if ( argc == 20 )
+						break;
+				}
+		}
+
+	for( i = 0; i < argc; i++ )
+		{
+			std::string libname = argv[i];
+			isyslog( "try load shared lib : %s\n", argv[i] );
+			libname = *argv[i] == '/' ? argv[i] : ( DBPLUGINDIR  "/" + libname ).c_str();
+			// kill that damned newline char, grrr
+			if ( libname[libname.length()-1] == 10 ) libname[libname.length()-1] = 0;
+			libhandle[i] = dlopen ( libname.c_str(), RTLD_NOW | RTLD_GLOBAL );
+			if ( !libhandle )
+				{
+					fputs ( dlerror(), stderr );
+					break;
+				}
+		}
+	while ( i == argc )
+		{
+			handle = dlopen ( the_plugins[num].soname.c_str(), RTLD_NOW | RTLD_GLOBAL );
+			if ( !handle )
+				{
+					fputs ( dlerror(), stderr );
+					break;
+				}
+			execPlugin = ( PluginExec ) dlsym( handle, "plugin_exec" );
+			if ( ( error = dlerror() ) != NULL )
+				{
+					fputs( error, stderr );
+					dlclose( handle );
+					break;
+				}
+			isyslog( "try plugin exec...\n" );
+			execPlugin( startparam );
+			dlclose( handle );
+			isyslog( "plugin exec done...\n" );
+
+			if ( the_plugins[num].needvtxtpid )
+				{
+					if ( tpid )
+						{
+							cDevice::PrimaryDevice()->vtxtPid( true );
+						}
+				}
+			if ( the_plugins[num].needlcd )
+				{
+					if( lcd_fd != -1 )
+						close( lcd_fd );
+					cChannel *channel = Channels.GetByNumber( cDevice::CurrentChannel() );
+					cLcdDisplay::getInstance()->ShowServiceName( channel->Name() );
+				}
+
+    			if ( the_plugins[num].needfb )
+    				{
+    					CFrameBuffer::getInstance()->ClearFrameBuffer();;
+    					CFrameBuffer::getInstance()->paintBackgroundBoxRel( 0, 0, 720, 576 );
+    				}
+
+		//redraw menue...
+			break;	// break every time - never loop - run once !!!
+		}
+
+	/* unload shared libs */
+	for( i = 0; i < argc; i++ )
+		{
+			if ( libhandle[i] )
+				dlclose( libhandle[i] );
+			else
+				break;
+		}
+}
+
+PluginParam* cDbox2Plugin::makeParam( std::string id, PluginParam *next )
+{
+	PluginParam *startparam = new PluginParam;
+
+	startparam->next = next;
+	startparam->id = new char[id.length() + 2];
+	startparam->val = new char[params.find(id)->second.length() + 2];
+	strcpy( startparam->id, id.c_str() );
+	strcpy( startparam->val, params.find(id)->second.c_str() );
+
+	return startparam;
+}
+
+void cDbox2Plugin::addParm( std::string cmd, std::string value )
+{
+	params[cmd] = value;
+}
+
+void cDbox2Plugin::addParm( std::string cmd, int value )
+{
+	char aval[10];
+	sprintf( aval, "%d", value );
+
+	addParm( cmd, aval );
+}
+
+void cDbox2Plugin::setfb( int fd )
+{
+	addParm( P_ID_FBUFFER, fd );
+}
+
+void cDbox2Plugin::setrc( int fd )
+{
+	addParm( P_ID_RCINPUT, fd );
+}
+
+void cDbox2Plugin::setlcd( int fd )
+{
+	addParm( P_ID_LCD, fd );
+}
+
+void cDbox2Plugin::setvtxtpid( int fd )
+{
+	addParm( P_ID_VTXTPID, fd );
+}
diff -Nur vdr-1.2.6.orig/PLUGINS/src/dbox2/plugins.h vdr-1.2.6/PLUGINS/src/dbox2/plugins.h
--- vdr-1.2.6.orig/PLUGINS/src/dbox2/plugins.h	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/dbox2/plugins.h	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,76 @@
+/*
+ * plugins.h: for dbox2 plugin
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#ifndef __PLUGINS_H_
+#define __PLUGINS_H_
+
+#include <vdr/osd.h>
+#include <vector>
+#include <string>
+#include <map>
+#include <plugin.h>
+
+#define DBPLUGINDIR "/lib/tuxbox/plugins"
+
+class cDbox2PluginMenu : public cOsdMenu
+{
+	public:
+		cDbox2PluginMenu( void );
+};
+
+class cDbox2Plugin
+{
+	public:
+		struct structplugin
+			{
+				std::string name;
+				std::string desc;
+				std::string depend;
+				std::string soname;
+				int version;
+				bool needfb;
+				bool needrc;
+				bool needlcd;
+				bool needvtxtpid;
+				bool pigon;
+				bool needoffsets;
+				bool operator < ( const structplugin &p ) const
+					{
+						bool result = this->name < p.name;
+						return result;
+					}
+			  } ;
+
+	public:
+		cDbox2Plugin( void );
+		~cDbox2Plugin( void );
+
+		int getPlugins( void );
+		void startPlugin( int num );
+		std::string &getPname( int num ) { return the_plugins[num].name; }
+		PluginParam* makeParam( std::string id, PluginParam *next );
+
+	private:
+		std::vector<structplugin> the_plugins;
+		std::map<std::string, std::string> params;
+
+		void readSpecs( std::string fname );
+
+		void addParm( std::string cmd, std::string value );
+		void addParm( std::string cmd, int value );
+		void setfb( int fd );
+		void setrc( int fd );
+		void setlcd( int fd );
+		void setvtxtpid( int fd );
+};
+
+#endif
+
+
+
+
diff -Nur vdr-1.2.6.orig/PLUGINS/src/hello/Makefile vdr-1.2.6/PLUGINS/src/hello/Makefile
--- vdr-1.2.6.orig/PLUGINS/src/hello/Makefile	2002-12-13 15:54:14.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/hello/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-#
-# Makefile for a Video Disk Recorder plugin
-#
-# $Id: Makefile 1.8 2002/12/13 14:54:14 kls Exp $
-
-# The official name of this plugin.
-# This name will be used in the '-P...' option of VDR to load the plugin.
-# By default the main source file also carries this name.
-#
-PLUGIN = hello
-
-### The version number of this plugin (taken from the main source file):
-
-VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
-
-### The C++ compiler and options:
-
-CXX      ?= g++
-CXXFLAGS ?= -O2 -Wall -Woverloaded-virtual
-
-### The directory environment:
-
-DVBDIR = ../../../../DVB
-VDRDIR = ../../..
-LIBDIR = ../../lib
-TMPDIR = /tmp
-
-### Allow user defined options to overwrite defaults:
-
--include $(VDRDIR)/Make.config
-
-### The version number of VDR (taken from VDR's "config.h"):
-
-VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
-
-### The name of the distribution archive:
-
-ARCHIVE = $(PLUGIN)-$(VERSION)
-PACKAGE = vdr-$(ARCHIVE)
-
-### Includes and Defines (add further entries here):
-
-INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include
-
-DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
-
-### The object files (add further files here):
-
-OBJS = $(PLUGIN).o i18n.o
-
-### Implicit rules:
-
-%.o: %.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
-
-# Dependencies:
-
-MAKEDEP = g++ -MM -MG
-DEPFILE = .dependencies
-$(DEPFILE): Makefile
-	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
-
--include $(DEPFILE)
-
-### Targets:
-
-all: libvdr-$(PLUGIN).so
-
-libvdr-$(PLUGIN).so: $(OBJS)
-	$(CXX) $(CXXFLAGS) -shared $(OBJS) -o $@
-	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
-
-dist: clean
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@mkdir $(TMPDIR)/$(ARCHIVE)
-	@cp -a * $(TMPDIR)/$(ARCHIVE)
-	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@echo Distribution package created as $(PACKAGE).tgz
-
-clean:
-	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/COPYING vdr-1.2.6/PLUGINS/src/remote/COPYING
--- vdr-1.2.6.orig/PLUGINS/src/remote/COPYING	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/COPYING	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/FAQ vdr-1.2.6/PLUGINS/src/remote/FAQ
--- vdr-1.2.6.orig/PLUGINS/src/remote/FAQ	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/FAQ	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,111 @@
+Remote Control Mini-FAQ (En, 2003-03-31)
+========================================
+
+Q: Which hardware is supported?
+A: Configurations which have been reported to work:
+
+type          connector         ir protocol
+-------------------------------------------
+Activy 300                      RCMM
+DVB-S 1.3[1]  J2                RC5
+DVB-S 1.5[1]  ???               ???
+DVB-S 1.6[1]  CI module         RC5
+DVB-S 2.1     ir connector      RC5
+DVB-S 2.2     ir connector      RC5
+
+[1] Probably DVB-S board revisions 1.3/1.5/1.6 work with:
+- J2 connector (if no CI module has been connected)
+- ir receiver connected to the CI module
+
+Please report if you have a working configuration not listed here. Thx.
+
+------------------------------------------------------------------------------
+
+Q: What is the expected behavior of evtest?
+A: You should see something like this:
+
+./evtest /dev/input/event0
+Input driver version is 1.0.0
+Input device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0
+Input device name: "DVB on-card IR receiver"
+Supported events:
+  Event type 1 (Key)
+    Event code 2 (1)
+    Event code 3 (2)
+    Event code 4 (3)
+    Event code 5 (4)
+    Event code 6 (5)
+    Event code 7 (6)
+    Event code 8 (7)
+    Event code 9 (8)
+    Event code 10 (9)
+    Event code 11 (0)
+    Event code 113 (Mute)
+    Event code 114 (VolumeDown)
+    Event code 115 (VolumeUp)
+    Event code 154 (CycleWindows)
+    Event code 353 (Select)
+    Event code 360 (Vendor)
+    Event code 375 (Screen)
+    Event code 377 (TV)
+    Event code 385 (Radio)
+    Event code 402 (ChannelUp)
+    Event code 403 (ChannelDown)
+Testing ... (interrupt to exit)
+Event: time 1047342384.790038, type 1 (Key), code 402 (ChannelUp), value 1
+Event: time 1047342385.290630, type 1 (Key), code 402 (ChannelUp), value 0
+
+'DVB on-card IR receiver' indicates that you are using the correct device.
+'Event:' lines are the result of pressing the 'Up' key on the remote control.
+
+------------------------------------------------------------------------------
+
+Q: evtest does not show any events.
+A: Try this checklist:
+
+0. compile everything:
+   cd DVB/driver
+   make
+   makedev.napi
+   cd DVB/apps/av7110_loadkeys
+   make
+
+1. load the driver
+   cd DVB/driver
+   make insmod
+
+2. load the keymap [see note below]
+   cd DVB/apps/av7110_loadkeys
+   ./av7110_loadkeys hauppauge.rc5 > /proc/av7110_ir
+
+3. run evtest
+   ./evtest /dev/input/event0
+
+If this does not work, try
+   ./evtest /dev/input/event1
+   ./evtest /dev/input/event2
+   ./evtest /dev/input/event3
+   ...
+
+One of these should work. (If your device is not '/dev/input/event0', 
+you have to specify this device with the '-i' command line option of
+the remote control plugin.)
+
+Note:
+   The keymap above works for the RC5 remote of a DVB-S Nexus 2.1 card.
+   For RCMM receivers, use a .rcmm keymap, i.e. 'activy.rcmm'.
+   If unsure, you might also try
+   ./av7110_loadkeys -i hauppauge.rc5 > /proc/av7110_ir
+   ./av7110_loadkeys activy.rcmm > /proc/av7110_ir
+   ./av7110_loadkeys -i activy.rcmm > /proc/av7110_ir
+
+------------------------------------------------------------------------------
+
+Q: It still doesn't work. Any other idea?
+A: Verify that the plug of the remote control receiver is connected properly.
+   :)
+
+------------------------------------------------------------------------------
+
+Q: How do I have to modify 'runvdr' to load the keymap?
+A: Take a look at the script 'runvdr.remote' in sub-directory 'misc'.
\ No newline at end of file
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/HISTORY vdr-1.2.6/PLUGINS/src/remote/HISTORY
--- vdr-1.2.6.orig/PLUGINS/src/remote/HISTORY	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/HISTORY	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,13 @@
+VDR Plugin 'remote' Revision History
+------------------------------------
+
+2002-10-14: Version 0.0.1
+
+- Initial revision.
+
+
+2002-03-31: Version 0.1.0
+
+- Support autorepeat on /dev/input/eventX with following API-3 drivers:
+  o DVB HEAD (2003-03-31 and later)
+  o dvb kernel (2003-03-31 and later)
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/Makefile vdr-1.2.6/PLUGINS/src/remote/Makefile
--- vdr-1.2.6.orig/PLUGINS/src/remote/Makefile	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/Makefile	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,80 @@
+#
+# Makefile for a Video Disk Recorder plugin
+#
+# $Id$
+
+# The official name of this plugin.
+# This name will be used in the '-P...' option of VDR to load the plugin.
+# By default the main source file also carries this name.
+#
+PLUGIN = remote
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+### The directory environment:
+
+DVBDIR = ../../../../DVB
+VDRDIR = ../../..
+LIBDIR = ../../lib
+TMPDIR = /tmp
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+### Includes and Defines (add further entries here):
+
+-include $(VDRDIR)/Make.config
+INCLUDES += -I$(VDRDIR)/include
+
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+
+### The object files (add further files here):
+
+OBJS = $(PLUGIN).o
+
+### The C++ compiler and options:
+
+CXX      = powerpc-tuxbox-linux-gnu-g++
+#CXXFLAGS = -O3 -Wall -Woverloaded-virtual -msoft-float
+CXXFLAGS = -mcpu=823 -msoft-float -mmultiple -mstring -meabi -O3 -g -DREMOTE_
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+### Targets:
+
+all: libvdr-$(PLUGIN).so
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
+
+dist: clean
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
+	@-rm -rf $(TMPDIR)/$(ARCHIVE)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/README vdr-1.2.6/PLUGINS/src/remote/README
--- vdr-1.2.6.orig/PLUGINS/src/remote/README	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/README	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,113 @@
+remote - a remote control plugin for the Video Disk Recorder (VDR)
+==================================================================
+
+Written by:                   Oliver Endriss <o.endriss@gmx.de>
+
+Latest version available at:  http://endriss.escape.bei.t-online.de/vdr
+
+Requirements:                 VDR 1.1.13 or later
+
+Distributed under GPL, see the file COPYING for license information.
+
+
+Description:
+------------
+This plugin supports the built-in remote control port of the DVB-S Rev. 2.1/2.2
+(and the J2 or CAM connectors of some other boards, see file FAQ).
+It is primarily intended for use with the new DVB driver (NEWSTRUCT and later,
+i.e. API versions 2 and 3), but may be used with the old driver, too.
+
+When the plugin is loaded for the first time, vdr will prompt you to learn
+the keys of the remote control. It is possible to use several devices at the
+same time, but this is not very important right now...
+
+Supported kernel devices:
+- new DVB driver (API-2, API-3): /dev/input/eventX
+- old DVB driver (API-1): /dev/lirc
+- keyboard: /dev/console, /dev/ttyX
+
+
+Installation:
+-------------
+The remote plugin is installed as usual:
+- cd VDR/PLUGINS/src
+- tar xfz vdr-remote-0.1.0.tgz
+- ln -s remote-0.1.0 remote
+- cd ../..
+- make plugins
+
+
+API-3 driver (version 1.0.0, CVS HEAD, CVS dvb-kernel) 
+------------------------------------------------------
+Remote control events are passed through '/device/input/eventX'.
+Since the /dev/input protocol is standardized in the kernel, there is a
+chance that this plugin will work with other /dev/input devices, too.
+However, this has not been tested yet...
+The -i option allows you to specify the name of the /dev/input device.
+
+Before submitting a bug report, please verify that driver and remote control
+are working properly. You may do this using the 'evtest' tool supplied
+with the driver (directory 'DVB/apps/av7110_loadkeys').
+Verify that the device node exists and you have read access rights.
+You have to select the correct remote control type, inversion setting and
+keymap using the tool 'av7110_loadkeys'. Please read the file README in
+the directory 'DVB/apps/av7110_loadkeys'.
+If you still have problems, take a look on the checklist in file 'FAQ'.
+
+If you'd like to use autorepeat, you have to use CVS HEAD, CVS dvb-kernel
+2003-03-31 or later (or the next 1.0.0 release, of course).
+The feature is automatically detected and used.
+
+BTW, these drivers might also be useful, if the remote control of your
+TV set interferes with the remote control of your DVB-S. See the file
+'DVB/apps/av7110_loadkeys/README' for information how to enable 
+checking of the device address.
+
+
+API-2 (CVS NEWSTRUCT)
+---------------------
+Since the NEWSTRUCT branch is obsolete, there is no reason to use this
+driver anymore. See API-3 above.
+
+
+API-1 (old driver, version 0.9.4)
+---------------------------------
+The old DVB driver provides a module (DVB/driver/lirc/lirc_dvb.o) which
+connects to the LIRC device ('/dev/lirc', lirc_dev.o).
+Using the -l option, it is possible to use '/dev/lirc' as a direct input
+device, i.e. lircd is *not* needed. However, the lirc_dev.o driver
+supplied by the LIRC package is still required (and must be loaded).
+If you use this option, you should know what you are doing. :-)
+
+
+TTY devices
+-----------
+The -t option may be used to specify a virtual console as an input device.
+This is useful, if you haven't compiled keyboard support into your VDR.
+
+
+Summary of command line options:
+--------------------------------
+-i dev, --input dev   select device which supports the /dev/input protocol
+-l dev, --lirc dev    select device which uses the /dev/lirc protocol
+-t dev, --tty dev     select terminal device
+
+
+Examples:
+---------
+vdr -Premote
+    use default device, same as '-i /dev/input/event0'
+
+vdr -P"remote -i /dev/input/event2"
+    use specified input device '/dev/input/event2'
+
+vdr -P"remote -l /dev/lirc"
+    use lirc kernel device
+
+vdr -P"remote -i /dev/input/event0 -i /dev/input/event2 -t /dev/tty10"
+    use multiple devices
+
+
+Have fun,
+
+Oliver
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/remote.c vdr-1.2.6/PLUGINS/src/remote/remote.c
--- vdr-1.2.6.orig/PLUGINS/src/remote/remote.c	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/remote.c	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,426 @@
+/*
+ * remote.c: Remote Control plugin for the Video Disk Recorder
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id$
+ */
+
+#include <stdio.h>
+#include <sys/fcntl.h>
+#include <getopt.h>
+#include <termios.h>
+#include <linux/input.h>
+#include "remote.h"
+
+//#define DEBUG
+
+#ifdef DEBUG
+#define DSYSLOG(x...)    dsyslog(x)
+#else
+#define DSYSLOG(x...)
+#endif
+
+//------------------------------------------------------------------------------
+
+cRemoteGeneric::cRemoteGeneric(const char *name, int f, char *d)
+:cRemote(name)
+{
+    fh = f;
+    device = d;
+    polldelay     = 40;   // ms
+    repeatdelay   = 350;  // ms
+    repeatfreq    = 100;  // ms
+    repeattimeout = 500;  // ms
+}
+
+cRemoteGeneric::~cRemoteGeneric()
+{
+    Cancel();
+}
+
+void cRemoteGeneric::Action(void)
+{
+    int now, first = 0, last = 0;
+    uint64 code, lastcode = INVALID_KEY;
+    bool repeat = false;
+
+    for (;;)
+    {
+        if (polldelay)
+            delay_ms(polldelay);
+
+        code = getKey();
+        if (code == INVALID_KEY)
+        {
+            esyslog("error reading '%s'\n", device);
+            delay_ms(100*polldelay);
+            continue;
+        }
+
+        now = time_ms();
+
+        if (keyPressed(code))
+        {
+            // key down
+            if (now - last > repeattimeout)
+            {
+                if (repeat)
+                {
+                    Put(lastcode,false,true);
+                    DSYSLOG("%s: timeout %016llx\n", device, code);
+                    repeat = false;
+                }
+                lastcode = INVALID_KEY;
+            }
+
+            if (code != lastcode)
+            {
+                Put(code);
+                DSYSLOG("%s: press %016llx\n", device, code);
+                lastcode = code;
+                last = first = now;
+                repeat = false;
+            }
+            else
+            {
+                if (now - first < repeatdelay || now - last < repeatfreq)
+                    continue;
+                Put(code,true);
+                DSYSLOG("%s: repeat %016llx\n", device, code);
+                last = now;
+                repeat = true;
+            }
+        }
+        else
+        {
+            // key up
+            if (repeat)
+            {
+                Put(lastcode,false,true);
+                DSYSLOG("%s: release %016llx\n", device, lastcode);
+                repeat = false;
+            }
+            lastcode = INVALID_KEY;
+        }
+    }/* for */
+}
+
+//------------------------------------------------------------------------------
+
+cRemoteDevInput::cRemoteDevInput(const char *name, int f, char *d)
+:cRemoteGeneric(name, f, d)
+{
+    unsigned long data[EV_MAX];
+
+    Start();
+
+    memset (data, 0, sizeof data);
+    ioctl(f, EVIOCGBIT(0,EV_MAX), data);
+
+#define BITS_PER_LONG	(sizeof(unsigned long) * 8)
+
+    if ( data[EV_REP/BITS_PER_LONG] & (1 << EV_REP%BITS_PER_LONG) )
+    {
+        // autorepeat driver
+        DSYSLOG("%s: supports autorepeat!", d);
+        polldelay = 0;
+    }
+    else
+    {
+        // non-autorepeat drivers
+        polldelay = repeatdelay = repeatfreq = repeattimeout = 0;
+    }
+}
+
+uint64 cRemoteDevInput::getKey(void)
+{
+    struct input_event ev;
+    int n;
+    uint64 code;
+
+    n = read(fh, &ev, sizeof ev);
+    if (n == sizeof ev)
+    {
+        if (ev.value)
+            ev.value = 1;
+        code = ((uint64)ev.value << 32) | ((uint64)ev.type << 16) | (uint64)ev.code;
+    }
+    else
+        code = INVALID_KEY;
+    return code;
+}
+
+bool cRemoteDevInput::keyPressed(uint64 code)
+{
+    return (code & 0xFFFF00000000ULL);
+}
+
+void cRemoteDevInput::RCmd( bool onoff )
+{
+	switch ( onoff )
+		{
+			case false:
+					usleep( 1000 );
+					Start();
+				break;
+			case true:
+					Cancel();
+				break;
+		}
+}
+
+
+//------------------------------------------------------------------------------
+
+class cRemoteDevLirc : protected cRemoteGeneric
+{
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevLirc(const char *name, int f, char *d)
+  :cRemoteGeneric(name, f, d) { Start(); }
+  virtual void RCmd( bool onoff );
+};
+
+uint64 cRemoteDevLirc::getKey(void)
+{
+    unsigned long code;
+    int n;
+
+    n = read(fh, &code, sizeof code);
+    if (n != sizeof code)
+        return INVALID_KEY;
+    else
+        return (uint64)code;
+}
+
+bool cRemoteDevLirc::keyPressed(uint64 code)
+{
+    return (code & 0x80);
+}
+
+void cRemoteDevLirc::RCmd( bool onoff )
+{
+	switch ( onoff )
+		{
+			case false:
+					Start();
+				break;
+			case true:
+					Cancel();
+				break;
+		}
+}
+
+//------------------------------------------------------------------------------
+
+class cRemoteDevTty : protected cRemoteGeneric
+{
+private:
+  struct termios tm;
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevTty(const char *name, int f, char *d);
+  virtual ~cRemoteDevTty();
+  virtual void RCmd( bool onoff );
+};
+
+cRemoteDevTty::cRemoteDevTty(const char *name, int f, char *d)
+:cRemoteGeneric(name, f, d)
+{
+    struct termios t;
+
+    if (!tcgetattr(f, &tm))
+    {
+        t = tm;   
+        t.c_lflag &= ~(ICANON | ECHO);
+        tcsetattr(f, TCSANOW, &t);
+    }
+    polldelay     = 0;
+    repeattimeout = 80;
+    Start();
+}
+
+cRemoteDevTty::~cRemoteDevTty()
+{
+    tcsetattr(fh, TCSANOW, &tm);
+}
+
+uint64 cRemoteDevTty::getKey(void)
+{
+    int n;
+    uint64 code = 0;
+
+    n = read(fh, &code, sizeof code);
+    return (n > 0) ? code : INVALID_KEY;
+}
+
+bool cRemoteDevTty::keyPressed(uint64 code)
+{
+    return true;
+}
+
+void cRemoteDevTty::RCmd( bool onoff )
+{
+	switch ( onoff )
+		{
+			case false:
+					Start();
+				break;
+			case true:
+					Cancel();
+				break;
+		}
+}
+
+//------------------------------------------------------------------------------
+
+void *cPluginRemote::GetSetData( int what )
+{
+	if ( what == RDATAFILEHANDLE )
+		{
+			return fh;
+		}
+	else
+	if ( what == RSTOPREMOTE )
+		{
+			if ( prdi != NULL )
+				prdi->RCmd( true );
+			return NULL;
+		}
+	if ( what == RSTARTREMOTE )
+		{
+			if ( prdi != NULL )
+				prdi->RCmd( false );
+			return NULL;
+		}
+	return NULL;
+}
+
+cPluginRemote::cPluginRemote(void)
+{
+    for (int i = 0; i < NUMREMOTES; i++)
+    {
+        devtyp[i] = '\0';
+        devnam[i] = NULL;
+        fh[i] = -1;
+    }
+    devcnt = 0;
+}
+
+cPluginRemote::~cPluginRemote()
+{
+    // must not delete any remotes, see PLUGINS.html!
+
+    for (int i = 0; i < devcnt; i++)
+    {
+        if (fh[i] >= 0)
+            close(fh[i]);
+        fh[i] = -1;
+    }
+    devcnt = 0;
+}
+
+const char *cPluginRemote::CommandLineHelp(void)
+{
+    return "  -i dev,   --input=dev    kernel input device (/dev/input/...)\n"
+           "  -l dev,   --lirc=dev     kernel lirc device (/dev/lirc)\n"
+           "  -t dev,   --tty=dev      tty device\n";
+}
+
+bool cPluginRemote::ProcessArgs(int argc, char *argv[])
+{
+    static struct option long_options[] =
+            { { "input", required_argument, NULL, 'i' },
+              { "lirc",  required_argument, NULL, 'l' },
+              { "tty",   required_argument, NULL, 't' },
+              { NULL } };
+    int c;
+
+    while ((c = getopt_long(argc, argv, "i:l:t:", long_options, NULL)) != -1)
+    {
+        switch (c)
+        {
+          case 'i':
+          case 'l':
+          case 't':
+              if (devcnt >= NUMREMOTES)
+              {
+                  esyslog("%s: too many remotes", Name());
+                  return false;
+              }
+              devtyp[devcnt] = c;
+              devnam[devcnt] = optarg;
+	      devcnt++;
+              break;
+
+          default:
+              esyslog("%s: invalid argument", Name());
+              return false;
+        }
+    }
+
+    return true;
+}
+
+bool cPluginRemote::Start(void)
+{
+    char nam[25];
+    bool ok = false;
+
+    // defaults
+    if (devcnt == 0)
+    {
+        devtyp[0] = 'i';
+        devnam[0] = "/dev/input/event0";
+        devcnt = 1;
+    }
+
+    for (int i = 0; i < devcnt; i++)
+    {
+        fh[i] = open(devnam[i], O_RDONLY);
+        if (fh[i] < 0)
+        {
+            esyslog("%s: unable to open '%s'", Name(), devnam[i]);
+            continue;
+        }
+	
+        // at least, one device opened successfully
+        ok = true;
+        dsyslog("%s: using '%s'", Name(), devnam[i]);
+
+        // build name for remote.conf
+        char *cp = strrchr(devnam[i], '/');
+	if (cp)
+            sprintf (nam, "%s-%s", Name(), cp+1);
+        else
+            sprintf (nam, "%s-%u", Name(), i);
+
+	switch (devtyp[i])
+        {
+            case 'i':
+                prdi = new cRemoteDevInput(nam,fh[i],devnam[i]);
+                break;
+
+            case 'l':
+                new cRemoteDevLirc(nam,fh[i],devnam[i]);
+                break;
+
+            case 't':
+                new cRemoteDevTty(nam,fh[i],devnam[i]);
+                break;
+        }
+    }
+    
+    if (!ok)
+        esyslog("%s: fatal error - unable to open input device", Name());
+    return ok;
+}
+
+//------------------------------------------------------------------------------
+
+VDRPLUGINCREATOR(cPluginRemote); // Don't touch this!
diff -Nur vdr-1.2.6.orig/PLUGINS/src/remote/remote.h vdr-1.2.6/PLUGINS/src/remote/remote.h
--- vdr-1.2.6.orig/PLUGINS/src/remote/remote.h	2004-02-19 08:34:46.000000000 +0100
+++ vdr-1.2.6/PLUGINS/src/remote/remote.h	2004-02-11 15:19:50.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef __REMOTE_H__
+#define __REMOTE_H__
+
+#include <vdr/plugin.h>
+#include <vdr/remote.h>
+#include <vdr/thread.h>
+
+#define NUMREMOTES      5         // maximum number of remote control devices
+
+#define RDATAFILEHANDLE 	1
+#define RSTOPREMOTE		2
+#define RSTARTREMOTE		3
+
+static const char *VERSION        = "0.1.0";
+static const char *DESCRIPTION    = "Remote control";
+
+class cRemoteGeneric : protected cRemote, protected cThread
+{
+protected:
+  static const uint64 INVALID_KEY = (uint64) -1;
+  int fh;
+  char *device;
+  int polldelay;
+  int repeatdelay;
+  int repeatfreq;
+  int repeattimeout;
+  cRemoteGeneric(const char *name, int f, char *d);
+  virtual ~cRemoteGeneric();
+  virtual uint64 getKey(void) = 0;
+  virtual bool keyPressed(uint64 code) = 0;
+  virtual void Action(void);
+public:
+	  virtual void RCmd( bool onoff ) = 0;
+};
+
+class cRemoteDevInput : protected cRemoteGeneric
+{
+protected:
+  virtual uint64 getKey(void);
+  virtual bool keyPressed(uint64 code);
+public:
+  cRemoteDevInput(const char *name, int f, char *d);
+  virtual void RCmd( bool onoff );
+};
+
+
+class cPluginRemote : public cPlugin
+{
+private:
+  int  devcnt;
+  char devtyp[NUMREMOTES];
+  char *devnam[NUMREMOTES];
+  int  fh[NUMREMOTES];
+  cRemoteDevInput * prdi;
+public:
+  cPluginRemote(void);
+  virtual ~cPluginRemote();
+  virtual const char *Version(void) { return VERSION; }
+  virtual const char *Description(void) { return DESCRIPTION; }
+  virtual const char *CommandLineHelp(void);
+  virtual bool ProcessArgs(int argc, char *argv[]);
+  virtual bool Start(void);
+  virtual void *GetSetData( int what );
+};
+
+#endif
+
+
+
+
+
diff -Nur vdr-1.2.6.orig/config.c vdr-1.2.6/config.c
--- vdr-1.2.6.orig/config.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/config.c	2004-02-17 13:59:48.000000000 +0100
@@ -272,6 +272,7 @@
   UseSubtitle = 1;
   RecordingDirs = 1;
   VideoFormat = 0;
+  VideoOutput = 0;
   RecordDolbyDigital = 1;
   ChannelInfoPos = 0;
   OSDwidth = 52;
@@ -424,6 +425,7 @@
   else if (!strcasecmp(Name, "UseSubtitle"))         UseSubtitle        = atoi(Value);
   else if (!strcasecmp(Name, "RecordingDirs"))       RecordingDirs      = atoi(Value);
   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
+  else if (!strcasecmp(Name, "VideoOutput"))         VideoOutput        = atoi(Value);
   else if (!strcasecmp(Name, "RecordDolbyDigital"))  RecordDolbyDigital = atoi(Value);
   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
   else if (!strcasecmp(Name, "OSDwidth"))            OSDwidth           = atoi(Value);
@@ -474,6 +476,7 @@
   Store("UseSubtitle",        UseSubtitle);
   Store("RecordingDirs",      RecordingDirs);
   Store("VideoFormat",        VideoFormat);
+  Store("VideoOutput",        VideoOutput);
   Store("RecordDolbyDigital", RecordDolbyDigital);
   Store("ChannelInfoPos",     ChannelInfoPos);
   Store("OSDwidth",           OSDwidth);
diff -Nur vdr-1.2.6.orig/config.h vdr-1.2.6/config.h
--- vdr-1.2.6.orig/config.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/config.h	2004-02-17 13:58:10.000000000 +0100
@@ -227,6 +227,7 @@
   int UseSubtitle;
   int RecordingDirs;
   int VideoFormat;
+  int VideoOutput;
   int RecordDolbyDigital;
   int ChannelInfoPos;
   int OSDwidth, OSDheight;
diff -Nur vdr-1.2.6.orig/device.c vdr-1.2.6/device.c
--- vdr-1.2.6.orig/device.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/device.c	2004-02-17 13:57:46.000000000 +0100
@@ -37,6 +37,7 @@
   cardIndex = nextCardIndex++;
 
   SetVideoFormat(Setup.VideoFormat);
+  SetVideoOutput(Setup.VideoOutput);
 
   active = false;
 
@@ -216,6 +217,10 @@
 {
 }
 
+void cDevice::SetVideoOutput(int VideoOutput)
+{
+}
+
 eVideoSystem cDevice::GetVideoSystem(void)
 {
   return vsPAL;
@@ -311,6 +316,11 @@
   return false;
 }
 
+void cDevice::vtxtPid( bool onoff )
+{
+	SetPid( &pidHandles[ptTeletext], ptTeletext, onoff );
+}
+
 bool cDevice::ProvidesSource(int Source) const
 {
   return false;
diff -Nur vdr-1.2.6.orig/device.h vdr-1.2.6/device.h
--- vdr-1.2.6.orig/device.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/device.h	2004-02-17 13:56:52.000000000 +0100
@@ -198,6 +198,7 @@
   bool active;
   virtual void Action(void);
 protected:
+  public:
   enum ePidType { ptAudio, ptVideo, ptPcr, ptTeletext, ptDolby, ptOther };
   class cPidHandle {
   public:
@@ -221,6 +222,8 @@
          ///< Handle->used indicated how many receivers are using this PID.
          ///< Type indicates some special types of PIDs, which the device may
          ///< need to set in a specific way.
+  public:
+  	void vtxtPid( bool onoff );
 
 // Common Interface facilities:
 
@@ -252,6 +255,7 @@
   virtual void SetVideoFormat(bool VideoFormat16_9);
          ///< Sets the output video format to either 16:9 or 4:3 (only useful
          ///< if this device has an MPEG decoder).
+  virtual void SetVideoOutput(int VideoOutput);
   virtual eVideoSystem GetVideoSystem(void);
          ///< Returns the video system of the currently displayed material
          ///< (default is PAL).
diff -Nur vdr-1.2.6.orig/dvbdevice.c vdr-1.2.6/dvbdevice.c
--- vdr-1.2.6.orig/dvbdevice.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/dvbdevice.c	2004-02-17 15:11:23.000000000 +0100
@@ -22,6 +22,8 @@
 #include <linux/dvb/dmx.h>
 #include <linux/dvb/frontend.h>
 #include <linux/dvb/video.h>
+#include <dbox/avs_core.h>
+#include <dbox/saa7126_core.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include "channels.h"
@@ -70,7 +72,7 @@
   int fd_frontend;
   int cardIndex;
   fe_type_t frontendType;
-  cCiHandler *ciHandler;
+  /*cCiHandler *ciHandler;*/
   cChannel channel;
   const char *diseqcCommands;
   bool active;
@@ -81,20 +83,21 @@
   cCondVar newSet;
   bool SetFrontend(void);
   virtual void Action(void);
+  void SetVoltage(const fe_sec_voltage voltage, const uint32_t ms);
+  void SetTone(const fe_sec_tone_mode_t toneMode, const uint32_t ms);
 public:
-  cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType, cCiHandler *CiHandler);
+  cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType/*, cCiHandler *CiHandler*/);
   virtual ~cDvbTuner();
   bool IsTunedTo(const cChannel *Channel) const;
   void Set(const cChannel *Channel, bool Tune, bool UseCa);
   bool Locked(void) { return tunerStatus == tsLocked; }
   };
 
-cDvbTuner::cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType, cCiHandler *CiHandler)
+cDvbTuner::cDvbTuner(int Fd_Frontend, int CardIndex, fe_type_t FrontendType/*, cCiHandler *CiHandler*/)
 {
   fd_frontend = Fd_Frontend;
   cardIndex = CardIndex;
   frontendType = FrontendType;
-  ciHandler = CiHandler;
   diseqcCommands = NULL;
   active = false;
   useCa = false;
@@ -138,6 +141,20 @@
   return f;
 }
 
+void cDvbTuner::SetVoltage(const fe_sec_voltage voltage, const uint32_t ms)
+{
+	if (ioctl( fd_frontend,FE_SET_VOLTAGE, voltage) == 0) {
+		usleep(1000 * ms);
+	}
+}
+
+void cDvbTuner::SetTone(const fe_sec_tone_mode_t toneMode, const uint32_t ms)
+{
+	if (ioctl(fd_frontend,FE_SET_TONE,toneMode) == 0) {
+		usleep(1000 * ms);
+	}
+}
+
 bool cDvbTuner::SetFrontend(void)
 {
   dvb_frontend_parameters Frontend;
@@ -157,10 +174,10 @@
                   for (char *CurrentAction = NULL; (da = diseqc->Execute(&CurrentAction)) != cDiseqc::daNone; ) {
                       switch (da) {
                         case cDiseqc::daNone:      break;
-                        case cDiseqc::daToneOff:   CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF)); break;
-                        case cDiseqc::daToneOn:    CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_ON)); break;
-                        case cDiseqc::daVoltage13: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); break;
-                        case cDiseqc::daVoltage18: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_18)); break;
+                        case cDiseqc::daToneOff:   SetTone(SEC_TONE_OFF,15); break;
+                        case cDiseqc::daToneOn:    SetTone(SEC_TONE_ON,15); break;
+                        case cDiseqc::daVoltage13: SetVoltage(SEC_VOLTAGE_13,15); break;
+                        case cDiseqc::daVoltage18: SetVoltage(SEC_VOLTAGE_18,15); break;
                         case cDiseqc::daMiniA:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_A)); break;
                         case cDiseqc::daMiniB:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_B)); break;
                         case cDiseqc::daCodes: {
@@ -197,8 +214,8 @@
                tone = SEC_TONE_ON;
                }
             int volt = (channel.Polarization() == 'v' || channel.Polarization() == 'V') ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18;
-            CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, volt));
-            CHECK(ioctl(fd_frontend, FE_SET_TONE, tone));
+	    SetVoltage(fe_sec_voltage(volt),15);
+	    SetTone(fe_sec_tone_mode(tone),15);
             }
 
          frequency = abs(frequency); // Allow for C-band, where the frequency is less than the LOF
@@ -238,6 +255,12 @@
          esyslog("ERROR: attempt to set channel with unknown DVB frontend type");
          return false;
     }
+
+  struct dvb_frontend_event event;
+  if (errno !=0)
+    errno = 0;
+  while ((errno == 0) || (errno == EOVERFLOW))
+    ioctl(fd_frontend,FE_GET_EVENT, &event);
   if (ioctl(fd_frontend, FE_SET_FRONTEND, &Frontend) < 0) {
      esyslog("ERROR: frontend %d: %m", cardIndex);
      return false;
@@ -268,8 +291,9 @@
                  continue;
                  }
               }
-           if (tunerStatus >= tsLocked) {
-              if (ciHandler) {
+            if (tunerStatus >= tsLocked) tunerStatus = tsLocked;
+           /*if (tunerStatus >= tsLocked) {
+             if (ciHandler) {
                  if (ciHandler->Process() && useCa) {
                     if (tunerStatus != tsCam) {//XXX TODO update in case the CA descriptors have changed
                        for (int Slot = 0; Slot < ciHandler->NumSlots(); Slot++) {
@@ -297,10 +321,10 @@
                  else
                     tunerStatus = tsLocked;
                  }
-              }
+              }*/
            }
         // in the beginning we loop more often to let the CAM connection start up fast
-        newSet.TimedWait(mutex, (ciHandler && (time(NULL) - startTime < 20)) ? 100 : 1000);
+       newSet.TimedWait(mutex,   (time(NULL) - startTime < 20) ? 100 : 1000);
         }
   dsyslog("tuner thread ended on device %d (pid=%d)", cardIndex + 1, getpid());
 }
@@ -364,6 +388,10 @@
   // Video format:
 
   SetVideoFormat(Setup.VideoFormat ? VIDEO_FORMAT_16_9 : VIDEO_FORMAT_4_3);
+  
+  
+  // Video output:
+  SetVideoOutput(Setup.VideoOutput);
 
   // We only check the devices that must be present - the others will be checked before accessing them://XXX
 
@@ -372,8 +400,8 @@
      siProcessor = new cSIProcessor(DvbName(DEV_DVB_DEMUX, n));
      if (ioctl(fd_frontend, FE_GET_INFO, &feinfo) >= 0) {
         frontendType = feinfo.type;
-        ciHandler = cCiHandler::CreateCiHandler(DvbName(DEV_DVB_CA, n));
-        dvbTuner = new cDvbTuner(fd_frontend, CardIndex(), frontendType, ciHandler);
+        /*ciHandler = cCiHandler::CreateCiHandler(DvbName(DEV_DVB_CA, n));*/
+        dvbTuner = new cDvbTuner(fd_frontend, CardIndex(), frontendType/*, ciHandler*/);
         }
      else
         LOG_ERROR;
@@ -410,6 +438,8 @@
   return false;
 }
 
+cDvbDevice *cDvbDevice::mpDvbDevice = NULL;
+
 bool cDvbDevice::Initialize(void)
 {
   int found = 0;
@@ -417,7 +447,10 @@
   for (i = 0; i < MAXDVBDEVICES; i++) {
       if (UseDevice(NextCardIndex())) {
          if (Probe(DvbName(DEV_DVB_FRONTEND, i))) {
-            new cDvbDevice(i);
+			 if ( i == 0 )
+				mpDvbDevice = new cDvbDevice(i);
+			 else
+            	new cDvbDevice(i);
             found++;
             }
          else
@@ -434,10 +467,37 @@
   return found > 0;
 }
 
+cDvbDevice *cDvbDevice::getInstance( void )
+{
+	if ( mpDvbDevice != NULL )
+			return mpDvbDevice;
+	return NULL;
+}
+
+void cDvbDevice::SiP( bool onoff )
+{
+	if ( siProcessor != NULL )
+		{
+			if ( onoff )				
+				{
+					cChannel *Channel = Channels.GetByNumber( currentChannel );
+     				siProcessor->SetCurrentTransponder(Channel->Source(), Channel->Frequency());
+					siProcessor->SetStatus( true );
+					siProcessor->StartStopThread( true );
+				}
+			else
+				{
+					siProcessor->SetCurrentTransponder(0, 0);
+					siProcessor->SetStatus( false );
+					siProcessor->StartStopThread( false );
+				}
+		}
+}
+
 void cDvbDevice::MakePrimaryDevice(bool On)
 {
-  if (HasDecoder())
-     cDvbOsd::SetDvbDevice(On ? this : NULL);
+  //if (HasDecoder())
+    // cDvbOsd::SetDvbDevice(On ? this : NULL);
 }
 
 bool cDvbDevice::HasDecoder(void) const
@@ -562,6 +622,39 @@
      CHECK(ioctl(fd_video, VIDEO_SET_FORMAT, VideoFormat16_9 ? VIDEO_FORMAT_16_9 : VIDEO_FORMAT_4_3));
 }
 
+
+#define AVS_DEVICE     "/dev/dbox/avs0"
+#define SAA7126_DEVICE "/dev/dbox/saa0"
+
+void cDvbDevice::SetVideoOutput(int VideoOutput)
+{
+   const int avs_fd = open(AVS_DEVICE, O_RDWR);
+   if (avs_fd < 0)
+   {
+      LOG_ERROR_STR("SetVideoOutput open AVS device");
+      return;
+   }
+   int avs_arg = 0;
+   int saa_arg = SAA_MODE_FBAS;
+   switch (VideoOutput)
+   {
+      case 1: saa_arg = SAA_MODE_RGB;    avs_arg = 1; break;
+      case 2: saa_arg = SAA_MODE_SVIDEO;              break;
+      case 3: saa_arg = SAA_MODE_YUV_V;  avs_arg = 1; break;
+      case 4: saa_arg = SAA_MODE_YUV_C;  avs_arg = 1; break;
+   }
+   CHECK(ioctl(avs_fd, AVSIOSFBLK, &avs_arg));
+   close(avs_fd);
+   const int saa_fd = open(SAA7126_DEVICE, O_RDWR|O_NONBLOCK);
+   if (open(SAA7126_DEVICE, O_RDWR|O_NONBLOCK) < 0)
+   {
+      LOG_ERROR_STR("SetVideoOutput open SAA7126 device");
+      return;
+   }
+   CHECK(ioctl(saa_fd, SAAIOSMODE, &saa_arg));
+   close(saa_fd);
+}
+
 eVideoSystem cDvbDevice::GetVideoSystem(void)
 {
   eVideoSystem VideoSytem = vsPAL;
@@ -591,29 +684,32 @@
            }
         pesFilterParams.pid     = Handle->pid;
         pesFilterParams.input   = DMX_IN_FRONTEND;
-        pesFilterParams.output  = (Type <= ptTeletext && Handle->used <= 1) ? DMX_OUT_DECODER : DMX_OUT_TS_TAP;
-        pesFilterParams.pes_type= PesTypes[Type < ptOther ? Type : ptOther];
-        pesFilterParams.flags   = DMX_IMMEDIATE_START;
+        pesFilterParams.output  = DMX_OUT_DECODER;//(Type <= ptTeletext && Handle->used <= 1) ? DMX_OUT_DECODER : DMX_OUT_TS_TAP;
+       	pesFilterParams.pes_type= PesTypes[Type]; //PesTypes[Type < ptOther ? Type : ptOther];
+	pesFilterParams.flags = DMX_IMMEDIATE_START;
         if (ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams) < 0) {
            LOG_ERROR;
            return false;
            }
         }
-     else if (!Handle->used) {
-        CHECK(ioctl(Handle->handle, DMX_STOP));
-        if (Type <= ptTeletext) {
-           pesFilterParams.pid     = 0x1FFF;
+     else
+     	{
+		CHECK(ioctl(Handle->handle,DMX_STOP));
+		 if (!Handle->used) {
+        /*if (Type <= ptTeletext) {
+          /* pesFilterParams.pid     = 0x1FFF;
            pesFilterParams.input   = DMX_IN_FRONTEND;
            pesFilterParams.output  = DMX_OUT_DECODER;
            pesFilterParams.pes_type= PesTypes[Type];
-           pesFilterParams.flags   = DMX_IMMEDIATE_START;
+	   pesFilterParams.flags   = DMX_IMMEDIATE_START;
            CHECK(ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams));
-           if (PesTypes[Type] == DMX_PES_VIDEO) // let's only do this once
-              SetPlayMode(pmNone); // necessary to switch a PID from DMX_PES_VIDEO/AUDIO to DMX_PES_OTHER
-           }
+        //   if (PesTypes[Type] == DMX_PES_VIDEO) // let's only do this once
+          //    SetPlayMode(pmNone); // necessary to switch a PID from DMX_PES_VIDEO/AUDIO to DMX_PES_OTHER
+           }*/
         close(Handle->handle);
         Handle->handle = -1;
         }
+	}
      }
   return true;
 }
@@ -623,17 +719,16 @@
   // Avoid noise while switching:
 
   CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
-  CHECK(ioctl(fd_video, VIDEO_SET_BLANK, true));
-  CHECK(ioctl(fd_audio, AUDIO_CLEAR_BUFFER));
-  CHECK(ioctl(fd_video, VIDEO_CLEAR_BUFFER));
+  CHECK(ioctl(fd_video,VIDEO_SET_BLANK));
+  CHECK(ioctl(fd_audio,AUDIO_STOP));
+  CHECK(ioctl(fd_video,VIDEO_STOP));
 
   // Turn off live PIDs:
-
-  DelPid(pidHandles[ptAudio].pid);
-  DelPid(pidHandles[ptVideo].pid);
-  DelPid(pidHandles[ptPcr].pid, ptPcr);
-  DelPid(pidHandles[ptTeletext].pid);
-  DelPid(pidHandles[ptDolby].pid);
+  		DelPid(pidHandles[ptTeletext].pid);
+  		DelPid(pidHandles[ptVideo].pid);
+  		DelPid(pidHandles[ptAudio].pid);
+  		DelPid(pidHandles[ptPcr].pid, ptPcr);
+  		DelPid(pidHandles[ptDolby].pid);
 }
 
 bool cDvbDevice::ProvidesSource(int Source) const
@@ -659,8 +754,9 @@
            if (!HasPid(Channel->Vpid())) {
 #ifdef DO_MULTIPLE_RECORDINGS
               if (Channel->Ca() > CACONFBASE)
-                 needsDetachReceivers = !ciHandler // only LL-firmware can do non-live CA channels
-                                        || Ca() != Channel->Ca();
+                 /*needsDetachReceivers = !ciHandler // only LL-firmware can do non-live CA channels
+                                        || Ca() != Channel->Ca();*/
+		needsDetachReceivers = Ca()!=Channel->Ca();
               else if (!IsPrimaryDevice())
                  result = true;
 #ifdef DO_REC_AND_PLAY_ON_PRIMARY_DEVICE
@@ -683,7 +779,7 @@
 
 bool cDvbDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
 {
-  bool IsEncrypted = Channel->Ca() > CACONFBASE && !ciHandler; // only LL-firmware can do non-live CA channels
+  bool IsEncrypted = Channel->Ca() > CACONFBASE; //==101;// 101 = Premiere // > CACONFBASE && !ciHandler; // only LL-firmware can do non-live CA channels
 
   bool DoTune = !dvbTuner->IsTunedTo(Channel);
 
@@ -730,19 +826,58 @@
 
   dvbTuner->Set(Channel, DoTune, !EITScanner.UsesDevice(this)); //XXX 1.3: this is an ugly hack - find a cleaner solution
 
+  // this is needed for the dbox2...
+  // otherwise we don't get a picture sometimes or the tv picture looks like
+  // a replay :)
+  // not really perfect, but it works better than without it. If you switch to fast
+  // tv picture still gets stuck...
+  #define LOCKWAITTIME 10000
+  #define MAXCOUNT 20000
+  int lcounter = 0;
+  do
+  	{
+		lcounter++;
+		usleep(LOCKWAITTIME);
+	}
+  while ((!dvbTuner->Locked()) && (lcounter < MAXCOUNT));
+
+  usleep(LOCKWAITTIME);
+
   // PID settings:
 
   if (TurnOnLivePIDs) {
      aPid1 = Channel->Apid1();
      aPid2 = Channel->Apid2();
      int pPid = Channel->Ppid() ? Channel->Ppid() : Channel->Vpid();
-     if (!(AddPid(pPid, ptPcr) && AddPid(Channel->Apid1(), ptAudio) && AddPid(Channel->Vpid(), ptVideo))) {//XXX+ dolby dpid1!!! (if audio plugins are attached)
+    /* if (!(AddPid(pPid, ptPcr) && AddPid(Channel->Apid1(), ptAudio) && AddPid(Channel->Vpid(), ptVideo))) {//XXX+ dolby dpid1!!! (if audio plugins are attached)
         esyslog("ERROR: failed to set PIDs for channel %d on device %d", Channel->Number(), CardIndex() + 1);
         return false;
         }
      if (IsPrimaryDevice())
-        AddPid(Channel->Tpid(), ptTeletext);
+        AddPid(Channel->Tpid(), ptTeletext);*/
+
+	if (pPid!=0)
+		{
+			AddPid(pPid,ptPcr);
+		}
+	if (Channel->Apid1()!=0)
+		{
+			AddPid(Channel->Apid1(),ptAudio);
+		}
+	if (Channel->Vpid()!=0)
+		{
+			AddPid(Channel->Vpid(),ptVideo);
+		}
+	if (Channel->Tpid()!=0)
+		{
+			AddPid(Channel->Tpid(),ptTeletext);
+		}
+     CHECK(ioctl(fd_video,VIDEO_SELECT_SOURCE,VIDEO_SOURCE_DEMUX));
+     CHECK(ioctl(fd_video,VIDEO_PLAY));
+     CHECK(ioctl(fd_audio, AUDIO_SELECT_SOURCE,AUDIO_SOURCE_DEMUX));
      CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE,false));
+     CHECK(ioctl(fd_audio, AUDIO_PLAY));
      }
   else if (StartTransferMode)
      cControl::Launch(new cTransferControl(this, Channel->Vpid(), Channel->Apid1(), Channel->Apid2(), Channel->Dpid1(), Channel->Dpid2()));
@@ -803,7 +938,7 @@
   if (Receiving())
      return false;
 #endif
-  return cDevice::CanReplay() && (Ca() <= MAXDEVICES || ciHandler); // with non-LL-firmware we can only replay if there is no CA recording going on
+  return cDevice::CanReplay() && (Ca() <= MAXDEVICES);// || ciHandler); // with non-LL-firmware we can only replay if there is no CA recording going on
 }
 
 bool cDvbDevice::SetPlayMode(ePlayMode PlayMode)
@@ -818,18 +953,14 @@
   switch (PlayMode) {
     case pmNone:
          // special handling to return from PCM replay:
-         CHECK(ioctl(fd_video, VIDEO_SET_BLANK, true));
-         CHECK(ioctl(fd_video, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY));
-         CHECK(ioctl(fd_video, VIDEO_PLAY));
-
-         CHECK(ioctl(fd_video, VIDEO_STOP, true));
-         CHECK(ioctl(fd_audio, AUDIO_STOP, true));
-         CHECK(ioctl(fd_video, VIDEO_CLEAR_BUFFER));
-         CHECK(ioctl(fd_audio, AUDIO_CLEAR_BUFFER));
+	 CHECK(ioctl(fd_video,VIDEO_STOP));
+	 CHECK(ioctl(fd_audio,AUDIO_STOP));
          CHECK(ioctl(fd_video, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX));
+	 CHECK(ioctl(fd_video,VIDEO_PLAY));
          CHECK(ioctl(fd_audio, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_DEMUX));
          CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
          CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, false));
+	 CHECK(ioctl(fd_audio,AUDIO_PLAY));
          if (siProcessor)
             siProcessor->SetStatus(true);
          break;
@@ -907,7 +1038,10 @@
      }
   else {
      if (fd_audio >= 0)
+     {
         CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
+        CHECK(ioctl(fd_audio, AUDIO_CONTINUE));
+     }
      if (fd_video >= 0)
         CHECK(ioctl(fd_video, VIDEO_CONTINUE));
      }
@@ -922,7 +1056,10 @@
      }
   else {
      if (fd_audio >= 0)
+     {
         CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, false));
+        CHECK(ioctl(fd_audio, AUDIO_PAUSE));
+     }
      if (fd_video >= 0)
         CHECK(ioctl(fd_video, VIDEO_FREEZE));
      }
@@ -1044,10 +1181,56 @@
 
 int cDvbDevice::PlayVideo(const uchar *Data, int Length)
 {
-  int fd = (playMode == pmAudioOnly || playMode == pmAudioOnlyBlack) ? fd_audio : fd_video;
-  if (fd >= 0)
-     return write(fd, Data, Length);
-  return -1;
+   for (int i = 0; i < Length - 6; i++)
+      if (Data[i] == 0x00 && Data[i + 1] == 0x00 && Data[i + 2] == 0x01)
+      {
+         const int packet_length = Data[i + 4] * 256 + Data[i + 5] + 6;
+         if (i + packet_length > Length)
+         {
+            esyslog("ERROR: bad packet length %d at %d of %d.", packet_length, i, Length);
+            return -1;
+         }
+         const uchar packet_id = Data[i + 3];
+         int fd;
+         switch (packet_id) 
+         {
+            case 0xBD: // dolby
+            case 0xC0 ... 0xC1: // audio
+               fd = fd_audio;
+            break;
+            case 0xE0 ... 0xEF: // video
+               fd = fd_video;
+            break;
+            default:
+               esyslog("ERROR: unexpected packet id %02X.", packet_id);
+               fd = -1;
+         }
+         if (fd != -1)
+         {
+            int bytes_written = 0;
+            while (bytes_written < packet_length)
+            {
+               int l = write(fd, Data + bytes_written + i, packet_length - bytes_written);
+               if (l > 0) 
+                  bytes_written += l;
+               else if (l == -1)
+               {
+                  if (errno == EAGAIN)
+                     usleep(1);
+                  else
+                  {
+                     LOG_ERROR_STR("PlayVideo write");
+                     return -1;
+                  }
+               }
+            }
+            i += packet_length - 1; // the loop increments, too!
+         }
+      }
+      else
+         esyslog("ERROR: bad packet header %02X %02X %02X.", Data[i], Data[i + 1], Data[i + 2]);
+
+   return Length;
 }
 
 void cDvbDevice::PlayAudio(const uchar *Data, int Length)
diff -Nur vdr-1.2.6.orig/dvbdevice.h vdr-1.2.6/dvbdevice.h
--- vdr-1.2.6.orig/dvbdevice.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/dvbdevice.h	2004-02-17 13:14:56.000000000 +0100
@@ -36,6 +36,9 @@
          ///< Initializes the DVB devices.
          ///< Must be called before accessing any DVB functions.
          ///< \return True if any devices are available.
+	static cDvbDevice *mpDvbDevice;
+	static cDvbDevice *getInstance( void );
+	void SiP( bool onoff );
 private:
   fe_type_t frontendType;
   int fd_osd, fd_audio, fd_video, fd_dvr, fd_stc;
@@ -83,6 +86,7 @@
 
 public:
   virtual void SetVideoFormat(bool VideoFormat16_9);
+  virtual void SetVideoOutput(int VideoOutput);
   virtual eVideoSystem GetVideoSystem(void);
 
 // Audio facilities
diff -Nur vdr-1.2.6.orig/dvbosd.c vdr-1.2.6/dvbosd.c
--- vdr-1.2.6.orig/dvbosd.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/dvbosd.c	2004-02-11 15:19:48.000000000 +0100
@@ -13,14 +13,18 @@
 #include <sys/unistd.h>
 #include "tools.h"
 
-const cDvbDevice *cDvbOsd::dvbDevice = NULL;
+//const cDvbDevice *cDvbOsd::dvbDevice = NULL;
 
 cDvbOsd::cDvbOsd(int x, int y)
 :cOsdBase(x, y)
 {
-  osdDev = dvbDevice ? dvbDevice->OsdDeviceHandle() : -1;
-  if (dvbDevice && osdDev < 0)
-     esyslog("ERROR: illegal OSD device handle (%d)!", osdDev);
+  // framebuffer wrapper class, singleton
+  pFBOsd = cFBOsd::getInstance();
+  if (!pFBOsd)
+  	esyslog("ERROR: can't create framebuffer OSD!");
+  //osdDev = dvbDevice ? dvbDevice->OsdDeviceHandle() : -1;
+  //if (dvbDevice && osdDev < 0)
+    // esyslog("ERROR: illegal OSD device handle (%d)!", osdDev);
 }
 
 cDvbOsd::~cDvbOsd()
@@ -29,10 +33,10 @@
       CloseWindow(GetWindowNr(i));
 }
 
-void cDvbOsd::SetDvbDevice(const cDvbDevice *DvbDevice)
-{
-  dvbDevice = DvbDevice;
-}
+//void cDvbOsd::SetDvbDevice(const cDvbDevice *DvbDevice)
+//{
+//  dvbDevice = DvbDevice;
+//}
 
 bool cDvbOsd::SetWindow(cWindow *Window)
 {
@@ -51,7 +55,7 @@
 
 void cDvbOsd::Cmd(OSD_Command cmd, int color, int x0, int y0, int x1, int y1, const void *data)
 {
-  if (osdDev >= 0) {
+ // if (osdDev >= 0) {
      osd_cmd_t dc;
      dc.cmd   = cmd;
      dc.color = color;
@@ -60,8 +64,11 @@
      dc.x1    = x1;
      dc.y1    = y1;
      dc.data  = (void *)data;
-     ioctl(osdDev, OSD_SEND_CMD, &dc);
-     }
+
+    // no driver, no ioctl, instead use the wrapper class cFBOsd
+    // ioctl(osdDev, OSD_SEND_CMD, &dc);
+      pFBOsd->Cmd(&dc);
+   //  }
 }
 
 bool cDvbOsd::OpenWindow(cWindow *Window)
diff -Nur vdr-1.2.6.orig/dvbosd.h vdr-1.2.6/dvbosd.h
--- vdr-1.2.6.orig/dvbosd.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/dvbosd.h	2004-02-11 15:19:48.000000000 +0100
@@ -11,13 +11,16 @@
 #define __DVBOSD_H
 
 #include <linux/dvb/osd.h>
-#include "dvbdevice.h"
+//#include "dvbdevice.h"
 #include "osdbase.h"
+#include "fbosd.h"
 
 class cDvbOsd : public cOsdBase {
 private:
-  static const cDvbDevice *dvbDevice;
-  int osdDev;
+  //static const cDvbDevice *dvbDevice;
+  // cFBOsd: framebuffer OSD for DBox
+  cFBOsd* pFBOsd;
+  //int osdDev;
   bool SetWindow(cWindow *Window);
   void Cmd(OSD_Command cmd, int color = 0, int x0 = 0, int y0 = 0, int x1 = 0, int y1 = 0, const void *data = NULL);
 protected:
@@ -30,7 +33,7 @@
 public:
   cDvbOsd(int x, int y);
   virtual ~cDvbOsd();
-  static void SetDvbDevice(const cDvbDevice *DvbDevice);
+  //static void SetDvbDevice(const cDvbDevice *DvbDevice);
   };
 
 #endif //__DVBOSD_H
diff -Nur vdr-1.2.6.orig/eit.c vdr-1.2.6/eit.c
--- vdr-1.2.6.orig/eit.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/eit.c	2004-02-17 18:34:55.000000000 +0100
@@ -38,6 +38,8 @@
 #include "libdtv/libdtv.h"
 #include "videodir.h"
 
+cCaSystemIds* cCaSystemIds::pCaSystemIds = NULL;
+
 // --- cMJD ------------------------------------------------------------------
 
 class cMJD {
@@ -1084,6 +1086,7 @@
    pmtIndex = 0;
    pmtPid = 0;
    filters = NULL;
+
    if (!numSIProcessors++) { // the first one creates them
       schedules = new cSchedules;
       }
@@ -1294,7 +1297,8 @@
                         case 0x14:
                            if (buf[0] == 0x70)
                            {
-                              if (Setup.SetSystemTime && Setup.TimeTransponder && ISTRANSPONDER(currentTransponder, Setup.TimeTransponder))
+                              if ((time(NULL) < 365*24*60*60) || // if the system time is not set at all, set it even if not configured
+                                  (Setup.SetSystemTime && Setup.TimeTransponder && ISTRANSPONDER(currentTransponder, Setup.TimeTransponder)))
                               {
                                  cTDT ctdt((tdt_t *)buf);
                                  ctdt.SetSystemTime();
@@ -1451,12 +1455,15 @@
             return;
          }
      caDescriptors.Add(new cCaDescriptor(currentSource, currentTransponder, ServiceId, cd->CA_type, cd->ProviderID, cd->CA_PID, cd->DataLength, cd->Data));
+     cCaSystemIds::getInstance()->AddCaSystemId(cd->CA_type);
      //XXX update???
      }
 }
 
 int cSIProcessor::GetCaDescriptors(int Source, int Transponder, int ServiceId, const unsigned short *CaSystemIds, int BufSize, uchar *Data)
 {
+  CaSystemIds = NULL;
+  CaSystemIds = cCaSystemIds::getInstance()->GetCaSystemIds();
   if (!CaSystemIds || !*CaSystemIds)
      return 0;
   if (BufSize > 0 && Data) {
@@ -1481,3 +1488,44 @@
      }
   return -1;
 }
+
+void cSIProcessor::StartStopThread( bool onoff )
+{
+	if ( onoff )
+		{
+			active = true;
+			Start();
+		}
+	else
+		{
+			active = false;
+			Cancel( 3 );
+		}
+}
+
+
+
+cCaSystemIds* cCaSystemIds::getInstance( void )
+{
+	if ( pCaSystemIds == NULL )
+		pCaSystemIds = new cCaSystemIds;
+	return pCaSystemIds;
+}
+
+cCaSystemIds::cCaSystemIds( void )
+{
+	caSystemIds[ numCaSystemIds = 0 ] = 0;
+}
+
+void cCaSystemIds::AddCaSystemId( int id )
+{
+	for (int i = 0; i < numCaSystemIds; i++ )
+		if ( id == caSystemIds[i] ) return;
+
+	caSystemIds[ numCaSystemIds++ ] = id;
+}
+
+const unsigned short * cCaSystemIds::GetCaSystemIds( void )
+{
+	return caSystemIds;
+}
diff -Nur vdr-1.2.6.orig/eit.h vdr-1.2.6/eit.h
--- vdr-1.2.6.orig/eit.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/eit.h	2004-02-11 15:19:49.000000000 +0100
@@ -134,6 +134,23 @@
 
 }SIP_FILTER;
 
+#define MAXCASYSTEMIDS 16
+
+class cCaSystemIds {
+	public:
+		cCaSystemIds( void );
+		void AddCaSystemId( int id );
+		const unsigned short *GetCaSystemIds( void );
+
+	public:
+		static cCaSystemIds *getInstance( void );
+		static cCaSystemIds *pCaSystemIds;
+
+	private:
+		int numCaSystemIds;
+  		unsigned short caSystemIds[MAXCASYSTEMIDS + 1];
+};
+
 class cCaDescriptor;
 
 class cSIProcessor : public cThread {
@@ -179,6 +196,9 @@
   static void Clear(void);
   void SetStatus(bool On);
   void SetCurrentTransponder(int CurrentSource, int CurrentTransponder);
+
+	void StartStopThread( bool onoff );
+
   static bool SetCurrentChannelID(tChannelID channelid);
   static void TriggerDump(void);
   };
diff -Nur vdr-1.2.6.orig/fbosd.c vdr-1.2.6/fbosd.c
--- vdr-1.2.6.orig/fbosd.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/fbosd.c	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,305 @@
+/*
+ * fbosd.c replaces hardware osd driver
+ *
+ * (C) 2003 Alexander Olk <xenomorph2@onlinehome.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include "fbosd.h"
+#include "tools.h"
+
+cFBOsd* cFBOsd::mpFBOsd = NULL;
+
+CFBWindow::CFBWindow( const int _x, const int _y, const int _dx, const int _dy, int ibpp )
+{
+	x  = _x ;
+	y  = _y ;
+	dx = _dx;
+	dy = _dy;
+	bpp = ibpp;
+	showhide = false;
+	Block = NULL;
+	frameBuffer = NULL;
+	palette = NULL;
+	frameBuffer = CFrameBuffer::getInstance();
+
+	Block = new unsigned char [_dx * _dy];
+
+	// create a new palette for the window
+	// bpp = 2, palette size 4
+	// bpp = 4, palette size 16
+	// bpp = 8, palette size 256
+	palette = new unsigned char [1 << bpp];
+
+	for ( int i = 0 ; i < (1 << bpp) ; i++ )
+		palette[i] = i;
+}
+
+CFBWindow::~CFBWindow( void )
+{
+	if ( Block != NULL )
+	{
+		if ( frameBuffer != NULL )
+			{
+				frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+				frameBuffer = NULL;
+			}
+		delete Block;
+		Block = NULL;
+	}
+	if ( palette != NULL )
+		{
+			delete palette;
+			palette = NULL;
+		}
+}
+
+void CFBWindow::ShowHide( bool sh )
+{
+	if ( !sh && showhide )
+		if ( frameBuffer != NULL )
+			frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+	if ( sh && !showhide )
+		Show();
+	showhide = sh;
+
+}
+
+void CFBWindow::Show()
+{
+	if ( showhide )
+		if ( ( Block != NULL ) && ( frameBuffer != NULL ) )
+			frameBuffer->RestoreScreen( x, y, dx, dy, Block );
+}
+
+void CFBWindow::MoveWindow( int nx, int ny )
+{
+	showhide = true;
+	if ( ( nx != x ) || ( ny != y ) )
+		{
+			if ( frameBuffer != NULL )
+				frameBuffer->paintBackgroundBoxRel( x, y, dx, dy );
+			x = nx;
+			y = ny;
+		}
+	Show();
+}
+
+void CFBWindow::paletteSetColor( int nr, int acol )
+{
+	if ( palette != NULL )
+		palette[nr] = acol;
+}
+
+void CFBWindow::paletteSet()
+{
+	if ( Block != NULL )
+		{
+			unsigned char colfill = 0;
+			if ( palette != NULL )
+				colfill = ( palette[0] == 0 ) ? 0 : 1;
+			memset( Block, colfill, dx * dy );
+		}
+}
+
+int CFBWindow::SetBlock( osd_cmd_t *dc )
+{
+	if ( Block != NULL )
+		{
+       		uint w, h;
+
+		    w = dc->x1 - dc->x0 + 1; h = dc->y1 - dc->y0 + 1;
+        	if ( dc->color <= 0 )
+            	dc->color = w;
+        	if ( w <= 0 || w > 720 || h <= 0 || h > 576 )
+            	return -1;  // out of range...
+
+			unsigned char *pout = ( Block != NULL ) ? Block : NULL;
+
+			if ( pout == NULL ) return 0;
+	
+			//far from perfect ;) but it works...
+
+			for ( int _y = 0; _y < h; _y++ )
+				for ( int _x = 0; _x < w; _x++ )
+						pout[( _x + dc->x0 ) + dx* ( _y + dc->y0 )] = palette[( (unsigned char *) dc->data ) [_y * dc->color + _x]];
+
+			if ( showhide ) ShowBlock( dc, w, h );
+		}
+	return 1;
+}
+
+void CFBWindow::ShowBlock( osd_cmd_t *dc, uint w, uint h )
+{
+	if ( frameBuffer == NULL ) return;
+
+	unsigned int stride = frameBuffer != NULL ? frameBuffer->getStride() : 0;
+	unsigned char *fbpos = frameBuffer->getFrameBufferPointer() + x + dc->x0 + stride * ( y + dc->y0 );
+	unsigned char *pin = Block + dc->x0 + dx * dc->y0;
+
+	for ( int i = 0; i < h ; i++ )
+		{
+			memcpy( fbpos, pin, w - 1 );
+			fbpos += stride;
+			pin += dx;
+		}
+}
+
+//=========================================================================0
+
+cFBOsd::cFBOsd()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	// setup framebuffer - from neutrino src
+
+	frameBuffer->init();
+	if ( frameBuffer->setMode( 720, 576, 8 ) )
+		{
+			esyslog("Error while setting framebuffer mode");
+			exit( -1 );
+		}
+
+	// set the framebuffer palette with the colours of vdr
+
+	frameBuffer->ClearFrameBuffer();
+}
+
+cFBOsd::~cFBOsd()
+{
+	if ( frameBuffer != NULL )
+		{
+			for(int x=0;x<256;x++)
+				frameBuffer->paletteSetColor(x, 0x000000, 0xffff);
+
+			frameBuffer->paletteSet();
+
+			delete frameBuffer;
+		}
+
+	for ( int i = 0 ; i <= MAXNUMWINDOWS; i++ )
+		if ( win[i] != NULL ) delete win[i];
+}
+
+cFBOsd *cFBOsd::getInstance()
+{
+	if ( !mpFBOsd )
+		{
+			mpFBOsd = new cFBOsd();
+		}
+	return mpFBOsd;
+}
+
+void cFBOsd::Cmd( osd_cmd_t *dc )
+{
+	switch ( dc->cmd )
+		{
+			case OSD_Close:
+				//closes window "whandle"
+				if ( win[whandle] != NULL )
+					delete win[whandle];
+				win[whandle] = NULL;
+				return;
+			case OSD_Open:
+				// create a new window without showing it
+				win[whandle] = new CFBWindow (dc->x0, dc->y0, dc->x1, dc->y1, dc->color );
+				return;
+			case OSD_Show:
+				// set Show
+				if ( win[whandle] != NULL )
+					win[whandle]->ShowHide( true );
+				return;
+			case OSD_Hide:
+				// set Hide
+				if ( win[whandle] != NULL )
+					win[whandle]->ShowHide( false );
+				return;
+			case OSD_SetPalette:
+				// convert vdr cWindow palette to framebuffer palette
+				int len;
+				len = dc->x0 - dc->color + 1;
+				__u32 *colors;
+				int acol;
+				colors = ( __u32 * ) dc->data;
+				for ( int i = 0; i<len; i++ )
+					{
+						switch ( colors[i] )
+							{
+								case 0x00000000:
+									acol = 0;
+									break;
+								case 0x0000007F:
+								case 0x7F000000:
+									acol = 1;
+									break;
+								case 0x000000FF:
+								case 0xFF000000:
+									acol = 2;
+									break;
+								case 0xFC1414FF:
+								case 0xFF1414FC:
+									acol = 3;
+									break;
+								case 0x24FC24FF:
+								case 0xFF24FC24:
+									acol = 4;
+									break;
+								case 0xFCC024FF:
+								case 0xFF24C0FC:
+									acol = 5;
+									break;
+								case 0xB000FCFF:
+								case 0xFFFC00B0:
+									acol = 6;
+									break;
+								case 0x0000FCFF:
+								case 0xFFFC0000:
+									acol = 7;
+									break;
+								case 0x00FCFCFF:
+								case 0xFFFCFC00:
+									acol = 8;
+									break;
+								case 0xFCFCFCFF:
+								case 0xFFFCFCFC:
+									acol = 9;
+									break;
+							}
+						if ( win[whandle] != NULL )
+							win[whandle]->paletteSetColor( i, acol );
+					}
+				if ( win[whandle] != NULL )
+					win[whandle]->paletteSet();
+				return;
+			case OSD_MoveWindow:
+				// Move OSD window to new position and show it
+				if ( win[whandle] != NULL )
+					win[whandle]->MoveWindow( dc->x0, dc->y0 );
+				return;
+			case OSD_SetBlock:
+				// fills CFBWindow Block with vdr cWindow data (dc->data)
+				// dc->x0,y0,x1,y1 are the coordinates where dc->data will be written inside Block
+				if ( win[whandle] != NULL )
+					win[whandle]->SetBlock( dc );
+				return;
+			case OSD_SetWindow:
+				if ( dc->x0 < 1 || dc->x0 > 7 ) return;
+				whandle = dc->x0;
+				return;
+			default:
+				return;
+		}
+};
diff -Nur vdr-1.2.6.orig/fbosd.h vdr-1.2.6/fbosd.h
--- vdr-1.2.6.orig/fbosd.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/fbosd.h	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * fbosd.h
+ *
+ * (C) 2003 Alexander Olk <xenomorph2@onlinehome.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __FBOSD_H
+#define __FBOSD_H
+
+#include <linux/dvb/osd.h>
+#include "osdbase.h"
+#include "framebuffer.h"
+
+// CFBWindow class, taken from neutrino fbwindow source and modified a little bit :)
+class CFBWindow {
+
+ private:
+	int bpp; 				// bits per pixel, needed for palette
+	unsigned char *palette;	// holds the palette for the window
+						// global framebuffer palette is set in cFBOsd class
+	bool showhide;			// show or hide the window...
+	unsigned char *Block;		// holds data being sent from osd/osdbase
+	CFrameBuffer *frameBuffer;
+
+ public:
+	int x, y;   /* upper left corner */
+	int dx, dy; /* dimension         */
+
+	CFBWindow( const int _x, const int _y, const int _dx, const int _dy, int ibpp );
+	~CFBWindow();
+
+	// set showhide
+	void ShowHide( bool sh );
+	// moves window to a new position and shows it
+	void MoveWindow( int nx, int ny );
+	// fill Block with data from vdr cWindow
+	// dc has x0,y0,x1,y1 positions where dc->data should be put in Block
+	int SetBlock( osd_cmd_t *dc );
+	// set entry nr in window palette to colour acol
+	void paletteSetColor( int nr, int acol );
+	// fills Block with background colour according to first palette entry
+	// if palette[0]=1, background will be clrBackground (50%gray), else clrTransparent
+	void paletteSet();
+
+ private:
+ 	// writes (restores) contents of Block to framebuffer, called from MoveWindow
+ 	void Show();
+	// special for SetBlock, paints only updated area...
+	void ShowBlock( osd_cmd_t *dc, uint w, uint h );
+};
+
+// singleton...
+class cFBOsd {
+public:
+	cFBOsd();
+	~cFBOsd();
+
+	static cFBOsd* mpFBOsd;
+	static cFBOsd *getInstance();
+	// Cmd replaces ioctl of a real hardware driver
+	void Cmd( osd_cmd_t *dc );
+private:
+	CFrameBuffer		*frameBuffer;
+	int whandle; // handle which window ??
+	CFBWindow *win[MAXNUMWINDOWS];
+};
+
+
+#endif
+
+
diff -Nur vdr-1.2.6.orig/framebuffer.c vdr-1.2.6/framebuffer.c
--- vdr-1.2.6.orig/framebuffer.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/framebuffer.c	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,414 @@
+/*
+	Neutrino-GUI  -   DBoxII-Project
+
+	Copyright (C) 2001 Steffen Hehn 'McClean'
+                      2003 thegoodguy
+		      changes for vdr Alexander Olk
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <memory.h>
+
+#include <linux/kd.h>
+
+#include <stdint.h>
+#include <dbox/fb.h>
+#include "tools.h"
+
+#include "framebuffer.h"
+
+#define BACKGROUNDIMAGEWIDTH 720
+
+#define COL_BACKGROUND 		255
+
+static uint8_t * virtual_fb = NULL;
+
+CFrameBuffer::CFrameBuffer()
+: active ( true )
+{
+	available  = 0;
+	cmap.start = 0;
+	cmap.len = 256;
+	cmap.red = red;
+	cmap.green = green;
+	cmap.blue  = blue;
+	cmap.transp = trans;
+	backgroundColor = 0;
+	fd  = 0;
+	tty = 0;
+}
+
+CFrameBuffer* CFrameBuffer::getInstance()
+{
+	static CFrameBuffer* frameBuffer = NULL;
+
+	if(!frameBuffer)
+		{
+			frameBuffer = new CFrameBuffer();
+			isyslog("frameBuffer Instance created");
+		}
+	return frameBuffer;
+}
+
+void CFrameBuffer::init(std::string fbDevice)
+{
+	fd=open(fbDevice.c_str(), O_RDWR);
+	if (fd<0)
+	{
+		perror(fbDevice.c_str());
+		goto nolfb;
+	}
+
+	if (ioctl(fd, FBIOGET_VSCREENINFO, &screeninfo)<0)
+	{
+		perror("FBIOGET_VSCREENINFO");
+		goto nolfb;
+	}
+
+	memcpy(&oldscreen, &screeninfo, sizeof(screeninfo));
+
+	fb_fix_screeninfo fix;
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &fix)<0)
+	{
+		perror("FBIOGET_FSCREENINFO");
+		goto nolfb;
+	}
+
+	available=fix.smem_len;
+	isyslog("%dk video mem\n", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fd, 0);
+
+	if (!lfb)
+	{
+		perror("mmap");
+		goto nolfb;
+	}
+
+	if ((tty=open("/dev/vc/0", O_RDWR))<0)
+	{
+		perror("open (tty)");
+		goto nolfb;
+	}
+
+	struct sigaction act;
+
+	memset(&act,0,sizeof(act));
+	act.sa_handler  = switch_signal;
+	sigemptyset(&act.sa_mask);
+	sigaction(SIGUSR1,&act,NULL);
+	sigaction(SIGUSR2,&act,NULL);
+
+	struct vt_mode mode;
+
+	if (-1 == ioctl(tty,KDGETMODE, &kd_mode)) {
+		perror("ioctl KDGETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,VT_GETMODE, &vt_mode)) {
+      		perror("ioctl VT_GETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,VT_GETMODE, &mode)) {
+      		perror("ioctl VT_GETMODE");
+		goto nolfb;
+	}
+
+	mode.mode   = VT_PROCESS;
+	mode.waitv  = 0;
+	mode.relsig = SIGUSR1;
+	mode.acqsig = SIGUSR2;
+
+	if (-1 == ioctl(tty,VT_SETMODE, &mode)) {
+		perror("ioctl VT_SETMODE");
+		goto nolfb;
+	}
+
+	if (-1 == ioctl(tty,KDSETMODE, KD_GRAPHICS)) {
+		perror("ioctl KDSETMODE");
+		goto nolfb;
+	}
+
+	return;
+
+nolfb:
+	esyslog("framebuffer not available.\n");
+	lfb=0;
+}
+
+
+CFrameBuffer::~CFrameBuffer()
+{
+#ifdef RETURN_FROM_GRAPHICS_MODE
+	if (-1 == ioctl(tty,KDSETMODE, kd_mode))
+		perror("ioctl KDSETMODE");
+#endif
+
+	if (-1 == ioctl(tty,VT_SETMODE, &vt_mode))
+		perror("ioctl VT_SETMODE");
+
+	/*
+	if (available)
+		ioctl(fd, FBIOPUT_VSCREENINFO, &oldscreen);
+	if (lfb)
+		munmap(lfb, available);
+		*/
+
+	if (virtual_fb == NULL)
+		delete[] virtual_fb;
+}
+
+int CFrameBuffer::getFileHandle()
+{
+	return fd;
+}
+
+unsigned int CFrameBuffer::getStride()
+{
+	return stride;
+}
+
+unsigned char* CFrameBuffer::getFrameBufferPointer()
+{
+	if (active || (virtual_fb == NULL))
+		return lfb;
+	else
+		return virtual_fb;
+}
+
+bool CFrameBuffer::getActive()
+{
+	return (active || (virtual_fb != NULL));
+}
+
+t_fb_var_screeninfo *CFrameBuffer::getScreenInfo()
+{
+	return &screeninfo;
+}
+
+int CFrameBuffer::setMode(unsigned int nxRes, unsigned int nyRes, unsigned int nbpp)
+{
+	if (!available&&!active)
+		return -1;
+
+	screeninfo.xres_virtual=screeninfo.xres=nxRes;
+	screeninfo.yres_virtual=screeninfo.yres=nyRes;
+	screeninfo.bits_per_pixel=nbpp;
+
+	if (ioctl(fd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
+	{
+		perror("FBIOPUT_VSCREENINFO");
+		return -1;
+	}
+
+	if ((screeninfo.xres!=nxRes) && (screeninfo.yres!=nyRes) && (screeninfo.bits_per_pixel!=nbpp))
+	{
+		esyslog("SetMode failed: wanted: %dx%dx%d, got %dx%dx%d\n",
+		       nxRes, nyRes, nbpp,
+		       screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
+		return -1;
+	}
+
+	xRes = screeninfo.xres;
+	yRes = screeninfo.yres;
+	bpp  = screeninfo.bits_per_pixel;
+	fb_fix_screeninfo fix;
+
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &fix)<0)
+	{
+		perror("FBIOGET_FSCREENINFO");
+		return -1;
+	}
+
+	stride=fix.line_length;
+	memset(getFrameBufferPointer(), 0, stride*yRes);
+	return 0;
+}
+
+
+void CFrameBuffer::paletteFade(int i, __u32 rgb1, __u32 rgb2, int level)
+{
+	__u16 *r = cmap.red+i;
+	__u16 *g = cmap.green+i;
+	__u16 *b = cmap.blue+i;
+	*r= ((rgb2&0xFF0000)>>16)*level;
+	*g= ((rgb2&0x00FF00)>>8 )*level;
+	*b= ((rgb2&0x0000FF)    )*level;
+	*r+=((rgb1&0xFF0000)>>16)*(255-level);
+	*g+=((rgb1&0x00FF00)>>8 )*(255-level);
+	*b+=((rgb1&0x0000FF)    )*(255-level);
+}
+
+void CFrameBuffer::setTransparency( int tr )
+{
+	if (!active)
+		return;
+
+	if (tr> 8)
+		tr= 8;
+
+	int val = (tr << 8) | tr;
+	if (ioctl(fd, AVIA_GT_GV_SET_BLEV, val ))
+		perror("AVIA_GT_GV_SET_BLEV");
+}
+
+void CFrameBuffer::setAlphaFade(int in, int num, int tr)
+{
+	for (int i=0; i<num; i++)
+	{
+		cmap.transp[in+i]=tr;
+		//tr++;
+	}
+}
+
+void CFrameBuffer::paletteGenFade(int in, __u32 rgb1, __u32 rgb2, int num, int tr)
+{
+	for (int i=0; i<num; i++)
+	{
+		paletteFade(in+i, rgb1, rgb2, i*(255/(num-1)));
+		cmap.transp[in+i]=tr;
+		tr++;
+	}
+}
+
+void CFrameBuffer::paletteSetColor(int i, __u32 rgb, int tr)
+{
+	cmap.red[i]    =(rgb&0xFF0000)>>8;
+	cmap.green[i]  =(rgb&0x00FF00)   ;
+	cmap.blue[i]   =(rgb&0x0000FF)<<8;
+	cmap.transp[i] =tr;
+}
+
+void CFrameBuffer::paletteSet(struct fb_cmap *map)
+{
+	if (!active)
+		return;
+	
+	if(map == NULL)
+		map = &cmap;
+
+	ioctl(fd, FBIOPUTCMAP, map);
+}
+
+
+void CFrameBuffer::paintBoxRel(int x, int y, int dx, int dy, unsigned char col)
+{
+	if (!getActive())
+		return;
+
+	unsigned char* pos = getFrameBufferPointer() + x + stride*y;
+	for(int count=0;count<dy;count++)
+	{
+		memset(pos, col, dx);
+		pos += stride;
+	}
+}
+
+void CFrameBuffer::setBackgroundColor(int color)
+{
+	backgroundColor = color;
+}
+
+void CFrameBuffer::paintBackgroundBoxRel(int x, int y, int dx, int dy)
+{
+	if (!getActive())
+		return;
+	paintBoxRel(x, y, dx, dy, backgroundColor);
+}
+
+void CFrameBuffer::RestoreScreen(int x, int y, int dx, int dy, unsigned char* memp)
+{
+	if (!getActive())
+		return;
+
+	unsigned char *fbpos = getFrameBufferPointer() + x + stride*y;
+	unsigned char *bkpos = memp;
+	for(int count=0;count<dy;count++)
+	{
+		memcpy(fbpos, bkpos, dx);
+		fbpos += stride;
+		bkpos += dx;
+	}
+}
+
+void CFrameBuffer::switch_signal (int signal)
+{
+	CFrameBuffer * thiz = CFrameBuffer::getInstance();
+	if (signal == SIGUSR1) {
+		if (virtual_fb == NULL)
+			delete[] virtual_fb;
+		virtual_fb = new uint8_t[thiz->stride * thiz->yRes];
+		thiz->active = false;
+		if (virtual_fb != NULL)
+			memcpy(virtual_fb, thiz->lfb, thiz->stride * thiz->yRes);
+		ioctl(thiz->tty, VT_RELDISP, 1);
+		isyslog ("release display\n");
+	}
+	else if (signal == SIGUSR2) {
+		ioctl(thiz->tty, VT_RELDISP, VT_ACKACQ);
+		thiz->active = true;
+		isyslog ("acquire display\n");
+		thiz->paletteSet(NULL);
+		if (virtual_fb != NULL)
+			memcpy(thiz->lfb, virtual_fb, thiz->stride * thiz->yRes);
+		else
+			memset(thiz->lfb, 0, thiz->stride*thiz->yRes);
+	}
+}
+
+void CFrameBuffer::ClearFrameBuffer()
+{
+	setBackgroundColor(COL_BACKGROUND);
+
+	//background
+	paletteSetColor(COL_BACKGROUND, 0x000000, 0xffff);
+
+	// vdr colors
+	paletteSetColor(0,0x00000000,0xffff);
+	paletteSetColor(1,0x7F000000,0x7fff);
+	paletteSetColor(2,0xFF000000,0);
+	paletteSetColor(3,0xFF1414FC,0);
+	paletteSetColor(4,0xFF24FC24,0);
+	paletteSetColor(5,0xFF24C0FC,0);
+	paletteSetColor(6,0xFFFC00B0,0);
+	paletteSetColor(7,0xFFFC0000,0);
+	paletteSetColor(8,0xFFFCFC00,0);
+	paletteSetColor(9,0xFFFCFCFC,0);
+
+	paletteSetColor(10, 0x000000, 0);
+	paletteSetColor(11, 0x000000, 0);
+	paletteSetColor(12, 0x000000, 0);
+	paletteSetColor(13, 0x000000, 0);
+	paletteSetColor(14, 0x000000, 0);
+	paletteSetColor(15, 0x000000, 0);
+	paletteSetColor(16, 0x000000, 0);
+
+	paletteSet();
+}
diff -Nur vdr-1.2.6.orig/framebuffer.h vdr-1.2.6/framebuffer.h
--- vdr-1.2.6.orig/framebuffer.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/framebuffer.h	2004-02-11 15:19:49.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+	Neutrino-GUI  -   DBoxII-Project
+
+	Copyright (C) 2001 Steffen Hehn 'McClean'
+	Homepage: http://dbox.cyberphoria.org/
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#ifndef __framebuffer__
+#define __framebuffer__
+
+
+#include <linux/fb.h>
+#include <linux/vt.h>
+
+#include <stdint.h>
+#include <string>
+
+typedef struct fb_var_screeninfo t_fb_var_screeninfo;
+
+/** Ausfhrung als Singleton */
+class CFrameBuffer
+{
+	private:
+
+		CFrameBuffer();
+
+		struct rgbData
+		{
+			uint8_t r;
+			uint8_t g;
+			uint8_t b;
+		} __attribute__ ((packed));
+
+		struct rawHeader
+		{
+			uint8_t width_lo;
+			uint8_t width_hi;
+			uint8_t height_lo;
+			uint8_t height_hi;
+			uint8_t transp;
+		} __attribute__ ((packed));
+
+		int             fd, tty;
+		unsigned char * lfb;
+		int		available;
+		int             backgroundColor;
+		unsigned int	xRes, yRes, stride, bpp;
+		t_fb_var_screeninfo screeninfo, oldscreen;
+		fb_cmap cmap;
+		__u16 red[256], green[256], blue[256], trans[256];
+
+		void paletteFade(int i, __u32 rgb1, __u32 rgb2, int level);
+
+		int 	kd_mode;
+		struct	vt_mode vt_mode;
+		bool	active;
+		static	void switch_signal (int);
+
+	public:
+
+		~CFrameBuffer();
+
+		static CFrameBuffer* getInstance();
+
+		void init(std::string fbDevice="/dev/fb/0");
+		int setMode(unsigned int xRes, unsigned int yRes, unsigned int bpp);
+
+
+		int getFileHandle(); //only used for plugins (games) !!
+		t_fb_var_screeninfo *getScreenInfo();
+
+		unsigned char* getFrameBufferPointer(); //pointer to framebuffer
+		unsigned int getStride(); //stride (anzahl bytes die eine Zeile im Framebuffer belegt)
+		bool getActive(); //is framebuffer active
+
+		void setTransparency( int tr = 0 );
+
+		//Palette stuff
+		void setAlphaFade(int in, int num, int tr);
+		void paletteGenFade(int in, __u32 rgb1, __u32 rgb2, int num, int tr=0);
+		void paletteSetColor(int i, __u32 rgb, int tr);
+		void paletteSet(struct fb_cmap *map = NULL);
+
+		void paintBoxRel(int x, int y, int dx, int dy, unsigned char col);
+
+		int getBackgroundColor() { return backgroundColor;}
+		void setBackgroundColor(int color);
+		void paintBackgroundBoxRel(int x, int y, int dx, int dy);
+
+		void RestoreScreen(int x, int y, int dx, int dy, unsigned char* memp);
+
+		void ClearFrameBuffer();
+
+};
+
+
+#endif
diff -Nur vdr-1.2.6.orig/menu.c vdr-1.2.6/menu.c
--- vdr-1.2.6.orig/menu.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/menu.c	2004-02-17 13:18:55.000000000 +0100
@@ -2044,15 +2044,18 @@
 
 cMenuSetupDVB::cMenuSetupDVB(void)
 {
+  static const char * const VideoOutputTexts[] = {"CVBS", "RGB", "S-VIDEO", "YUV_V", "YUV_C"};
   SetSection(tr("DVB"));
   Add(new cMenuEditIntItem( tr("Setup.DVB$Primary DVB interface"), &data.PrimaryDVB, 1, cDevice::NumDevices()));
   Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
+  Add(new cMenuEditStraItem(tr("Setup.DVB$Video output"),          &data.VideoOutput, sizeof(VideoOutputTexts)/sizeof(char *), VideoOutputTexts));
 }
 
 eOSState cMenuSetupDVB::ProcessKey(eKeys Key)
 {
   int oldPrimaryDVB = Setup.PrimaryDVB;
   bool oldVideoFormat = Setup.VideoFormat;
+  int  oldVideoOutput = Setup.VideoOutput;
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
   if (state == osBack && Key == kOk) {
@@ -2060,6 +2063,8 @@
         state = osSwitchDvb;
      if (Setup.VideoFormat != oldVideoFormat)
         cDevice::PrimaryDevice()->SetVideoFormat(Setup.VideoFormat);
+     if (Setup.VideoOutput != oldVideoOutput)
+        cDevice::PrimaryDevice()->SetVideoOutput(Setup.VideoOutput);
      }
   return state;
 }
diff -Nur vdr-1.2.6.orig/plugin.c vdr-1.2.6/plugin.c
--- vdr-1.2.6.orig/plugin.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/plugin.c	2004-02-11 15:19:49.000000000 +0100
@@ -112,6 +112,11 @@
   return MakeDirs(buffer, true) ? buffer : NULL;
 }
 
+void * cPlugin::GetSetData( int what )
+{
+	return NULL;
+}
+
 // --- cDll ------------------------------------------------------------------
 
 cDll::cDll(const char *FileName, const char *Args)
diff -Nur vdr-1.2.6.orig/plugin.h vdr-1.2.6/plugin.h
--- vdr-1.2.6.orig/plugin.h	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/plugin.h	2004-02-11 15:19:49.000000000 +0100
@@ -47,6 +47,8 @@
 
   void RegisterI18n(const tI18nPhrase * const Phrases);
 
+  virtual void *GetSetData( int what );
+
   static void SetConfigDirectory(const char *Dir);
   static const char *ConfigDirectory(const char *PluginName = NULL);
   };
diff -Nur vdr-1.2.6.orig/recording.c vdr-1.2.6/recording.c
--- vdr-1.2.6.orig/recording.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/recording.c	2004-02-16 21:36:59.000000000 +0100
@@ -784,6 +784,14 @@
 // The minimum age of an index file for considering it no longer to be written:
 #define MININDEXAGE    3600 // seconds
 
+inline int swap32(int x)
+
+{
+   return
+     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |
+      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24));
+}
+
 cIndexFile::cIndexFile(const char *FileName, bool Record)
 :resumeFile(FileName)
 {
@@ -821,6 +829,8 @@
                           close(f);
                           f = -1;
                           }
+                          else for (int i = 0; i < size; i++)
+                             index[i].offset = swap32(index[i].offset);
                        // we don't close f here, see CatchUp()!
                        }
                     else
@@ -916,7 +926,7 @@
 bool cIndexFile::Write(uchar PictureType, uchar FileNumber, int FileOffset)
 {
   if (f >= 0) {
-     tIndex i = { FileOffset, PictureType, FileNumber, 0 };
+     tIndex i = { swap32(FileOffset), PictureType, FileNumber, 0 };
      if (safe_write(f, &i, sizeof(i)) < 0) {
         LOG_ERROR_STR(fileName);
         close(f);
diff -Nur vdr-1.2.6.orig/thread.c vdr-1.2.6/thread.c
--- vdr-1.2.6.orig/thread.c	2004-02-19 08:34:47.000000000 +0100
+++ vdr-1.2.6/thread.c	2004-02-11 15:19:50.000000000 +0100
@@ -391,4 +391,3 @@
      _exit(0);
      }
 }
-
diff -Nur vdr-1.2.6.orig/vdr.c vdr-1.2.6/vdr.c
--- vdr-1.2.6.orig/vdr.c	2004-02-19 08:34:48.000000000 +0100
+++ vdr-1.2.6/vdr.c	2004-02-17 17:04:29.000000000 +0100
@@ -69,6 +69,12 @@
   signal(signum, SignalHandler);
 }
 
+static void HandleSegv(int signum)
+{
+  esyslog("Process %d received signal %d. Sleeping.", getpid(), signum);
+  sleep(3600);
+}
+
 static void Watchdog(int signum)
 {
   // Something terrible must have happened that prevented the 'alarm()' from
@@ -446,6 +452,8 @@
   if (signal(SIGPIPE, SignalHandler) == SIG_IGN) signal(SIGPIPE, SIG_IGN);
   if (WatchdogTimeout > 0)
      if (signal(SIGALRM, Watchdog)   == SIG_IGN) signal(SIGALRM, SIG_IGN);
+  
+  signal(SIGSEGV, HandleSegv);
 
   // Watchdog:
 
