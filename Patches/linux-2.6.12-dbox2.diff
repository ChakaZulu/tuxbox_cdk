diff --git a/arch/ppc/Kconfig b/arch/ppc/Kconfig
--- a/arch/ppc/Kconfig
+++ b/arch/ppc/Kconfig
@@ -525,6 +525,9 @@ config WINCEPT
 	  MPC821 PowerPC, introduced in 1998 and designed to be used in
 	  thin-client machines.  Say Y to support it directly.
 
+config DBOX2
+	bool "dbox2"
+
 endchoice
 
 choice
diff --git a/arch/ppc/platforms/Makefile b/arch/ppc/platforms/Makefile
--- a/arch/ppc/platforms/Makefile
+++ b/arch/ppc/platforms/Makefile
@@ -46,6 +46,7 @@ obj-$(CONFIG_SANDPOINT)		+= sandpoint.o
 obj-$(CONFIG_SBC82xx)		+= sbc82xx.o
 obj-$(CONFIG_SPRUCE)		+= spruce.o
 obj-$(CONFIG_LITE5200)		+= lite5200.o
+obj-$(CONFIG_DBOX2)			+= dbox2.o
 
 ifeq ($(CONFIG_SMP),y)
 obj-$(CONFIG_PPC_PMAC)		+= pmac_smp.o
diff --git a/arch/ppc/platforms/dbox2.c b/arch/ppc/platforms/dbox2.c
new file mode 100644
--- /dev/null
+++ b/arch/ppc/platforms/dbox2.c
@@ -0,0 +1,220 @@
+/*
+ * arch/ppc/platforms/dbox2.c
+ *
+ * setup routines for the dbox2 board
+ *
+ * Copyright (C) 2004 Andreas Oberritter <obi@linuxtv.org>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/commproc.h>
+#include <asm/io.h>
+
+enum dbox2_mid {
+	MID_NOKIA	= 1,
+	MID_PHILIPS	= 2,
+	MID_SAGEM	= 3,
+};
+
+const char *manuf_name[3] = {
+	"Nokia",
+	"Philips",
+	"Sagem",
+};
+
+static unsigned int manuf_id;
+
+static struct resource enx_resources[] = {
+	[0] = {
+		.start	= 0x08000000,
+		.end	= 0x080033ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0x09000000,
+		.end	= 0x091fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= SIU_IRQ1,
+		.end	= SIU_IRQ1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device enx_device = {
+	.name		= "enx",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(enx_resources),
+	.resource	= enx_resources,
+};
+
+static struct resource gtx_resources[] = {
+	[0] = {
+		.start	= 0x08400000,
+		.end	= 0x08402fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0x08000000,
+		.end	= 0x081fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= SIU_IRQ1,
+		.end	= SIU_IRQ1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gtx_device = {
+	.name		= "gtx",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(gtx_resources),
+	.resource	= gtx_resources,
+};
+
+static struct resource fp_resources[] = {
+	[0] = {
+		.start	= SIU_IRQ2,
+		.end	= SIU_IRQ2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device fp_device = {
+	.name		= "fp",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(fp_resources),
+	.resource	= fp_resources,
+};
+
+static struct resource fe_resources[] = {
+	[0] = {
+		.start	= SIU_IRQ7,
+		.end	= SIU_IRQ7,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device fe_device = {
+	.name		= "fe",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(fe_resources),
+	.resource	= fe_resources,
+};
+
+static struct resource cam_resources[] = {
+	[0] = {
+		.start	= 0x0c000000,
+		.end	= 0x0c01ffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SIU_IRQ3,
+		.end	= SIU_IRQ3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cam_device = {
+	.name		= "cam",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(cam_resources),
+	.resource	= cam_resources,
+};
+
+static struct resource avia_resources[] = {
+	[0] = {
+		.start	= 0x0a000000,
+		.end	= 0x0a0001ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SIU_IRQ4,
+		.end	= SIU_IRQ4,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device avia_device = {
+	.name		= "avia",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(avia_resources),
+	.resource	= avia_resources,
+};
+
+static ssize_t dbox2_manufacturer_node(struct bus_type *bus, char *buf)
+{
+	return sprintf(buf, "%s\n", manuf_name[manuf_id - 1]);
+}
+static BUS_ATTR(manufacturer, S_IRUGO, dbox2_manufacturer_node, NULL);
+
+static ssize_t dbox2_mID_node(struct bus_type *bus, char *buf)
+{
+	return sprintf(buf, "%d\n", manuf_id);
+}
+static BUS_ATTR(mID, S_IRUGO, dbox2_mID_node, NULL);
+
+static struct bus_attribute *const platform_bus_attrs[] = {
+	&bus_attr_manufacturer,
+	&bus_attr_mID,
+	NULL
+};
+
+static struct platform_device *dbox2_devs[] __initdata = {
+	&enx_device,
+	&fp_device,
+	&fe_device,
+	&cam_device,
+	&avia_device,
+};
+
+static int __init dbox2_add_devices(void)
+{
+	u8 *config_area;
+	int i;
+
+	config_area = ioremap(0x1001ffe0, 0x20);
+	if (!config_area) {
+		printk(KERN_ERR "dbox2: could not map config area!\n");
+		return -EIO;
+	}
+	manuf_id = config_area[0];
+	iounmap(config_area);
+
+	if ((manuf_id < MID_NOKIA) || (manuf_id > MID_SAGEM)) {
+		printk(KERN_ERR "dbox2: invalid config area!\n");
+		return -EIO;
+	}
+
+	printk(KERN_INFO "dbox2: %s board detected.\n", manuf_name[manuf_id - 1]);
+
+	if (manuf_id == MID_NOKIA) {
+		dbox2_devs[0] = &gtx_device;
+	} else if (manuf_id == MID_PHILIPS) {
+		cam_resources[0].start += 0x40000;
+		cam_resources[0].end += 0x40000;
+	}
+	fe_device.dev.platform_data = (void*)manuf_id;
+	
+	for (i=0; platform_bus_attrs[i]; i++){
+		int ret = bus_create_file(&platform_bus_type, platform_bus_attrs[i]);
+		if (ret<0){
+			while (--i>=0){
+				bus_remove_file(&platform_bus_type, platform_bus_attrs[i]);
+			}
+			printk(KERN_ERR "dbox2: error creating platform bus attributes: errno: %d\n",ret);
+		}
+	}
+	
+	return platform_add_devices(dbox2_devs, ARRAY_SIZE(dbox2_devs));
+}
+
+void __init board_init(void)
+{
+	device_initcall(dbox2_add_devices);
+}
diff --git a/arch/ppc/platforms/dbox2.h b/arch/ppc/platforms/dbox2.h
new file mode 100644
--- /dev/null
+++ b/arch/ppc/platforms/dbox2.h
@@ -0,0 +1,29 @@
+/*
+ * arch/ppc/platforms/dbox2.h
+ *
+ * Copyright (c) 2001-2002 Florian Schirmer <jolt@tuxbox.org>
+ *
+ */
+
+#ifndef _PPC_PLATFORMS_DBOX2_H
+#define _PPC_PLATFORMS_DBOX2_H
+
+#include <asm/ppcboot.h>
+
+/* physical base address of IMMR area */
+#define IMAP_ADDR	0xFF000000
+/* mapped size of IMMR area */
+#define IMAP_SIZE	(64 * 1024)
+
+#define PA_ENET_RXD	((u16)0x0004)
+#define PA_ENET_TXD	((u16)0x0008)
+#define PA_ENET_RCLK	((u16)0x0200)
+#define PA_ENET_TCLK	((u16)0x0800)
+#define PC_ENET_TENA	((u16)0x0002)
+#define PC_ENET_CLSN	((u16)0x0040)
+#define PC_ENET_RENA	((u16)0x0080)
+
+#define SICR_ENET_MASK	((u32)0x0000ff00)
+#define SICR_ENET_CLKRT	((u32)0x00003d00)
+
+#endif /* _PPC_PLATFORMS_DBOX2_H */
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -357,6 +357,17 @@ config FB_OF
 	  Say Y if you want support with Open Firmware for your graphics
 	  board.
 
+config FB_DBOX2
+	bool "Framebuffer generic functions (for dbox2)"
+	depends on FB && PPC
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SOFT_CURSOR
+	help
+	  Say Y here to include the generic functions necessary for
+	  building the (external) dbox2 driver
+
 config FB_CONTROL
 	bool "Apple \"control\" display support"
 	depends on (FB = y) && PPC_PMAC
diff --git a/include/asm-ppc/mpc8xx.h b/include/asm-ppc/mpc8xx.h
--- a/include/asm-ppc/mpc8xx.h
+++ b/include/asm-ppc/mpc8xx.h
@@ -32,6 +32,10 @@
 #include <platforms/rpxclassic.h>
 #endif
 
+#ifdef CONFIG_DBOX2
+#include <platforms/dbox2.h>
+#endif
+
 #if defined(CONFIG_TQM8xxL)
 #include <platforms/tqm8xx.h>
 #endif
