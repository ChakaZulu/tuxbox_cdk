diff -Naur procps-010114.orig/Makefile procps-010114/Makefile
--- procps-010114.orig/Makefile	2001-01-13 12:00:48.000000000 +0100
+++ procps-010114/Makefile	2006-03-04 11:40:14.000000000 +0100
@@ -31,17 +31,6 @@
 
 SUBDIRS    =  ps # sub-packages to build/install
 
-# easy to command-line override
-export INCDIRS    =  -I/usr/include/ncurses -I/usr/X11R6/include
-
-export CC         =  gcc #-ggdb # this gets compiling and linking :-)
-export OPT        =  -O2
-export CFLAGS     =  -D_GNU_SOURCE $(OPT) -I$(shell pwd) $(INCDIRS) -W -Wall -Wstrict-prototypes -Wshadow -Wcast-align -Wmissing-prototypes
-
-export SHARED     =  1# build/install both a static and ELF shared library
-export SHLIBDIR   =  $(DESTDIR)/lib# where to install the shared library
-
-export LDFLAGS    =  -Wl,-warn-common #-s	recommended for ELF systems
 #LDFLAGS    =  -qmagic -s#		recommended for a.out systems
 #LDFLAGS    =  -Xlinker -qmagic -s#	older a.out systems may need this
 #LDFLAGS    =  -N -s#			still older a.out systems use this
diff -Naur procps-010114.orig/proc/ksym.c procps-010114/proc/ksym.c
--- procps-010114.orig/proc/ksym.c	2001-01-13 10:46:07.000000000 +0100
+++ procps-010114/proc/ksym.c	2006-03-04 11:40:14.000000000 +0100
@@ -112,7 +112,7 @@
 
 /* These mostly rely on POSIX to make them zero. */
 
-static const symb hashtable[256];
+static symb hashtable[256];
 
 static char       *sysmap_data;
 static unsigned    sysmap_room;
@@ -224,7 +224,7 @@
     default:     _exit(101);
     case EACCES:   /* somebody screwing around? */
       /* FIXME: set a flag to disable symbol lookup? */
-    case ENOENT:   /* no module support */
+    case ENOENT:;   /* no module support */
     }
     goto hell;
   }
diff -Naur procps-010114.orig/proc/proc/compare.h procps-010114/proc/proc/compare.h
--- procps-010114.orig/proc/proc/compare.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/compare.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,9 @@
+typedef int (*cmp_t)(void*,void*);       /* for function pointer casts */
+
+extern void register_sort_function (int dir, cmp_t func);
+extern void reset_sort_options(void);
+extern int mult_lvl_cmp(void* a, void* b);
+extern int node_mult_lvl_cmp(void* a, void* b);
+extern const char *parse_sort_opt(const char* opt);
+extern const char *parse_long_sort(const char* opt);
+
diff -Naur procps-010114.orig/proc/proc/devname.h procps-010114/proc/proc/devname.h
--- procps-010114.orig/proc/proc/devname.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/devname.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,7 @@
+#define ABBREV_DEV  1     /* remove /dev/         */
+#define ABBREV_TTY  2     /* remove tty           */
+#define ABBREV_PTS  4     /* remove pts/          */
+
+int dev_to_tty(char *ret, int chop, int dev, int pid, unsigned int flags);
+
+int tty_to_dev(char *name);
diff -Naur procps-010114.orig/proc/proc/procps.h procps-010114/proc/proc/procps.h
--- procps-010114.orig/proc/proc/procps.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/procps.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,27 @@
+/* The shadow of the original with only common prototypes now. */
+#include <stdio.h>
+#include <sys/types.h>
+
+/* The HZ constant from <asm/param.h> is replaced by the Hertz variable
+ * available from "proc/sysinfo.h".
+ */
+
+/* get page info */
+#include <asm/page.h>
+
+void *xrealloc(void *oldp, unsigned int size);
+void *xmalloc(unsigned int size);
+void *xcalloc(void *pointer, int size);
+       
+int   mult_lvl_cmp(void* a, void* b);
+int   node_mult_lvl_cmp(void* a, void* b);
+       
+char *user_from_uid(uid_t uid);
+char *group_from_gid(gid_t gid);
+
+const char * wchan(unsigned long address);
+int   open_psdb(const char *override);
+int   open_psdb_message(const char *override, void (*message)(const char *, ...));
+
+unsigned print_str    (FILE* file, char *s, unsigned max);
+unsigned print_strlist(FILE* file, char **strs, char* sep, unsigned max);
diff -Naur procps-010114.orig/proc/proc/readproc.h procps-010114/proc/proc/readproc.h
--- procps-010114.orig/proc/proc/readproc.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/readproc.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,200 @@
+#ifndef PROCPS_PROC_READPROC_H
+#define PROCPS_PROC_READPROC_H
+/*
+ * New Interface to Process Table -- PROCTAB Stream (a la Directory streams)
+ * Copyright (C) 1996 Charles L. Blake.
+ * Copyright (C) 1998 Michael K. Johnson
+ * May be distributed under the terms of the
+ * GNU Library General Public License, a copy of which is provided
+ * in the file COPYING
+ */
+
+
+#define SIGNAL_STRING
+
+
+/*
+ ld	cutime, cstime, priority, nice, timeout, it_real_value, rss,
+ c	state,
+ d	ppid, pgrp, session, tty, tpgid,
+ s	signal, blocked, sigignore, sigcatch,
+ lu	flags, min_flt, cmin_flt, maj_flt, cmaj_flt, utime, stime,
+ lu	rss_rlim, start_code, end_code, start_stack, kstk_esp, kstk_eip,
+ lu	start_time, vsize, wchan, nswap, cnswap,
+*/
+
+/* Basic data structure which holds all information we can get about a process.
+ * (unless otherwise specified, fields are read from /proc/#/stat)
+ *
+ * Most of it comes from task_struct in linux/sched.h
+ */
+typedef struct proc_s {
+#ifdef SIGNAL_STRING
+    char
+	/* Linux 2.1.7x and up have more signals. This handles 88. */
+	signal[24],	/* mask of pending signals */
+	blocked[24],	/* mask of blocked signals */
+	sigignore[24],	/* mask of ignored signals */
+	sigcatch[24];	/* mask of caught  signals */
+#else
+    long long
+	/* Linux 2.1.7x and up have more signals. This handles 64. */
+	signal,		/* mask of pending signals */
+	blocked,	/* mask of blocked signals */
+	sigignore,	/* mask of ignored signals */
+	sigcatch;	/* mask of caught  signals */
+#endif
+    long
+	cutime,		/* cumulative utime of process and reaped children */
+	cstime,		/* cumulative stime of process and reaped children */
+	priority,	/* kernel scheduling priority */
+	timeout,	/* ? */
+	nice,		/* standard unix nice level of process */
+	rss,		/* resident set size from /proc/#/stat (pages) */
+	it_real_value,	/* ? */
+    /* the next 7 members come from /proc/#/statm */
+	size,		/* total # of pages of memory */
+	resident,	/* number of resident set (non-swapped) pages (4k) */
+	share,		/* number of pages of shared (mmap'd) memory */
+	trs,		/* text resident set size */
+	lrs,		/* shared-lib resident set size */
+	drs,		/* data resident set size */
+	dt;		/* dirty pages */
+    unsigned long
+	/* FIXME: are these longs? Maybe when the alpha does PCI bounce buffers */
+	vm_size,        /* same as vsize in kb */
+	vm_lock,        /* locked pages in kb */
+	vm_rss,         /* same as rss in kb */
+	vm_data,        /* data size */
+	vm_stack,       /* stack size */
+	vm_exe,         /* executable size */
+	vm_lib,         /* library size (all pages, not just used ones) */
+	vsize,		/* number of pages of virtual memory ... */
+	rss_rlim,	/* resident set size limit? */
+	flags,		/* kernel flags for the process */
+	min_flt,	/* number of minor page faults since process start */
+	maj_flt,	/* number of major page faults since process start */
+	cmin_flt,	/* cumulative min_flt of process and child processes */
+	cmaj_flt,	/* cumulative maj_flt of process and child processes */
+	nswap,		/* ? */
+	cnswap,		/* cumulative nswap ? */
+	utime,		/* user-mode CPU time accumulated by process */
+	stime,		/* kernel-mode CPU time accumulated by process */
+	start_code,	/* address of beginning of code segment */
+	end_code,	/* address of end of code segment */
+	start_stack,	/* address of the bottom of stack for the process */
+	kstk_esp,	/* kernel stack pointer */
+	kstk_eip,	/* kernel instruction pointer */
+	start_time,	/* start time of process -- seconds since 1-1-70 */
+	wchan;		/* address of kernel wait channel proc is sleeping in */
+    struct proc_s *l,	/* ptrs for building arbitrary linked structs */
+                  *r;	/* (i.e. singly/doubly-linked lists and trees */
+    char
+	**environ,	/* environment string vector (/proc/#/environ) */
+	**cmdline;	/* command line string vector (/proc/#/cmdline) */
+    char
+	/* Be compatible: Digital allows 16 and NT allows 14 ??? */
+    	ruser[16],	/* real user name */
+    	euser[16],	/* effective user name */
+    	suser[16],	/* saved user name */
+    	fuser[16],	/* filesystem user name */
+    	rgroup[16],	/* real group name */
+    	egroup[16],	/* effective group name */
+    	sgroup[16],	/* saved group name */
+    	fgroup[16],	/* filesystem group name */
+    	cmd[16];	/* basename of executable file in call to exec(2) */
+    int
+        ruid, rgid,     /* real      */
+        euid, egid,     /* effective */
+        suid, sgid,     /* saved     */
+        fuid, fgid,     /* fs (used for file access only) */
+    	pid,		/* process id */
+    	ppid,		/* pid of parent process */
+	pgrp,		/* process group id */
+	session,	/* session id */
+	tty,		/* full device number of controlling terminal */
+	tpgid,		/* terminal process group id */
+	exit_signal,	/* might not be SIGCHLD */
+	processor;      /* current (or most recent?) CPU */
+    unsigned
+        pcpu;           /* %CPU usage (is not filled in by readproc!!!) */
+    char
+    	state;		/* single-char code for process state (S=sleeping) */
+} proc_t;
+
+/* PROCTAB: data structure holding the persistent information readproc needs
+ * from openproc().  The setup is intentionally similar to the dirent interface
+ * and other system table interfaces (utmp+wtmp come to mind).
+ */
+#include <sys/types.h>
+#include <dirent.h>
+#include <unistd.h>
+typedef struct {
+    DIR*	procfs;
+    int		flags;
+    pid_t*	pids;	/* pids of the procs */
+    dev_t*	ttys;	/* devnos of the cttys */
+    uid_t*	uids;	/* uids of procs */
+    int		nuid;	/* cannot really sentinel-terminate unsigned short[] */
+    char*	stats;	/* status chars (actually output into /proc//stat) */
+} PROCTAB;
+
+/* initialize a PROCTAB structure holding needed call-to-call persistent data
+ */
+PROCTAB* openproc(int flags, ... /* pid_t*|uid_t*|dev_t*|char* [, int n] */ );
+
+
+/* Convenient wrapper around openproc and readproc to slurp in the whole process
+ * table subset satisfying the constraints of flags and the optional PID list.
+ * Free allocated memory with freeproctab().  Access via tab[N]->member.  The
+ * pointer list is NULL terminated.
+ */
+proc_t** readproctab(int flags, ... /* same as openproc */ );
+
+/* clean-up open files, etc from the openproc()
+ */
+void closeproc(PROCTAB* PT);
+
+/* retrieve the next process matching the criteria set by the openproc()
+ */
+proc_t* readproc(PROCTAB* PT, proc_t* return_buf);
+proc_t* ps_readproc(PROCTAB* PT, proc_t* return_buf);
+
+void look_up_our_self(proc_t *p);
+
+/* deallocate space allocated by readproc
+ */
+void freeproc(proc_t* p);
+
+/* openproc/readproctab:
+ *   
+ * Return PROCTAB* / *proc_t[] or NULL on error ((probably) "/proc" cannot be
+ * opened.)  By default readproc will consider all processes as valid to parse
+ * and return, but not actually fill in the cmdline, environ, and /proc/#/statm
+ * derived memory fields.
+ *
+ * `flags' (a bitwise-or of PROC_* below) modifies the default behavior.  The
+ * "fill" options will cause more of the proc_t to be filled in.  The "filter"
+ * options all use the second argument as the pointer to a list of objects:
+ * process status', process id's, user id's, and tty device numbers.  The third
+ * argument is the length of the list (currently only used for lists of user
+ * id's since unsigned short[] supports no convenient termination sentinel.)
+ */
+#define PROC_FILLANY    0x00 /* either stat or status will do */
+#define PROC_FILLMEM    0x01 /* read statm into the appropriate proc_t entries */
+#define PROC_FILLCMD    0x02 /* alloc and fill in `cmdline' part of proc_t */
+#define PROC_FILLENV    0x04 /* alloc and fill in `environ' part of proc_t */
+#define PROC_FILLUSR    0x08 /* resolve user id number -> user name via passwd */
+#define PROC_FILLSTATUS 0x10
+#define PROC_FILLSTAT   0x20
+#define PROC_FILLBUG    0x3f    /* No idea what we need */
+
+
+/* Obsolete, consider only processes with one of the passed: */
+#define PROC_PID     0x0100  /* process id numbers ( 0   terminated) */
+#define PROC_TTY     0x0200  /* ctty device nos.   ( 0   terminated) */
+#define PROC_UID     0x0400  /* user id numbers    ( length needed ) */
+#define PROC_STAT    0x0800  /* status fields      ('\0' terminated) */
+#define PROC_ANYTTY  0x1000  /* proc must have a controlling terminal */
+
+#endif
diff -Naur procps-010114.orig/proc/proc/sig.h procps-010114/proc/proc/sig.h
--- procps-010114.orig/proc/proc/sig.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/sig.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,19 @@
+/*
+ * Copyright 1998 by Albert Cahalan; all rights resered.
+ * This file may be used subject to the terms and conditions of the
+ * GNU Library General Public License Version 2, or any later version
+ * at your option, as published by the Free Software Foundation.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Library General Public License for more details.
+ */
+
+/* return -1 on failure */
+extern int signal_name_to_number(char *name);
+
+extern int print_given_signals(int argc, char *argv[], int max_line);
+
+extern void pretty_print_signals(void);
+
+extern void unix_print_signals(void);
diff -Naur procps-010114.orig/proc/proc/status.h procps-010114/proc/proc/status.h
--- procps-010114.orig/proc/proc/status.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/status.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,4 @@
+#ifndef __PROC_STATUS_H
+#define __PROC_STATUS_H
+extern char *status(proc_t* task);
+#endif
diff -Naur procps-010114.orig/proc/proc/sysinfo.h procps-010114/proc/proc/sysinfo.h
--- procps-010114.orig/proc/proc/sysinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/sysinfo.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,40 @@
+#ifndef SYSINFO_H
+#define SYSINFO_H
+
+extern unsigned long Hertz;   /* clock tick frequency */
+extern long smp_num_cpus;     /* number of CPUs */
+
+#define JT double
+extern void four_cpu_numbers(JT *uret, JT *nret, JT *sret, JT *iret);
+#undef JT
+
+extern int        uptime (double *uptime_secs, double *idle_secs);
+extern void       loadavg(double *av1, double *av5, double *av15);
+
+
+/* obsolete */
+extern unsigned kb_main_shared;
+/* old but still kicking -- the important stuff */
+extern unsigned kb_main_buffers;
+extern unsigned kb_main_cached;
+extern unsigned kb_main_free;
+extern unsigned kb_main_total;
+extern unsigned kb_swap_free;
+extern unsigned kb_swap_total;
+/* recently introduced */
+extern unsigned kb_high_free;
+extern unsigned kb_high_total;
+extern unsigned kb_low_free;
+extern unsigned kb_low_total;
+/* 2.4.xx era */
+extern unsigned kb_active;
+extern unsigned kb_inact_dirty;
+extern unsigned kb_inact_clean;
+extern unsigned kb_inact_target;
+/* derived values */
+extern unsigned kb_swap_used;
+extern unsigned kb_main_used;
+
+extern void meminfo(void);
+
+#endif /* SYSINFO_H */
diff -Naur procps-010114.orig/proc/proc/tree.h procps-010114/proc/proc/tree.h
--- procps-010114.orig/proc/proc/tree.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/tree.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,15 @@
+/* for oldps.c and proc/compare.c */
+struct tree_node {
+    proc_t *proc;
+    pid_t pid;
+    pid_t ppid;
+    char *line;
+    char *cmd;
+    char **cmdline;
+    char **environ;
+    int children;
+    int maxchildren;
+    int *child;
+    int have_parent;
+};
+
diff -Naur procps-010114.orig/proc/proc/version.h procps-010114/proc/proc/version.h
--- procps-010114.orig/proc/proc/version.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/version.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,23 @@
+#ifndef PROC_VERSION_H
+#define PROC_VERSION_H
+
+/* Suite version information for procps utilities
+ * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
+ * Linux kernel version information for procps utilities
+ * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
+ * Distributable under the terms of the GNU Library General Public License
+ */
+
+extern void display_version(void);	/* display suite version */
+extern char procps_version[];		/* global buf for suite version */
+
+extern int linux_version_code;		/* runtime version of LINUX_VERSION_CODE
+					   in /usr/include/linux/version.h */
+
+/* Convenience macros for composing/decomposing version codes */
+#define LINUX_VERSION(x,y,z)   (0x10000*(x) + 0x100*(y) + z)
+#define LINUX_VERSION_MAJOR(x) (((x)>>16) & 0xFF)
+#define LINUX_VERSION_MINOR(x) (((x)>> 8) & 0xFF)
+#define LINUX_VERSION_PATCH(x) ( (x)      & 0xFF)
+
+#endif	/* PROC_VERSION_H */
diff -Naur procps-010114.orig/proc/proc/whattime.h procps-010114/proc/proc/whattime.h
--- procps-010114.orig/proc/proc/whattime.h	1970-01-01 01:00:00.000000000 +0100
+++ procps-010114/proc/proc/whattime.h	2006-03-04 11:40:14.000000000 +0100
@@ -0,0 +1,9 @@
+/* whattime.h --- see whattime.c for explanation */
+
+#ifndef __WHATTIME_H
+#define __WHATTIME_H
+
+extern void print_uptime(void);
+extern char *sprint_uptime(void);
+
+#endif
diff -Naur procps-010114.orig/proc/sysinfo.c procps-010114/proc/sysinfo.c
--- procps-010114.orig/proc/sysinfo.c	2001-01-13 09:46:06.000000000 +0100
+++ procps-010114/proc/sysinfo.c	2006-03-04 11:40:14.000000000 +0100
@@ -310,7 +310,7 @@
     );
     head = tail+1;
     if(!found) goto nextline;
-    *(found->slot) = strtoul(head,&tail,10);
+    *(unsigned *)(found->slot) = strtoul(head,&tail,10);
 nextline:
     tail = strchr(head, '\n');
     if(!tail) break;
diff -Naur procps-010114.orig/ps/common.h procps-010114/ps/common.h
--- procps-010114.orig/ps/common.h	2001-01-15 06:50:25.000000000 +0100
+++ procps-010114/ps/common.h	2006-03-04 12:11:22.000000000 +0100
@@ -68,6 +68,12 @@
 /* maximum escape expansion is 6, for &quot; */
 #define ESC_STRETCH 6
 /* output buffer size */
+#if !defined(PAGE_SIZE) && defined(__PPC__)
+#define PAGE_SIZE 4096
+#endif
+#if !defined(PAGE_SIZE)
+#error "PAGE_SIZE is not defined for architecture"
+#endif
 #define OUTBUF_SIZE (32*PAGE_SIZE*ESC_STRETCH + 8*PAGE_SIZE)
 /* spaces used to right-justify things */
 #define SPACE_AMOUNT (int)(PAGE_SIZE)
diff -Naur procps-010114.orig/ps/display.c procps-010114/ps/display.c
--- procps-010114.orig/ps/display.c	2000-06-18 23:11:18.000000000 +0200
+++ procps-010114/ps/display.c	2006-03-04 11:40:14.000000000 +0100
@@ -326,7 +326,7 @@
       if(processes[j]->pid == processes[i]->ppid) goto not_root;
     }
     show_tree(i,n,0,0);
-not_root:
+not_root:;
   }
   /* don't free the array because it takes time and ps will exit anyway */
 }
@@ -375,7 +375,7 @@
     case SIGPROF:  /* profiling */
     case SIGKILL:  /* can not catch */
     case SIGSTOP:  /* can not catch */
-    case SIGWINCH: /* don't care if window size changes */
+    case SIGWINCH:; /* don't care if window size changes */
     }
   } while (0);
 #endif
diff -Naur procps-010114.orig/ps/parser.c procps-010114/ps/parser.c
--- procps-010114.orig/ps/parser.c	2001-01-15 06:52:36.000000000 +0100
+++ procps-010114/ps/parser.c	2006-03-04 11:40:14.000000000 +0100
@@ -696,7 +696,7 @@
   case '=': case ':':
     if(*++flagptr) return flagptr;   /* found it */
     return NULL;                     /* empty '=' or ':' */
-  case '\0': /* try next argv[] */
+  case '\0':; /* try next argv[] */
   }
   if(thisarg+2 > ps_argc) return NULL;   /* there is nothing left */
   /* argument follows ps_argv[thisarg] */
diff -Naur procps-010114.orig/ps/sortformat.c procps-010114/ps/sortformat.c
--- procps-010114.orig/ps/sortformat.c	2001-01-15 09:40:06.000000000 +0100
+++ procps-010114/ps/sortformat.c	2006-03-04 11:40:14.000000000 +0100
@@ -136,7 +136,7 @@
     c = *walk++;
     if(c)         goto initial;
     return "Improper AIX field descriptor.";
-  looks_ok:
+  looks_ok:;
   }
 
   /*** sanity check passed ***/
diff -Naur procps-010114.orig/top.c procps-010114/top.c
--- procps-010114.orig/top.c	2001-01-14 11:40:14.000000000 +0100
+++ procps-010114/top.c	2006-03-04 11:40:14.000000000 +0100
@@ -92,7 +92,7 @@
 #include <time.h>
 #include <sys/ioctl.h>
 #include <pwd.h>
-#include <termcap.h>
+#include <ncurses/termcap.h>
 #include <termios.h>
 #include <signal.h>
 #include <sys/time.h>
@@ -489,7 +489,7 @@
 	    }
 	    cp++;
 	}
-    breakargv:
+    breakargv:;
     }
     
     if (nr_cpu > 1 && CPU_states)
diff -Naur procps-010114.orig/top.h procps-010114/top.h
--- procps-010114.orig/top.h	2001-01-14 11:41:29.000000000 +0100
+++ procps-010114/top.h	2006-03-04 12:06:54.000000000 +0100
@@ -98,6 +98,13 @@
 static int CPU_states = 0;
 static char CurrUser[BUFSIZ];
 
+#if !defined(PAGE_SHIFT) && defined(__PPC__)
+#define PAGE_SHIFT 12
+#endif
+#if !defined(PAGE_SHIFT)
+#error PAGE_SHIFT not defined for architecture
+#endif
+
 static int CL_pg_shift = (PAGE_SHIFT - 10);
 static int CL_wchan_nout = -1;
 
