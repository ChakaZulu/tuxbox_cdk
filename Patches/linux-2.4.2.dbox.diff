diff -Naur linux-2.4.2.orig/Documentation/Configure.help linux-2.4.2/Documentation/Configure.help
--- linux-2.4.2.orig/Documentation/Configure.help	Mon Feb 19 19:18:18 2001
+++ linux-2.4.2/Documentation/Configure.help	Fri Feb 15 14:41:15 2002
@@ -15834,6 +15834,11 @@
   only supports one type or the other. However, there is very early
   work on support for CHRP, PReP and PowerMac's from a single binary.
 
+Nokia dbox2 Mainboard
+CONFIG_DBOX2
+  Enables various fixes and changes for the Nokia dbox2. The Nokia
+  dbox2 is a satellite receiver for DVB + Pay-TV in Germany and Austria.
+
 Power management support for PowerBooks
 CONFIG_PMAC_PBOOK
   This provides support for putting a PowerBook to sleep; it also
diff -Naur linux-2.4.2.orig/Makefile linux-2.4.2/Makefile
--- linux-2.4.2.orig/Makefile	Thu Feb 22 01:54:15 2001
+++ linux-2.4.2/Makefile	Fri Feb 15 14:41:15 2002
@@ -5,7 +5,8 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+#ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH  := ppc
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 	  else if [ -x /bin/bash ]; then echo /bin/bash; \
@@ -18,7 +19,7 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+CROSS_COMPILE 	= powerpc-tuxbox-linux-gnu-
 
 #
 # Include the make variables (CC, etc...)
@@ -87,7 +88,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Os -fomit-frame-pointer -fno-strict-aliasing
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
 #
@@ -372,7 +373,7 @@
 endif
 .PHONY: _modinst_post
 _modinst_post: _modinst_post_pcmcia
-	if [ -r System.map ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
+	if [ -r System.map ]; then echo "don't foreget to run depmod on the target system"; fi
 
 # Backwards compatibilty symlinks for people still using old versions
 # of pcmcia-cs with hard coded pathnames on insmod.  Remove
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/commproc.h linux-2.4.2/arch/ppc/8xx_io/commproc.h
--- linux-2.4.2.orig/arch/ppc/8xx_io/commproc.h	Sat Feb 17 01:02:34 2001
+++ linux-2.4.2/arch/ppc/8xx_io/commproc.h	Fri Feb 15 14:41:15 2002
@@ -513,8 +513,13 @@
 
 #define PA_ENET_RXD	((ushort)0x0004)	/* PA 13 */
 #define PA_ENET_TXD	((ushort)0x0008)	/* PA 12 */
+#ifdef CONFIG_DBOX2
+#define PA_ENET_RCLK	((ushort)0x0200)	/* PA  7 */
+#define PA_ENET_TCLK	((ushort)0x0800)	/* PA  5 */
+#else
 #define PA_ENET_RCLK	((ushort)0x0100)	/* PA  7 */
 #define PA_ENET_TCLK	((ushort)0x0400)	/* PA  5 */
+#endif
 
 #ifndef	CONFIG_FPS850	/* not valid on FPS board */
 #define	PB_ENET_TENA	((uint)0x00002000)
@@ -530,7 +535,11 @@
  * SCC2.  Also, make sure GR2 (bit 16) and SC2 (bit 17) are zero.
  */
 #define SICR_ENET_MASK	((uint)0x0000ff00)
+#ifdef CONFIG_DBOX2
+#define SICR_ENET_CLKRT	((uint)0x00003d00)
+#else
 #define SICR_ENET_CLKRT	((uint)0x00002600)
+#endif
 
 #endif	/* CONFIG_TQM8xxL */
 
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/enet.c linux-2.4.2/arch/ppc/8xx_io/enet.c
--- linux-2.4.2.orig/arch/ppc/8xx_io/enet.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/8xx_io/enet.c	Fri Feb 15 14:41:15 2002
@@ -889,7 +889,7 @@
 	immap->im_ioport.iop_pcdir &= ~PC_ENET_TENA;
 #endif
 
-#if (defined(CONFIG_TQM8xxL) && !defined(CONFIG_FPS850))
+#if (defined(CONFIG_TQM8xxL) && !defined(CONFIG_FPS850) && !defined(CONFIG_DBOX2))
 	cp->cp_pbpar |= PB_ENET_TENA;
 	cp->cp_pbdir |= PB_ENET_TENA;
 #endif
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/uart.c linux-2.4.2/arch/ppc/8xx_io/uart.c
--- linux-2.4.2.orig/arch/ppc/8xx_io/uart.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/8xx_io/uart.c	Fri Feb 15 14:41:15 2002
@@ -2458,7 +2458,7 @@
 	__clear_user(&serial_driver,sizeof(struct tty_driver));
 	serial_driver.magic = TTY_DRIVER_MAGIC;
 	serial_driver.driver_name = "serial";
-	serial_driver.name = "ttyS";
+	serial_driver.name = "tts/%d";
 	serial_driver.major = TTY_MAJOR;
 	serial_driver.minor_start = 64;
 	serial_driver.num = NR_PORTS;
@@ -2496,7 +2496,7 @@
 	 * major number and the subtype code.
 	 */
 	callout_driver = serial_driver;
-	callout_driver.name = "cua";
+	callout_driver.name = "cua/%d";
 	callout_driver.major = TTYAUX_MAJOR;
 	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
 	callout_driver.read_proc = 0;
@@ -2833,6 +2833,9 @@
 
 	bd = (bd_t *)__res;
 
+#ifdef CONFIG_DBOX2
+        bd->bi_baudrate=9600; /* Unsure if this is still needed */
+#endif
 	for (bidx = 0; bidx < (sizeof(baud_table) / sizeof(int)); bidx++)
 		if (bd->bi_baudrate == baud_table[bidx])
 			break;
diff -Naur linux-2.4.2.orig/arch/ppc/Makefile linux-2.4.2/arch/ppc/Makefile
--- linux-2.4.2.orig/arch/ppc/Makefile	Tue Jan 23 00:41:14 2001
+++ linux-2.4.2/arch/ppc/Makefile	Fri Feb 15 14:41:15 2002
@@ -31,7 +31,11 @@
 endif
 
 ifdef CONFIG_8xx
-CFLAGS := $(CFLAGS) -mcpu=860 -I../8xx_io
+  ifdef CONFIG_DBOX2
+    CFLAGS := $(CFLAGS) -mcpu=823 -I../8xx_io
+  else
+    CFLAGS := $(CFLAGS) -mcpu=860 -I../8xx_io
+  endif
 endif
 
 ifdef CONFIG_PPC64BRIDGE
diff -Naur linux-2.4.2.orig/arch/ppc/config.in linux-2.4.2/arch/ppc/config.in
--- linux-2.4.2.orig/arch/ppc/config.in	Tue Jan 23 00:41:14 2001
+++ linux-2.4.2/arch/ppc/config.in	Fri Feb 15 14:41:15 2002
@@ -65,6 +65,7 @@
 	 
   if [ "$CONFIG_TQM8xxL" = "y" ]; then
     bool 'FPS850 Mainboard' CONFIG_FPS850
+    bool 'Nokia dbox2' CONFIG_DBOX2
   fi
 fi
 
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/irq.c linux-2.4.2/arch/ppc/kernel/irq.c
--- linux-2.4.2.orig/arch/ppc/kernel/irq.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/kernel/irq.c	Fri Feb 15 14:41:15 2002
@@ -520,6 +520,15 @@
 		else if (irq_desc[irq].handler->enable)
 			irq_desc[irq].handler->enable(irq);
 	}
+#ifdef CONFIG_DBOX2
+	if (action)
+	{
+	  if ( action->flags & SA_ONESHOT )
+	  {
+	    disable_irq_nosync(irq);
+	  }
+	}
+#endif
 	spin_unlock(&desc->lock);
 }
 
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/m8xx_setup.c linux-2.4.2/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.2.orig/arch/ppc/kernel/m8xx_setup.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/kernel/m8xx_setup.c	Fri Feb 15 14:41:15 2002
@@ -140,6 +140,22 @@
 	printk("timebase_interrupt()\n");
 }
 
+#ifdef CONFIG_DBOX2
+void m8xx_reset_watchdog(void)
+{
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0x556c;             /* write magic1 */
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0xaa39;             /* write magic2 */
+}
+
+void pit_interrupt(int irq, void * dev, struct pt_regs * regs)
+{
+	m8xx_reset_watchdog();
+
+	// Clear irq
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr |= PISCR_PS;
+}
+#endif
+
 /* The decrementer counts at the system (internal) clock frequency divided by
  * sixteen, or external oscillator divided by four.  We force the processor
  * to use system clock divided by sixteen.
@@ -148,6 +164,10 @@
 {
 	bd_t	*binfo = (bd_t *)__res;
 	int freq, fp, divisor;
+#ifdef CONFIG_DBOX2
+	unsigned long sypcr;
+	unsigned short pitc, swtc, swp;
+#endif	
 
 	/* Unlock the SCCR.
 	*/
@@ -195,6 +215,22 @@
 	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtcsc &=
 						~(RTCSC_SIE | RTCSC_ALE);
 
+	/* Enable the RTC (fixed by gillem).
+	*/
+
+// wrong define in header file ... hack ;-)
+#ifdef RTC_IRQ
+#undef RTC_IRQ
+#define RTC_IRQ 9
+#endif
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtcsc |=
+				((mk_int_int_mask(RTC_IRQ) << 8) |
+					(RTCSC_RTE));
+			
+
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtcsck = ~KAPWR_KEY;
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtcsck = KAPWR_KEY;
+
 	/* Enabling the decrementer also enables the timebase interrupts
 	 * (or from the other point of view, to get decrementer interrupts
 	 * we have to enable the timebase).  The decrementer interrupt
@@ -206,6 +242,42 @@
 
 	if (request_8xxirq(DEC_INTERRUPT, timebase_interrupt, 0, "tbint", NULL) != 0)
 		panic("Could not allocate timer IRQ!");
+
+#ifdef CONFIG_DBOX2
+	sypcr = ((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_sypcr;
+
+	if ((sypcr >> 2) & 0x1) {
+	    m8xx_reset_watchdog();
+	
+	    if (sypcr >> 16)
+		swtc = sypcr >> 16;
+	    else	
+		swtc = 0xFFFF;
+
+	    if (sypcr & 0x1)
+		swp = 2048;
+	    else
+		swp = 1;
+
+#define PITRTCLK 8192
+
+	    // Fire trigger if half of the wdt ticked down		
+	    if ((swp * swtc) > (UINT_MAX / PITRTCLK))
+		pitc = swtc * swp / binfo->bi_intfreq * PITRTCLK / 2;
+	    else
+		pitc = PITRTCLK * swtc * swp / binfo->bi_intfreq / 2;
+	    
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_pitc = pitc << 16;
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr = (mk_int_int_mask(PIT_INTERRUPT) << 8) | PISCR_PIE | PISCR_PTE;
+	
+	    if (request_8xxirq(PIT_INTERRUPT, pit_interrupt, 0, "pit", NULL) != 0)
+		    panic("mpc8xx-wdt: could not allocate pit irq!");
+
+	    printk("mpc8xx-wdt: active wdt found (SWTC: 0x%04X, SWP: 0x%01X)\n", sypcr >> 16, sypcr & 0x1);
+	    printk("mpc8xx-wdt: keep-alive trigger activated (PITC: 0x%04X)\n", pitc);
+	}
+#endif
+
 }
 
 /* The RTC on the MPC8xx is an internal register.
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/ppc_ksyms.c linux-2.4.2/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.4.2.orig/arch/ppc/kernel/ppc_ksyms.c	Tue Feb 13 22:15:04 2001
+++ linux-2.4.2/arch/ppc/kernel/ppc_ksyms.c	Fri Feb 15 14:41:15 2002
@@ -242,8 +242,8 @@
 EXPORT_SYMBOL(set_backlight_enable);
 EXPORT_SYMBOL(register_backlight_controller);
 #endif /* CONFIG_PMAC_BACKLIGHT */
-EXPORT_SYMBOL_NOVERS(sys_ctrler);
 #ifndef CONFIG_MACH_SPECIFIC
+EXPORT_SYMBOL_NOVERS(sys_ctrler);
 EXPORT_SYMBOL_NOVERS(have_of);
 #endif /* CONFIG_MACH_SPECIFIC */
 #if defined(CONFIG_ALL_PPC)
@@ -280,7 +280,10 @@
 #if defined(CONFIG_SCSI) && defined(CONFIG_ALL_PPC)
 EXPORT_SYMBOL(note_scsi_host);
 #endif
+#ifndef CONFIG_DBOX2
+// das ist hier vermutlich ganz falsch
 EXPORT_SYMBOL(kd_mksound);
+#endif
 #ifdef CONFIG_NVRAM
 EXPORT_SYMBOL(nvram_read_byte);
 EXPORT_SYMBOL(nvram_write_byte);
@@ -367,3 +370,20 @@
 EXPORT_SYMBOL(last_task_used_math);
 EXPORT_SYMBOL(ret_from_except);
 #endif /* CONFIG_MOL */
+
+#ifdef CONFIG_DBOX2
+extern void m8xx_cpm_setbrg(void);
+extern void m8xx_cpm_hostalloc(void);
+extern void m8xx_cpm_dpalloc(void);
+extern void cpm_free_handler(void);
+extern void cpm_install_handler(void);
+extern void cpmp(void);
+extern int request_8xxirq(unsigned int irq,void (*handler)(int, void *, struct pt_regs *),unsigned long flags,const char *device,void *dev_id);
+EXPORT_SYMBOL(m8xx_cpm_setbrg);
+EXPORT_SYMBOL(m8xx_cpm_hostalloc);
+EXPORT_SYMBOL(m8xx_cpm_dpalloc);
+EXPORT_SYMBOL(cpm_free_handler);
+EXPORT_SYMBOL(cpm_install_handler);
+EXPORT_SYMBOL(cpmp);
+EXPORT_SYMBOL(request_8xxirq);
+#endif
diff -Naur linux-2.4.2.orig/drivers/char/console.c linux-2.4.2/drivers/char/console.c
--- linux-2.4.2.orig/drivers/char/console.c	Fri Feb  9 20:30:22 2001
+++ linux-2.4.2/drivers/char/console.c	Fri Feb 15 14:41:15 2002
@@ -108,7 +108,13 @@
 #include "console_macros.h"
 
 
-const struct consw *conswitchp;
+// const struct consw *conswitchp;
+#ifdef CONFIG_DUMMY_CONSOLE
+const struct consw *conswitchp=&dummy_con;
+#else
+const struct consw *conswitchp=0;
+#endif
+
 
 /* A bitmap for codes <32. A bit of 1 indicates that the code
  * corresponding to that bit number invokes some special action
diff -Naur linux-2.4.2.orig/drivers/char/vt.c linux-2.4.2/drivers/char/vt.c
--- linux-2.4.2.orig/drivers/char/vt.c	Fri Feb  9 20:30:22 2001
+++ linux-2.4.2/drivers/char/vt.c	Fri Feb 15 14:46:02 2002
@@ -93,7 +93,7 @@
  * comments - KDMKTONE doesn't put the process to sleep.
  */
 
-#if defined(__i386__) || defined(__alpha__) || defined(__powerpc__) \
+#if defined(__i386__) || defined(__alpha__) \
     || (defined(__mips__) && !defined(CONFIG_SGI_IP22)) \
     || (defined(__arm__) && defined(CONFIG_HOST_FOOTBRIDGE))
 
diff -Naur linux-2.4.2.orig/drivers/input/keybdev.c linux-2.4.2/drivers/input/keybdev.c
--- linux-2.4.2.orig/drivers/input/keybdev.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/input/keybdev.c	Fri Feb 15 14:43:02 2002
@@ -37,7 +37,7 @@
 #include <linux/module.h>
 #include <linux/kbd_kern.h>
 
-#if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(__alpha__) || defined(__mips__)
+#if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(__alpha__) || defined(__mips__) || defined(__powerpc__)
 
 static int x86_sysrq_alt = 0;
 
diff -Naur linux-2.4.2.orig/drivers/mtd/Config.in linux-2.4.2/drivers/mtd/Config.in
--- linux-2.4.2.orig/drivers/mtd/Config.in	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/Config.in	Fri Feb 15 14:41:15 2002
@@ -1,5 +1,5 @@
 
-# $Id: No. :) $
+# $Id: Config.in,v 1.72 2001/11/01 20:38:53 rmk Exp $
 
 mainmenu_option next_comment
 comment 'Memory Technology Devices (MTD)'
@@ -11,72 +11,33 @@
    if [ "$CONFIG_MTD_DEBUG" = "y" ]; then
       int '  Debugging verbosity (0 = quiet, 3 = noisy)' CONFIG_MTD_DEBUG_VERBOSE 0
    fi
-
-comment 'Disk-On-Chip Device Drivers'
-   dep_tristate '  M-Systems Disk-On-Chip 1000' CONFIG_MTD_DOC1000 $CONFIG_MTD
-   dep_tristate '  M-Systems Disk-On-Chip 2000 and Millennium' CONFIG_MTD_DOC2000 $CONFIG_MTD
-   dep_tristate '  M-Systems Disk-On-Chip Millennium-only alternative driver' CONFIG_MTD_DOC2001 $CONFIG_MTD
-   if [ "$CONFIG_MTD_DOC2001" = "y" -o "$CONFIG_MTD_DOC2000" = "y" ]; then
-      define_tristate CONFIG_MTD_DOCPROBE y
-   else
-      if [ "$CONFIG_MTD_DOC2001" = "m" -o "$CONFIG_MTD_DOC2000" = "m" ]; then
-	 define_tristate CONFIG_MTD_DOCPROBE m
-      else
-	 define_tristate CONFIG_MTD_DOCPROBE n
-      fi
-   fi
-   if [ "$CONFIG_MTD_DOCPROBE" = "y" -o "$CONFIG_MTD_DOCPROBE" = "m" ]; then
-      hex  '    Physical address of DiskOnChip' CONFIG_MTD_DOCPROBE_ADDRESS 0x0000
-      bool '    Probe high addresses' CONFIG_MTD_DOCPROBE_HIGH
-      bool '    Probe for 0x55 0xAA BIOS Extension Signature' CONFIG_MTD_DOCPROBE_55AA
-   fi
-
-comment 'RAM/ROM Device Drivers'
-   dep_tristate '  Use extra onboard system memory as MTD device' CONFIG_MTD_SLRAM $CONFIG_MTD
-   dep_tristate '  Ramix PMC551 PCI Mezzanine ram card support' CONFIG_MTD_PMC551 $CONFIG_MTD $CONFIG_PCI
-   if [ "$CONFIG_MTD_PMC551" != "n" ]; then
-      bool '    PMC551 256M DRAM Bugfix' CONFIG_MTD_PMC551_BUGFIX
-      bool '    PMC551 Debugging' CONFIG_MTD_PMC551_DEBUG
-   fi
-   dep_tristate '  Debugging RAM test driver' CONFIG_MTD_MTDRAM $CONFIG_MTD
-   if [ "$CONFIG_MTD_MTDRAM" != "n" ]; then
-      int 'Device size in kB' CONFIG_MTDRAM_TOTAL_SIZE 4096
-      int 'Size of the erase sectors in kB' CONFIG_MTDRAM_ERASE_SIZE 128
+   dep_tristate '  MTD partitioning support' CONFIG_MTD_PARTITIONS $CONFIG_MTD
+   dep_tristate '  RedBoot partition table parsing' CONFIG_MTD_REDBOOT_PARTS $CONFIG_MTD_PARTITIONS
+   if [ "$CONFIG_ARM" = "y" ]; then
+      dep_tristate '  Compaq bootldr partition table parsing' CONFIG_MTD_BOOTLDR_PARTS $CONFIG_MTD_PARTITIONS
+      dep_tristate '  ARM Firmware Suite partition parsing' CONFIG_MTD_AFS_PARTS $CONFIG_MTD_PARTITIONS
    fi
 
-comment 'Linearly Mapped Flash Device Drivers'
-   dep_tristate '  Common Flash Interface (CFI) support' CONFIG_MTD_CFI $CONFIG_MTD
-   dep_tristate '    CFI support for Intel/Sharp Extended Command Set chips' CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_CFI
-   dep_tristate '    CFI support for AMD/Fujitsu Standard Command Set chips' CONFIG_MTD_CFI_AMDSTD $CONFIG_MTD_CFI
-   dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
-   dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
-
-# These will later become config-options
-define_bool CONFIG_MTD_JEDEC n
-
-   dep_tristate '  Flash chip mapping in physical memory' CONFIG_MTD_PHYSMAP $CONFIG_MTD_CFI
-   if [ "$CONFIG_MTD_PHYSMAP" = "y" -o "$CONFIG_MTD_PHYSMAP" = "m" ]; then
-      hex '    Physical start location of flash chip mapping' CONFIG_MTD_PHYSMAP_START 0x8000000
-      hex '    Physical length of flash chip mapping' CONFIG_MTD_PHYSMAP_LEN 0x4000000
-      int '    Bus width in octets' CONFIG_MTD_PHYSMAP_BUSWIDTH 2
+comment 'User Modules And Translation Layers'
+   dep_tristate '  Direct char device access to MTD devices' CONFIG_MTD_CHAR $CONFIG_MTD
+   dep_tristate '  Caching block device access to MTD devices' CONFIG_MTD_BLOCK $CONFIG_MTD
+   if [ "$CONFIG_MTD_BLOCK" = "n" -o "$CONFIG_MTD_BLOCK" = "m" ]; then
+   	dep_tristate '  Readonly block device access to MTD devices' CONFIG_MTD_BLOCK_RO $CONFIG_MTD
    fi
-
-comment 'Drivers for chip mappings'
-   dep_tristate '  Flash chip mapping on Mixcom piggyback card' CONFIG_MTD_MIXMEM $CONFIG_MTD_JEDEC
-   dep_tristate '  Flash chip mapping on Nora' CONFIG_MTD_NORA $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on Octagon 5066 SBC' CONFIG_MTD_OCTAGON $CONFIG_MTD_JEDEC
-   dep_tristate '  Flash chip mapping on Photron PNC-2000' CONFIG_MTD_PNC2000 $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on RPXLite PPC board' CONFIG_MTD_RPXLITE $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on Tempustech VMAX SBC301' CONFIG_MTD_VMAX $CONFIG_MTD_JEDEC
-
-comment 'User modules and translation layers for MTD devices'
-   dep_tristate '  Direct chardevice access to MTD devices' CONFIG_MTD_CHAR $CONFIG_MTD
-   dep_tristate '  Caching blockdevice access to MTD devices' CONFIG_MTD_BLOCK $CONFIG_MTD
    dep_tristate '  FTL (Flash Translation Layer) support' CONFIG_FTL $CONFIG_MTD
    dep_tristate '  NFTL (NAND Flash Translation Layer) support' CONFIG_NFTL $CONFIG_MTD
    if [ "$CONFIG_NFTL" = "y" -o "$CONFIG_NFTL" = "m" ]; then
       bool '    Write support for NFTL (BETA)' CONFIG_NFTL_RW
    fi
+
+   source drivers/mtd/chips/Config.in
+
+   source drivers/mtd/maps/Config.in
+
+   source drivers/mtd/devices/Config.in
+
+   source drivers/mtd/nand/Config.in
+
 fi
 
 endmenu
diff -Naur linux-2.4.2.orig/drivers/mtd/GNUmakefile linux-2.4.2/drivers/mtd/GNUmakefile
--- linux-2.4.2.orig/drivers/mtd/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/GNUmakefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,63 @@
+# $Id: GNUmakefile,v 1.10 2002/01/03 15:00:54 dwmw2 Exp $
+
+LINUXDIR=/lib/modules/$(shell uname -r)/build
+
+ifndef VERSION
+
+# Someone just typed 'make'
+
+modules:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` modules
+
+dep:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` dep
+
+clean:
+	rm -f *.o */*.o
+
+else
+
+
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+
+# We add to $CC rather than setting EXTRA_CFLAGS because the local 
+# header files _must_ appear before the in-kernel ones. 
+CC += -I$(shell pwd)/../../include
+
+CONFIG_MTD := m
+CONFIG_MTD_PARTITIONS := m
+CONFIG_MTD_REDBOOT_PARTS := m
+#CONFIG_MTD_BOOTLDR_PARTS := m
+CONFIG_MTD_AFS_PARTS := m
+CONFIG_MTD_CHAR := m
+CONFIG_MTD_BLOCK := m
+CONFIG_FTL := m
+CONFIG_NFTL := m
+
+CFLAGS_nftl.o := -DCONFIG_NFTL_RW
+
+endif
+
+# Normal case - build in-kernel
+
+ifeq ($(VERSION),2)
+ ifneq ($(PATCHLEVEL),4)
+  ifneq ($(PATCHLEVEL),5)
+   OLDTOPDIR := $(TOPDIR)
+   TOPDIR := $(shell pwd)
+  endif
+ endif
+endif
+
+ifeq ($(VERSION),2)
+ ifeq ($(PATCHLEVEL),0)
+   obj-y += initcalls.o
+  endif
+endif
+
+include Makefile
+
+endif
diff -Naur linux-2.4.2.orig/drivers/mtd/Makefile linux-2.4.2/drivers/mtd/Makefile
--- linux-2.4.2.orig/drivers/mtd/Makefile	Fri Dec 29 23:07:22 2000
+++ linux-2.4.2/drivers/mtd/Makefile	Fri Feb 15 14:41:15 2002
@@ -8,54 +8,58 @@
 # Note 2! The CFLAGS definitions are now inherited from the
 # parent makes..
 #
-# $Id: Makefile,v 1.22 2000/07/14 08:10:52 dwmw2 Exp $
+# $Id: Makefile,v 1.63 2001/06/13 09:43:07 dwmw2 Exp $
 
-# Object file lists.
 
-obj-y           :=
+obj-y           += chips/chipslink.o maps/mapslink.o \
+			devices/devlink.o nand/nandlink.o
 obj-m           :=
 obj-n           :=
 obj-            :=
 
 O_TARGET	:= mtdlink.o
-SUB_DIRS	:=
-ALL_SUB_DIRS 	:=
-MOD_SUB_DIRS	:=
 
-export-objs	:=	mtdcore.o mtdpart.o jedec.o
-list-multi	:=
+export-objs	:= mtdcore.o mtdpart.o redboot.o bootldr.o afs.o
+list-multi	:= nftl.o
 
-# MTD devices
+mod-subdirs	:= 
+subdir-y	:= chips maps devices nand
+subdir-m	:= $(subdir-y)
+
+#                       *** BIG UGLY NOTE ***
+#
+# The shiny new inter_module_xxx has introduced yet another ugly link
+# order dependency, which I'd previously taken great care to avoid.
+# We now have to ensure that the chip drivers are initialised before the
+# map drivers, and that the doc200[01] drivers are initialised before
+# docprobe.
+#
+# We'll hopefully merge the doc200[01] drivers and docprobe back into
+# a single driver some time soon, but the CFI drivers are going to have
+# to stay like that.
+#
+# Urgh.
+# 
+# dwmw2 21/11/0
+
+# Core functionality.
 obj-$(CONFIG_MTD)		+= mtdcore.o
-obj-$(CONFIG_MTD_DOC1000)	+= doc1000.o
-obj-$(CONFIG_MTD_DOC2000)	+= doc2000.o
-obj-$(CONFIG_MTD_DOC2001)	+= doc2001.o
-obj-$(CONFIG_MTD_DOCPROBE)	+= docprobe.o docecc.o
-obj-$(CONFIG_MTD_SLRAM)		+= slram.o
-obj-$(CONFIG_MTD_PMC551)	+= pmc551.o
-obj-$(CONFIG_MTD_MTDRAM)	+= mtdram.o
-
-# Chip drivers
-obj-$(CONFIG_MTD_JEDEC)		+= jedec.o
-obj-$(CONFIG_MTD_RAM)		+= map_ram.o
-obj-$(CONFIG_MTD_ROM)		+= map_rom.o
-obj-$(CONFIG_MTD_CFI)		+= cfi_probe.o
-obj-$(CONFIG_MTD_CFI_INTELEXT)	+= cfi_cmdset_0001.o
-obj-$(CONFIG_MTD_CFI_AMDSTD)	+= cfi_cmdset_0002.o
-
-# Chip mappings
-obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o
-obj-$(CONFIG_MTD_MIXMEM)	+= mixmem.o
-obj-$(CONFIG_MTD_NORA)		+= nora.o
-obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
-obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o mtdpart.o
-obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
-obj-$(CONFIG_MTD_VMAX)		+= vmax301.o
+obj-$(CONFIG_MTD_PARTITIONS)	+= mtdpart.o
+obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
+obj-$(CONFIG_MTD_BOOTLDR_PARTS) += bootldr.o
+obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 
-# Users
+# 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
 obj-$(CONFIG_MTD_BLOCK)		+= mtdblock.o
+obj-$(CONFIG_MTD_BLOCK_RO)	+= mtdblock_ro.o
 obj-$(CONFIG_FTL)		+= ftl.o
-obj-$(CONFIG_NFTL)		+= nftl.o nftlmount.o
+obj-$(CONFIG_NFTL)		+= nftl.o
+
+nftl-objs	:= nftlcore.o nftlmount.o
 
 include $(TOPDIR)/Rules.make
+
+nftl.o: $(nftl-objs)
+	$(LD) -r -o $@ $(nftl-objs)
+
diff -Naur linux-2.4.2.orig/drivers/mtd/Rules.make linux-2.4.2/drivers/mtd/Rules.make
--- linux-2.4.2.orig/drivers/mtd/Rules.make	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/Rules.make	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,35 @@
+# $Id: Rules.make,v 1.3 2001/09/25 22:51:40 dwmw2 Exp $
+
+# Replace mtdchar.o with mtdchar-compat.o
+
+obj-y		:= $(subst mtdchar.o,mtdchar-compat.o,$(obj-y))
+obj-m		:= $(subst mtdchar.o,mtdchar-compat.o,$(obj-m))
+
+# Makefile fragments for older kernels.
+
+multi-y		:= $(filter $(list-multi), $(obj-y))
+multi-m		:= $(filter $(list-multi), $(obj-m))
+int-y		:= $(sort $(foreach m, $(multi-y), $($(basename $(m))-objs)))
+int-m		:= $(sort $(foreach m, $(multi-m), $($(basename $(m))-objs)))
+
+# Files that are both resident and modular: remove from modular.
+
+obj-m		:= $(filter-out $(obj-y), $(obj-m))
+int-m		:= $(filter-out $(int-y), $(int-m))
+
+# Take multi-part drivers out of obj-y and put components in.
+
+obj-y		:= $(filter-out $(list-multi), $(obj-y)) $(int-y)
+
+# Translate to Rules.make lists.
+
+O_OBJS		:= $(filter-out $(export-objs), $(obj-y))
+OX_OBJS		:= $(filter     $(export-objs), $(obj-y))
+M_OBJS		:= $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS		:= $(sort $(filter     $(export-objs), $(obj-m)))
+
+SUB_DIRS	:= $(subdir-y)
+MOD_SUB_DIRS	:= $(subdir-m)
+
+TOPDIR := $(OLDTOPDIR)
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/afs.c linux-2.4.2/drivers/mtd/afs.c
--- linux-2.4.2.orig/drivers/mtd/afs.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/afs.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,233 @@
+/*======================================================================
+
+    drivers/mtd/afs.c: ARM Flash Layout/Partitioning
+  
+    Copyright (C) 2000 ARM Limited
+  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+  
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+  
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  
+   This is access code for flashes using ARM's flash partitioning 
+   standards.
+
+   $Id: afs.c,v 1.7 2001/11/01 20:04:54 rmk Exp $
+
+======================================================================*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+struct footer_struct {
+	u32 image_info_base;	/* Address of first word of ImageFooter  */
+	u32 image_start;	/* Start of area reserved by this footer */
+	u32 signature;		/* 'Magic' number proves it's a footer   */
+	u32 type;		/* Area type: ARM Image, SIB, customer   */
+	u32 checksum;		/* Just this structure                   */
+};
+
+struct image_info_struct {
+	u32 bootFlags;		/* Boot flags, compression etc.          */
+	u32 imageNumber;	/* Unique number, selects for boot etc.  */
+	u32 loadAddress;	/* Address program should be loaded to   */
+	u32 length;		/* Actual size of image                  */
+	u32 address;		/* Image is executed from here           */
+	char name[16];		/* Null terminated                       */
+	u32 headerBase;		/* Flash Address of any stripped header  */
+	u32 header_length;	/* Length of header in memory            */
+	u32 headerType;		/* AIF, RLF, s-record etc.               */
+	u32 checksum;		/* Image checksum (inc. this struct)     */
+};
+
+static int
+afs_read_footer(struct mtd_info *mtd, u_int *img_start, u_int *iis_start,
+		u_int off, u_int mask)
+{
+	struct footer_struct fs;
+	u_int ptr = off + mtd->erasesize - sizeof(fs);
+	size_t sz;
+	int ret;
+
+	ret = mtd->read(mtd, ptr, sizeof(fs), &sz, (u_char *) &fs);
+	if (ret >= 0 && sz != sizeof(fs))
+		ret = -EINVAL;
+
+	if (ret < 0) {
+		printk(KERN_ERR "AFS: mtd read failed at 0x%x: %d\n",
+			ptr, ret);
+		return ret;
+	}
+
+	/*
+	 * Does it contain the magic number?
+	 */
+	if (fs.signature != 0xa0ffff9f)
+		ret = 1;
+
+	/*
+	 * Don't touch the SIB.
+	 */
+	if (fs.type == 2)
+		ret = 1;
+
+	*iis_start = fs.image_info_base & mask;
+	*img_start = fs.image_start & mask;
+
+	/*
+	 * Check the image info base.  This can not
+	 * be located after the footer structure.
+	 */
+	if (*iis_start >= ptr)
+		ret = 1;
+
+	/*
+	 * Check the start of this image.  The image
+	 * data can not be located after this block.
+	 */
+	if (*img_start > off)
+		ret = 1;
+
+	return ret;
+}
+
+static int
+afs_read_iis(struct mtd_info *mtd, struct image_info_struct *iis, u_int ptr)
+{
+	size_t sz;
+	int ret;
+
+	memset(iis, 0, sizeof(*iis));
+	ret = mtd->read(mtd, ptr, sizeof(*iis), &sz, (u_char *) iis);
+	if (ret >= 0 && sz != sizeof(*iis))
+		ret = -EINVAL;
+	if (ret < 0)
+		printk(KERN_ERR "AFS: mtd read failed at 0x%x: %d\n",
+			ptr, ret);
+
+	return ret;
+}
+
+int parse_afs_partitions(struct mtd_info *mtd, struct mtd_partition **pparts)
+{
+	struct mtd_partition *parts;
+	u_int mask, off, idx, sz;
+	int ret = 0;
+	char *str;
+
+	/*
+	 * This is the address mask; we use this to mask off out of
+	 * range address bits.
+	 */
+	mask = mtd->size - 1;
+
+	/*
+	 * First, calculate the size of the array we need for the
+	 * partition information.  We include in this the size of
+	 * the strings.
+	 */
+	for (idx = off = sz = 0; off < mtd->size; off += mtd->erasesize) {
+		struct image_info_struct iis;
+		u_int iis_ptr, img_ptr;
+
+		ret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);
+		if (ret < 0)
+			break;
+		if (ret == 1)
+			continue;
+
+		ret = afs_read_iis(mtd, &iis, iis_ptr);
+		if (ret < 0)
+			break;
+
+		sz += sizeof(struct mtd_partition);
+		sz += strlen(iis.name) + 1;
+		idx += 1;
+	}
+
+	if (!sz)
+		return ret;
+
+	parts = kmalloc(sz, GFP_KERNEL);
+	if (!parts)
+		return -ENOMEM;
+
+	str = (char *)(parts + idx);
+
+	/*
+	 * Identify the partitions
+	 */
+	for (idx = off = 0; off < mtd->size; off += mtd->erasesize) {
+		struct image_info_struct iis;
+		u_int iis_ptr, img_ptr, size;
+
+		/* Read the footer. */
+		ret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);
+		if (ret < 0)
+			break;
+		if (ret == 1)
+			continue;
+
+		/* Read the image info block */
+		ret = afs_read_iis(mtd, &iis, iis_ptr);
+		if (ret < 0)
+			break;
+
+		strcpy(str, iis.name);
+		size = mtd->erasesize + off - img_ptr;
+
+		/*
+		 * In order to support JFFS2 partitions on this layout,
+		 * we must lie to MTD about the real size of JFFS2
+		 * partitions; this ensures that the AFS flash footer
+		 * won't be erased by JFFS2.  Please ensure that your
+		 * JFFS2 partitions are given image numbers between
+		 * 1000 and 2000 inclusive.
+		 */
+		if (iis.imageNumber >= 1000 && iis.imageNumber < 2000)
+			size -= mtd->erasesize;
+
+		parts[idx].name		= str;
+		parts[idx].size		= size;
+		parts[idx].offset	= img_ptr;
+		parts[idx].mask_flags	= 0;
+
+		printk("  mtd%d: at 0x%08x, %5dKB, %8u, %s\n",
+			idx, img_ptr, parts[idx].size / 1024,
+			iis.imageNumber, str);
+
+		idx += 1;
+		str = str + strlen(iis.name) + 1;
+	}
+
+	if (!idx) {
+		kfree(parts);
+		parts = NULL;
+	}
+
+	*pparts = parts;
+	return idx ? idx : ret;
+}
+
+EXPORT_SYMBOL(parse_afs_partitions);
+
+MODULE_AUTHOR("ARM Ltd");
+MODULE_DESCRIPTION("ARM Firmware Suite partition parser");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/amd_flash.c linux-2.4.2/drivers/mtd/amd_flash.c
--- linux-2.4.2.orig/drivers/mtd/amd_flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/amd_flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1245 @@
+/*
+ * MTD map driver for AMD compatible flash chips (non-CFI)
+ *
+ * Author: Jonas Holmberg <jonas.holmberg@axis.com>
+ *
+ * $Id: amd_flash.c,v 1.4 2001/03/09 13:48:24 jonashg Exp $
+ *
+ * Copyright (c) 2001 Axis Communications AB
+ *
+ * This file is under GPL.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/delay.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+
+/* There's no limit. It exists only to avoid realloc. */
+#define MAX_AMD_CHIPS 8
+
+#define DEVICE_TYPE_X8	(8 / 8)
+#define DEVICE_TYPE_X16	(16 / 8)
+#define DEVICE_TYPE_X32	(32 / 8)
+
+/* Addresses */
+#define ADDR_MANUFACTURER		0x0000
+#define ADDR_DEVICE_ID			0x0001
+#define ADDR_UNLOCK_1			0x0555
+#define ADDR_UNLOCK_2			0x02AA
+
+/* Commands */
+#define CMD_UNLOCK_DATA_1		0x00AA
+#define CMD_UNLOCK_DATA_2		0x0055
+#define CMD_MANUFACTURER_UNLOCK_DATA	0x0090
+#define CMD_UNLOCK_BYPASS_MODE		0x0020
+#define CMD_PROGRAM_UNLOCK_DATA		0x00A0
+#define CMD_RESET_DATA			0x00F0
+#define CMD_SECTOR_ERASE_UNLOCK_DATA	0x0080
+#define CMD_SECTOR_ERASE_UNLOCK_DATA_2	0x0030
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+#define D6_MASK	0x40
+
+struct amd_flash_private {
+	int device_type;	
+	int interleave;	
+	int numchips;	
+	unsigned long chipshift;
+//	const char *im_name;
+	struct flchip chips[0];
+};
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+
+
+static int amd_flash_read(struct mtd_info *, loff_t, size_t, size_t *,
+			  u_char *);
+static int amd_flash_write(struct mtd_info *, loff_t, size_t, size_t *,
+			   const u_char *);
+static int amd_flash_erase(struct mtd_info *, struct erase_info *);
+static void amd_flash_sync(struct mtd_info *);
+static int amd_flash_suspend(struct mtd_info *);
+static void amd_flash_resume(struct mtd_info *);
+static void amd_flash_destroy(struct mtd_info *);
+
+
+
+static const char im_name[] = "amd_flash";
+
+
+
+static inline __u32 wide_read(struct map_info *map, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		return map->read8(map, addr);
+	} else if (map->buswidth == 2) {
+		return map->read16(map, addr);
+	} else if (map->buswidth == 4) {
+		return map->read32(map, addr);
+        }
+
+	return 0;
+}
+
+static inline void wide_write(struct map_info *map, __u32 val, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		map->write8(map, val, addr);
+	} else if (map->buswidth == 2) {
+		map->write16(map, val, addr);
+	} else if (map->buswidth == 4) {
+		map->write32(map, val, addr);
+	}
+}
+
+static inline __u32 make_cmd(struct map_info *map, __u32 cmd)
+{
+	const struct amd_flash_private *private = map->fldrv_priv;
+	if ((private->interleave == 2) &&
+	    (private->device_type == DEVICE_TYPE_X16)) {
+		cmd |= (cmd << 16);
+	}
+
+	return cmd;
+}
+
+static inline void send_unlock(struct map_info *map, unsigned long base)
+{
+	wide_write(map, (CMD_UNLOCK_DATA_1 << 16) | CMD_UNLOCK_DATA_1,
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+	wide_write(map, (CMD_UNLOCK_DATA_2 << 16) | CMD_UNLOCK_DATA_2,
+		   base + (map->buswidth * ADDR_UNLOCK_2));
+}
+
+static inline void send_cmd(struct map_info *map, unsigned long base, __u32 cmd)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd),
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+}
+
+static inline void send_cmd_to_addr(struct map_info *map, unsigned long base,
+				    __u32 cmd, unsigned long addr)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd), addr);
+}
+
+static inline int flash_is_busy(struct map_info *map, unsigned long addr,
+				int interleave)
+{
+
+	if ((interleave == 2) && (map->buswidth == 4)) {
+		__u32 read1, read2;
+
+		read1 = wide_read(map, addr);
+		read2 = wide_read(map, addr);
+
+		return (((read1 >> 16) & D6_MASK) !=
+			((read2 >> 16) & D6_MASK)) ||
+		       (((read1 & 0xffff) & D6_MASK) !=
+			((read2 & 0xffff) & D6_MASK));
+	}
+
+	return ((wide_read(map, addr) & D6_MASK) !=
+		(wide_read(map, addr) & D6_MASK));
+}
+
+
+
+/*
+ * Reads JEDEC manufacturer ID and device ID and returns the index of the first
+ * matching table entry (-1 if not found or alias for already found chip).
+ */ 
+static int probe_new_chip(struct mtd_info *mtd, unsigned long base,
+			  struct flchip *chips,
+			  struct amd_flash_private *private,
+			  const struct amd_flash_info *table, int table_size)
+{
+	__u32 mfr_id, dev_id;
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private temp;
+	int i;
+
+	temp.device_type = DEVICE_TYPE_X16;	// Assume X16 (FIXME)
+	temp.interleave = 2;
+	map->fldrv_priv = &temp;
+
+	/* Enter autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+	send_cmd(map, base, CMD_MANUFACTURER_UNLOCK_DATA);
+
+	mfr_id = wide_read(map, base + (map->buswidth * ADDR_MANUFACTURER));
+	dev_id = wide_read(map, base + (map->buswidth * ADDR_DEVICE_ID));
+
+	if ((map->buswidth == 4) && ((mfr_id >> 16) == (mfr_id & 0xffff)) &&
+	    ((dev_id >> 16) == (dev_id & 0xffff))) {
+		mfr_id = mfr_id & 0xffff;
+		dev_id = dev_id & 0xffff;
+	} else {
+		temp.interleave = 1;
+	}
+
+	for (i = 0; i < table_size; i++) {
+		if ((mfr_id == table[i].mfr_id) &&
+		    (dev_id == table[i].dev_id)) {
+			if (chips) {
+				int j;
+
+				/* Is this an alias for an already found chip?
+				 * In that case that chip should be in
+				 * autoselect mode now.
+				 */
+				for (j = 0; j < private->numchips; j++) {
+					if ((wide_read(map, chips[j].start +
+							    (map->buswidth *
+							     ADDR_MANUFACTURER))
+					     == mfr_id)
+					    &&
+					    (wide_read(map, chips[j].start +
+					    		    (map->buswidth *
+							     ADDR_DEVICE_ID))
+					     == dev_id)) {
+
+						/* Exit autoselect mode. */
+						send_cmd(map, base,
+							 CMD_RESET_DATA);
+
+						return -1;
+					}
+				}
+
+				if (private->numchips == MAX_AMD_CHIPS) {
+					printk(KERN_WARNING
+					       "%s: Too many flash chips "
+					       "detected. Increase "
+					       "MAX_AMD_CHIPS from %d.\n",
+					       map->name, MAX_AMD_CHIPS);
+
+					return -1;
+				}
+
+				chips[private->numchips].start = base;
+				chips[private->numchips].state = FL_READY;
+				chips[private->numchips].mutex =
+					&chips[private->numchips]._spinlock;
+				private->numchips++;
+			}
+
+			printk("%s: Found %d x %ldMb %s at 0x%x\n", map->name,
+			       temp.interleave, (table[i].size*8)/(1024*1024),
+			       table[i].name, base);
+
+			mtd->size += table[i].size * temp.interleave;
+			mtd->numeraseregions += table[i].numeraseregions;
+
+			break;
+		}
+	}
+
+	/* Exit autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+
+	if (i == table_size) {
+		printk(KERN_DEBUG "%s: unknown flash device at 0x%x, "
+		       "mfr id 0x%x, dev id 0x%x\n", map->name,
+		       base, mfr_id, dev_id);
+		map->fldrv_priv = NULL;
+
+		return -1;
+	}
+
+	private->device_type = temp.device_type;
+	private->interleave = temp.interleave;
+
+	return i;
+}
+
+
+
+struct mtd_info *amd_flash_probe(struct map_info *map)
+{
+	/* Keep this table on the stack so that it gets deallocated after the
+	 * probe is done.
+	 */
+	const struct amd_flash_info table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	} 
+	};
+
+	struct mtd_info *mtd;
+	struct flchip chips[MAX_AMD_CHIPS];
+	int table_pos[MAX_AMD_CHIPS];
+	struct amd_flash_private temp;
+	struct amd_flash_private *private;
+	u_long size;
+	unsigned long base;
+	int i;
+	int reg_idx;
+	int offset;
+
+	mtd = (struct mtd_info*)kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for info structure\n", map->name);
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+
+	memset(&temp, 0, sizeof(temp));
+
+	printk("%s: Probing for AMD compatible flash...\n", map->name);
+
+	if ((table_pos[0] = probe_new_chip(mtd, 0, NULL, &temp, table,
+					   sizeof(table)/sizeof(table[0])))
+	    == -1) {
+		printk(KERN_WARNING
+		       "%s: Found no AMD compatible device at location zero\n",
+		       map->name);
+		kfree(mtd);
+
+		return NULL;
+	}
+
+	chips[0].start = 0;
+	chips[0].state = FL_READY;
+	chips[0].mutex = &chips[0]._spinlock;
+	temp.numchips = 1;
+	for (size = mtd->size; size > 1; size >>= 1) {
+		temp.chipshift++;
+	}
+	switch (temp.interleave) {
+		case 2:
+			temp.chipshift += 1;
+			break;
+		case 4:
+			temp.chipshift += 2;
+			break;
+	}
+
+	/* Find out if there are any more chips in the map. */
+	for (base = (1 << temp.chipshift);
+	     base < map->size;
+	     base += (1 << temp.chipshift)) {
+	     	int numchips = temp.numchips;
+		table_pos[numchips] = probe_new_chip(mtd, base, chips,
+			&temp, table, sizeof(table)/sizeof(table[0]));
+	}
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+				    mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+		printk(KERN_WARNING "%s: Failed to allocate "
+		       "memory for MTD erase region info\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return 0;
+	}
+
+	reg_idx = 0;
+	offset = 0;
+	for (i = 0; i < temp.numchips; i++) {
+		int dev_size;
+		int j;
+
+		dev_size = 0;
+		for (j = 0; j < table[table_pos[i]].numeraseregions; j++) {
+			mtd->eraseregions[reg_idx].offset = offset +
+				(table[table_pos[i]].regions[j].offset *
+				 temp.interleave);
+			mtd->eraseregions[reg_idx].erasesize =
+				table[table_pos[i]].regions[j].erasesize *
+				temp.interleave;
+			mtd->eraseregions[reg_idx].numblocks =
+				table[table_pos[i]].regions[j].numblocks;
+			if (mtd->erasesize <
+			    mtd->eraseregions[reg_idx].erasesize) {
+				mtd->erasesize =
+					mtd->eraseregions[reg_idx].erasesize;
+			}
+			dev_size += mtd->eraseregions[reg_idx].erasesize *
+				    mtd->eraseregions[reg_idx].numblocks;
+			reg_idx++;
+		}
+		offset += dev_size;
+	}
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+	mtd->erase = amd_flash_erase;	
+	mtd->read = amd_flash_read;	
+	mtd->write = amd_flash_write;	
+	mtd->sync = amd_flash_sync;	
+	mtd->suspend = amd_flash_suspend;	
+	mtd->resume = amd_flash_resume;	
+	map->fldrv_destroy = amd_flash_destroy;
+
+	private = kmalloc(sizeof(*private) + (sizeof(struct flchip) *
+					      temp.numchips), GFP_KERNEL);
+	if (!private) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for private structure\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return NULL;
+	}
+	memcpy(private, &temp, sizeof(temp));
+	memcpy(private->chips, chips,
+	       sizeof(struct flchip) * private->numchips);
+	for (i = 0; i < private->numchips; i++) {
+		init_waitqueue_head(&private->chips[i].wq);
+		spin_lock_init(&private->chips[i]._spinlock);
+	}
+
+	map->fldrv_priv = private;
+
+	return mtd;
+}
+
+
+
+static inline int read_one_chip(struct map_info *map, struct flchip *chip,
+			       loff_t adr, size_t len, u_char *buf)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = jiffies + HZ;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk(KERN_INFO "%s: waiting for chip to read, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	adr += chip->start;
+
+	chip->state = FL_READY;
+
+	map->copy_from(map, buf, adr, len);
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long ofs;
+	int chipnum;
+	int ret = 0;
+
+	if ((from + len) > mtd->size) {
+		printk(KERN_WARNING "%s: read request past end of device "
+		       "(0x%x)\n", map->name, from + len);
+
+		return -EINVAL;
+	}
+
+	/* Offset within the first chip that the first read should start. */
+	chipnum = (from >> private->chipshift);
+	ofs = from - (chipnum <<  private->chipshift);
+
+	*retlen = 0;
+
+	while (len) {
+		unsigned long this_len;
+
+		if (chipnum >= private->numchips) {
+			break;
+		}
+
+		if ((len + ofs - 1) >> private->chipshift) {
+			this_len = (1 << private->chipshift) - ofs;
+		} else {
+			this_len = len;
+		}
+
+		ret = read_one_chip(map, &private->chips[chipnum], ofs,
+				    this_len, buf);
+		if (ret) {
+			break;
+		}
+
+		*retlen += this_len;
+		len -= this_len;
+		buf += this_len;
+
+		ofs = 0;
+		chipnum++;
+	}
+
+	return ret;
+}
+
+
+
+static int write_one_word(struct map_info *map, struct flchip *chip,
+			  unsigned long adr, __u32 datum)
+{
+	unsigned long timeo = jiffies + HZ;
+	unsigned int Last[4];
+	unsigned long Count = 0;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+	int times_left;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk("%s: waiting for chip to write, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		printk(KERN_INFO "%s: woke up to write\n", map->name);
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_WRITING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_PROGRAM_UNLOCK_DATA);
+	wide_write(map, datum, adr);
+
+	times_left = 500000;
+	while (times_left-- && flash_is_busy(map, chip->start,
+					     private->interleave)) {
+		if (current->need_resched) {
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			spin_lock_bh(chip->mutex);
+		}
+	}
+
+	if (!times_left) {
+		printk(KERN_WARNING "%s: write to 0x%x timed out!\n",
+		       map->name, adr);
+		ret = -EIO;
+	} else {
+		__u32 verify;
+		if ((verify = wide_read(map, adr)) != datum) {
+			printk(KERN_WARNING "%s: write to 0x%x failed. "
+			       "datum = %x, verify = %x\n",
+			       map->name, adr, datum, verify);
+			ret = -EIO;
+		}
+	}
+
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return ret;
+}
+
+
+
+static int amd_flash_write(struct mtd_info *mtd, loff_t to , size_t len,
+			   size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
+	unsigned long chipstart;
+
+	*retlen = 0;
+	if (!len) {
+		return 0;
+	}
+
+	chipnum = to >> private->chipshift;
+	ofs = to  - (chipnum << private->chipshift);
+	chipstart = private->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write. */
+	if (ofs & (map->buswidth - 1)) {
+		unsigned long bus_ofs = ofs & ~(map->buswidth - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       bus_ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len && i < map->buswidth)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], bus_ofs,
+				     datum);
+		if (ret) {
+			return ret;
+		}
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+		}
+	}
+	
+	/* We are now aligned, write as much as possible. */
+	while(len >= map->buswidth) {
+		__u32 datum;
+
+		if (map->buswidth == 1) {
+			datum = *(__u8*)buf;
+		} else if (map->buswidth == 2) {
+			datum = *(__u16*)buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+
+		ofs += map->buswidth;
+		buf += map->buswidth;
+		(*retlen) += map->buswidth;
+		len -= map->buswidth;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+			chipstart = private->chips[chipnum].start;
+		}
+	}
+
+	if (len & (map->buswidth - 1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[2];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len--) {
+			tmp_buf[i++] = buf[n++];
+		}
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+		
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+
+
+static inline int erase_one_block(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, u_long size)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_ERASING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA);
+	send_cmd_to_addr(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA_2, adr);
+	
+	timeo = jiffies + (HZ * 20);
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+	
+	while (flash_is_busy(map, chip->start, private->interleave)) {
+
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_INFO "%s: erase suspended. Sleeping\n",
+			       map->name);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+			
+			timeo = jiffies + (HZ*2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING "%s: waiting for erase to complete "
+			       "timed out.\n", map->name);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+
+		if (current->need_resched)
+			schedule();
+		else
+			udelay(1);
+		
+		spin_lock_bh(chip->mutex);
+	}
+
+	/* Verify every single word */
+	{
+		int address;
+		int error = 0;
+		__u8 verify;
+
+		for (address = adr; address < (adr + size); address++) {
+			if ((verify = map->read8(map, address)) != 0xFF) {
+				error = 1;
+				break;
+			}
+		}
+		if (error) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING
+			       "%s: verify error at 0x%x, size %ld.\n",
+			       map->name, address, size);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+	}
+	
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum;
+	int ret = 0;
+	int i;
+	int first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size) {
+		return -EINVAL;
+	}
+
+	if ((instr->len + instr->addr) > mtd->size) {
+		return -EINVAL;
+	}
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+        /* Skip all erase regions which are ended before the start of
+           the requested erase. Actually, to save on the calculations,
+           we skip to the first erase region which starts after the
+           start of the requested erase, and then go back one.
+        */
+
+        while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset)) {
+               i++;
+	}
+        i--;
+
+	/* OK, now i is pointing at the erase region in which this
+	 * erase request starts. Check the start of the requested
+	 * erase range is aligned with the erase size which is in
+	 * effect here.
+	 */
+
+	if (instr->addr & (regions[i].erasesize-1)) {
+		return -EINVAL;
+	}
+
+	/* Remember the erase region we start on. */
+
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while ((i < mtd->numeraseregions) && 
+	       ((instr->addr + instr->len) >= regions[i].offset)) {
+                i++;
+	}
+
+	/* As before, drop back one to point at the region in which
+	 * the address actually falls.
+	 */
+
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1)) {
+                return -EINVAL;
+	}
+
+	chipnum = instr->addr >> private->chipshift;
+	adr = instr->addr - (chipnum << private->chipshift);
+	len = instr->len;
+
+	i = first;
+
+	while (len) {
+		ret = erase_one_block(map, &private->chips[chipnum], adr,
+				      regions[i].erasesize);
+
+		if (ret) {
+			return ret;
+		}
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if ((adr % (1 << private->chipshift)) ==
+		    ((regions[i].offset + (regions[i].erasesize *
+		    			   regions[i].numblocks))
+		     % (1 << private->chipshift))) {
+			i++;
+		}
+
+		if (adr >> private->chipshift) {
+			adr = 0;
+			chipnum++;
+			if (chipnum >= private->numchips) {
+				break;
+			}
+		}
+	}
+		
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback) {
+		instr->callback(instr);
+	}
+	
+	return 0;
+}
+
+
+
+static void amd_flash_sync(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i = 0; !ret && (i < private->numchips); i++) {
+		chip = &private->chips[i];
+
+	retry:
+		spin_lock_bh(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_SYNCING:
+			spin_unlock_bh(chip->mutex);
+			break;
+
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+
+			schedule();
+
+		        remove_wait_queue(&chip->wq, &wait);
+			
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+	for (i--; i >= 0; i--) {
+		chip = &private->chips[i];
+
+		spin_lock_bh(chip->mutex);
+		
+		if (chip->state == FL_SYNCING) {
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+
+
+static int amd_flash_suspend(struct mtd_info *mtd)
+{
+printk("amd_flash_suspend(): not implemented!\n");
+	return -EINVAL;
+}
+
+
+
+static void amd_flash_resume(struct mtd_info *mtd)
+{
+printk("amd_flash_resume(): not implemented!\n");
+}
+
+
+
+static void amd_flash_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	kfree(private);
+}
+
+
+
+int __init amd_flash_init(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &amd_flash_probe);
+
+	return 0;
+}
+
+void __exit amd_flash_exit(void)
+{
+	inter_module_unregister(im_name);
+}
+
+module_init(amd_flash_init);
+module_exit(amd_flash_exit);
diff -Naur linux-2.4.2.orig/drivers/mtd/armflash.c linux-2.4.2/drivers/mtd/armflash.c
--- linux-2.4.2.orig/drivers/mtd/armflash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/armflash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,520 @@
+/*======================================================================
+
+    drivers/mtd/armflash.c: ARM Flash Layout/Partitioning
+  
+    Copyright (C) 2000 ARM Limited
+ 
+   $Id: armflash.c,v 1.2 2001/03/26 17:47:27 dwmw2 Exp $
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+  
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+  
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  
+   This is access code for flashes using ARM's flash partitioning 
+   standards.
+
+   NOTES:  The write stuff is completely board specific and I don't think
+   that this is the right thing to do.	 Better would be to use the
+   CFI stuff.
+
+======================================================================*/
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/malloc.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/iflash.h>
+#include <linux/mtd/map.h>
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+#include <asm/arch/bits.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/platform.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#define AFS_DEBUG 0
+#define AFS_DEBUG_RW 0
+
+/* data structures */
+struct footer_struct {
+	void *infoBase;			/* Address of first word of ImageFooter  */
+	char *blockBase;		/* Start of area reserved by this footer */
+	unsigned int signature;		/* 'Magic' number proves it's a footer   */
+	unsigned int type;		/* Area type: ARM Image, SIB, customer   */
+	unsigned int checksum;		/* Just this structure                   */
+};
+
+struct image_info_struct {
+	unsigned int bootFlags;		/* Boot flags, compression etc.          */
+	unsigned int imageNumber;	/* Unique number, selects for boot etc.  */
+	char *loadAddress;		/* Address program should be loaded to   */
+	unsigned int length;		/* Actual size of image                  */
+	unsigned int address;		/* Image is executed from here           */
+	char name[16];			/* Null terminated                       */
+	char *headerBase;		/* Flash Address of any stripped header  */
+	unsigned int header_length;	/* Length of header in memory            */
+	unsigned int headerType;	/* AIF, RLF, s-record etc.               */
+	unsigned int checksum;		/* Image checksum (inc. this struct)     */
+};
+
+struct afs_info {
+	struct afs_info *next;		/* next in list                          */
+	struct mtd_info *mtd;		/* Owning mtd_info block                 */
+	struct mtd_info *dev_mtd;	/* Device MTD                            */
+	u_int base;			/* offset                                */
+	char *name;			/* Name of thing (set by AFU)            */
+};
+
+// board specific stuff - sorry, it should be in arch/arm/mach-*.
+#ifdef CONFIG_ARCH_INTEGRATOR
+
+#define FLASH_BASE	INTEGRATOR_FLASH_BASE
+#define FLASH_SIZE	INTEGRATOR_FLASH_SIZE
+
+#define FLASH_PART_SIZE 0x400000
+
+static void afs_flash_unlock(void)
+{
+	volatile unsigned int *sc_ctrlc = (unsigned int *) (IO_ADDRESS(INTEGRATOR_SC_BASE) +
+					     INTEGRATOR_SC_CTRLC_OFFSET);
+	volatile unsigned int *ebi_csr1 = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_CSR1_OFFSET);
+#if AFS_DEBUG
+	printk("AFS Flash: Debug: unlocking flash\n");
+#endif
+
+	// Set the write enable bit in system controller EBI register.
+	*ebi_csr1 |= INTEGRATOR_EBI_WRITE_ENABLE;
+	if (!(*ebi_csr1 & INTEGRATOR_EBI_WRITE_ENABLE)) {
+		volatile unsigned int *ebi_lock = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_LOCK_OFFSET);
+
+		*ebi_lock = 0xA05F;
+		*ebi_csr1 |= INTEGRATOR_EBI_WRITE_ENABLE;
+		*ebi_lock = 0;
+	}
+	// Set the Flash programming bits in the system controller.
+	*sc_ctrlc |= INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP;
+}
+
+static void afs_flash_lock(void)
+{
+	volatile unsigned int *sc_ctrls = (unsigned int *) (IO_ADDRESS(INTEGRATOR_SC_BASE) +
+					     INTEGRATOR_SC_CTRLS_OFFSET);
+	volatile unsigned int *ebi_csr1 = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_CSR1_OFFSET);
+
+#if AFS_DEBUG
+	printk("AFS Flash: Debug: locking flash\n");
+#endif
+
+	// Clear the write enable bit in system controller EBI register.
+	*ebi_csr1 &= ~INTEGRATOR_EBI_WRITE_ENABLE;
+	if (*ebi_csr1 & INTEGRATOR_EBI_WRITE_ENABLE) {
+		volatile unsigned int *ebi_lock = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_LOCK_OFFSET);
+
+		*ebi_lock = 0xA05F;
+		*ebi_csr1 &= ~INTEGRATOR_EBI_WRITE_ENABLE;
+		*ebi_lock = 0;
+	}
+	// Clear the Flash programming bits in the system controller.
+	*sc_ctrls |= INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP;
+}
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+
+#define FLASH_BASE		(0x04000000)
+#define FLASH_SIZE		(64*1024*1024)
+
+#define FLASH_PART_SIZE 	(4*1024*1024)
+#define FLASH_BLOCK_SIZE	(128*1024)
+
+static void afs_flash_unlock(void)
+{
+}
+
+static void afs_flash_lock(void)
+{
+}
+#endif
+
+// AFS flash partitioning 
+static int afs_flash_suspend(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	u_int status = 0;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_suspend() called\n");
+#endif
+
+	if (afs->dev_mtd->suspend)
+		status = afs->dev_mtd->suspend(afs->dev_mtd);
+
+	return status;
+}
+
+static void afs_flash_resume(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_resume() called\n");
+#endif
+
+	if (afs->dev_mtd->resume)
+		afs->dev_mtd->resume(afs->dev_mtd);
+}
+
+static void afs_flash_sync(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_sync() called\n");
+#endif
+
+	afs->dev_mtd->sync(afs->dev_mtd);
+}
+
+static void afs_erase_callback(struct erase_info *ei)
+{
+	struct erase_info *eii = (struct erase_info *) ei->priv;
+
+	if (eii->callback)
+		eii->callback(eii);
+}
+
+static int afs_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	struct erase_info ei = *instr;
+	u_int status;
+
+	ei.mtd = afs->dev_mtd;
+	ei.addr = afs->base + instr->addr;
+	ei.callback = afs_erase_callback;
+	ei.priv = (u_long) instr;
+	ei.next = NULL;
+
+	status = afs->dev_mtd->erase(afs->dev_mtd, &ei);
+
+	return status;
+}
+
+static int afs_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	int ret;
+
+	from += afs->base;
+
+	afs_flash_unlock();
+	ret = afs->dev_mtd->read(afs->dev_mtd, from, len, retlen, buf);
+	afs_flash_lock();
+
+	return ret;
+}
+
+
+static int afs_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	int ret;
+
+	to += afs->base;
+
+//	afs_flash_unlock();
+	ret = afs->dev_mtd->write(afs->dev_mtd, to, len, retlen, buf);
+//	afs_flash_lock();
+
+	return ret;
+}
+
+static __u8 afs_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 val = readb(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read8(0x%06lx) = 0x%02x\n", ofs, val);
+#endif
+	return val;
+}
+
+static __u16 afs_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 val = readw(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read16(0x%06lx) = 0x%04x\n", ofs, val);
+#endif
+	return val;
+}
+
+static __u32 afs_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 val = readl(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read32(0x%06lx) = 0x%08x\n", ofs, val);
+#endif
+	return val;
+}
+
+static void afs_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_copy_from(0x%p, 0x%lx, %d)\n", to, from, len);
+#endif
+	memcpy(to, (void *) (from + map->map_priv_2), len);
+}
+
+static void afs_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write8(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writeb(d, adr + map->map_priv_2);
+}
+
+static void afs_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write16(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writew(d, adr + map->map_priv_2);
+}
+
+static void afs_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write32(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writel(d, adr + map->map_priv_2);
+}
+
+static void afs_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_copy_to(0x%lx, 0x%px, %d)\n", to, from, len);
+#endif
+	memcpy((void *) (to + map->map_priv_2), from, len);
+}
+
+static struct map_info afs_map =
+{
+	name:		"AFS",
+	read8:		afs_read8,
+	read16:		afs_read16,
+	read32:		afs_read32,
+	copy_from:	afs_copy_from,
+	write8:		afs_write8,
+	write16:	afs_write16,
+	write32:	afs_write32,
+	copy_to:	afs_copy_to,
+};
+
+static int __init afs_cfi_init(u_int base, u_int size)
+{
+	struct mtd_info *mtd;
+	u_int mask, off, idx;
+
+	/*
+	 * look for CFI based flash parts fitted to this board
+	 */
+	afs_map.size       = size;
+	afs_map.buswidth   = 4;
+	afs_map.map_priv_1 = 0;
+	afs_map.map_priv_2 = (unsigned long) base;
+
+	/*
+	 * Also, the CFI layer automatically works out what size
+	 * of chips we have, and does the necessary identification
+	 * for us automatically.
+	 *
+	 * Note that we don't want to keep the flash unlocked for
+	 * more time than necessary.
+	 */
+	afs_flash_unlock();
+	mtd = do_cfi_probe(&afs_map);
+	afs_flash_lock();
+
+	if (!mtd)
+		return -ENODEV;
+
+	mtd->module = THIS_MODULE;
+
+	/*
+	 * This is the address mask; we use this to mask off out of
+	 * range address bits.
+	 */
+	mask = afs_map.size - 1;
+
+	/*
+	 * Identify the partitions
+	 */
+	for (idx = off = 0; off < mtd->size; off += FLASH_BLOCK_SIZE) {
+		struct afs_info *afs_part;
+		struct mtd_info *my_mtd;
+		struct footer_struct fs;
+		struct image_info_struct iis;
+		u_int ptr, length;
+		size_t sz;
+		int ret;
+
+		/*
+		 * Read the footer
+		 */
+		afs_flash_unlock();
+		ret = mtd->read(mtd, off + FLASH_BLOCK_SIZE - sizeof(fs),
+				sizeof(fs), &sz, (u_char *) &fs);
+		afs_flash_lock();
+
+		if (ret) {
+			printk(KERN_ERR "error reading flash at offset 0x%x: %d\n",
+				off + FLASH_BLOCK_SIZE - sizeof(fs), ret);
+			break;
+		}
+
+		/*
+		 * Does it contain the magic number?
+		 */
+		if (fs.signature != 0xa0ffff9f)
+			continue;
+
+		/*
+		 * Read the image info block
+		 */
+		ptr = (u_int) fs.infoBase & mask;
+		if (ptr >= mtd->size)
+			continue;
+
+		memset(&iis, 0, sizeof(iis));
+		if (ptr) {
+			afs_flash_unlock();
+			ret = mtd->read(mtd, ptr, sizeof(iis), &sz, (u_char *) &iis);
+			afs_flash_lock();
+		}
+
+		if (ret) {
+			printk(KERN_ERR "error reading flash at offset 0x%x: %d\n",
+				ptr, ret);
+			break;
+		}
+
+		ptr = (u_int) fs.blockBase & mask;
+		if (ptr > mtd->size || ptr > off)
+			continue;
+
+		length = FLASH_BLOCK_SIZE + off - ptr;
+
+		afs_part = kmalloc(sizeof(struct afs_info) +
+				   sizeof(struct mtd_info) + 16,
+				   GFP_KERNEL);
+		if (!afs_part)
+			return -ENOMEM;
+
+		memset(afs_part, 0, sizeof(struct afs_info) + sizeof(struct mtd_info));
+
+		my_mtd = (struct mtd_info *) (afs_part + 1);
+
+		afs_part->dev_mtd = mtd;
+		afs_part->base    = ptr;
+		afs_part->mtd     = my_mtd;
+		afs_part->name    = (char *) (my_mtd + 1);
+
+		my_mtd->type      = mtd->type;
+		my_mtd->flags     = mtd->flags;
+		my_mtd->size      = length;
+		my_mtd->erasesize = mtd->erasesize;
+		my_mtd->oobblock  = mtd->oobblock;
+		my_mtd->oobsize   = mtd->oobsize;
+		my_mtd->ecctype   = mtd->ecctype;
+		my_mtd->eccsize   = mtd->eccsize;
+		my_mtd->name      = "ARM Firmware Suite, Flash Partition";
+		my_mtd->bank_size = mtd->bank_size;
+		my_mtd->module    = THIS_MODULE;
+		my_mtd->erase     = afs_flash_erase;
+		my_mtd->point     = NULL;
+		my_mtd->unpoint   = NULL;
+		my_mtd->read      = afs_flash_read;
+		my_mtd->write     = afs_flash_write;
+		my_mtd->read_ecc  = mtd->read_ecc;
+		my_mtd->write_ecc = mtd->write_ecc;
+		my_mtd->read_oob  = mtd->read_oob;
+		my_mtd->write_oob = mtd->write_oob;
+		my_mtd->sync      = afs_flash_sync;
+		my_mtd->suspend   = afs_flash_suspend;
+		my_mtd->resume    = afs_flash_resume;
+		my_mtd->priv      = afs_part;
+
+		memcpy(afs_part->name, iis.name, 16);
+
+		if (add_mtd_device(afs_part->mtd)) {
+			printk(KERN_ERR "AFS: MTD device registration failed!\n");
+			kfree(afs_part);
+			return -EAGAIN;
+		}
+		printk("  mtd%d: at 0x%08x, %5dKB, %8d, %s\n",
+		     idx, ptr, length / 1024, iis.imageNumber, iis.name);
+
+		idx += 1;
+	}
+
+	return 0;
+}
+
+#if defined (MODULE) && LINUX_VERSION_CODE < 0x20300
+#define init_armflash init_module
+#define cleanup_armflash cleanup_module
+#endif
+
+int __init init_armflash(void)
+{
+	unsigned int flash_base;
+
+	printk("ARM Flash Layout (V1.0)\n");
+
+	flash_base = (unsigned int)__ioremap(FLASH_BASE, FLASH_SIZE, 0);
+	return afs_cfi_init(flash_base, FLASH_SIZE);
+}
+
+static void __init cleanup_armflash(void)
+{
+	afs_flash_lock();
+	iounmap((void *)afs_map.map_priv_2);
+}
+
+#if LINUX_VERSION_CODE > 0x20300
+module_init(init_armflash);
+module_exit(cleanup_armflash);
+#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/bootldr.c linux-2.4.2/drivers/mtd/bootldr.c
--- linux-2.4.2.orig/drivers/mtd/bootldr.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/bootldr.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,219 @@
+/*
+ * Read flash partition table from Compaq Bootloader
+ *
+ * Copyright 2001 Compaq Computer Corporation.
+ *
+ * $Id: bootldr.c,v 1.7 2001/11/20 19:31:37 jamey Exp $
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * COMPAQ COMPUTER CORPORATION MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ */
+
+/*
+ * Maintainer: Jamey Hicks (jamey.hicks@compaq.com)
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <asm/setup.h>
+#include <linux/bootmem.h>
+
+#define FLASH_PARTITION_NAMELEN 32
+enum LFR_FLAGS {
+        LFR_SIZE_PREFIX = 1,		/* prefix data with 4-byte size */
+        LFR_PATCH_BOOTLDR = 2,	/* patch bootloader's 0th instruction */
+        LFR_KERNEL = 4,		/* add BOOTIMG_MAGIC, imgsize and VKERNEL_BASE to head of programmed region (see bootldr.c) */
+        LFR_EXPAND = 8               /* expand partition size to fit rest of flash */
+};
+
+// the tags are parsed too early to malloc or alloc_bootmem so we'll fix it
+// for now
+#define MAX_NUM_PARTITIONS 8
+typedef struct FlashRegion {
+        char name[FLASH_PARTITION_NAMELEN];
+        u32 base;
+        u32 size;
+        u32 flags;
+} FlashRegion;
+
+typedef struct BootldrFlashPartitionTable {
+        u32 magic; /* should be filled with 0x646c7470 (btlp) BOOTLDR_PARTITION_MAGIC */
+        u32 npartitions;
+        struct FlashRegion partition[8];
+} BootldrFlashPartitionTable;
+
+#define BOOTLDR_MAGIC      0x646c7462        /* btld: marks a valid bootldr image */
+#define BOOTLDR_PARTITION_MAGIC  0x646c7470  /* btlp: marks a valid bootldr partition table in params sector */
+
+#define BOOTLDR_MAGIC_OFFSET 0x20 /* offset 0x20 into the bootldr */
+#define BOOTCAP_OFFSET 0X30 /* offset 0x30 into the bootldr */
+
+#define BOOTCAP_WAKEUP	(1<<0)
+#define BOOTCAP_PARTITIONS (1<<1) /* partition table stored in params sector */
+#define BOOTCAP_PARAMS_AFTER_BOOTLDR (1<<2) /* params sector right after bootldr sector(s), else in last sector */
+
+static struct BootldrFlashPartitionTable Table;
+static struct BootldrFlashPartitionTable *partition_table = NULL;
+
+
+int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+{
+	struct mtd_partition *parts;
+	int ret = 0;
+	int retlen, i;
+	int npartitions = 0;
+	long partition_table_offset;
+	long bootmagic = 0;
+	long bootcap = 0;
+	int namelen = 0;
+
+	char *names; 
+
+        /* if we did not receive a partition table from the bootldr, then try to read one from flash */
+        if (!partition_table) {
+                /* verify bootldr magic */
+                ret = master->read(master, BOOTLDR_MAGIC_OFFSET, sizeof(long), &retlen, (void *)&bootmagic);
+                if (ret) 
+                        goto out;
+                if (bootmagic != BOOTLDR_MAGIC)
+                        goto out;
+                /* see if bootldr supports partition tables and where to find the partition table */
+                ret = master->read(master, BOOTCAP_OFFSET, sizeof(long), &retlen, (void *)&bootcap);
+                if (ret) 
+                        goto out;
+
+                if (!(bootcap & BOOTCAP_PARTITIONS))
+                        goto out;
+                if (bootcap & BOOTCAP_PARAMS_AFTER_BOOTLDR)
+                        partition_table_offset = master->erasesize;
+                else
+                        partition_table_offset = master->size - master->erasesize;
+
+                /* Read the partition table */
+                partition_table = (struct BootldrFlashPartitionTable *)kmalloc(PAGE_SIZE, GFP_KERNEL);
+                if (!partition_table)
+                        return -ENOMEM;
+
+                ret = master->read(master, partition_table_offset,
+                                   PAGE_SIZE, &retlen, (void *)partition_table);
+                if (ret)
+                        goto out;
+        }
+
+	if (!partition_table)
+                return -ENOMEM;
+	
+	printk(__FUNCTION__ ": magic=%#x\n", partition_table->magic);
+	printk(__FUNCTION__ ": numPartitions=%#x\n", partition_table->npartitions);
+
+	/* check for partition table magic number */
+	if (partition_table->magic != BOOTLDR_PARTITION_MAGIC) 
+		goto out;
+	npartitions = (partition_table->npartitions > MAX_NUM_PARTITIONS)?
+                MAX_NUM_PARTITIONS:partition_table->npartitions;	
+
+	printk(__FUNCTION__ ": npartitions=%#x\n", npartitions);
+
+	for (i = 0; i < npartitions; i++) {
+		namelen += strlen(partition_table->partition[i].name) + 1;
+	}
+
+	parts = kmalloc(sizeof(*parts)*npartitions + namelen, GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	names = (char *)&parts[npartitions];
+	memset(parts, 0, sizeof(*parts)*npartitions + namelen);
+
+
+	// from here we use the partition table
+	for (i = 0; i < npartitions; i++) {
+                struct FlashRegion *partition = &partition_table->partition[i];
+		const char *name = partition->name;
+		parts[i].name = names;
+		names += strlen(name) + 1;
+		strcpy(parts[i].name, name);
+
+                if (partition->flags & LFR_EXPAND)
+                        parts[i].size = MTDPART_SIZ_FULL;
+                else
+                        parts[i].size = partition->size;
+		parts[i].offset = partition->base;
+		parts[i].mask_flags = 0;
+		
+		printk("        partition %s o=%x s=%x\n", 
+		       parts[i].name, parts[i].offset, parts[i].size);
+
+	}
+
+	ret = npartitions;
+	*pparts = parts;
+
+ out:
+#if 0
+	if (partition_table)
+		kfree(partition_table);
+#endif
+	
+	return ret;
+}
+
+
+static int __init parse_tag_ptable(const struct tag *tag)
+{
+#ifdef CONFIG_DEBUG_LL
+        char buf[128];
+        int i;
+        int j;
+#endif
+        struct BootldrFlashPartitionTable *ptable = (struct BootldrFlashPartitionTable *)(&tag->u);
+    
+        partition_table = &Table;
+
+#ifdef CONFIG_DEBUG_LL    
+        sprintf(buf,"ptable: magic = = 0x%lx  npartitions= %d \n",
+                ptable->magic,ptable->npartitions);
+        printascii(buf);
+    
+        for (i=0; i<ptable->npartitions; i++){
+                sprintf(buf,"ptable: partition name = %s base= 0x%lx  size= 0x%lx flags= 0x%lx\n",
+                        (char *) (&ptable->partition[i].name[0]),
+                        ptable->partition[i].base,
+                        ptable->partition[i].size,
+                        ptable->partition[i].flags);
+                printascii(buf);
+        }
+#endif
+
+        memcpy((void *)partition_table,(void *) ptable,sizeof(partition_table) +
+               sizeof(struct FlashRegion)*ptable->npartitions);
+    
+        return 0;
+}
+static int __init parse_tag_ptable_compat(const struct tag *tag) 
+{
+        return parse_tag_ptable(tag);
+}
+
+/* keep the unofficial ptag entry until we get bootldr's updated */ 
+#define ATAG_PTABLE_COMPAT 0x5441000A /* unofficial value we were using -- will delete */
+__tagtable(ATAG_PTABLE_COMPAT, parse_tag_ptable_compat);
+
+/* official one */
+__tagtable(ATAG_PTABLE, parse_tag_ptable);
+
+EXPORT_SYMBOL(parse_bootldr_partitions);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Compaq Computer Corporation");
+MODULE_DESCRIPTION("Parsing code for Compaq bootldr partitions");
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0001.c linux-2.4.2/drivers/mtd/cfi_cmdset_0001.c
--- linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0001.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_cmdset_0001.c	Fri Feb 15 14:41:15 2002
@@ -4,7 +4,15 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0001.c,v 1.21 2000/07/13 10:36:14 dwmw2 Exp $
+ * $Id: cfi_cmdset_0001.c,v 1.72 2001/03/26 13:51:15 kd Exp $
+ *
+ * 
+ * 10/10/2000	Nicolas Pitre <nico@cam.org>
+ * 	- completely revamped method functions so they are aware and
+ * 	  independent of the flash geometry (buswidth, interleave, etc.)
+ * 	- scalability vs code size is completely set at compile-time
+ * 	  (see include/linux/mtd/cfi.h for selection)
+ *	- optimized write buffer method
  */
 
 #include <linux/module.h>
@@ -15,29 +23,32 @@
 #include <asm/byteorder.h>
 
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/delay.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
+#include <linux/mtd/compatmac.h>
 
-#if LINUX_VERSION_CODE < 0x20300
-#define set_current_state(x) current->state = (x);
-#endif
-static int cfi_intelext_read_1_by_16 (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-static int cfi_intelext_write_1_by_16(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
-static int cfi_intelext_erase_1_by_16 (struct mtd_info *, struct erase_info *);
+static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_erase_varsize(struct mtd_info *, struct erase_info *);
 static void cfi_intelext_sync (struct mtd_info *);
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
 static int cfi_intelext_suspend (struct mtd_info *);
 static void cfi_intelext_resume (struct mtd_info *);
 
 static void cfi_intelext_destroy(struct mtd_info *);
 
-static void cfi_cmdset_0001(struct map_info *, int, unsigned long);
+void cfi_cmdset_0001(struct map_info *, int, unsigned long);
 
 static struct mtd_info *cfi_intelext_setup (struct map_info *);
 
 static const char im_name[] = "cfi_cmdset_0001";
 
+/* #define DEBUG_LOCK_BITS */
+
 /* This routine is made available to other mtd code via
  * inter_module_register.  It must only be accessed through
  * inter_module_get which will bump the use count of this module.  The
@@ -45,21 +56,22 @@
  * this module is non-zero, i.e. between inter_module_get and
  * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
  */
-static void cfi_cmdset_0001(struct map_info *map, int primary, unsigned long base)
+void cfi_cmdset_0001(struct map_info *map, int primary, unsigned long base)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	int i;
 	struct cfi_pri_intelext *extp;
+	int ofs_factor = cfi->interleave * cfi->device_type;
 
-	__u16 adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+	__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 
-	printk(" Intel/Sharp Extended Query Table at 0x%4.4X\n", adr);
+	//printk(" Intel/Sharp Extended Query Table at 0x%4.4X\n", adr);
 
 	if (!adr)
 		return;
 
 	/* Switch it into Query Mode */
-	switch(map->buswidth) {
+	switch(CFIDEV_BUSWIDTH) {
 	case 1:
 		map->write8(map, 0x98, 0x55);
 		break;
@@ -80,7 +92,7 @@
 	/* Read in the Extended Query Table */
 	for (i=0; i<sizeof(*extp); i++) {
 		((unsigned char *)extp)[i] = 
-			map->read8(map, (base+((adr+i)*map->buswidth)));
+		    cfi_read_query(map, (base+((adr+i)*cfi->interleave*cfi->device_type)));
 	}
 
 	if (extp->MajorVersion != '1' || 
@@ -92,8 +104,8 @@
 	}
 
 	/* Do some byteswapping if necessary */
-	extp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);
-	extp->BlkStatusRegMask = le32_to_cpu(extp->BlkStatusRegMask);
+	extp->FeatureSupport = cfi32_to_cpu(extp->FeatureSupport);
+	extp->BlkStatusRegMask = cfi32_to_cpu(extp->BlkStatusRegMask);
 
 	
 	/* Tell the user about it in lots of lovely detail */
@@ -137,7 +149,7 @@
 	/* OK. We like it. Take over the control of it. */
 
 	/* Switch it into Read Mode */
-	switch(map->buswidth) {
+	switch(CFIDEV_BUSWIDTH) {
 	case 1:
 		map->write8(map, 0xff, 0x55);
 		break;
@@ -151,7 +163,7 @@
 
 
 	/* If there was an old setup function, decrease its use count */
-	if (cfi->cmdset_setup)
+	if (cfi->im_name)
 		inter_module_put(cfi->im_name);
 	if (cfi->cmdset_priv)
 		kfree(cfi->cmdset_priv);
@@ -164,9 +176,18 @@
 		
 
 	cfi->cmdset_setup = cfi_intelext_setup;
-	cfi->im_name = im_name;
 	cfi->cmdset_priv = extp;
-	
+
+#if 1 /* Does this work? */
+	cfi_send_gen_cmd(0x90, 0x55, base, map, cfi->interleave, cfi->device_type, NULL);
+
+	cfi->mfr = cfi_read_query(map, base);
+	cfi->id = cfi_read_query(map, base + ofs_factor);
+
+	printk("JEDEC ID: %2.2X %2.2X\n", cfi->mfr, cfi->id);
+#endif
+
+        cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
 	return;
 }
 
@@ -174,9 +195,12 @@
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct mtd_info *mtd;
+	unsigned long offset = 0;
+	int i,j;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
 	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
-	printk("number of CFI chips: %d\n", cfi->numchips);
+	//printk("number of CFI chips: %d\n", cfi->numchips);
 
 	if (!mtd) {
 	  printk("Failed to allocate memory for MTD device\n");
@@ -187,13 +211,59 @@
 	memset(mtd, 0, sizeof(*mtd));
 	mtd->priv = map;
 	mtd->type = MTD_NORFLASH;
-	mtd->erasesize = 0x20000; /* FIXME */
+	mtd->size = devsize * cfi->numchips;
+
+	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) 
+			* mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+			printk("Failed to allocate memory for MTD erase region info\n");
+			kfree(cfi->cmdset_priv);
+			return NULL;
+	}
+	
+	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+		unsigned long ernum, ersize;
+		ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+		ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+
+		if (mtd->erasesize < ersize) {
+			mtd->erasesize = ersize;
+		}
+		for (j=0; j<cfi->numchips; j++) {
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+		}
+		offset += (ersize * ernum);
+		}
+
+		if (offset != devsize) {
+			/* Argh */
+			printk("Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk("%d: offset=0x%lx,size=0x%lx,blocks=%d\n",i,mtd->eraseregions[i].offset,
+			mtd->eraseregions[i].erasesize,mtd->eraseregions[i].numblocks);
+		}
+
 	/* Also select the correct geometry setup too */ 
-	mtd->size = (1 << cfi->cfiq.DevSize) * cfi->numchips;
-	mtd->erase = cfi_intelext_erase_1_by_16;
-	mtd->read = cfi_intelext_read_1_by_16;
-	mtd->write = cfi_intelext_write_1_by_16;
+		mtd->erase = cfi_intelext_erase_varsize;
+	mtd->read = cfi_intelext_read;
+	if ( cfi->cfiq->BufWriteTimeoutTyp ) {
+		//printk( KERN_INFO"Using buffer write method\n" );
+		mtd->write = cfi_intelext_write_buffers;
+	} else {
+		//printk( KERN_INFO"Using word write method\n" );
+		mtd->write = cfi_intelext_write_words;
+	}
 	mtd->sync = cfi_intelext_sync;
+	mtd->lock = cfi_intelext_lock;
+	mtd->unlock = cfi_intelext_unlock;
 	mtd->suspend = cfi_intelext_suspend;
 	mtd->resume = cfi_intelext_resume;
 	mtd->flags = MTD_CAP_NORFLASH;
@@ -202,101 +272,129 @@
 	return mtd;
 }
 
-static inline int do_read_1_by_16_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	__u32 status, status_OK;
+	unsigned long timeo;
 	DECLARE_WAITQUEUE(wait, current);
+	int suspended = 0;
+	unsigned long cmd_addr;
+	struct cfi_private *cfi = map->fldrv_priv;
 
 	adr += chip->start;
 
+	/* Ensure cmd read/writes are aligned. */ 
+	cmd_addr = adr & ~(CFIDEV_BUSWIDTH-1); 
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
 	/* Check that the chip's ready to talk to us.
-	 * Later, we can actually think about interrupting it
-	 * if it's in FL_ERASING or FL_WRITING state.
-	 * Not just yet, though.
+	 * If it's in FL_ERASING state, suspend it and make it talk now.
 	 */
 	switch (chip->state) {
-#if 0
 	case FL_ERASING:
-	case FL_WRITING:
-		/* Suspend the operation, set state to FL_xxx_SUSPENDED */
-#endif
-
-	case FL_CFI_QUERY:
-	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
-		chip->state = FL_STATUS;
-
-	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-			static int z=0;
-			/* Urgh. Chip not yet ready to talk to us. */
+		cfi_write (map, CMD(0xb0), cmd_addr);
+		chip->oldstate = FL_ERASING;
+		chip->state = FL_ERASE_SUSPENDING;
+//		printk("Erase suspending at 0x%lx\n", cmd_addr);
+		for (;;) {
+			status = cfi_read(map, cmd_addr);
+			if ((status & status_OK) == status_OK)
+				break;
+			
 			if (time_after(jiffies, timeo)) {
+				/* Urgh */
+				cfi_write(map, CMD(0xd0), cmd_addr);
+				chip->state = FL_ERASING;
 				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in read");
+				printk("Chip not ready after erase suspended\n");
 				return -EIO;
 			}
 
-			/* Latency issues. Drop the lock, wait a while and retry */
 			spin_unlock_bh(chip->mutex);
+			cfi_udelay(1);
+			spin_lock_bh(chip->mutex);
+		}
 
-			z++;
-			if ( 0 && !(z % 100 )) 
-				printk("chip not ready yet before read. looping\n");
+		suspended = 1;
+		cfi_write(map, CMD(0xff), cmd_addr);
+		chip->state = FL_READY;
+		break;
 
-			udelay(1);
+#if 0
+	case FL_WRITING:
+		/* Not quite yet */
+#endif
 
-			goto retry;
-		}
+	case FL_READY:
 		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+		cfi_write(map, CMD(0x70), cmd_addr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, cmd_addr);
+		if ((status & status_OK) == status_OK) {
+			cfi_write(map, CMD(0xff), cmd_addr);
+			chip->state = FL_READY;
+			break;
+		}
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in read. WSM status = %x\n", status);
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
-		if(signal_pending(current))
-			return -EINTR;
-
-
 		timeo = jiffies + HZ;
-
 		goto retry;
 	}
 
-	map->write16(map, cpu_to_le16(0x00ff), adr);
-	chip->state = FL_READY;
-
 	map->copy_from(map, buf, adr, len);
 
-	if (chip->state == FL_ERASE_SUSPENDED || 
-	    chip->state == FL_WRITE_SUSPENDED) {
-		printk("Who in hell suspended the pending operation? I didn't write that code yet!\n");
-		/* Restart it and set the state accordingly */
+	if (suspended) {
+		chip->state = chip->oldstate;
+		/* What if one interleaved chip has finished and the 
+		   other hasn't? The old code would leave the finished
+		   one in READY mode. That's bad, and caused -EROFS 
+		   errors to be returned from do_erase_oneblock because
+		   that's the only bit it checked for at the time.
+		   As the state machine appears to explicitly allow 
+		   sending the 0x70 (Read Status) command to an erasing
+		   chip and expecting it to be ignored, that's what we 
+		   do. */
+		cfi_write(map, CMD(0xd0), cmd_addr);
+		cfi_write(map, CMD(0x70), cmd_addr);		
 	}
 
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-
 	return 0;
 }
 
-static int cfi_intelext_read_1_by_16 (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+static int cfi_intelext_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -321,7 +419,7 @@
 		else
 			thislen = len;
 
-		ret = do_read_1_by_16_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
 		if (ret)
 			break;
 
@@ -335,14 +433,20 @@
 	return ret;
 }
 
-static inline int do_write_1_by_16_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u16 datum)
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
 	DECLARE_WAITQUEUE(wait, current);
-	int z = 0;
+	int z;
+
 	adr += chip->start;
 
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
@@ -352,111 +456,85 @@
 	 * Not just yet, though.
 	 */
 	switch (chip->state) {
+	case FL_READY:
+		break;
+		
 	case FL_CFI_QUERY:
 	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
+		cfi_write(map, CMD(0x70), adr);
 		chip->state = FL_STATUS;
-		timeo = jiffies + HZ;
 
 	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-
-			/* Urgh. Chip not yet ready to talk to us. */
-			if (time_after(jiffies, timeo)) {
-				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in read");
-				return -EIO;
-			}
-
-			/* Latency issues. Drop the lock, wait a while and retry */
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
 			spin_unlock_bh(chip->mutex);
-
-			z++;
-			if ( 0 && !(z % 100 ))
-				printk("chip not ready yet before write. looping\n");
-			
-			udelay(1);
-
-			goto retry;
+			printk("waiting for chip to be ready timed out in read\n");
+			return -EIO;
 		}
-		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
-		if(signal_pending(current))
-			return -EINTR;
-
 		timeo = jiffies + HZ;
-
 		goto retry;
 	}
-	
-	map->write16(map, cpu_to_le16(0x0040), adr);
-	map->write16(map, datum, adr);
-	chip->state = FL_WRITING;
 
-	timeo = jiffies + (HZ/2);
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x40), adr);
+	cfi_write(map, datum, adr);
+	chip->state = FL_WRITING;
 
 	spin_unlock_bh(chip->mutex);
-	udelay(chip->word_write_time);
+	cfi_udelay(chip->word_write_time);
 	spin_lock_bh(chip->mutex);
 
+	timeo = jiffies + (HZ/2);
 	z = 0;
-	while ( !( (status = le16_to_cpu(map->read16(map, adr)))  & 0x80 ) ) {
-
+	for (;;) {
 		if (chip->state != FL_WRITING) {
 			/* Someone's suspended the write. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			
 			spin_unlock_bh(chip->mutex);
-			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
-			if (signal_pending(current))
-				return -EINTR;
-			
 			timeo = jiffies + (HZ / 2); /* FIXME */
-
 			spin_lock_bh(chip->mutex);
 			continue;
 		}
 
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
 			spin_unlock_bh(chip->mutex);
-			printk("waiting for chip to be ready timed out in read");
+			printk("waiting for chip to be ready timed out in word write\n");
 			return -EIO;
 		}
-		
+
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock_bh(chip->mutex);
-		
 		z++;
-		if ( 0 && !(z % 100 )) 
-		  printk("chip not ready yet after write. looping\n");
-		
-		udelay(1);
-		
+		cfi_udelay(1);
 		spin_lock_bh(chip->mutex);
-		continue;
 	}
 	if (!z) {
 		chip->word_write_time--;
@@ -467,18 +545,25 @@
 		chip->word_write_time++;
 
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-	//	printk("write ret OK at %lx\n", adr);
 	return 0;
 }
 
 
-/* This version only uses the 'word write' instruction. We should update it
- * to write using 'buffer write' if it's available 
- */
-static int cfi_intelext_write_1_by_16 (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+static int cfi_intelext_write_words (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -487,27 +572,43 @@
 	unsigned long ofs;
 
 	*retlen = 0;
+	if (!len)
+		return 0;
+
 	chipnum = to >> cfi->chipshift;
 	ofs = to  - (chipnum << cfi->chipshift);
 
-	/* If it's not word-aligned, do the first byte write */
-	if (ofs & 1) {
-#if defined(__LITTLE_ENDIAN)
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF | (*buf << 8));
-#elif defined(__BIG_ENDIAN) 
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF00 | (*buf));
-#else
-#error define a sensible endianness
-#endif
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int gap = ofs - bus_ofs;
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (gap--)
+			tmp_buf[i++] = 0xff;
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       bus_ofs, datum);
 		if (ret) 
 			return ret;
 		
-		ofs++;
-		buf++;
-		(*retlen)++;
-		len--;
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
 
 		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
@@ -517,16 +618,28 @@
 		}
 	}
 	
-	while(len > 1) {
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, *(__u16 *)buf);
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				ofs, datum);
 		if (ret)
 			return ret;
 
-		ofs += 2;
-		buf += 2;
-		(*retlen) += 2;
-		len -= 2;
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
 
 		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
@@ -536,186 +649,515 @@
 		}
 	}
 
-	if (len) {
-		/* Final byte to write */
-#if defined(__LITTLE_ENDIAN)
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF00 | (*buf));
-#elif defined(__BIG_ENDIAN) 
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF | (*buf << 8));
-#else
-#error define a sensible endianness
-#endif
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       ofs, datum);
 		if (ret) 
 			return ret;
 		
-		(*retlen)++;
+		(*retlen) += n;
 	}
 
 	return 0;
 }
 
 
-static inline int do_erase_1_by_16_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+static inline int do_write_buffer(struct map_info *map, struct flchip *chip, 
+				  unsigned long adr, const u_char *buf, int len)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int interleave = cfi->interleave;
+	__u32 status, status_OK;
+	unsigned long cmd_adr, timeo;
 	DECLARE_WAITQUEUE(wait, current);
+	int wbufsize, z;
 
+	wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
 	adr += chip->start;
+	cmd_adr = adr & ~(wbufsize-1);
+	
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
 
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
-	/* Check that the chip's ready to talk to us. */
+	/* Check that the chip's ready to talk to us.
+	 * Later, we can actually think about interrupting it
+	 * if it's in FL_ERASING state.
+	 * Not just yet, though.
+	 */
 	switch (chip->state) {
+	case FL_READY:
+		break;
+		
 	case FL_CFI_QUERY:
 	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
+		cfi_write(map, CMD(0x70), cmd_adr);
 		chip->state = FL_STATUS;
-		timeo = jiffies + HZ;
 
 	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-			static int z=0;
-			/* Urgh. Chip not yet ready to talk to us. */
-			if (time_after(jiffies, timeo)) {
-				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in erase");
-				return -EIO;
-			}
-
-			/* Latency issues. Drop the lock, wait a while and retry */
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
 			spin_unlock_bh(chip->mutex);
-
-			z++;
-			if ( 0 && !(z % 100 )) 
-				printk("chip not ready yet before erase. looping\n");
-
-			udelay(1);
-
-			goto retry;
+			printk("waiting for chip to be ready timed out in buffer write\n");
+			return -EIO;
 		}
-		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
 
-		if(signal_pending(current))
-			return -EINTR;
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0xe8), cmd_adr);
+	chip->state = FL_WRITING_TO_BUFFER;
 
-		timeo = jiffies + HZ;
+	z = 0;
+	for (;;) {
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
 
-		goto retry;
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+
+		if (++z > 20) {
+			/* Argh. Not ready for write to buffer */
+			cfi_write(map, CMD(0x70), cmd_adr);
+			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			printk("Chip not ready for buffer write. Xstatus = %x, status = %x\n", status, cfi_read(map, cmd_adr));
+			return -EIO;
+		}
 	}
-	
-	map->write16(map, cpu_to_le16(0x0020), adr);
-	map->write16(map, cpu_to_le16(0x00D0), adr);
 
-	chip->state = FL_ERASING;
-	
-	timeo = jiffies + (HZ*2);
-	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
-	spin_lock_bh(chip->mutex);
+	/* Write length of data to come */
+	cfi_write(map, CMD(len/CFIDEV_BUSWIDTH-1), cmd_adr );
 
-	/* FIXME. Use a timer to check this, and return immediately. */
-	/* Once the state machine's known to be working I'll do that */
+	/* Write data */
+	for (z = 0; z < len; z += CFIDEV_BUSWIDTH) {
+		if (cfi_buswidth_is_1()) {
+			map->write8 (map, *((__u8*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_2()) {
+			map->write16 (map, *((__u16*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_4()) {
+			map->write32 (map, *((__u32*)buf)++, adr+z);
+		} else {
+			DISABLE_VPP(map);
+			return -EINVAL;
+		}
+	}
+	/* GO GO GO */
+	cfi_write(map, CMD(0xd0), cmd_adr);
+	chip->state = FL_WRITING;
 
-	while ( !( (status = le16_to_cpu(map->read16(map, adr)))  & 0x80 ) ) {
-		static int z=0;
+	spin_unlock_bh(chip->mutex);
+	cfi_udelay(chip->buffer_write_time);
+	spin_lock_bh(chip->mutex);
 
-		if (chip->state != FL_ERASING) {
-			/* Someone's suspended the erase. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+	timeo = jiffies + (HZ/2);
+	z = 0;
+	for (;;) {
+		if (chip->state != FL_WRITING) {
+			/* Someone's suspended the write. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			
 			spin_unlock_bh(chip->mutex);
-			printk("erase suspended. Sleeping\n");
-			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
-			if (signal_pending(current))
-				return -EINTR;
-			
-			timeo = jiffies + (HZ*2); /* FIXME */
+			timeo = jiffies + (HZ / 2); /* FIXME */
 			spin_lock_bh(chip->mutex);
 			continue;
 		}
 
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
 			spin_unlock_bh(chip->mutex);
-			printk("waiting for erase to complete timed out.");
+			printk("waiting for chip to be ready timed out in bufwrite\n");
 			return -EIO;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock_bh(chip->mutex);
-
+		cfi_udelay(1);
 		z++;
-		if ( 0 && !(z % 100 )) 
-			printk("chip not ready yet after erase. looping\n");
-
-		udelay(1);
-		
 		spin_lock_bh(chip->mutex);
-		continue;
 	}
-	
+	if (!z) {
+		chip->buffer_write_time--;
+		if (!chip->buffer_write_time)
+			chip->buffer_write_time++;
+	}
+	if (z > 1) 
+		chip->buffer_write_time++;
+
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), cmd_adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-	//printk("erase ret OK\n");
 	return 0;
 }
 
-static int cfi_intelext_erase_1_by_16 (struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_intelext_write_buffers (struct mtd_info *mtd, loff_t to, 
+				       size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
-	unsigned long adr, len;
-	int chipnum, ret = 0;
+	int interleave = cfi->interleave;
+	int wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
 
-	if (instr->addr & (mtd->erasesize - 1))
-		return -EINVAL;
+	*retlen = 0;
+	if (!len)
+		return 0;
 
-	if (instr->len & (mtd->erasesize -1))
-		return -EINVAL;
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
 
-	if ((instr->len + instr->addr) > mtd->size)
-		return -EINVAL;
+	/* If it's not bus-aligned, do the first word write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		size_t local_len = (-ofs)&(CFIDEV_BUSWIDTH-1);
+		if (local_len > len)
+			local_len = len;
+		ret = cfi_intelext_write_words(mtd, to, local_len,
+					       retlen, buf);
+		if (ret)
+			return ret;
+		ofs += local_len;
+		buf += local_len;
+		len -= local_len;
 
-	chipnum = instr->addr >> cfi->chipshift;
-	adr = instr->addr - (chipnum << cfi->chipshift);
-	len = instr->len;
+		if (ofs >> cfi->chipshift) {
+			chipnum ++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
 
-	while(len) {
-		ret = do_erase_1_by_16_oneblock(map, &cfi->chips[chipnum], adr);
-		
+	/* Write buffer is worth it only if more than one word to write... */
+	while(len > CFIDEV_BUSWIDTH) {
+		/* We must not cross write block boundaries */
+		int size = wbufsize - (ofs & (wbufsize-1));
+
+		if (size > len)
+			size = len & ~(CFIDEV_BUSWIDTH-1);
+		ret = do_write_buffer(map, &cfi->chips[chipnum], 
+				      ofs, buf, size);
 		if (ret)
 			return ret;
 
-		adr += mtd->erasesize;
-		len -= mtd->erasesize;
+		ofs += size;
+		buf += size;
+		(*retlen) += size;
+		len -= size;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* ... and write the remaining bytes */
+	if (len > 0) {
+		size_t local_retlen;
+		ret = cfi_intelext_write_words(mtd, ofs + (chipnum << cfi->chipshift),
+					       len, &local_retlen, buf);
+		if (ret)
+			return ret;
+		(*retlen) += local_retlen;
+	}
+
+	return 0;
+}
+
+
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
+	int retries = 3;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in erase\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	/* Clear the status register first */
+	cfi_write(map, CMD(0x50), adr);
+
+	/* Now erase */
+	cfi_write(map, CMD(0x20), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_ERASING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*20);
+	for (;;) {
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			timeo = jiffies + (HZ*2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for erase to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	DISABLE_VPP(map);
+	ret = 0;
+
+	/* We've broken this before. It doesn't hurt to be safe */
+	cfi_write(map, CMD(0x70), adr);
+	chip->state = FL_STATUS;
+	status = cfi_read(map, adr);
+
+	/* check for lock bit */
+	if (status & CMD(0x3a)) {
+		unsigned char chipstatus = status;
+		if (status != CMD(status & 0xff)) {
+			int i = cfi->interleave;
+			for (i = 1; i<cfi->interleave; i++) {
+				      chipstatus |= status >> (cfi->device_type * 8);
+			}
+			printk(KERN_WARNING "Status is not identical for all chips: 0x%x. Merging to give 0x%02x\n", status, chipstatus);
+		}
+		/* Reset the error bits */
+		cfi_write(map, CMD(0x50), adr);
+		cfi_write(map, CMD(0x70), adr);
+		
+		if (chipstatus & 0x30) {
+			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x02) {
+			/* Protection bit set */
+			ret = -EROFS;
+		} else if (chipstatus & 0x8) {
+			/* Voltage */
+			printk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x20) {
+			if (retries--) {
+				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, status);
+				timeo = jiffies + HZ;
+				chip->state = FL_STATUS;
+				spin_unlock_bh(chip->mutex);
+				goto retry;
+			}
+			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, status);
+			ret = -EIO;
+		}
+	}
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return ret;
+}
+
+int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+{	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+		
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
 
 		if (adr >> cfi->chipshift) {
 			adr = 0;
@@ -726,14 +1168,13 @@
 		}
 	}
 		
+	instr->state = MTD_ERASE_DONE;
 	if (instr->callback)
 		instr->callback(instr);
 	
 	return 0;
 }
 
-
-
 static void cfi_intelext_sync (struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -760,6 +1201,7 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_SYNCING:
 			spin_unlock_bh(chip->mutex);
 			break;
 
@@ -769,9 +1211,8 @@
 			
 			spin_unlock_bh(chip->mutex);
 			schedule();
+		        remove_wait_queue(&chip->wq, &wait);
 			
-			remove_wait_queue(&chip->wq, &wait);
-
 			goto retry;
 		}
 	}
@@ -791,6 +1232,288 @@
 	}
 }
 
+static inline int do_lock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK) 
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in lock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0x01), adr);
+	chip->state = FL_LOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for lock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	if (ofs & (mtd->erasesize - 1))
+		return -EINVAL;
+
+	if (len & (mtd->erasesize -1))
+		return -EINVAL;
+
+	if ((len + ofs) > mtd->size)
+		return -EINVAL;
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+	while(len) {
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		printk("before lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif
+
+		ret = do_lock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		printk("after lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif	
+		
+		if (ret)
+			return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+	return 0;
+}
+static inline int do_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in unlock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_UNLOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for unlock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the unlock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+#ifdef DEBUG_LOCK_BITS
+	{
+		unsigned long temp_adr = adr;
+		unsigned long temp_len = len;
+                 
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+                while (temp_len) {
+			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
+			temp_adr += mtd->erasesize;
+			temp_len -= mtd->erasesize;
+		}
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+	}
+#endif
+
+	ret = do_unlock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+	cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+	printk("after unlock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+	cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif
+	
+	return ret;
+}
 
 static int cfi_intelext_suspend(struct mtd_info *mtd)
 {
@@ -816,6 +1539,7 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_PM_SUSPENDED:
 			break;
 
 		default:
@@ -827,17 +1551,19 @@
 
 	/* Unlock the chips again */
 
-	for (i--; i >=0; i--) {
-		chip = &cfi->chips[i];
-
-		spin_lock_bh(chip->mutex);
-		
-		if (chip->state == FL_PM_SUSPENDED) {
-			chip->state = chip->oldstate;
-			wake_up(&chip->wq);
+	if (ret) {
+		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
+			
+			spin_lock_bh(chip->mutex);
+			
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			spin_unlock_bh(chip->mutex);
 		}
-		spin_unlock_bh(chip->mutex);
-	}
+	} 
 	
 	return ret;
 }
@@ -859,8 +1585,6 @@
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		else
-			printk("Argh. Chip not in PM_SUSPENDED state upon resume()\n");
 
 		spin_unlock_bh(chip->mutex);
 	}
@@ -871,18 +1595,21 @@
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	kfree(cfi->cmdset_priv);
-	inter_module_put(cfi->im_name);
 	kfree(cfi);
 }
 
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_intelext_init init_module
+#define cfi_intelext_exit cleanup_module
+#endif
 
-static int __init cfi_intelext_init(void)
+mod_init_t cfi_intelext_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0001);
 	return 0;
 }
 
-static void __exit cfi_intelext_exit(void)
+mod_exit_t cfi_intelext_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0002.c linux-2.4.2/drivers/mtd/cfi_cmdset_0002.c
--- linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0002.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_cmdset_0002.c	Fri Feb 15 14:41:15 2002
@@ -1,12 +1,14 @@
 /*
  * Common Flash Interface support:
- *   AMD & Fujitsu Extended Vendor Command Set (ID 0x0002)
+ *   AMD & Fujitsu Standard Vendor Command Set (ID 0x0002)
  *
  * Copyright (C) 2000 Crossnet Co. <info@crossnet.co.jp>
  *
+ * 2_by_8 routines added by Simon Munton
+ *
  * This code is GPL
  *
- * $Id: cfi_cmdset_0002.c,v 1.1 2000/07/11 12:32:09 dwmw2 Exp $
+ * $Id: cfi_cmdset_0002.c,v 1.42 2001/03/27 06:26:10 dwmw2 Exp $
  *
  */
 
@@ -18,68 +20,111 @@
 #include <asm/byteorder.h>
 
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/delay.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 
-#if LINUX_VERSION_CODE < 0x20300
-#define set_current_state(x) current->state = (x);
-#endif
-
-static int cfi_amdext_read_2_by_16 (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-static int cfi_amdext_write_2_by_16(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
-static int cfi_amdext_erase_2_by_16 (struct mtd_info *, struct erase_info *);
-static void cfi_amdext_sync (struct mtd_info *);
-static int cfi_amdext_suspend (struct mtd_info *);
-static void cfi_amdext_resume (struct mtd_info *);
+#define AMD_BOOTLOC_BUG
 
-static void cfi_amdext_destroy(struct mtd_info *);
+static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_amdstd_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_amdstd_erase_onesize(struct mtd_info *, struct erase_info *);
+static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
+static void cfi_amdstd_sync (struct mtd_info *);
+static int cfi_amdstd_suspend (struct mtd_info *);
+static void cfi_amdstd_resume (struct mtd_info *);
 
-static void cfi_cmdset_0002(struct map_info *, int, unsigned long);
+static void cfi_amdstd_destroy(struct mtd_info *);
 
-static struct mtd_info *cfi_amdext_setup (struct map_info *);
+void cfi_cmdset_0002(struct map_info *, int, unsigned long);
+static struct mtd_info *cfi_amdstd_setup (struct map_info *);
 
 static const char im_name[] = "cfi_cmdset_0002";
 
-static void cfi_cmdset_0002(struct map_info *map, int primary, unsigned long base)
+void cfi_cmdset_0002(struct map_info *map, int primary, unsigned long base)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned char bootloc;
+	int ofs_factor = cfi->interleave * cfi->device_type;
 	int i;
+	__u8 major, minor;
 //	struct cfi_pri_intelext *extp;
 
-	__u16 adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+    if (cfi->cfi_mode==0){
+	__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 
-	printk(" Amd/Fujitsu Extended Query Table at 0x%4.4X\n", adr);
+	cfi_send_gen_cmd(0x98, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
 
+	major = cfi_read_query(map, (adr+3)*ofs_factor);
+	minor = cfi_read_query(map, (adr+4)*ofs_factor);
 
-	/* If there was an old setup function, decrease its use count */
-	if (cfi->cmdset_setup)
+	printk(" Amd/Fujitsu Extended Query Table v%c.%c at 0x%4.4X\n",
+	       major, minor, adr);
+
+	cfi_send_gen_cmd(0xf0, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+
+	cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x90, 0x555, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi->mfr = cfi_read_query(map, base);
+	cfi->id = cfi_read_query(map, base + ofs_factor);
+
+	/* Wheee. Bring me the head of someone at AMD. */
+#ifdef AMD_BOOTLOC_BUG
+	if (((major << 8) | minor) < 0x3131) {
+		/* CFI version 1.0 => don't trust bootloc */
+		if (cfi->id & 0x80) {
+			printk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);
+			bootloc = 3;	/* top boot */
+		} else {
+			bootloc = 2;	/* bottom boot */
+		}
+	} else
+#endif
+	{
+		cfi_send_gen_cmd(0x98, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		bootloc = cfi_read_query(map, (adr+15)*ofs_factor);
+	}
+	if (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {
+		printk(KERN_WARNING "%s: Swapping erase regions for broken CFI table.\n", map->name);
+
+		for (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {
+			int j = (cfi->cfiq->NumEraseRegions-1)-i;
+			__u32 swap;
+
+			swap = cfi->cfiq->EraseRegionInfo[i];
+			cfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];
+			cfi->cfiq->EraseRegionInfo[j] = swap;
+		}
+	}
+    }
+
+    /* If there was an old setup function, decrease its use count */
+    if (cfi->im_name)
 		inter_module_put(cfi->im_name);
-	if (cfi->cmdset_priv)
+    if (cfi->cmdset_priv)
 		kfree(cfi->cmdset_priv);
 
-	for (i=0; i< cfi->numchips; i++) {
-		cfi->chips[i].word_write_time = 128;
-		cfi->chips[i].buffer_write_time = 128;
-		cfi->chips[i].erase_time = 1024;
-	}		
-		
-
-	cfi->cmdset_setup = cfi_amdext_setup;
-	cfi->im_name = im_name;
-//	cfi->cmdset_priv = extp;
-	
-	return;
+    for (i=0; i< cfi->numchips; i++) {
+		cfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;
+		cfi->chips[i].buffer_write_time = 1<<cfi->cfiq->BufWriteTimeoutTyp;
+		cfi->chips[i].erase_time = 1<<cfi->cfiq->BlockEraseTimeoutTyp;
+    }		
+
+    cfi->cmdset_setup = cfi_amdstd_setup;
+    cfi_send_gen_cmd(0xf0, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+    return;
 }
 
-static struct mtd_info *cfi_amdext_setup(struct map_info *map)
+static struct mtd_info *cfi_amdstd_setup(struct map_info *map)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct mtd_info *mtd;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
 	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
-	printk("number of CFI chips: %d\n", cfi->numchips);
+	printk("number of %s chips: %d\n", (cfi->cfi_mode)?"JEDEC":"CFI",cfi->numchips);
 
 	if (!mtd) {
 	  printk("Failed to allocate memory for MTD device\n");
@@ -90,42 +135,105 @@
 	memset(mtd, 0, sizeof(*mtd));
 	mtd->priv = map;
 	mtd->type = MTD_NORFLASH;
-	mtd->erasesize = 0x20000; /* FIXME */
 	/* Also select the correct geometry setup too */ 
-	mtd->size = (1 << cfi->cfiq.DevSize) * cfi->numchips * cfi->interleave;
-	mtd->erase = cfi_amdext_erase_2_by_16;
-	mtd->read = cfi_amdext_read_2_by_16;
-	mtd->write = cfi_amdext_write_2_by_16;
-	mtd->sync = cfi_amdext_sync;
-	mtd->suspend = cfi_amdext_suspend;
-	mtd->resume = cfi_amdext_resume;
+	mtd->size = devsize * cfi->numchips;
+	
+	if (cfi->cfiq->NumEraseRegions == 1) {
+		/* No need to muck about with multiple erase sizes */
+		mtd->erasesize = ((cfi->cfiq->EraseRegionInfo[0] >> 8) & ~0xff) * cfi->interleave;
+	} else {
+		unsigned long offset = 0;
+		int i,j;
+
+		mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+		mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) * mtd->numeraseregions, GFP_KERNEL);
+		if (!mtd->eraseregions) { 
+			printk("Failed to allocate memory for MTD erase region info\n");
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+			
+		for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+			unsigned long ernum, ersize;
+			ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+			ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+			
+			if (mtd->erasesize < ersize) {
+				mtd->erasesize = ersize;
+			}
+			for (j=0; j<cfi->numchips; j++) {
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+			}
+			offset += (ersize * ernum);
+		}
+		if (offset != devsize) {
+			/* Argh */
+			printk("Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+		// debug
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk("%d: offset=0x%lx,size=0x%lx,blocks=%d\n",i,mtd->eraseregions[i].offset,
+			mtd->eraseregions[i].erasesize,mtd->eraseregions[i].numblocks);
+		}
+	}
+
+	switch (CFIDEV_BUSWIDTH)
+	{
+	case 1:
+	case 2:
+	case 4:
+#if 1
+		if (mtd->numeraseregions > 1)
+			mtd->erase = cfi_amdstd_erase_varsize;
+		else
+#endif
+			mtd->erase = cfi_amdstd_erase_onesize;
+		mtd->read = cfi_amdstd_read;
+		mtd->write = cfi_amdstd_write;
+		break;
+
+	default:
+	        printk("Unsupported buswidth\n");
+		kfree(mtd);
+		kfree(cfi->cmdset_priv);
+		return NULL;
+		break;
+	}
+	mtd->sync = cfi_amdstd_sync;
+	mtd->suspend = cfi_amdstd_suspend;
+	mtd->resume = cfi_amdstd_resume;
 	mtd->flags = MTD_CAP_NORFLASH;
-	map->fldrv_destroy = cfi_amdext_destroy;
+	map->fldrv_destroy = cfi_amdstd_destroy;
 	mtd->name = map->name;
 	return mtd;
 }
 
-static inline int do_read_2_by_16_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long timeo = jiffies + HZ;
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-printk("Waiting for chip to read, status = %d\n", chip->state);
-		set_current_state(TASK_INTERRUPTIBLE);
+	        printk("Waiting for chip to read, status = %d\n", chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -133,19 +241,17 @@
 
 	adr += chip->start;
 
-//     	map->write32(map, cpu_to_le32(0x00F000F0), adr);
-
 	chip->state = FL_READY;
 
 	map->copy_from(map, buf, adr, len);
 
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	cfi_spin_unlock(chip->mutex);
 
 	return 0;
 }
 
-static int cfi_amdext_read_2_by_16 (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+static int cfi_amdstd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -156,8 +262,8 @@
 	/* ofs: offset within the first chip that the first read should start */
 
 	chipnum = (from >> cfi->chipshift);
-	chipnum /= (cfi->interleave);
-	ofs = from - (chipnum <<  cfi->chipshift) * (cfi->interleave);
+	ofs = from - (chipnum <<  cfi->chipshift);
+
 
 	*retlen = 0;
 
@@ -167,12 +273,12 @@
 		if (chipnum >= cfi->numchips)
 			break;
 
-		if (((len + ofs -1) >> cfi->chipshift) / (cfi->interleave))
-			thislen = (1<<cfi->chipshift) * (cfi->interleave) - ofs;
+		if ((len + ofs -1) >> cfi->chipshift)
+			thislen = (1<<cfi->chipshift) - ofs;
 		else
 			thislen = len;
 
-		ret = do_read_2_by_16_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
 		if (ret)
 			break;
 
@@ -186,30 +292,32 @@
 	return ret;
 }
 
-static inline int do_write_2_by_16_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum)
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum, int fast)
 {
 	unsigned long timeo = jiffies + HZ;
 	unsigned int Last[4];
 	unsigned long Count = 0;
+	struct cfi_private *cfi = map->fldrv_priv;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-printk("Waiting for chip to write, status = %d\n", chip->state);
-		set_current_state(TASK_INTERRUPTIBLE);
+	        printk("Waiting for chip to write, status = %d\n", chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-printk("Wake up to write:\n");
+		printk("Wake up to write:\n");
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -218,125 +326,217 @@
 	chip->state = FL_WRITING;
 
 	adr += chip->start;
-
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00A000A0), 0x555 *4);
-	map->write32(map, cpu_to_le32(datum), adr);
-
-	spin_unlock_bh(chip->mutex);
-	udelay(chip->word_write_time);
-	spin_lock_bh(chip->mutex);
-
-	Last[0] = map->read32(map, adr);
-	Last[1] = map->read32(map, adr);
-	Last[2] = map->read32(map, adr);
+	ENABLE_VPP(map);
+	if (fast) { /* Unlock bypass */
+		cfi_send_gen_cmd(0xA0, 0, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	}
+	else {
+	        cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	        cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	        cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	}
+
+	cfi_write(map, datum, adr);
+
+	cfi_spin_unlock(chip->mutex);
+	cfi_udelay(chip->word_write_time);
+	cfi_spin_lock(chip->mutex);
+
+	Last[0] = cfi_read(map, adr);
+	//	printk("Last[0] is %x\n", Last[0]);
+	Last[1] = cfi_read(map, adr);
+	//	printk("Last[1] is %x\n", Last[1]);
+	Last[2] = cfi_read(map, adr);
+	//	printk("Last[2] is %x\n", Last[2]);
 
 	for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] && Count < 10000; Count++){
-		udelay(10);
-
-		Last[Count % 4] = map->read32(map, adr);
+		cfi_spin_unlock(chip->mutex);
+		cfi_udelay(10);
+		cfi_spin_lock(chip->mutex);
+		
+	        Last[Count % 4] = cfi_read(map, adr);
+		//		printk("Last[%d%%4] is %x\n", Count, Last[Count%4]);
 	}
-
+	
 	if (Last[(Count - 1) % 4] != datum){
-	     	map->write32(map, cpu_to_le32(0x00F000F0), adr);
+		printk("Last[%ld] is %x, datum is %x\n",(Count - 1) % 4,Last[(Count - 1) % 4],datum);
+	        cfi_send_gen_cmd(0xF0, 0, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+		DISABLE_VPP(map);
 		ret = -EIO;
 	}       
-
+	DISABLE_VPP(map);
 	chip->state = FL_READY;
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
-
+	cfi_spin_unlock(chip->mutex);
+	
 	return ret;
 }
 
-
-static int cfi_amdext_write_2_by_16 (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+static int cfi_amdstd_write (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	int ret = 0;
 	int chipnum;
-	unsigned long ofs;
+	unsigned long ofs, chipstart;
 
 	*retlen = 0;
+	if (!len)
+		return 0;
 
-	chipnum = (to >> cfi->chipshift);
-	chipnum /= cfi->interleave;
-	ofs = to  - (chipnum << cfi->chipshift) * cfi->interleave;
-
-	while(len > 3) {
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
+	chipstart = cfi->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, bus_ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
 
-		ret = do_write_2_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, *(__u32 *)buf);
-		if (ret)
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				bus_ofs, datum, 0);
+		if (ret) 
 			return ret;
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
 
-		ofs += 4;
-		buf += 4;
-		(*retlen) += 4;
-		len -= 4;
-
-		if ((ofs >> cfi->chipshift) / cfi->interleave) {
+		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
 			ofs = 0;
 			if (chipnum == cfi->numchips)
 				return 0;
 		}
 	}
+	
+	/* Go into unlock bypass mode */
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+
+	/* We are now aligned, write as much as possible */
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				       ofs, datum, cfi->fast_prog);
+		if (ret) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
+			return ret;
+		}
 
-	if (len) {
-		unsigned int tmp;
-
-		/* Final byte to write */
-#if defined(__LITTLE_ENDIAN)
-		tmp = map->read32(map, ofs);
-
-		tmp = 0xffffffff >> (len*8);
-		tmp = tmp << (len*8);
-
-		tmp |= *(__u32 *)(buf);
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
+
+		if (ofs >> cfi->chipshift) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
 
-		ret = do_write_2_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, tmp);
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+			chipstart = cfi->chips[chipnum].start;
+			if (cfi->fast_prog){
+				/* Go into unlock bypass mode for next set of chips */
+				cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
+		}
+	}
 
-#elif defined(__BIG_ENDIAN) 
-#error not support big endian yet
-#else
-#error define a sensible endianness
-#endif
+	if (cfi->fast_prog){
+		/* Get out of unlock bypass mode */
+		cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	}
+
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
 
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				ofs, datum, 0);
 		if (ret) 
 			return ret;
 		
-		(*retlen)+=len;
+		(*retlen) += n;
 	}
 
 	return 0;
 }
 
-
-static inline int do_erase_2_by_16_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
 {
 	unsigned int status;
 	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned int rdy_mask;
 	DECLARE_WAITQUEUE(wait, current);
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -345,83 +545,175 @@
 	chip->state = FL_ERASING;
 
 	adr += chip->start;
-
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00800080), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00300030), adr);
-
+	ENABLE_VPP(map);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_write(map, CMD(0x30), adr);
 	
 	timeo = jiffies + (HZ*20);
 
-	spin_unlock_bh(chip->mutex);
+	cfi_spin_unlock(chip->mutex);
 	schedule_timeout(HZ);
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
+	
+	rdy_mask = CMD(0x80);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
 	/* Once the state machine's known to be working I'll do that */
 
-	while ( ( (status = le32_to_cpu(map->read32(map, 0x00))) & 0x80808080 ) != 0x80808080 ) {
+	while ( ( (status = cfi_read(map,adr)) & rdy_mask ) != rdy_mask ) {
 		static int z=0;
 
 		if (chip->state != FL_ERASING) {
 			/* Someone's suspended the erase. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 			
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 			printk("erase suspended. Sleeping\n");
 			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
+#if 0			
 			if (signal_pending(current))
 				return -EINTR;
-			
+#endif			
 			timeo = jiffies + (HZ*2); /* FIXME */
-			spin_lock_bh(chip->mutex);
+			cfi_spin_lock(chip->mutex);
 			continue;
 		}
 
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_READY;
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 			printk("waiting for erase to complete timed out.");
+			DISABLE_VPP(map);
 			return -EIO;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		z++;
 		if ( 0 && !(z % 100 )) 
 			printk("chip not ready yet after erase. looping\n");
 
-		udelay(1);
+		cfi_udelay(1);
 		
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		continue;
 	}
 	
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_READY;
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
-	printk("erase ret OK\n");
+	cfi_spin_unlock(chip->mutex);
 	return 0;
 }
 
-static int cfi_amdext_erase_2_by_16 (struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long adr, len;
 	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+	
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
 
-//printk("erase : 0x%x 0x%x 0x%x\n", instr->addr, instr->len, mtd->size);
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static int cfi_amdstd_erase_onesize(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
 
 	if (instr->addr & (mtd->erasesize - 1))
 		return -EINVAL;
@@ -433,15 +725,11 @@
 		return -EINVAL;
 
 	chipnum = instr->addr >> cfi->chipshift;
-	chipnum /= cfi->interleave;
-	adr = instr->addr - (chipnum << cfi->chipshift) * (cfi->interleave);
+	adr = instr->addr - (chipnum << cfi->chipshift);
 	len = instr->len;
 
-	printk("erase : 0x%lx 0x%lx 0x%x 0x%lx\n", adr, len, chipnum, mtd->size);
-
 	while(len) {
-//printk("erase : 0x%x 0x%x 0x%x 0x%x\n", chipnum, adr, len, cfi->chipshift);
-		ret = do_erase_2_by_16_oneblock(map, &cfi->chips[chipnum], adr);
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
 
 		if (ret)
 			return ret;
@@ -449,7 +737,7 @@
 		adr += mtd->erasesize;
 		len -= mtd->erasesize;
 
-		if ((adr >> cfi->chipshift) / (cfi->interleave)) {
+		if (adr >> cfi->chipshift) {
 			adr = 0;
 			chipnum++;
 			
@@ -458,15 +746,14 @@
 		}
 	}
 		
+	instr->state = MTD_ERASE_DONE;
 	if (instr->callback)
 		instr->callback(instr);
 	
 	return 0;
 }
 
-
-
-static void cfi_amdext_sync (struct mtd_info *mtd)
+static void cfi_amdstd_sync (struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -474,13 +761,12 @@
 	struct flchip *chip;
 	int ret = 0;
 	DECLARE_WAITQUEUE(wait, current);
-printk("sync\n");
 
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
 	retry:
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -493,19 +779,20 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
-			spin_unlock_bh(chip->mutex);
+		case FL_SYNCING:
+			cfi_spin_unlock(chip->mutex);
 			break;
 
 		default:
 			/* Not an idle state */
 			add_wait_queue(&chip->wq, &wait);
 			
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 
 			schedule();
-			
-			remove_wait_queue(&chip->wq, &wait);
 
+		        remove_wait_queue(&chip->wq, &wait);
+			
 			goto retry;
 		}
 	}
@@ -515,19 +802,18 @@
 	for (i--; i >=0; i--) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		
 		if (chip->state == FL_SYNCING) {
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
-printk("sync end\n");
 }
 
 
-static int cfi_amdext_suspend(struct mtd_info *mtd)
+static int cfi_amdstd_suspend(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -539,7 +825,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -552,33 +838,36 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_PM_SUSPENDED:
 			break;
 
 		default:
 			ret = -EAGAIN;
 			break;
 		}
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
 
 	/* Unlock the chips again */
 
-	for (i--; i >=0; i--) {
-		chip = &cfi->chips[i];
+	if (ret) {
+    		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+			cfi_spin_lock(chip->mutex);
 		
-		if (chip->state == FL_PM_SUSPENDED) {
-			chip->state = chip->oldstate;
-			wake_up(&chip->wq);
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			cfi_spin_unlock(chip->mutex);
 		}
-		spin_unlock_bh(chip->mutex);
 	}
 	
 	return ret;
 }
 
-static void cfi_amdext_resume(struct mtd_info *mtd)
+static void cfi_amdstd_resume(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -590,7 +879,7 @@
 	
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		
 		if (chip->state == FL_PM_SUSPENDED) {
 			chip->state = chip->oldstate;
@@ -599,30 +888,34 @@
 		else
 			printk("Argh. Chip not in PM_SUSPENDED state upon resume()\n");
 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
 }
 
-static void cfi_amdext_destroy(struct mtd_info *mtd)
+static void cfi_amdstd_destroy(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	kfree(cfi->cmdset_priv);
-	inter_module_put(cfi->im_name);
 	kfree(cfi);
 }
 
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_amdstd_init init_module
+#define cfi_amdstd_exit cleanup_module
+#endif
 
-static int __init cfi_amdext_init(void)
+mod_init_t cfi_amdstd_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0002);
 	return 0;
 }
 
-static void __exit cfi_amdext_exit(void)
+mod_exit_t cfi_amdstd_exit(void)
 {
 	inter_module_unregister(im_name);
 }
 
-module_init(cfi_amdext_init);
-module_exit(cfi_amdext_exit);
+module_init(cfi_amdstd_init);
+module_exit(cfi_amdstd_exit);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_flagadm.c linux-2.4.2/drivers/mtd/cfi_flagadm.c
--- linux-2.4.2.orig/drivers/mtd/cfi_flagadm.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cfi_flagadm.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,164 @@
+/*
+ *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
+ *
+ *  $Id: cfi_flagadm.c,v 1.2 2001/03/26 21:43:22 dwmw2 Exp $
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+/* We split the flash chip up into two parts.
+ * part one is the bootloader and the kernelimage, in total the first 0x90000
+ * bytes.
+ * part two is the boot disk, i.e. 0x400000 - 0x90000 = 0x370000 bytes.
+ */
+
+#define FLASH_PHYS_ADDR 0x40000000
+#define FLASH_SIZE 0x400000  
+
+#define FLASH_PARTITION1_ADDR 0x00000000
+#define FLASH_PARTITION1_SIZE 0x00090000
+#define FLASH_PARTITION2_ADDR (FLASH_PARTITION1_ADDR | FLASH_PARTITION1_SIZE)
+#define FLASH_PARTITION2_SIZE 0x00370000
+
+__u8 flagadm_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 flagadm_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 flagadm_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void flagadm_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void flagadm_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info flagadm_map = {
+		name: "FlagaDM flash device",
+		size: FLASH_SIZE,
+		buswidth: 2,
+		read8: flagadm_read8,
+		read16: flagadm_read16,
+		read32: flagadm_read32,
+		copy_from: flagadm_copy_from,
+		write8: flagadm_write8,
+		write16: flagadm_write16,
+		write32: flagadm_write32,
+		copy_to: flagadm_copy_to
+};
+
+struct mtd_partition flagadm_parts[] = {
+	{
+		offset	: FLASH_PARTITION1_ADDR,
+		size	: FLASH_PARTITION1_SIZE
+	},
+	{
+		offset	: FLASH_PARTITION2_ADDR,
+		size	: FLASH_PARTITION2_SIZE
+	}
+};
+
+#define PARTITION_COUNT (sizeof(flagadm_parts)/sizeof(struct mtd_partition))
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_flagadm init_module
+#define cleanup_flagadm cleanup_module
+#endif
+
+static struct mtd_info *mymtd;
+
+int __init init_flagadm(void)
+{	
+	printk(KERN_NOTICE "FlagaDM flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	flagadm_map.map_priv_1 = (unsigned long)ioremap(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!flagadm_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_cfi_probe(&flagadm_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, flagadm_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "FlagaDM flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)flagadm_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_flagadm(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (flagadm_map.map_priv_1) {
+		iounmap((void *)flagadm_map.map_priv_1);
+		flagadm_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_flagadm);
+module_exit(cleanup_flagadm);
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_jedec.c linux-2.4.2/drivers/mtd/cfi_jedec.c
--- linux-2.4.2.orig/drivers/mtd/cfi_jedec.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cfi_jedec.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,285 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_ATMEL	0x001f
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+
+/* Atmel */
+#define AT49BV16X4	0x00c0
+#define AT49BV16X4T	0x00c2
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const int DevSize;
+	const int InterfaceDesc;
+	const int NumEraseRegions;
+	const ulong regions[4];
+};
+
+#define ERASEINFO(size,blocks) (size<<8)|(blocks-1)
+
+#define SIZE_1MB 20
+#define SIZE_2MB 21
+#define SIZE_4MB 22
+
+static const struct amd_flash_info jedec_table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ATMEL,
+		dev_id: AT49BV16X4,
+		name: "Atmel AT49BV16X4",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 3,
+		regions: {ERASEINFO(0x02000,8),
+			  ERASEINFO(0x08000,2),
+			  ERASEINFO(0x10000,30)
+		}
+	}, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16X4T,
+                name: "Atmel AT49BV16X4T",
+                DevSize: SIZE_2MB,
+                NumEraseRegions: 3,
+                regions: {ERASEINFO(0x10000,30),
+                          ERASEINFO(0x08000,2),
+			  ERASEINFO(0x02000,8)
+                }
+        }, {
+		0
+	} 
+};
+
+int cfi_jedec_lookup(int index, int mfr_id, int dev_id)
+{
+  	if (index>=0){
+		if (jedec_table[index].mfr_id == mfr_id &&
+		    jedec_table[index].dev_id == dev_id) return index;
+  	}
+  	else{
+		for (index=0; jedec_table[index].mfr_id; index++){
+		    if (jedec_table[index].mfr_id == mfr_id &&
+		        jedec_table[index].dev_id == dev_id) return index;
+		}
+  	}
+	return -1;
+}
+
+int cfi_jedec_setup(struct cfi_private *p_cfi, int index)
+{
+int i,num_erase_regions;
+
+	num_erase_regions = jedec_table[index].NumEraseRegions;
+	
+	p_cfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+	if (!p_cfi->cfiq) {
+		//xx printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+		return -1;
+	}
+
+	memset(p_cfi->cfiq,0,sizeof(struct cfi_ident));	
+	
+	p_cfi->cfiq->P_ID = P_ID_AMD_STD;
+	p_cfi->cfiq->NumEraseRegions = jedec_table[index].NumEraseRegions;
+	p_cfi->cfiq->DevSize = jedec_table[index].DevSize;
+
+	for (i=0; i<num_erase_regions; i++){
+		p_cfi->cfiq->EraseRegionInfo[i] = jedec_table[index].regions[i];
+	}	
+	return 0; 	/* ok */
+}
+
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_probe.c linux-2.4.2/drivers/mtd/cfi_probe.c
--- linux-2.4.2.orig/drivers/mtd/cfi_probe.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_probe.c	Fri Feb 15 14:41:15 2002
@@ -1,30 +1,42 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: cfi_probe.c,v 1.12 2000/07/03 13:29:16 dwmw2 Exp $
+   $Id: cfi_probe.c,v 1.47 2001/03/26 11:59:46 dwmw2 Exp $
 */
 
 
+/*! \file cfi_probe.c
+  \brief Common Flash Interface probe code. (C) 2000 Red Hat. GPL'd.
+
+  \version $Id: cfi_probe.c,v 1.47 2001/03/26 11:59:46 dwmw2 Exp $
+*/
+
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 
+/* #define DEBUG_CFI */
 
-struct mtd_info *cfi_probe(struct map_info *);
-
+#ifdef DEBUG_CFI
 static void print_cfi_ident(struct cfi_ident *);
+#endif
+
+int cfi_jedec_setup(struct cfi_private *p_cfi, int index);
+int cfi_jedec_lookup(int index, int mfr_id, int dev_id);
+
 static void check_cmd_set(struct map_info *, int, unsigned long);
 static struct cfi_private *cfi_cfi_probe(struct map_info *);
-
 static const char im_name[] = "cfi_probe";
 
+
 /* This routine is made available to other mtd code via
  * inter_module_register.  It must only be accessed through
  * inter_module_get which will bump the use count of this module.  The
@@ -32,10 +44,13 @@
  * this module is non-zero, i.e. between inter_module_get and
  * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
  */
+/*! \brief test only 
+ */
 struct mtd_info *cfi_probe(struct map_info *map)
 {
 	struct mtd_info *mtd = NULL;
 	struct cfi_private *cfi;
+
 	/* First probe the map to see if we have CFI stuff there. */
 	cfi = cfi_cfi_probe(map);
 	
@@ -43,8 +58,6 @@
 		return NULL;
 
 	map->fldrv_priv = cfi;
-	map->im_name = im_name;
-
 	/* OK we liked it. Now find a driver for the command set it talks */
 
 	check_cmd_set(map, 1, cfi->chips[0].start); /* First the primary cmdset */
@@ -60,197 +73,232 @@
 		
 		if (mtd)
 			return mtd;
-		inter_module_put(cfi->im_name);
+		if (cfi->im_name)
+			inter_module_put(cfi->im_name);
 	}
-	printk("No supported Vendor Command Set found\n");
+	printk(KERN_WARNING"cfi_probe: No supported Vendor Command Set found\n");
 	
+	kfree(cfi->cfiq);
 	kfree(cfi);
 	map->fldrv_priv = NULL;
 	return NULL;
+}
 
+static __u32 cfi_send_cmd(u_char cmd, __u32 base, struct map_info *map, u_char interleave, int type, __u32 *prev_val)
+{
+	return cfi_send_gen_cmd(cmd, 0x55, base, map, interleave, type, prev_val);
 }
 
-static int cfi_probe_new_chip(struct map_info *map, unsigned long base,
-			      struct flchip *chips, struct cfi_private *cfi)
+/* check for QRY, or search for jedec id.
+   in: interleave,type,mode
+   ret: table index, <0 for error
+ */
+static int cfi_check_qry_or_id(struct map_info *map, __u32 base, int index,
+				struct cfi_private *cfi)
 {
-	switch (map->buswidth) {
-		
-	case 1: {
-		unsigned char tmp = map->read8(map, base + 0x55);
+	__u32 manufacturer_id, device_id;
+	int osf = cfi->interleave * cfi->device_type;	// scale factor
+
+	//printk("cfi_check_qry_or_id: base=0x%08lx interl=%d type=%d index=%d\n",base,cfi->interleave,cfi->device_type,index);
 
-		/* If there's a device there, put it in Query Mode */
-		map->write8(map, 0x98, base+0x55);
+	switch(cfi->cfi_mode){
+	case 0:
+		if (cfi_read(map,base+osf*0x10)==cfi_build_cmd('Q',map,cfi->interleave) &&
+		    cfi_read(map,base+osf*0x11)==cfi_build_cmd('R',map,cfi->interleave) &&
+		    cfi_read(map,base+osf*0x12)==cfi_build_cmd('Y',map,cfi->interleave))
+			return 0;	// ok !
+		break;
 		
-		if (map->read8(map,base+0x10) == 'Q' &&
-		    map->read8(map,base+0x11) == 'R' &&
-		    map->read8(map,base+0x12) == 'Y') {
-			printk("%s: Found a CFI device at 0x%lx in 8 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-				/* Put it back into Read Mode */
-				map->write8(map, 0x98, base+0x55);
-			}
-			return 1;
-		} else {
-			if (map->read8(map, base + 0x55) == 0x98) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write8(map, tmp, base+0x55);
-			}
-			return 0;
-		}
+	case 1:
+		manufacturer_id = cfi_read(map,base+0*osf);
+		device_id 	= cfi_read(map,base+1*osf);
+		//printk("cfi_check_qry_or_id: man=0x%lx,id=0x%lx\n",manufacturer_id, device_id);
+		
+		return cfi_jedec_lookup(index,manufacturer_id,device_id);	
 	}
 	
-	case 2: {
-		__u16 tmp = map->read16(map, base + 0xaa);
-		
-		/* If there's a device there, put it into Query Mode */
-		map->write16(map, 0x9898, base+0xAA);
-		
-		if (map->read16(map, base+0x20) == cpu_to_le16(0x0051) &&
-		    map->read16(map, base+0x22) == cpu_to_le16(0x0052) &&
-		    map->read16(map, base+0x24) == cpu_to_le16(0x0059)) {
-			printk("%s: Found a CFI device at 0x%lx in 16 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				int i;
-
-				for (i=0; i < cfi->numchips; i++) {
-					/* This chip should be in read mode if it's one 
-					   we've already touched. */
-					if (map->read16(map, chips[i].start+0x20) == cpu_to_le16(0x0051) &&
-					    map->read16(map, chips[i].start+0x22) == cpu_to_le16(0x0052) &&
-					    map->read16(map, chips[i].start+0x24) == cpu_to_le16(0x0059)){
-						/* Either the old chip has got 'Q''R''Y' in a most
-						   unfortunate place, or it's an alias of the new
-						   chip. Double-check that it's in read mode, and check. */
-						map->write16(map, 0xffff, chips[i].start+0x20);
-						if (map->read16(map, chips[i].start+0x20) == cpu_to_le16(0x0051) &&
-						    map->read16(map, chips[i].start+0x22) == cpu_to_le16(0x0052) &&
-						    map->read16(map, chips[i].start+0x24) == cpu_to_le16(0x0059)) {
-							/* Yes it's got QRY for data. Most unfortunate. 
-							   Stick the old one in read mode too. */
-							map->write16(map, 0xffff, base);
-							if (map->read16(map, base+0x20) == cpu_to_le16(0x0051) &&
-							    map->read16(map, base+0x22) == cpu_to_le16(0x0052) &&
-							    map->read16(map, base+0x24) == cpu_to_le16(0x0059)) {
-								/* OK, so has the new one. Assume it's an alias */
-								printk("T'was probably an alias for the chip at 0x%lx\n", chips[i].start);
-								return 1;
-							} /* else no, they're different, fall through. */
-						} else {
-							/* No the old one hasn't got QRY for data. Therefore,
-							   it's an alias of the new one. */
-							map->write16(map, 0xffff, base+0xaa);
-							/* Just to be paranoid. */
-							map->write16(map, 0xffff, chips[i].start+0xaa);
-							printk("T'was an alias for the chip at 0x%lx\n", chips[i].start);
-							return 1;
-						}
-					} 
-					/* No, the old one didn't look like it's in query mode. Next. */
-				}
-				
-				/* OK, if we got to here, then none of the previous chips appear to
-				   be aliases for the current one. */
-				if (cfi->numchips == MAX_CFI_CHIPS) {
-					printk("%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
-					/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
-					return 1;
-				}
-				printk("Not an alias. Adding\n");
-				chips[cfi->numchips].start = base;
-				chips[cfi->numchips].state = FL_READY;
-				chips[cfi->numchips].mutex = &chips[cfi->numchips]._spinlock;
-				cfi->numchips++;
-
-				/* Put it back into Read Mode */
-				map->write16(map, 0xffff, base+0xaa);
-			}
-			
-			return 1;
-		}	
-		else if (map->read16(map, base+0x20) == 0x5151 &&
-			 map->read16(map, base+0x22) == 0x5252 &&
-			 map->read16(map, base+0x24) == 0x5959) {
-			printk("%s: Found a coupled pair of CFI devices at %lx in 8 bit mode\n",
-			       map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-
-				/* Put it back into Read Mode */
-				map->write16(map, 0xffff, base+0xaa);
-			}
+	return -1; 	// nothing found
+}
 
-			return 2;
-		} else {
-			if (map->read16(map, base+0xaa) == 0x9898) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write16(map, tmp, base+0xaa);
-			}
-			return 0;
-		}
+static void cfi_qry_mode(struct map_info *map, __u32 base, struct cfi_private *cfi)
+{
+	switch(cfi->cfi_mode){
+	case 0:
+		/* Query */
+		cfi_send_cmd(0x98, base, map, cfi->interleave, cfi->device_type, NULL);
+		break;
+		
+	case 1:
+		/* Autoselect */
+		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi->interleave, cfi->device_type, NULL);
+		break;
 	}
+}
 
+static int cfi_probe_chip_1(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi)
+{
+	int index;
+	__u32 tmp,ofs;
+	
+	ofs = cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave,cfi->device_type, &tmp);
+	
+	cfi_qry_mode(map,base,cfi);
+	
+	index=cfi_check_qry_or_id(map,base,-1,cfi);
+	if (index<0) return -1;
+	
+	if (chips){
+		int i;
+
+		for (i=0; i<cfi->numchips; i++){
+			/* This chip should be in read mode if it's one
+			   we've already touched. */
+			if (cfi_check_qry_or_id(map,chips[i].start,index,cfi) >= 0){
+				cfi_send_gen_cmd(0xF0, 0, chips[i].start, map, cfi->interleave, cfi->device_type, NULL);
+				if (cfi_check_qry_or_id(map,chips[i].start,index,cfi) >= 0){
+					/* Yes it's got QRY for data. Most unfortunate.
+					   Stick the old one in read mode too. */
+					cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave, cfi->device_type, NULL);
+					if (cfi_check_qry_or_id(map,base,index,cfi) >= 0){
+						/* OK, so has the new one. Assume it's an alias */
+						printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+						       map->name, base, chips[i].start);
+						return -1;
+					}
+				} else {
+					cfi_send_gen_cmd(0xF0, 0, base+0xaa*cfi->interleave * cfi->device_type, map, cfi->interleave, cfi->device_type, NULL);
+					cfi_send_gen_cmd(0xF0, 0, chips[i].start+0xaa*cfi->interleave * cfi->device_type, map, cfi->interleave, cfi->device_type, NULL);
+					return -1;
+				}
+			}
+		} /* for i */
 		
-	case 4: {
-		__u32 tmp = map->read32(map, base+0x154);
-		
-		/* If there's a device there, put it into Query Mode */
-		map->write32(map, 0x98989898, base+0x154);
+		/* OK, if we got to here, then none of the previous chips appear to
+		   be aliases for the current one. */
+		if (cfi->numchips == MAX_CFI_CHIPS) {
+			printk(KERN_WARNING"%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
+			/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
+			return -1;
+		}
+		chips[cfi->numchips].start = base;
+		chips[cfi->numchips].state = FL_READY;
+		chips[cfi->numchips].mutex = &chips[cfi->numchips]._spinlock;
+		cfi->numchips++;
 		
-		if (map->read32(map, base+0x40) == cpu_to_le32(0x00000051) &&
-		    map->read32(map, base+0x44) == cpu_to_le32(0x00000052) &&
-		    map->read32(map, base+0x48) == cpu_to_le32(0x00000059)) {
-				/* This isn't actually in the CFI spec - only x8 and x16 are. */
-			printk("%s: Found a CFI device at %lx in 32 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 1;
-		} 
-		else if (map->read32(map, base+0x40) == cpu_to_le32(0x00510051) &&
-			 map->read32(map, base+0x44) == cpu_to_le32(0x00520052) &&
-			 map->read32(map, base+0x48) == cpu_to_le32(0x00590059)) {
-			printk("%s: Found a coupled pair of CFI devices at location %lx in 16 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
+		/* Put it back into Read Mode */
+		cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave, cfi->device_type, NULL);
+	}
+	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit mode\n", map->name, 
+	       cfi->interleave, cfi->device_type*8, base, map->buswidth*8);
+	
+	return index;
+}
 
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 2;
-		}
-		else if (map->read32(map, base+0x40) == 0x51515151 &&
-			 map->read32(map, base+0x44) == 0x52525252 &&
-			 map->read32(map, base+0x48) == 0x59595959) {
-			printk("%s: Found four side-by-side CFI devices at location %lx in 8 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
+/*  put dev into qry mode, and try cfi and jedec modes for the given type/interleave
+ */
+static int cfi_probe_chip(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi)
+{
+	int index;
+	cfi->cfi_mode=0;	/* cfi mode */
+	cfi->addr_unlock1=0x555; cfi->addr_unlock2=0x2aa; 
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	if (index>=0) return index;
+	
+	cfi->cfi_mode=1;	/* jedec mode */
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	if (index>=0) return index;
+	
+	cfi->addr_unlock1=0x5555; cfi->addr_unlock2=0x2aaa; 
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	
+	return index;
+}
 
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 4;
-		} else {
-			if (map->read32(map, base+0x154) == 0x98989898) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write32(map, tmp, base+0x154);
-			}
-			return 0;
-		}
-	}	
+/*
+ * Since probeing for CFI chips requires writing to the device problems may
+ * occur if the flash is not present and RAM is accessed instead.  For now we
+ * assume that the flash is present so we don't check for RAM or replace
+ * possibly overwritten data.
+ */
+static int cfi_probe_new_chip(struct map_info *map, unsigned long base,
+			      struct flchip *chips, struct cfi_private *cfi)
+{
+int index;
+	switch (map->buswidth) {
+#ifdef CFIDEV_BUSWIDTH_1		
+	case CFIDEV_BUSWIDTH_1:
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+		break;			
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_2		
+	case CFIDEV_BUSWIDTH_2:
+#ifdef CFIDEV_INTERLEAVE_1
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+#endif
+		break;			
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_4
+	case CFIDEV_BUSWIDTH_4:
+#ifdef CFIDEV_INTERLEAVE_4
+		cfi->interleave = CFIDEV_INTERLEAVE_4;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X32;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_1
+                cfi->interleave = CFIDEV_INTERLEAVE_1;
+                cfi->device_type = CFI_DEVICETYPE_X32;
+                index = cfi_probe_chip(map,base,chips,cfi);
+                if (index>=0) return index;
+#endif
+		break;
+#endif
 	default:
-		printk(KERN_WARNING "cfi_probe called with strange buswidth %d\n", map->buswidth);
-		return 0;
-	}
+		printk(KERN_WARNING "cfi_probe called with unsupported buswidth %d\n", map->buswidth);
+		return -1;
+	} // switch
+	return -1;
 }
 
 static struct cfi_private *cfi_cfi_probe(struct map_info *map)
@@ -259,85 +307,121 @@
 	struct cfi_private cfi;
 	struct cfi_private *retcfi;
 	struct flchip chip[MAX_CFI_CHIPS];
-	int i;
+	int i,index; 
+	char num_erase_regions;
+ 	int ofs_factor;
 
 	memset(&cfi, 0, sizeof(cfi));
 
 	/* The first invocation (with chips == NULL) leaves the device in Query Mode */
-	cfi.interleave = cfi_probe_new_chip(map, 0, NULL, NULL);
+	index = cfi_probe_new_chip(map, 0, NULL, &cfi);
 
-	if (!cfi.interleave) {
-		printk("%s: Found no CFI device at location zero\n", map->name);
+	if (index<0) {
+		printk(KERN_WARNING"%s: Found no CFI device at location zero\n", map->name);
 		/* Doesn't appear to be CFI-compliant at all */
 		return NULL;
 	}
 
 	/* Read the Basic Query Structure from the device */
 
-	for (i=0; i<sizeof(struct cfi_ident); i++) {
-		((unsigned char *)&cfi.cfiq)[i] = map->read8(map,base + ((0x10 + i)*map->buswidth));
-	}
+ 	ofs_factor = cfi.interleave*cfi.device_type;
 
-	/* Do any necessary byteswapping */
-	cfi.cfiq.P_ID = le16_to_cpu(cfi.cfiq.P_ID);
-	cfi.cfiq.P_ADR = le16_to_cpu(cfi.cfiq.P_ADR);
-	cfi.cfiq.A_ID = le16_to_cpu(cfi.cfiq.A_ID);
-	cfi.cfiq.A_ADR = le16_to_cpu(cfi.cfiq.A_ADR);
-	cfi.cfiq.InterfaceDesc = le16_to_cpu(cfi.cfiq.InterfaceDesc);
-	cfi.cfiq.MaxBufWriteSize = le16_to_cpu(cfi.cfiq.MaxBufWriteSize);
-	
-#if 1
-	/* Dump the information therein */
-	print_cfi_ident(&cfi.cfiq);
+	/* First, work out the amount of space to allocate */
+	if (cfi.cfi_mode==0){
+		num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);
+
+#ifdef DEBUG_CFI
+		printk("Number of erase regions: %d\n", num_erase_regions);
+#endif
+
+		cfi.cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+		if (!cfi.cfiq) {
+			printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+			return NULL;
+		}
 
-	for (i=0; i<cfi.cfiq.NumEraseRegions; i++) {
-		__u16 EraseRegionInfoNum = (map->read8(map,base + ((0x2d + (4*i))*map->buswidth))) + 
-			(((map->read8(map,(0x2e + (4*i))*map->buswidth)) << 8));
-		__u16 EraseRegionInfoSize = (map->read8(map, base + ((0x2f + (4*i))*map->buswidth))) + 
-			(map->read8(map, base + ((0x30 + (4*i))*map->buswidth)) << 8);
-		
-		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
-		       i, EraseRegionInfoSize * 256, EraseRegionInfoNum+1);
+		memset(cfi.cfiq,0,sizeof(struct cfi_ident));	
+
+		cfi.fast_prog=1;		/* CFI supports fast programming */
+
+			/* CFI flash */
+		for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++) {
+			((unsigned char *)cfi.cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);
+		}
+
+		/* Do any necessary byteswapping */
+		cfi.cfiq->P_ID = le16_to_cpu(cfi.cfiq->P_ID);
+		cfi.cfiq->P_ADR = le16_to_cpu(cfi.cfiq->P_ADR);
+		cfi.cfiq->A_ID = le16_to_cpu(cfi.cfiq->A_ID);
+		cfi.cfiq->A_ADR = le16_to_cpu(cfi.cfiq->A_ADR);
+		cfi.cfiq->InterfaceDesc = le16_to_cpu(cfi.cfiq->InterfaceDesc);
+		cfi.cfiq->MaxBufWriteSize = le16_to_cpu(cfi.cfiq->MaxBufWriteSize);
+
+#ifdef CONFIG_MTD_CFI_INTELSTD
+		if (cfi.cfiq->P_ID == 3)
+		    cfi.cfiq->P_ID = 1;
+#endif
+
+		for (i=0; i<cfi.cfiq->NumEraseRegions; i++) {
+			cfi.cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi.cfiq->EraseRegionInfo[i]);
+
+#ifdef DEBUG_CFI		
+			printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
+		       		i, (cfi.cfiq->EraseRegionInfo[i] >> 8) & ~0xff, 
+		       		(cfi.cfiq->EraseRegionInfo[i] & 0xffff) + 1);
+#endif
+		}
+	}
+	else{
+		/* JEDEC flash */
+		if (cfi_jedec_setup(&cfi,index)<0){
+			printk(KERN_WARNING "cfi_jedec_setup failed\n");
+			return NULL;
+		}
 	}
-	
-	printk("\n");
-#endif	
 
-	/* Switch the chip back into Read Mode, to make the alias detection work */
-	switch(map->buswidth) {
-	case 1:
-		map->write8(map, 0xff, 0x55);
-		break;
-	case 2:
-		map->write16(map, 0xffff, 0xaa);
-		break;
-	case 4:
-		map->write32(map, 0xffffffff, 0x154);
-		break;
+	if (cfi.cfiq->NumEraseRegions == 0) {
+		printk(KERN_WARNING "Number of erase regions is zero\n");
+		kfree(cfi.cfiq);
+		return NULL;
 	}
 
+#ifdef DEBUG_CFI
+	/* Dump the information therein */
+	print_cfi_ident(cfi.cfiq);
+#endif
+
+	cfi_send_cmd(0xFF, base, map, cfi.interleave, cfi.device_type, NULL);
+
 	/* OK. We've worked out what it is and we're happy with it. Now see if there are others */
 
 	chip[0].start = 0;
 	chip[0].state = FL_READY;
 	chip[0].mutex = &chip[0]._spinlock;
 
-	cfi.chipshift =  cfi.cfiq.DevSize;
+	cfi.chipshift = cfi.cfiq->DevSize;
 	cfi.numchips = 1;
 
 	if (!cfi.chipshift) {
-		printk("cfi.chipsize is zero. This is bad. cfi.cfiq.DevSize is %d\n", cfi.cfiq.DevSize);
+		printk(KERN_ERR"cfi.chipsize is zero. This is bad. cfi.cfiq->DevSize is %d\n", cfi.cfiq->DevSize);
+		kfree(cfi.cfiq);
 		return NULL;
 	}
+	switch (cfi.interleave) {
+	    case 2: cfi.chipshift += 1; break;
+	    case 4: cfi.chipshift += 2; break;
+	}
 
 	for (base = (1<<cfi.chipshift); base < map->size; base += (1<<cfi.chipshift))
-		cfi_probe_new_chip(map, base, &chip[0], &cfi);
+		cfi_probe_chip_1(map, base, &chip[0], &cfi);
 
 	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
 
-	if (!retcfi)
+	if (!retcfi) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);
+		kfree(cfi.cfiq);
 		return NULL;
-
+	}
 	memcpy(retcfi, &cfi, sizeof(cfi));
 	memcpy(&retcfi->chips[0], chip, sizeof(struct flchip) * cfi.numchips);
 	for (i=0; i< retcfi->numchips; i++) {
@@ -347,6 +431,7 @@
 	return retcfi;
 }
 
+#ifdef DEBUG_CFI
 static char *vendorname(__u16 vendor) 
 {
 	switch (vendor) {
@@ -379,14 +464,15 @@
 	}
 }
 
-		
+
 static void print_cfi_ident(struct cfi_ident *cfip)
 {
+#if 0
 	if (cfip->qry[0] != 'Q' || cfip->qry[1] != 'R' || cfip->qry[2] != 'Y') {
 		printk("Invalid CFI ident structure.\n");
 		return;
 	}	
-		
+#endif		
 	printk("Primary Vendor Command Set: %4.4X (%s)\n", cfip->P_ID, vendorname(cfip->P_ID));
 	if (cfip->P_ADR)
 		printk("Primary Algorithm Table at %4.4X\n", cfip->P_ADR);
@@ -460,55 +546,102 @@
 	printk("Number of Erase Block Regions: %d\n", cfip->NumEraseRegions);
 	
 }
+#endif DEBUG_CFI
 
-static void check_cmd_set(struct map_info *map, int primary, unsigned long base)
+typedef void cfi_cmdset_fn_t(struct map_info *, int, unsigned long);
+
+extern cfi_cmdset_fn_t cfi_cmdset_0001;
+extern cfi_cmdset_fn_t cfi_cmdset_0002;
+
+static void cfi_cmdset_unknown(struct map_info *map, int primary, unsigned long base)
 {
 	__u16 adr;
 	struct cfi_private *cfi = map->fldrv_priv;
-	__u16 type = primary?cfi->cfiq.P_ID:cfi->cfiq.A_ID;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+#ifdef HAVE_INTER_MODULE
 	char probename[32];
-	void (*probe_function)(struct map_info *, int, unsigned long);
-	
-	if (type == P_ID_NONE || type == P_ID_RESERVED)
-		return;
-	
+	cfi_cmdset_fn_t *probe_function;
+
 	sprintf(probename, "cfi_cmdset_%4.4X", type);
-	
+		
 	probe_function = inter_module_get_request(probename, probename);
+
 	if (probe_function) {
 		(*probe_function)(map, primary, base);
 		return;
-	}
-
+	}	
+#endif
+	printk(KERN_NOTICE "Support for command set %04X not present\n", type);
 	/* This was a command set we don't know about. Print only the basic info */
-	adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+	adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 	
 	if (!adr) {
 		printk(" No Extended Query Table\n");
 	}
-	else if (map->read8(map,base+(adr*map->buswidth)) != (primary?'P':'A') ||
-		 map->read8(map,base+((adr+1)*map->buswidth)) != (primary?'R':'L') ||
-		 map->read8(map,base+((adr+2)*map->buswidth)) != (primary?'I':'T')) {
-		printk ("Invalid Extended Query Table at %4.4X: %2.2X %2.2X %2.2X\n",
-			adr,
-			map->read8(map,base+(adr*map->buswidth)),
-			map->read8(map,base+((adr+1)*map->buswidth)),
-			map->read8(map,base+((adr+2)*map->buswidth)));
-	}
 	else {
-		printk(" Extended Query Table version %c.%c\n",
-		       map->read8(map,base+((adr+3)*map->buswidth)), 
-		       map->read8(map,base+((adr+4)*map->buswidth)));
+ 		int ofs_factor = cfi->interleave * cfi->device_type;
+
+		if (cfi_read_query(map,base + adr*ofs_factor) != (primary?'P':'A') ||
+		    cfi_read_query(map,base + (adr+1)*ofs_factor) != (primary?'R':'L') ||
+		    cfi_read_query(map,base + (adr+2)*ofs_factor) != (primary?'I':'T')) {
+			printk ("Invalid Extended Query Table at %4.4X: %2.2X %2.2X %2.2X\n",
+				adr,
+				cfi_read_query(map,base + adr*ofs_factor),
+				cfi_read_query(map,base + (adr+1)*ofs_factor),
+				cfi_read_query(map,base + (adr+2)*ofs_factor));
+		}
+		else {
+			printk(" Extended Query Table version %c.%c\n",
+			       cfi_read_query(map,base + (adr+3)*ofs_factor), 
+			       cfi_read_query(map,base + (adr+4)*ofs_factor));
+		}
+	}
+	cfi_send_cmd(0xff, base, map, cfi->interleave, cfi->device_type, NULL);
+}
+
+static void check_cmd_set(struct map_info *map, int primary, unsigned long base)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+	
+	if (type == P_ID_NONE || type == P_ID_RESERVED)
+		return;
+	/* Put it in query mode */
+	cfi_qry_mode(map,base,cfi);
+
+	switch(type){
+		/* Urgh. Ifdefs. The version with weak symbols was
+		 * _much_ nicer. Shame it didn't seem to work on
+		 * anything but x86, really.
+		 * But we can't rely in inter_module_get() because
+		 * that'd mean we depend on link order.
+		 */
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	case 0x0001:
+		return cfi_cmdset_0001(map, primary, base);
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	case 0x0002:
+		return cfi_cmdset_0002(map, primary, base);
+#endif
 	}
+
+	return cfi_cmdset_unknown(map, primary, base);
 }
 
-static int __init cfi_probe_init(void)
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_probe_init init_module
+#define cfi_probe_exit cleanup_module
+#endif
+
+mod_init_t cfi_probe_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_probe);
 	return 0;
 }
 
-static void __exit cfi_probe_exit(void)
+mod_exit_t cfi_probe_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/Config.in linux-2.4.2/drivers/mtd/chips/Config.in
--- linux-2.4.2.orig/drivers/mtd/chips/Config.in	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/Config.in	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,56 @@
+# drivers/mtd/chips/Config.in
+
+# $Id: Config.in,v 1.13 2002/01/10 20:27:40 eric Exp $
+
+mainmenu_option next_comment
+
+comment 'RAM/ROM/Flash chip drivers'
+
+dep_tristate '  Detect flash chips by Common Flash Interface (CFI) probe' CONFIG_MTD_CFI $CONFIG_MTD
+dep_tristate '  Detect JEDEC JESD21c compatible flash chips' CONFIG_MTD_JEDECPROBE $CONFIG_MTD
+
+if [ "$CONFIG_MTD_CFI" = "y" -o "$CONFIG_MTD_JEDECPROBE" = "y" ]; then
+   define_bool CONFIG_MTD_GEN_PROBE y
+else
+   if [ "$CONFIG_MTD_CFI" = "m" -o "$CONFIG_MTD_JEDECPROBE" = "m" ]; then
+      define_bool CONFIG_MTD_GEN_PROBE m
+   else
+      define_bool CONFIG_MTD_GEN_PROBE n
+   fi
+fi
+if [ "$CONFIG_MTD_GEN_PROBE" = "y" -o "$CONFIG_MTD_GEN_PROBE" = "m" ]; then
+   bool '  Flash chip driver advanced configuration options' CONFIG_MTD_CFI_ADV_OPTIONS
+   if [ "$CONFIG_MTD_CFI_ADV_OPTIONS" = "y" ]; then
+     choice 'Flash cmd/query data swapping'			\
+	"NO			CONFIG_MTD_CFI_NOSWAP		\
+	 BIG_ENDIAN_BYTE	CONFIG_MTD_CFI_BE_BYTE_SWAP	\
+	 LITTLE_ENDIAN_BYTE	CONFIG_MTD_CFI_LE_BYTE_SWAP"	NO
+     bool '  Specific CFI Flash geometry selection' CONFIG_MTD_CFI_GEOMETRY
+     if [ "$CONFIG_MTD_CFI_GEOMETRY" = "y" ]; then
+       bool '    Support  8-bit buswidth' CONFIG_MTD_CFI_B1
+       bool '    Support 16-bit buswidth' CONFIG_MTD_CFI_B2
+       bool '    Support 32-bit buswidth' CONFIG_MTD_CFI_B4
+	 if [ "$CONFIG_MTD_CFI_B1" = "y" ]; then
+	   define_bool CONFIG_MTD_CFI_I1 y
+         else
+           bool '    Support 1-chip flash interleave' CONFIG_MTD_CFI_I1
+	 fi
+       bool '    Support 2-chip flash interleave' CONFIG_MTD_CFI_I2
+       bool '    Support 4-chip flash interleave' CONFIG_MTD_CFI_I4
+     fi
+  fi
+fi
+dep_tristate '  Support for Intel/Sharp flash chips' CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_GEN_PROBE
+dep_tristate '  Support for AMD/Fujitsu flash chips' CONFIG_MTD_CFI_AMDSTD $CONFIG_MTD_GEN_PROBE
+
+dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
+dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
+dep_tristate '  Support for absent chips in bus mapping' CONFIG_MTD_ABSENT $CONFIG_MTD
+
+bool '  Older (theoretically obsoleted now) drivers for non-CFI chips' CONFIG_MTD_OBSOLETE_CHIPS
+dep_tristate '  AMD compatible flash chip support (non-CFI)' CONFIG_MTD_AMDSTD $CONFIG_MTD $CONFIG_MTD_OBSOLETE_CHIPS
+dep_tristate '  pre-CFI Sharp chip support' CONFIG_MTD_SHARP $CONFIG_MTD $CONFIG_MTD_OBSOLETE_CHIPS
+dep_tristate '  JEDEC device support' CONFIG_MTD_JEDEC $CONFIG_MTD $CONFIG_MTD_OBSOLETE_CHIPS
+
+
+endmenu
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/GNUmakefile linux-2.4.2/drivers/mtd/chips/GNUmakefile
--- linux-2.4.2.orig/drivers/mtd/chips/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/GNUmakefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,36 @@
+# $Id: GNUmakefile,v 1.6 2001/09/02 18:57:01 dwmw2 Exp $
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+
+CONFIG_MTD := m
+CONFIG_MTD_AMDSTD := m
+CONFIG_MTD_CFI := m
+CONFIG_MTD_CFI_AMDSTD := m
+CONFIG_MTD_CFI_INTELEXT := m
+CONFIG_MTD_GEN_PROBE := m
+CONFIG_MTD_JEDEC := m
+CONFIG_MTD_JEDECPROBE := m
+CONFIG_MTD_INTELPROBE := m
+CONFIG_MTD_RAM := m
+CONFIG_MTD_ROM := m
+CONFIG_MTD_SHARP := m
+CONFIG_MTD_ABSENT := m
+
+endif
+
+# Normal case - build in-kernel
+
+ifeq ($(VERSION),2)
+ ifneq ($(PATCHLEVEL),4)
+  ifneq ($(PATCHLEVEL),5)
+   OLDTOPDIR := $(TOPDIR)
+   TOPDIR := $(shell pwd)/..
+  endif
+ endif
+endif
+
+include Makefile
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/Makefile linux-2.4.2/drivers/mtd/chips/Makefile
--- linux-2.4.2.orig/drivers/mtd/chips/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/Makefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,30 @@
+#
+# linux/drivers/chips/Makefile
+#
+# $Id: Makefile,v 1.8 2002/01/10 20:27:40 eric Exp $
+
+O_TARGET	:= chipslink.o
+
+export-objs	:= chipreg.o gen_probe.o
+
+#                       *** BIG UGLY NOTE ***
+#
+# The removal of get_module_symbol() and replacement with
+# inter_module_register() et al has introduced a link order dependency
+# here where previously there was none.  We now have to ensure that
+# the CFI command set drivers are linked before cfi_probe.o
+
+obj-$(CONFIG_MTD)		+= chipreg.o
+obj-$(CONFIG_MTD_AMDSTD)	+= amd_flash.o 
+obj-$(CONFIG_MTD_CFI)		+= cfi_probe.o
+obj-$(CONFIG_MTD_CFI_AMDSTD)	+= cfi_cmdset_0002.o
+obj-$(CONFIG_MTD_CFI_INTELEXT)	+= cfi_cmdset_0001.o
+obj-$(CONFIG_MTD_GEN_PROBE)	+= gen_probe.o
+obj-$(CONFIG_MTD_JEDEC)		+= jedec.o
+obj-$(CONFIG_MTD_JEDECPROBE)	+= jedec_probe.o
+obj-$(CONFIG_MTD_RAM)		+= map_ram.o
+obj-$(CONFIG_MTD_ROM)		+= map_rom.o
+obj-$(CONFIG_MTD_SHARP)		+= sharp.o
+obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/amd_flash.c linux-2.4.2/drivers/mtd/chips/amd_flash.c
--- linux-2.4.2.orig/drivers/mtd/chips/amd_flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/amd_flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1382 @@
+/*
+ * MTD map driver for AMD compatible flash chips (non-CFI)
+ *
+ * Author: Jonas Holmberg <jonas.holmberg@axis.com>
+ *
+ * $Id: amd_flash.c,v 1.15 2001/10/02 15:05:11 dwmw2 Exp $
+ *
+ * Copyright (c) 2001 Axis Communications AB
+ *
+ * This file is under GPL.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+
+/* There's no limit. It exists only to avoid realloc. */
+#define MAX_AMD_CHIPS 8
+
+#define DEVICE_TYPE_X8	(8 / 8)
+#define DEVICE_TYPE_X16	(16 / 8)
+#define DEVICE_TYPE_X32	(32 / 8)
+
+/* Addresses */
+#define ADDR_MANUFACTURER		0x0000
+#define ADDR_DEVICE_ID			0x0001
+#define ADDR_SECTOR_LOCK		0x0002
+#define ADDR_HANDSHAKE			0x0003
+#define ADDR_UNLOCK_1			0x0555
+#define ADDR_UNLOCK_2			0x02AA
+
+/* Commands */
+#define CMD_UNLOCK_DATA_1		0x00AA
+#define CMD_UNLOCK_DATA_2		0x0055
+#define CMD_MANUFACTURER_UNLOCK_DATA	0x0090
+#define CMD_UNLOCK_BYPASS_MODE		0x0020
+#define CMD_PROGRAM_UNLOCK_DATA		0x00A0
+#define CMD_RESET_DATA			0x00F0
+#define CMD_SECTOR_ERASE_UNLOCK_DATA	0x0080
+#define CMD_SECTOR_ERASE_UNLOCK_DATA_2	0x0030
+
+#define CMD_UNLOCK_SECTOR		0x0060
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+#define AM29BDS323D     0x22D1
+#define AM29BDS643D	0x227E
+
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+#define D6_MASK	0x40
+
+struct amd_flash_private {
+	int device_type;	
+	int interleave;	
+	int numchips;	
+	unsigned long chipshift;
+//	const char *im_name;
+	struct flchip chips[0];
+};
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+
+
+static int amd_flash_read(struct mtd_info *, loff_t, size_t, size_t *,
+			  u_char *);
+static int amd_flash_write(struct mtd_info *, loff_t, size_t, size_t *,
+			   const u_char *);
+static int amd_flash_erase(struct mtd_info *, struct erase_info *);
+static void amd_flash_sync(struct mtd_info *);
+static int amd_flash_suspend(struct mtd_info *);
+static void amd_flash_resume(struct mtd_info *);
+static void amd_flash_destroy(struct mtd_info *);
+static struct mtd_info *amd_flash_probe(struct map_info *map);
+
+
+static struct mtd_chip_driver amd_flash_chipdrv = {
+	probe: amd_flash_probe,
+	destroy: amd_flash_destroy,
+	name: "amd_flash",
+	module: THIS_MODULE
+};
+
+
+
+static const char im_name[] = "amd_flash";
+
+
+
+static inline __u32 wide_read(struct map_info *map, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		return map->read8(map, addr);
+	} else if (map->buswidth == 2) {
+		return map->read16(map, addr);
+	} else if (map->buswidth == 4) {
+		return map->read32(map, addr);
+        }
+
+	return 0;
+}
+
+static inline void wide_write(struct map_info *map, __u32 val, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		map->write8(map, val, addr);
+	} else if (map->buswidth == 2) {
+		map->write16(map, val, addr);
+	} else if (map->buswidth == 4) {
+		map->write32(map, val, addr);
+	}
+}
+
+static inline __u32 make_cmd(struct map_info *map, __u32 cmd)
+{
+	const struct amd_flash_private *private = map->fldrv_priv;
+	if ((private->interleave == 2) &&
+	    (private->device_type == DEVICE_TYPE_X16)) {
+		cmd |= (cmd << 16);
+	}
+
+	return cmd;
+}
+
+static inline void send_unlock(struct map_info *map, unsigned long base)
+{
+	wide_write(map, (CMD_UNLOCK_DATA_1 << 16) | CMD_UNLOCK_DATA_1,
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+	wide_write(map, (CMD_UNLOCK_DATA_2 << 16) | CMD_UNLOCK_DATA_2,
+		   base + (map->buswidth * ADDR_UNLOCK_2));
+}
+
+static inline void send_cmd(struct map_info *map, unsigned long base, __u32 cmd)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd),
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+}
+
+static inline void send_cmd_to_addr(struct map_info *map, unsigned long base,
+				    __u32 cmd, unsigned long addr)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd), addr);
+}
+
+static inline int flash_is_busy(struct map_info *map, unsigned long addr,
+				int interleave)
+{
+
+	if ((interleave == 2) && (map->buswidth == 4)) {
+		__u32 read1, read2;
+
+		read1 = wide_read(map, addr);
+		read2 = wide_read(map, addr);
+
+		return (((read1 >> 16) & D6_MASK) !=
+			((read2 >> 16) & D6_MASK)) ||
+		       (((read1 & 0xffff) & D6_MASK) !=
+			((read2 & 0xffff) & D6_MASK));
+	}
+
+	return ((wide_read(map, addr) & D6_MASK) !=
+		(wide_read(map, addr) & D6_MASK));
+}
+
+static inline void unlock_sector(struct map_info *map, unsigned long sect_addr,
+				 int unlock)
+{
+	/* Sector lock address. A6 = 1 for unlock, A6 = 0 for lock */
+	int SLA = unlock ?
+		(sect_addr |  (0x40 * map->buswidth)) :
+		(sect_addr & ~(0x40 * map->buswidth)) ;
+
+	__u32 cmd = make_cmd(map, CMD_UNLOCK_SECTOR);
+
+	wide_write(map, make_cmd(map, CMD_RESET_DATA), 0);
+	wide_write(map, cmd, SLA); /* 1st cycle: write cmd to any address */
+	wide_write(map, cmd, SLA); /* 2nd cycle: write cmd to any address */
+	wide_write(map, cmd, SLA); /* 3rd cycle: write cmd to SLA */
+}
+
+static inline int is_sector_locked(struct map_info *map,
+				   unsigned long sect_addr)
+{
+	int status;
+
+	wide_write(map, CMD_RESET_DATA, 0);
+	send_cmd(map, sect_addr, CMD_MANUFACTURER_UNLOCK_DATA);
+
+	/* status is 0x0000 for unlocked and 0x0001 for locked */
+	status = wide_read(map, sect_addr + (map->buswidth * ADDR_SECTOR_LOCK));
+	wide_write(map, CMD_RESET_DATA, 0);
+	return status;
+}
+
+static int amd_flash_do_unlock(struct mtd_info *mtd, loff_t ofs, size_t len,
+			       int is_unlock)
+{
+	struct map_info *map;
+	struct mtd_erase_region_info *merip;
+	int eraseoffset, erasesize, eraseblocks;
+	int i;
+	int retval = 0;
+	int lock_status;
+      
+	map = mtd->priv;
+
+	/* Pass the whole chip through sector by sector and check for each
+	   sector if the sector and the given interval overlap */
+	for(i = 0; i < mtd->numeraseregions; i++) {
+		merip = &mtd->eraseregions[i];
+
+		eraseoffset = merip->offset;
+		erasesize = merip->erasesize;
+		eraseblocks = merip->numblocks;
+
+		if (ofs > eraseoffset + erasesize)
+			continue;
+
+		while (eraseblocks > 0) {
+			if (ofs < eraseoffset + erasesize && ofs + len > eraseoffset) {
+				unlock_sector(map, eraseoffset, is_unlock);
+
+				lock_status = is_sector_locked(map, eraseoffset);
+				
+				if (is_unlock && lock_status) {
+					printk("Cannot unlock sector at address %x length %xx\n",
+					       eraseoffset, merip->erasesize);
+					retval = -1;
+				} else if (!is_unlock && !lock_status) {
+					printk("Cannot lock sector at address %x length %x\n",
+					       eraseoffset, merip->erasesize);
+					retval = -1;
+				}
+			}
+			eraseoffset += erasesize;
+			eraseblocks --;
+		}
+	}
+	return retval;
+}
+
+static int amd_flash_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	return amd_flash_do_unlock(mtd, ofs, len, 1);
+}
+
+static int amd_flash_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	return amd_flash_do_unlock(mtd, ofs, len, 0);
+}
+
+
+/*
+ * Reads JEDEC manufacturer ID and device ID and returns the index of the first
+ * matching table entry (-1 if not found or alias for already found chip).
+ */ 
+static int probe_new_chip(struct mtd_info *mtd, __u32 base,
+			  struct flchip *chips,
+			  struct amd_flash_private *private,
+			  const struct amd_flash_info *table, int table_size)
+{
+	__u32 mfr_id;
+	__u32 dev_id;
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private temp;
+	int i;
+
+	temp.device_type = DEVICE_TYPE_X16;	// Assume X16 (FIXME)
+	temp.interleave = 2;
+	map->fldrv_priv = &temp;
+
+	/* Enter autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+	send_cmd(map, base, CMD_MANUFACTURER_UNLOCK_DATA);
+
+	mfr_id = wide_read(map, base + (map->buswidth * ADDR_MANUFACTURER));
+	dev_id = wide_read(map, base + (map->buswidth * ADDR_DEVICE_ID));
+
+	if ((map->buswidth == 4) && ((mfr_id >> 16) == (mfr_id & 0xffff)) &&
+	    ((dev_id >> 16) == (dev_id & 0xffff))) {
+		mfr_id &= 0xffff;
+		dev_id &= 0xffff;
+	} else {
+		temp.interleave = 1;
+	}
+
+	for (i = 0; i < table_size; i++) {
+		if ((mfr_id == table[i].mfr_id) &&
+		    (dev_id == table[i].dev_id)) {
+			if (chips) {
+				int j;
+
+				/* Is this an alias for an already found chip?
+				 * In that case that chip should be in
+				 * autoselect mode now.
+				 */
+				for (j = 0; j < private->numchips; j++) {
+					__u32 mfr_id_other;
+					__u32 dev_id_other;
+
+					mfr_id_other =
+						wide_read(map, chips[j].start +
+							       (map->buswidth *
+								ADDR_MANUFACTURER
+							       ));
+					dev_id_other =
+						wide_read(map, chips[j].start +
+					    		       (map->buswidth *
+							        ADDR_DEVICE_ID));
+					if (temp.interleave == 2) {
+						mfr_id_other &= 0xffff;
+						dev_id_other &= 0xffff;
+					}
+					if ((mfr_id_other == mfr_id) &&
+					    (dev_id_other == dev_id)) {
+
+						/* Exit autoselect mode. */
+						send_cmd(map, base,
+							 CMD_RESET_DATA);
+
+						return -1;
+					}
+				}
+
+				if (private->numchips == MAX_AMD_CHIPS) {
+					printk(KERN_WARNING
+					       "%s: Too many flash chips "
+					       "detected. Increase "
+					       "MAX_AMD_CHIPS from %d.\n",
+					       map->name, MAX_AMD_CHIPS);
+
+					return -1;
+				}
+
+				chips[private->numchips].start = base;
+				chips[private->numchips].state = FL_READY;
+				chips[private->numchips].mutex =
+					&chips[private->numchips]._spinlock;
+				private->numchips++;
+			}
+
+			printk("%s: Found %d x %ldMiB %s at 0x%x\n", map->name,
+			       temp.interleave, (table[i].size)/(1024*1024),
+			       table[i].name, base);
+
+			mtd->size += table[i].size * temp.interleave;
+			mtd->numeraseregions += table[i].numeraseregions;
+
+			break;
+		}
+	}
+
+	/* Exit autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+
+	if (i == table_size) {
+		printk(KERN_DEBUG "%s: unknown flash device at 0x%x, "
+		       "mfr id 0x%x, dev id 0x%x\n", map->name,
+		       base, mfr_id, dev_id);
+		map->fldrv_priv = NULL;
+
+		return -1;
+	}
+
+	private->device_type = temp.device_type;
+	private->interleave = temp.interleave;
+
+	return i;
+}
+
+
+
+static struct mtd_info *amd_flash_probe(struct map_info *map)
+{
+	/* Keep this table on the stack so that it gets deallocated after the
+	 * probe is done.
+	 */
+	const struct amd_flash_info table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29BDS323D,
+		name: "AMD AM29BDS323D",
+		size: 0x00400000,
+		numeraseregions: 3,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 48 },
+			{ offset: 0x300000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x3f0000, erasesize: 0x02000, numblocks:  8 },
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29BDS643D,
+		name: "AMD AM29BDS643D",
+		size: 0x00800000,
+		numeraseregions: 3,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 96 },
+			{ offset: 0x600000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x7f0000, erasesize: 0x02000, numblocks:  8 },
+		}
+	} 
+	};
+
+	struct mtd_info *mtd;
+	struct flchip chips[MAX_AMD_CHIPS];
+	int table_pos[MAX_AMD_CHIPS];
+	struct amd_flash_private temp;
+	struct amd_flash_private *private;
+	u_long size;
+	unsigned long base;
+	int i;
+	int reg_idx;
+	int offset;
+
+	mtd = (struct mtd_info*)kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for info structure\n", map->name);
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+
+	memset(&temp, 0, sizeof(temp));
+
+	printk("%s: Probing for AMD compatible flash...\n", map->name);
+
+	if ((table_pos[0] = probe_new_chip(mtd, 0, NULL, &temp, table,
+					   sizeof(table)/sizeof(table[0])))
+	    == -1) {
+		printk(KERN_WARNING
+		       "%s: Found no AMD compatible device at location zero\n",
+		       map->name);
+		kfree(mtd);
+
+		return NULL;
+	}
+
+	chips[0].start = 0;
+	chips[0].state = FL_READY;
+	chips[0].mutex = &chips[0]._spinlock;
+	temp.numchips = 1;
+	for (size = mtd->size; size > 1; size >>= 1) {
+		temp.chipshift++;
+	}
+	switch (temp.interleave) {
+		case 2:
+			temp.chipshift += 1;
+			break;
+		case 4:
+			temp.chipshift += 2;
+			break;
+	}
+
+	/* Find out if there are any more chips in the map. */
+	for (base = (1 << temp.chipshift);
+	     base < map->size;
+	     base += (1 << temp.chipshift)) {
+	     	int numchips = temp.numchips;
+		table_pos[numchips] = probe_new_chip(mtd, base, chips,
+			&temp, table, sizeof(table)/sizeof(table[0]));
+	}
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+				    mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+		printk(KERN_WARNING "%s: Failed to allocate "
+		       "memory for MTD erase region info\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return 0;
+	}
+
+	reg_idx = 0;
+	offset = 0;
+	for (i = 0; i < temp.numchips; i++) {
+		int dev_size;
+		int j;
+
+		dev_size = 0;
+		for (j = 0; j < table[table_pos[i]].numeraseregions; j++) {
+			mtd->eraseregions[reg_idx].offset = offset +
+				(table[table_pos[i]].regions[j].offset *
+				 temp.interleave);
+			mtd->eraseregions[reg_idx].erasesize =
+				table[table_pos[i]].regions[j].erasesize *
+				temp.interleave;
+			mtd->eraseregions[reg_idx].numblocks =
+				table[table_pos[i]].regions[j].numblocks;
+			if (mtd->erasesize <
+			    mtd->eraseregions[reg_idx].erasesize) {
+				mtd->erasesize =
+					mtd->eraseregions[reg_idx].erasesize;
+			}
+			dev_size += mtd->eraseregions[reg_idx].erasesize *
+				    mtd->eraseregions[reg_idx].numblocks;
+			reg_idx++;
+		}
+		offset += dev_size;
+	}
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+	mtd->erase = amd_flash_erase;	
+	mtd->read = amd_flash_read;	
+	mtd->write = amd_flash_write;	
+	mtd->sync = amd_flash_sync;	
+	mtd->suspend = amd_flash_suspend;	
+	mtd->resume = amd_flash_resume;	
+	mtd->lock = amd_flash_lock;
+	mtd->unlock = amd_flash_unlock;
+
+	private = kmalloc(sizeof(*private) + (sizeof(struct flchip) *
+					      temp.numchips), GFP_KERNEL);
+	if (!private) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for private structure\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return NULL;
+	}
+	memcpy(private, &temp, sizeof(temp));
+	memcpy(private->chips, chips,
+	       sizeof(struct flchip) * private->numchips);
+	for (i = 0; i < private->numchips; i++) {
+		init_waitqueue_head(&private->chips[i].wq);
+		spin_lock_init(&private->chips[i]._spinlock);
+	}
+
+	map->fldrv_priv = private;
+
+	map->fldrv = &amd_flash_chipdrv;
+	MOD_INC_USE_COUNT;
+
+	return mtd;
+}
+
+
+
+static inline int read_one_chip(struct map_info *map, struct flchip *chip,
+			       loff_t adr, size_t len, u_char *buf)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = jiffies + HZ;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk(KERN_INFO "%s: waiting for chip to read, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	adr += chip->start;
+
+	chip->state = FL_READY;
+
+	map->copy_from(map, buf, adr, len);
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long ofs;
+	int chipnum;
+	int ret = 0;
+
+	if ((from + len) > mtd->size) {
+		printk(KERN_WARNING "%s: read request past end of device "
+		       "(0x%lx)\n", map->name, (unsigned long)from + len);
+
+		return -EINVAL;
+	}
+
+	/* Offset within the first chip that the first read should start. */
+	chipnum = (from >> private->chipshift);
+	ofs = from - (chipnum <<  private->chipshift);
+
+	*retlen = 0;
+
+	while (len) {
+		unsigned long this_len;
+
+		if (chipnum >= private->numchips) {
+			break;
+		}
+
+		if ((len + ofs - 1) >> private->chipshift) {
+			this_len = (1 << private->chipshift) - ofs;
+		} else {
+			this_len = len;
+		}
+
+		ret = read_one_chip(map, &private->chips[chipnum], ofs,
+				    this_len, buf);
+		if (ret) {
+			break;
+		}
+
+		*retlen += this_len;
+		len -= this_len;
+		buf += this_len;
+
+		ofs = 0;
+		chipnum++;
+	}
+
+	return ret;
+}
+
+
+
+static int write_one_word(struct map_info *map, struct flchip *chip,
+			  unsigned long adr, __u32 datum)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+	int times_left;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk("%s: waiting for chip to write, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		printk(KERN_INFO "%s: woke up to write\n", map->name);
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_WRITING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_PROGRAM_UNLOCK_DATA);
+	wide_write(map, datum, adr);
+
+	times_left = 500000;
+	while (times_left-- && flash_is_busy(map, adr, private->interleave)) { 
+		if (current->need_resched) {
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			spin_lock_bh(chip->mutex);
+		}
+	}
+
+	if (!times_left) {
+		printk(KERN_WARNING "%s: write to 0x%lx timed out!\n",
+		       map->name, adr);
+		ret = -EIO;
+	} else {
+		__u32 verify;
+		if ((verify = wide_read(map, adr)) != datum) {
+			printk(KERN_WARNING "%s: write to 0x%lx failed. "
+			       "datum = %x, verify = %x\n",
+			       map->name, adr, datum, verify);
+			ret = -EIO;
+		}
+	}
+
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return ret;
+}
+
+
+
+static int amd_flash_write(struct mtd_info *mtd, loff_t to , size_t len,
+			   size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
+	unsigned long chipstart;
+
+	*retlen = 0;
+	if (!len) {
+		return 0;
+	}
+
+	chipnum = to >> private->chipshift;
+	ofs = to  - (chipnum << private->chipshift);
+	chipstart = private->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write. */
+	if (ofs & (map->buswidth - 1)) {
+		unsigned long bus_ofs = ofs & ~(map->buswidth - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       bus_ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len && i < map->buswidth)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], bus_ofs,
+				     datum);
+		if (ret) {
+			return ret;
+		}
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+		}
+	}
+	
+	/* We are now aligned, write as much as possible. */
+	while(len >= map->buswidth) {
+		__u32 datum;
+
+		if (map->buswidth == 1) {
+			datum = *(__u8*)buf;
+		} else if (map->buswidth == 2) {
+			datum = *(__u16*)buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+
+		ofs += map->buswidth;
+		buf += map->buswidth;
+		(*retlen) += map->buswidth;
+		len -= map->buswidth;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+			chipstart = private->chips[chipnum].start;
+		}
+	}
+
+	if (len & (map->buswidth - 1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[2];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len--) {
+			tmp_buf[i++] = buf[n++];
+		}
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+		
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+
+
+static inline int erase_one_block(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, u_long size)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_ERASING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA);
+	send_cmd_to_addr(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA_2, adr);
+	
+	timeo = jiffies + (HZ * 20);
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+	
+	while (flash_is_busy(map, adr, private->interleave)) {
+
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_INFO "%s: erase suspended. Sleeping\n",
+			       map->name);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+			
+			timeo = jiffies + (HZ*2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING "%s: waiting for erase to complete "
+			       "timed out.\n", map->name);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+
+		if (current->need_resched)
+			schedule();
+		else
+			udelay(1);
+		
+		spin_lock_bh(chip->mutex);
+	}
+
+	/* Verify every single word */
+	{
+		int address;
+		int error = 0;
+		__u8 verify;
+
+		for (address = adr; address < (adr + size); address++) {
+			if ((verify = map->read8(map, address)) != 0xFF) {
+				error = 1;
+				break;
+			}
+		}
+		if (error) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING
+			       "%s: verify error at 0x%x, size %ld.\n",
+			       map->name, address, size);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+	}
+	
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum;
+	int ret = 0;
+	int i;
+	int first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size) {
+		return -EINVAL;
+	}
+
+	if ((instr->len + instr->addr) > mtd->size) {
+		return -EINVAL;
+	}
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+        /* Skip all erase regions which are ended before the start of
+           the requested erase. Actually, to save on the calculations,
+           we skip to the first erase region which starts after the
+           start of the requested erase, and then go back one.
+        */
+
+        while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset)) {
+               i++;
+	}
+        i--;
+
+	/* OK, now i is pointing at the erase region in which this
+	 * erase request starts. Check the start of the requested
+	 * erase range is aligned with the erase size which is in
+	 * effect here.
+	 */
+
+	if (instr->addr & (regions[i].erasesize-1)) {
+		return -EINVAL;
+	}
+
+	/* Remember the erase region we start on. */
+
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while ((i < mtd->numeraseregions) && 
+	       ((instr->addr + instr->len) >= regions[i].offset)) {
+                i++;
+	}
+
+	/* As before, drop back one to point at the region in which
+	 * the address actually falls.
+	 */
+
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1)) {
+                return -EINVAL;
+	}
+
+	chipnum = instr->addr >> private->chipshift;
+	adr = instr->addr - (chipnum << private->chipshift);
+	len = instr->len;
+
+	i = first;
+
+	while (len) {
+		ret = erase_one_block(map, &private->chips[chipnum], adr,
+				      regions[i].erasesize);
+
+		if (ret) {
+			return ret;
+		}
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if ((adr % (1 << private->chipshift)) ==
+		    ((regions[i].offset + (regions[i].erasesize *
+		    			   regions[i].numblocks))
+		     % (1 << private->chipshift))) {
+			i++;
+		}
+
+		if (adr >> private->chipshift) {
+			adr = 0;
+			chipnum++;
+			if (chipnum >= private->numchips) {
+				break;
+			}
+		}
+	}
+		
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback) {
+		instr->callback(instr);
+	}
+	
+	return 0;
+}
+
+
+
+static void amd_flash_sync(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i = 0; !ret && (i < private->numchips); i++) {
+		chip = &private->chips[i];
+
+	retry:
+		spin_lock_bh(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_SYNCING:
+			spin_unlock_bh(chip->mutex);
+			break;
+
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+
+			schedule();
+
+		        remove_wait_queue(&chip->wq, &wait);
+			
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+	for (i--; i >= 0; i--) {
+		chip = &private->chips[i];
+
+		spin_lock_bh(chip->mutex);
+		
+		if (chip->state == FL_SYNCING) {
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+
+
+static int amd_flash_suspend(struct mtd_info *mtd)
+{
+printk("amd_flash_suspend(): not implemented!\n");
+	return -EINVAL;
+}
+
+
+
+static void amd_flash_resume(struct mtd_info *mtd)
+{
+printk("amd_flash_resume(): not implemented!\n");
+}
+
+
+
+static void amd_flash_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	kfree(private);
+}
+
+int __init amd_flash_init(void)
+{
+	register_mtd_chip_driver(&amd_flash_chipdrv);
+	return 0;
+}
+
+void __exit amd_flash_exit(void)
+{
+	unregister_mtd_chip_driver(&amd_flash_chipdrv);
+}
+
+module_init(amd_flash_init);
+module_exit(amd_flash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jonas Holmberg <jonas.holmberg@axis.com>");
+MODULE_DESCRIPTION("Old MTD chip driver for AMD flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.4.2/drivers/mtd/chips/cfi_cmdset_0001.c
--- linux-2.4.2.orig/drivers/mtd/chips/cfi_cmdset_0001.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/cfi_cmdset_0001.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1759 @@
+/*
+ * Common Flash Interface support:
+ *   Intel Extended Vendor Command Set (ID 0x0001)
+ *
+ * (C) 2000 Red Hat. GPL'd
+ *
+ * $Id: cfi_cmdset_0001.c,v 1.91 2002/01/10 20:27:40 eric Exp $
+ *
+ * 
+ * 10/10/2000	Nicolas Pitre <nico@cam.org>
+ * 	- completely revamped method functions so they are aware and
+ * 	  independent of the flash geometry (buswidth, interleave, etc.)
+ * 	- scalability vs code size is completely set at compile-time
+ * 	  (see include/linux/mtd/cfi.h for selection)
+ *	- optimized write buffer method
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/compatmac.h>
+
+static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_intelext_read_user_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_intelext_read_fact_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_erase_varsize(struct mtd_info *, struct erase_info *);
+static void cfi_intelext_sync (struct mtd_info *);
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
+static int cfi_intelext_suspend (struct mtd_info *);
+static void cfi_intelext_resume (struct mtd_info *);
+
+static void cfi_intelext_destroy(struct mtd_info *);
+
+struct mtd_info *cfi_cmdset_0001(struct map_info *, int);
+
+static struct mtd_info *cfi_intelext_setup (struct map_info *);
+
+static struct mtd_chip_driver cfi_intelext_chipdrv = {
+	probe: NULL, /* Not usable directly */
+	destroy: cfi_intelext_destroy,
+	name: "cfi_cmdset_0001",
+	module: THIS_MODULE
+};
+
+/* #define DEBUG_LOCK_BITS */
+/* #define DEBUG_CFI_FEATURES */
+
+#ifdef DEBUG_CFI_FEATURES
+static void cfi_tell_features(struct cfi_pri_intelext *extp)
+{
+	printk("  Feature/Command Support: %4.4X\n", extp->FeatureSupport);
+	printk("     - Chip Erase:         %s\n", extp->FeatureSupport&1?"supported":"unsupported");
+	printk("     - Suspend Erase:      %s\n", extp->FeatureSupport&2?"supported":"unsupported");
+	printk("     - Suspend Program:    %s\n", extp->FeatureSupport&4?"supported":"unsupported");
+	printk("     - Legacy Lock/Unlock: %s\n", extp->FeatureSupport&8?"supported":"unsupported");
+	printk("     - Queued Erase:       %s\n", extp->FeatureSupport&16?"supported":"unsupported");
+	printk("     - Instant block lock: %s\n", extp->FeatureSupport&32?"supported":"unsupported");
+	printk("     - Protection Bits:    %s\n", extp->FeatureSupport&64?"supported":"unsupported");
+	printk("     - Page-mode read:     %s\n", extp->FeatureSupport&128?"supported":"unsupported");
+	printk("     - Synchronous read:   %s\n", extp->FeatureSupport&256?"supported":"unsupported");
+	for (i=9; i<32; i++) {
+		if (extp->FeatureSupport & (1<<i)) 
+			printk("     - Unknown Bit %X:      supported\n", i);
+	}
+	
+	printk("  Supported functions after Suspend: %2.2X\n", extp->SuspendCmdSupport);
+	printk("     - Program after Erase Suspend: %s\n", extp->SuspendCmdSupport&1?"supported":"unsupported");
+	for (i=1; i<8; i++) {
+		if (extp->SuspendCmdSupport & (1<<i))
+			printk("     - Unknown Bit %X:               supported\n", i);
+	}
+	
+	printk("  Block Status Register Mask: %4.4X\n", extp->BlkStatusRegMask);
+	printk("     - Lock Bit Active:      %s\n", extp->BlkStatusRegMask&1?"yes":"no");
+	printk("     - Valid Bit Active:     %s\n", extp->BlkStatusRegMask&2?"yes":"no");
+	for (i=2; i<16; i++) {
+		if (extp->BlkStatusRegMask & (1<<i))
+			printk("     - Unknown Bit %X Active: yes\n",i);
+	}
+	
+	printk("  Vcc Logic Supply Optimum Program/Erase Voltage: %d.%d V\n", 
+	       extp->VccOptimal >> 8, extp->VccOptimal & 0xf);
+	if (extp->VppOptimal)
+		printk("  Vpp Programming Supply Optimum Program/Erase Voltage: %d.%d V\n", 
+		       extp->VppOptimal >> 8, extp->VppOptimal & 0xf);
+}
+#endif
+
+/* This routine is made available to other mtd code via
+ * inter_module_register.  It must only be accessed through
+ * inter_module_get which will bump the use count of this module.  The
+ * addresses passed back in cfi are valid as long as the use count of
+ * this module is non-zero, i.e. between inter_module_get and
+ * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
+ */
+struct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	__u32 base = cfi->chips[0].start;
+
+	if (cfi->cfi_mode == CFI_MODE_CFI) {
+		/* 
+		 * It's a real CFI chip, not one for which the probe
+		 * routine faked a CFI structure. So we read the feature
+		 * table from it.
+		 */
+		__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
+		struct cfi_pri_intelext *extp;
+		int ofs_factor = cfi->interleave * cfi->device_type;
+
+		//printk(" Intel/Sharp Extended Query Table at 0x%4.4X\n", adr);
+		if (!adr)
+			return NULL;
+
+		/* Switch it into Query Mode */
+		cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+
+		extp = kmalloc(sizeof(*extp), GFP_KERNEL);
+		if (!extp) {
+			printk(KERN_ERR "Failed to allocate memory\n");
+			return NULL;
+		}
+		
+		/* Read in the Extended Query Table */
+		for (i=0; i<sizeof(*extp); i++) {
+			((unsigned char *)extp)[i] = 
+				cfi_read_query(map, (base+((adr+i)*ofs_factor)));
+		}
+		
+		if (extp->MajorVersion != '1' || 
+		    (extp->MinorVersion < '0' || extp->MinorVersion > '2')) {
+			printk(KERN_WARNING "  Unknown IntelExt Extended Query "
+			       "version %c.%c.\n",  extp->MajorVersion,
+			       extp->MinorVersion);
+			kfree(extp);
+			return NULL;
+		}
+		
+		/* Do some byteswapping if necessary */
+		extp->FeatureSupport = cfi32_to_cpu(extp->FeatureSupport);
+		extp->BlkStatusRegMask = cfi32_to_cpu(extp->BlkStatusRegMask);
+		extp->ProtRegAddr = cfi32_to_cpu(extp->ProtRegAddr);
+			
+#ifdef DEBUG_CFI_FEATURES
+		/* Tell the user about it in lots of lovely detail */
+		cfi_tell_features(extp);
+#endif	
+
+		/* Install our own private info structure */
+		cfi->cmdset_priv = extp;	
+	}
+
+	for (i=0; i< cfi->numchips; i++) {
+		cfi->chips[i].word_write_time = 128;
+		cfi->chips[i].buffer_write_time = 128;
+		cfi->chips[i].erase_time = 1024;
+	}		
+
+	map->fldrv = &cfi_intelext_chipdrv;
+	MOD_INC_USE_COUNT;
+	
+	/* Make sure it's in read mode */
+	cfi_send_gen_cmd(0xff, 0x55, base, map, cfi, cfi->device_type, NULL);
+	return cfi_intelext_setup(map);
+}
+
+static struct mtd_info *cfi_intelext_setup(struct map_info *map)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct mtd_info *mtd;
+	unsigned long offset = 0;
+	int i,j;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	//printk(KERN_DEBUG "number of CFI chips: %d\n", cfi->numchips);
+
+	if (!mtd) {
+		printk(KERN_ERR "Failed to allocate memory for MTD device\n");
+		kfree(cfi->cmdset_priv);
+		return NULL;
+	}
+
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	mtd->size = devsize * cfi->numchips;
+
+	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) 
+			* mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+		printk(KERN_ERR "Failed to allocate memory for MTD erase region info\n");
+		kfree(cfi->cmdset_priv);
+		return NULL;
+	}
+	
+	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+		unsigned long ernum, ersize;
+		ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+		ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+
+		if (mtd->erasesize < ersize) {
+			mtd->erasesize = ersize;
+		}
+		for (j=0; j<cfi->numchips; j++) {
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+		}
+		offset += (ersize * ernum);
+		}
+
+		if (offset != devsize) {
+			/* Argh */
+			printk(KERN_WARNING "Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk(KERN_DEBUG "%d: offset=0x%x,size=0x%x,blocks=%d\n",
+			       i,mtd->eraseregions[i].offset,
+			       mtd->eraseregions[i].erasesize,
+			       mtd->eraseregions[i].numblocks);
+		}
+
+	/* Also select the correct geometry setup too */ 
+		mtd->erase = cfi_intelext_erase_varsize;
+	mtd->read = cfi_intelext_read;
+	if ( cfi->cfiq->BufWriteTimeoutTyp ) {
+		//printk(KERN_INFO "Using buffer write method\n" );
+		mtd->write = cfi_intelext_write_buffers;
+	} else {
+		//printk(KERN_INFO "Using word write method\n" );
+		mtd->write = cfi_intelext_write_words;
+	}
+	mtd->read_user_prot_reg = cfi_intelext_read_user_prot_reg;
+	mtd->read_fact_prot_reg = cfi_intelext_read_fact_prot_reg;
+	mtd->sync = cfi_intelext_sync;
+	mtd->lock = cfi_intelext_lock;
+	mtd->unlock = cfi_intelext_unlock;
+	mtd->suspend = cfi_intelext_suspend;
+	mtd->resume = cfi_intelext_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	map->fldrv = &cfi_intelext_chipdrv;
+	MOD_INC_USE_COUNT;
+	mtd->name = map->name;
+	return mtd;
+}
+
+
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+{
+	__u32 status, status_OK;
+	unsigned long timeo;
+	DECLARE_WAITQUEUE(wait, current);
+	int suspended = 0;
+	unsigned long cmd_addr;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	adr += chip->start;
+
+	/* Ensure cmd read/writes are aligned. */ 
+	cmd_addr = adr & ~(CFIDEV_BUSWIDTH-1); 
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+ retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us.
+	 * If it's in FL_ERASING state, suspend it and make it talk now.
+	 */
+	switch (chip->state) {
+	case FL_ERASING:
+		if (!((struct cfi_pri_intelext *)cfi->cmdset_priv)->FeatureSupport & 2)
+			goto sleep; /* We don't support erase suspend */
+		
+		cfi_write (map, CMD(0xb0), cmd_addr);
+		/* If the flash has finished erasing, then 'erase suspend'
+		 * appears to make some (28F320) flash devices switch to
+		 * 'read' mode.  Make sure that we switch to 'read status'
+		 * mode so we get the right data. --rmk
+		 */
+		cfi_write(map, CMD(0x70), cmd_addr);
+		chip->oldstate = FL_ERASING;
+		chip->state = FL_ERASE_SUSPENDING;
+		//		printk("Erase suspending at 0x%lx\n", cmd_addr);
+		for (;;) {
+			status = cfi_read(map, cmd_addr);
+			if ((status & status_OK) == status_OK)
+				break;
+			
+			if (time_after(jiffies, timeo)) {
+				/* Urgh */
+				cfi_write(map, CMD(0xd0), cmd_addr);
+				/* make sure we're in 'read status' mode */
+				cfi_write(map, CMD(0x70), cmd_addr);
+				chip->state = FL_ERASING;
+				spin_unlock_bh(chip->mutex);
+				printk(KERN_ERR "Chip not ready after erase "
+				       "suspended: status = 0x%x\n", status);
+				return -EIO;
+			}
+			
+			spin_unlock_bh(chip->mutex);
+			cfi_udelay(1);
+			spin_lock_bh(chip->mutex);
+		}
+		
+		suspended = 1;
+		cfi_write(map, CMD(0xff), cmd_addr);
+		chip->state = FL_READY;
+		break;
+	
+#if 0
+	case FL_WRITING:
+		/* Not quite yet */
+#endif
+
+	case FL_READY:
+		break;
+
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+		cfi_write(map, CMD(0x70), cmd_addr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, cmd_addr);
+		if ((status & status_OK) == status_OK) {
+			cfi_write(map, CMD(0xff), cmd_addr);
+			chip->state = FL_READY;
+			break;
+		}
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in read. WSM status = %x\n", status);
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+	sleep:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	map->copy_from(map, buf, adr, len);
+
+	if (suspended) {
+		chip->state = chip->oldstate;
+		/* What if one interleaved chip has finished and the 
+		   other hasn't? The old code would leave the finished
+		   one in READY mode. That's bad, and caused -EROFS 
+		   errors to be returned from do_erase_oneblock because
+		   that's the only bit it checked for at the time.
+		   As the state machine appears to explicitly allow 
+		   sending the 0x70 (Read Status) command to an erasing
+		   chip and expecting it to be ignored, that's what we 
+		   do. */
+		cfi_write(map, CMD(0xd0), cmd_addr);
+		cfi_write(map, CMD(0x70), cmd_addr);		
+	}
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+
+static int cfi_intelext_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long ofs;
+	int chipnum;
+	int ret = 0;
+
+	/* ofs: offset within the first chip that the first read should start */
+	chipnum = (from >> cfi->chipshift);
+	ofs = from - (chipnum <<  cfi->chipshift);
+
+	*retlen = 0;
+
+	while (len) {
+		unsigned long thislen;
+
+		if (chipnum >= cfi->numchips)
+			break;
+
+		if ((len + ofs -1) >> cfi->chipshift)
+			thislen = (1<<cfi->chipshift) - ofs;
+		else
+			thislen = len;
+
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		if (ret)
+			break;
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+		
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int cfi_intelext_read_prot_reg (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf, int base_offst, int reg_sz)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *extp=cfi->cmdset_priv;
+	int ofs_factor = cfi->interleave * cfi->device_type;
+	int   count=len;
+	struct flchip *chip;
+	int chip_num,offst;
+	unsigned long timeo;
+	DECLARE_WAITQUEUE(wait, current);
+
+	chip=0;
+	/* Calculate which chip & protection register offset we need */
+	chip_num=((unsigned int)from/reg_sz);
+	offst=from-(reg_sz*chip_num)+base_offst;
+
+	while(count){
+		
+		if(chip_num>=cfi->numchips)
+			goto out;
+
+		/* Make sure that the chip is in the right state */
+
+		timeo = jiffies + HZ;
+		chip=&cfi->chips[chip_num];
+	retry:		
+		spin_lock_bh(chip->mutex);
+	
+		switch (chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			break;
+		
+		default:
+				/* Stick ourselves on a wait queue to be woken when
+				   someone changes the status */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			timeo = jiffies + HZ;
+			goto retry;
+		}
+			
+		/* Now read the data required from this flash */
+       
+		cfi_send_gen_cmd(0x90, 0x55,chip->start, map, cfi, cfi->device_type, NULL);
+		while(count && ((offst-base_offst)<reg_sz)){
+			*buf=map->read8(map,(chip->start+(extp->ProtRegAddr*ofs_factor)+offst));
+			buf++;
+			offst++;
+			count--;
+		}
+	       
+		chip->state=FL_CFI_QUERY;
+		spin_unlock_bh(chip->mutex);
+		/* Move on to the next chip */
+		chip_num++;
+		offst=base_offst;
+	
+	}
+	
+ out:	
+	wake_up(&chip->wq);
+	return len-count;
+}
+	
+static int cfi_intelext_read_user_prot_reg (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *extp=cfi->cmdset_priv;
+	int base_offst,reg_sz;
+	
+	/* Check that we actually have some protection registers */
+	if(!(extp->FeatureSupport&64)){
+		printk(KERN_WARNING "%s: This flash device has no protection data to read!\n",map->name);
+		return 0;
+	}
+
+	base_offst=(1<<extp->FactProtRegSize);
+	reg_sz=(1<<extp->UserProtRegSize);
+
+	return cfi_intelext_read_prot_reg(mtd, from, len, retlen, buf, base_offst, reg_sz);
+}
+
+static int cfi_intelext_read_fact_prot_reg (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *extp=cfi->cmdset_priv;
+	int base_offst,reg_sz;
+	
+	/* Check that we actually have some protection registers */
+	if(!(extp->FeatureSupport&64)){
+		printk(KERN_WARNING "%s: This flash device has no protection data to read!\n",map->name);
+		return 0;
+	}
+
+	base_offst=0;
+	reg_sz=(1<<extp->FactProtRegSize);
+
+	return cfi_intelext_read_prot_reg(mtd, from, len, retlen, buf, base_offst, reg_sz);
+}
+
+
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
+	DECLARE_WAITQUEUE(wait, current);
+	int z;
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+ retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us.
+	 * Later, we can actually think about interrupting it
+	 * if it's in FL_ERASING state.
+	 * Not just yet, though.
+	 */
+	switch (chip->state) {
+	case FL_READY:
+		break;
+		
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in read\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x40), adr);
+	cfi_write(map, datum, adr);
+	chip->state = FL_WRITING;
+
+	spin_unlock_bh(chip->mutex);
+	cfi_udelay(chip->word_write_time);
+	spin_lock_bh(chip->mutex);
+
+	timeo = jiffies + (HZ/2);
+	z = 0;
+	for (;;) {
+		if (chip->state != FL_WRITING) {
+			/* Someone's suspended the write. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			timeo = jiffies + (HZ / 2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in word write\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		z++;
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	if (!z) {
+		chip->word_write_time--;
+		if (!chip->word_write_time)
+			chip->word_write_time++;
+	}
+	if (z > 1) 
+		chip->word_write_time++;
+
+	/* Done and happy. */
+	DISABLE_VPP(map);
+	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+
+
+static int cfi_intelext_write_words (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
+
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int gap = ofs - bus_ofs;
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (gap--)
+			tmp_buf[i++] = 0xff;
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       bus_ofs, datum);
+		if (ret) 
+			return ret;
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+	
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				ofs, datum);
+		if (ret)
+			return ret;
+
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       ofs, datum);
+		if (ret) 
+			return ret;
+		
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+
+static inline int do_write_buffer(struct map_info *map, struct flchip *chip, 
+				  unsigned long adr, const u_char *buf, int len)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long cmd_adr, timeo;
+	DECLARE_WAITQUEUE(wait, current);
+	int wbufsize, z;
+
+	wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
+	adr += chip->start;
+	cmd_adr = adr & ~(wbufsize-1);
+	
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+ retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us.
+	 * Later, we can actually think about interrupting it
+	 * if it's in FL_ERASING state.
+	 * Not just yet, though.
+	 */
+	switch (chip->state) {
+	case FL_READY:
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+		cfi_write(map, CMD(0x70), cmd_adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in buffer write\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+	/* We know we're now in FL_STATUS mode, and 'status' is current */
+	/* 4.8 of the 28FxxxJ3A datasheet says "Any time SR.4 and/or SR.5 is set
+	   [...], the device will not accept any more Write to Buffer commands". 
+	   So we must check here and reset those bits if they're set. Otherwise
+	   we're just pissing in the wind */
+	if (status & CMD(0x30)) {
+		printk(KERN_WARNING "SR.4 or SR.5 bits set in buffer write (status %x). Clearing.\n", status);
+		cfi_write(map, CMD(0x50), cmd_adr);
+		cfi_write(map, CMD(0x70), cmd_adr);
+	}
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0xe8), cmd_adr);
+	chip->state = FL_WRITING_TO_BUFFER;
+
+	z = 0;
+	for (;;) {
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+
+		if (++z > 20) {
+			/* Argh. Not ready for write to buffer */
+			cfi_write(map, CMD(0x70), cmd_adr);
+			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
+			printk(KERN_ERR "Chip not ready for buffer write. Xstatus = %x, status = %x\n", status, cfi_read(map, cmd_adr));
+			/* Odd. Clear status bits */
+			cfi_write(map, CMD(0x50), cmd_adr);
+			cfi_write(map, CMD(0x70), cmd_adr);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+	}
+
+	/* Write length of data to come */
+	cfi_write(map, CMD(len/CFIDEV_BUSWIDTH-1), cmd_adr );
+
+	/* Write data */
+	for (z = 0; z < len; z += CFIDEV_BUSWIDTH) {
+		if (cfi_buswidth_is_1()) {
+			map->write8 (map, *((__u8*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_2()) {
+			map->write16 (map, *((__u16*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_4()) {
+			map->write32 (map, *((__u32*)buf)++, adr+z);
+		} else {
+			DISABLE_VPP(map);
+			return -EINVAL;
+		}
+	}
+	/* GO GO GO */
+	cfi_write(map, CMD(0xd0), cmd_adr);
+	chip->state = FL_WRITING;
+
+	spin_unlock_bh(chip->mutex);
+	cfi_udelay(chip->buffer_write_time);
+	spin_lock_bh(chip->mutex);
+
+	timeo = jiffies + (HZ/2);
+	z = 0;
+	for (;;) {
+		if (chip->state != FL_WRITING) {
+			/* Someone's suspended the write. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			timeo = jiffies + (HZ / 2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in bufwrite\n");
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		z++;
+		spin_lock_bh(chip->mutex);
+	}
+	if (!z) {
+		chip->buffer_write_time--;
+		if (!chip->buffer_write_time)
+			chip->buffer_write_time++;
+	}
+	if (z > 1) 
+		chip->buffer_write_time++;
+
+	/* Done and happy. */
+	DISABLE_VPP(map);
+	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), cmd_adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+
+static int cfi_intelext_write_buffers (struct mtd_info *mtd, loff_t to, 
+				       size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
+
+	/* If it's not bus-aligned, do the first word write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		size_t local_len = (-ofs)&(CFIDEV_BUSWIDTH-1);
+		if (local_len > len)
+			local_len = len;
+		ret = cfi_intelext_write_words(mtd, to, local_len,
+					       retlen, buf);
+		if (ret)
+			return ret;
+		ofs += local_len;
+		buf += local_len;
+		len -= local_len;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* Write buffer is worth it only if more than one word to write... */
+	while(len > CFIDEV_BUSWIDTH) {
+		/* We must not cross write block boundaries */
+		int size = wbufsize - (ofs & (wbufsize-1));
+
+		if (size > len)
+			size = len & ~(CFIDEV_BUSWIDTH-1);
+		ret = do_write_buffer(map, &cfi->chips[chipnum], 
+				      ofs, buf, size);
+		if (ret)
+			return ret;
+
+		ofs += size;
+		buf += size;
+		(*retlen) += size;
+		len -= size;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* ... and write the remaining bytes */
+	if (len > 0) {
+		size_t local_retlen;
+		ret = cfi_intelext_write_words(mtd, ofs + (chipnum << cfi->chipshift),
+					       len, &local_retlen, buf);
+		if (ret)
+			return ret;
+		(*retlen) += local_retlen;
+	}
+
+	return 0;
+}
+
+
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
+	int retries = 3;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in erase\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	/* Clear the status register first */
+	cfi_write(map, CMD(0x50), adr);
+
+	/* Now erase */
+	cfi_write(map, CMD(0x20), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_ERASING;
+	chip->oldstate = 0;
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*20);
+	for (;;) {
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+		if (chip->oldstate) {
+			/* This erase was suspended and resumed.
+			   Adjust the timeout */
+			timeo = jiffies + (HZ*20); /* FIXME */
+			chip->oldstate = 0;
+		}
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk(KERN_ERR "waiting for erase at %08x to complete timed out. Xstatus = %x, status = %x.\n", adr, status, cfi_read(map, adr));
+			/* Clear status bits */
+			cfi_write(map, CMD(0x50), adr);
+			cfi_write(map, CMD(0x70), adr);
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	DISABLE_VPP(map);
+	ret = 0;
+
+	/* We've broken this before. It doesn't hurt to be safe */
+	cfi_write(map, CMD(0x70), adr);
+	chip->state = FL_STATUS;
+	status = cfi_read(map, adr);
+
+	/* check for lock bit */
+	if (status & CMD(0x3a)) {
+		unsigned char chipstatus = status;
+		if (status != CMD(status & 0xff)) {
+			int i;
+			for (i = 1; i<CFIDEV_INTERLEAVE; i++) {
+				      chipstatus |= status >> (cfi->device_type * 8);
+			}
+			printk(KERN_WARNING "Status is not identical for all chips: 0x%x. Merging to give 0x%02x\n", status, chipstatus);
+		}
+		/* Reset the error bits */
+		cfi_write(map, CMD(0x50), adr);
+		cfi_write(map, CMD(0x70), adr);
+		
+		if ((chipstatus & 0x30) == 0x30) {
+			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x02) {
+			/* Protection bit set */
+			ret = -EROFS;
+		} else if (chipstatus & 0x8) {
+			/* Voltage */
+			printk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x20) {
+			if (retries--) {
+				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, status);
+				timeo = jiffies + HZ;
+				chip->state = FL_STATUS;
+				spin_unlock_bh(chip->mutex);
+				goto retry;
+			}
+			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, status);
+			ret = -EIO;
+		}
+	}
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return ret;
+}
+
+int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+{	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+		
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+		
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static void cfi_intelext_sync (struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i=0; !ret && i<cfi->numchips; i++) {
+		chip = &cfi->chips[i];
+
+	retry:
+		spin_lock_bh(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_SYNCING:
+			spin_unlock_bh(chip->mutex);
+			break;
+
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+			schedule();
+		        remove_wait_queue(&chip->wq, &wait);
+			
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+
+	for (i--; i >=0; i--) {
+		chip = &cfi->chips[i];
+
+		spin_lock_bh(chip->mutex);
+		
+		if (chip->state == FL_SYNCING) {
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+static inline int do_lock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK) 
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in lock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0x01), adr);
+	chip->state = FL_LOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk(KERN_ERR "waiting for lock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	if (ofs & (mtd->erasesize - 1))
+		return -EINVAL;
+
+	if (len & (mtd->erasesize -1))
+		return -EINVAL;
+
+	if ((len + ofs) > mtd->size)
+		return -EINVAL;
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+	while(len) {
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
+		printk("before lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
+#endif
+
+		ret = do_lock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
+		printk("after lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
+#endif	
+		
+		if (ret)
+			return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+	return 0;
+}
+static inline int do_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_ERR "waiting for chip to be ready timed out in unlock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_UNLOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk(KERN_ERR "waiting for unlock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the unlock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+#ifdef DEBUG_LOCK_BITS
+	{
+		unsigned long temp_adr = adr;
+		unsigned long temp_len = len;
+                 
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
+                while (temp_len) {
+			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
+			temp_adr += mtd->erasesize;
+			temp_len -= mtd->erasesize;
+		}
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
+	}
+#endif
+
+	ret = do_unlock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+	cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
+	printk("after unlock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+	cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
+#endif
+	
+	return ret;
+}
+
+static int cfi_intelext_suspend(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+
+	for (i=0; !ret && i<cfi->numchips; i++) {
+		chip = &cfi->chips[i];
+
+		spin_lock_bh(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_PM_SUSPENDED;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_PM_SUSPENDED:
+			break;
+
+		default:
+			ret = -EAGAIN;
+			break;
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+
+	/* Unlock the chips again */
+
+	if (ret) {
+		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
+			
+			spin_lock_bh(chip->mutex);
+			
+			if (chip->state == FL_PM_SUSPENDED) {
+				/* No need to force it into a known state here,
+				   because we're returning failure, and it didn't
+				   get power cycled */
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			spin_unlock_bh(chip->mutex);
+		}
+	} 
+	
+	return ret;
+}
+
+static void cfi_intelext_resume(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+
+	for (i=0; i<cfi->numchips; i++) {
+	
+		chip = &cfi->chips[i];
+
+		spin_lock_bh(chip->mutex);
+		
+		/* Go to known state. Chip may have been power cycled */
+		if (chip->state == FL_PM_SUSPENDED) {
+			cfi_write(map, CMD(0xFF), 0);
+			chip->state = FL_READY;
+			wake_up(&chip->wq);
+		}
+
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+static void cfi_intelext_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	kfree(cfi->cmdset_priv);
+	kfree(cfi);
+}
+
+static char im_name_1[]="cfi_cmdset_0001";
+static char im_name_3[]="cfi_cmdset_0003";
+
+int __init cfi_intelext_init(void)
+{
+	inter_module_register(im_name_1, THIS_MODULE, &cfi_cmdset_0001);
+	inter_module_register(im_name_3, THIS_MODULE, &cfi_cmdset_0001);
+	return 0;
+}
+
+static void __exit cfi_intelext_exit(void)
+{
+	inter_module_unregister(im_name_1);
+	inter_module_unregister(im_name_3);
+}
+
+module_init(cfi_intelext_init);
+module_exit(cfi_intelext_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
+MODULE_DESCRIPTION("MTD chip driver for Intel/Sharp flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.4.2/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.4.2.orig/drivers/mtd/chips/cfi_cmdset_0002.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/cfi_cmdset_0002.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1133 @@
+/*
+ * Common Flash Interface support:
+ *   AMD & Fujitsu Standard Vendor Command Set (ID 0x0002)
+ *
+ * Copyright (C) 2000 Crossnet Co. <info@crossnet.co.jp>
+ *
+ * 2_by_8 routines added by Simon Munton
+ *
+ * This code is GPL
+ *
+ * $Id: cfi_cmdset_0002.c,v 1.54 2002/01/10 20:27:40 eric Exp $
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+
+#define AMD_BOOTLOC_BUG
+
+static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_amdstd_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
+static int cfi_amdstd_erase_onesize(struct mtd_info *, struct erase_info *);
+static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
+static void cfi_amdstd_sync (struct mtd_info *);
+static int cfi_amdstd_suspend (struct mtd_info *);
+static void cfi_amdstd_resume (struct mtd_info *);
+
+static void cfi_amdstd_destroy(struct mtd_info *);
+
+struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
+static struct mtd_info *cfi_amdstd_setup (struct map_info *);
+
+
+static struct mtd_chip_driver cfi_amdstd_chipdrv = {
+	probe: NULL, /* Not usable directly */
+	destroy: cfi_amdstd_destroy,
+	name: "cfi_cmdset_0002",
+	module: THIS_MODULE
+};
+
+struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned char bootloc;
+	int ofs_factor = cfi->interleave * cfi->device_type;
+	int i;
+	__u8 major, minor;
+	__u32 base = cfi->chips[0].start;
+
+	if (cfi->cfi_mode==CFI_MODE_CFI){
+		__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
+
+		cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+		
+		major = cfi_read_query(map, base + (adr+3)*ofs_factor);
+		minor = cfi_read_query(map, base + (adr+4)*ofs_factor);
+		
+		printk(KERN_NOTICE " Amd/Fujitsu Extended Query Table v%c.%c at 0x%4.4X\n",
+		       major, minor, adr);
+				cfi_send_gen_cmd(0xf0, 0x55, base, map, cfi, cfi->device_type, NULL);
+		
+		cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x90, 0x555, base, map, cfi, cfi->device_type, NULL);
+		cfi->mfr = cfi_read_query(map, base);
+		cfi->id = cfi_read_query(map, base + ofs_factor);
+
+		/* Wheee. Bring me the head of someone at AMD. */
+#ifdef AMD_BOOTLOC_BUG
+		if (((major << 8) | minor) < 0x3131) {
+			/* CFI version 1.0 => don't trust bootloc */
+			if (cfi->id & 0x80) {
+				printk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);
+				bootloc = 3;	/* top boot */
+			} else {
+				bootloc = 2;	/* bottom boot */
+			}
+		} else
+#endif
+			{
+				cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+				bootloc = cfi_read_query(map, base + (adr+15)*ofs_factor);
+			}
+		if (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {
+			printk(KERN_WARNING "%s: Swapping erase regions for broken CFI table.\n", map->name);
+			
+			for (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {
+				int j = (cfi->cfiq->NumEraseRegions-1)-i;
+				__u32 swap;
+				
+				swap = cfi->cfiq->EraseRegionInfo[i];
+				cfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];
+				cfi->cfiq->EraseRegionInfo[j] = swap;
+			}
+		}
+		switch (cfi->device_type) {
+		case CFI_DEVICETYPE_X8:
+			cfi->addr_unlock1 = 0x555; 
+			cfi->addr_unlock2 = 0x2aa; 
+			break;
+		case CFI_DEVICETYPE_X16:
+			cfi->addr_unlock1 = 0xaaa;
+			if (map->buswidth == cfi->interleave) {
+				/* X16 chip(s) in X8 mode */
+				cfi->addr_unlock2 = 0x555;
+			} else {
+				cfi->addr_unlock2 = 0x554;
+			}
+			break;
+		case CFI_DEVICETYPE_X32:
+			cfi->addr_unlock1 = 0x1555; 
+			cfi->addr_unlock2 = 0xaaa; 
+			break;
+		default:
+			printk(KERN_NOTICE "Eep. Unknown cfi_cmdset_0002 device type %d\n", cfi->device_type);
+			return NULL;
+		}
+	} /* CFI mode */
+
+	for (i=0; i< cfi->numchips; i++) {
+		cfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;
+		cfi->chips[i].buffer_write_time = 1<<cfi->cfiq->BufWriteTimeoutTyp;
+		cfi->chips[i].erase_time = 1<<cfi->cfiq->BlockEraseTimeoutTyp;
+	}		
+	
+	map->fldrv = &cfi_amdstd_chipdrv;
+	MOD_INC_USE_COUNT;
+
+	cfi_send_gen_cmd(0xf0, 0x55, base, map, cfi, cfi->device_type, NULL);
+	return cfi_amdstd_setup(map);
+}
+
+static struct mtd_info *cfi_amdstd_setup(struct map_info *map)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct mtd_info *mtd;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	printk(KERN_NOTICE "number of %s chips: %d\n", 
+		(cfi->cfi_mode == CFI_MODE_CFI)?"CFI":"JEDEC",cfi->numchips);
+
+	if (!mtd) {
+	  printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
+	  kfree(cfi->cmdset_priv);
+	  return NULL;
+	}
+
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	/* Also select the correct geometry setup too */ 
+	mtd->size = devsize * cfi->numchips;
+	
+	if (cfi->cfiq->NumEraseRegions == 1) {
+		/* No need to muck about with multiple erase sizes */
+		mtd->erasesize = ((cfi->cfiq->EraseRegionInfo[0] >> 8) & ~0xff) * cfi->interleave;
+	} else {
+		unsigned long offset = 0;
+		int i,j;
+
+		mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+		mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) * mtd->numeraseregions, GFP_KERNEL);
+		if (!mtd->eraseregions) { 
+			printk(KERN_WARNING "Failed to allocate memory for MTD erase region info\n");
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+			
+		for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+			unsigned long ernum, ersize;
+			ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+			ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+			
+			if (mtd->erasesize < ersize) {
+				mtd->erasesize = ersize;
+			}
+			for (j=0; j<cfi->numchips; j++) {
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+			}
+			offset += (ersize * ernum);
+		}
+		if (offset != devsize) {
+			/* Argh */
+			printk(KERN_WARNING "Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+#if 0
+		// debug
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk("%d: offset=0x%x,size=0x%x,blocks=%d\n",
+			       i,mtd->eraseregions[i].offset,
+			       mtd->eraseregions[i].erasesize,
+			       mtd->eraseregions[i].numblocks);
+		}
+#endif
+	}
+
+	switch (CFIDEV_BUSWIDTH)
+	{
+	case 1:
+	case 2:
+	case 4:
+#if 1
+		if (mtd->numeraseregions > 1)
+			mtd->erase = cfi_amdstd_erase_varsize;
+		else
+#endif
+		if (((cfi->cfiq->EraseRegionInfo[0] & 0xffff) + 1) == 1)
+			mtd->erase = cfi_amdstd_erase_chip;
+		else
+			mtd->erase = cfi_amdstd_erase_onesize;
+		mtd->read = cfi_amdstd_read;
+		mtd->write = cfi_amdstd_write;
+		break;
+
+	default:
+	        printk(KERN_WARNING "Unsupported buswidth\n");
+		kfree(mtd);
+		kfree(cfi->cmdset_priv);
+		return NULL;
+		break;
+	}
+	mtd->sync = cfi_amdstd_sync;
+	mtd->suspend = cfi_amdstd_suspend;
+	mtd->resume = cfi_amdstd_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	map->fldrv = &cfi_amdstd_chipdrv;
+	mtd->name = map->name;
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = jiffies + HZ;
+
+ retry:
+	cfi_spin_lock(chip->mutex);
+
+	if (chip->state != FL_READY){
+#if 0
+	        printk(KERN_DEBUG "Waiting for chip to read, status = %d\n", chip->state);
+#endif
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		cfi_spin_unlock(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+#if 0
+		if(signal_pending(current))
+			return -EINTR;
+#endif
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	adr += chip->start;
+
+	chip->state = FL_READY;
+
+	map->copy_from(map, buf, adr, len);
+
+	wake_up(&chip->wq);
+	cfi_spin_unlock(chip->mutex);
+
+	return 0;
+}
+
+static int cfi_amdstd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long ofs;
+	int chipnum;
+	int ret = 0;
+
+	/* ofs: offset within the first chip that the first read should start */
+
+	chipnum = (from >> cfi->chipshift);
+	ofs = from - (chipnum <<  cfi->chipshift);
+
+
+	*retlen = 0;
+
+	while (len) {
+		unsigned long thislen;
+
+		if (chipnum >= cfi->numchips)
+			break;
+
+		if ((len + ofs -1) >> cfi->chipshift)
+			thislen = (1<<cfi->chipshift) - ofs;
+		else
+			thislen = len;
+
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		if (ret)
+			break;
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum, int fast)
+{
+	unsigned long timeo = jiffies + HZ;
+	unsigned int Last[4];
+	unsigned long Count = 0;
+	struct cfi_private *cfi = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+ retry:
+	cfi_spin_lock(chip->mutex);
+
+	if (chip->state != FL_READY){
+#if 0
+	        printk(KERN_DEBUG "Waiting for chip to write, status = %d\n", chip->state);
+#endif
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		cfi_spin_unlock(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+#if 0
+		printk(KERN_DEBUG "Wake up to write:\n");
+		if(signal_pending(current))
+			return -EINTR;
+#endif
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_WRITING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	if (fast) { /* Unlock bypass */
+		cfi_send_gen_cmd(0xA0, 0, chip->start, map, cfi, cfi->device_type, NULL);
+	}
+	else {
+	        cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	        cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	        cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	}
+
+	cfi_write(map, datum, adr);
+
+	cfi_spin_unlock(chip->mutex);
+	cfi_udelay(chip->word_write_time);
+	cfi_spin_lock(chip->mutex);
+
+	Last[0] = cfi_read(map, adr);
+	//	printk("Last[0] is %x\n", Last[0]);
+	Last[1] = cfi_read(map, adr);
+	//	printk("Last[1] is %x\n", Last[1]);
+	Last[2] = cfi_read(map, adr);
+	//	printk("Last[2] is %x\n", Last[2]);
+
+	for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] && Count < 10000; Count++){
+		cfi_spin_unlock(chip->mutex);
+		cfi_udelay(10);
+		cfi_spin_lock(chip->mutex);
+		
+	        Last[Count % 4] = cfi_read(map, adr);
+		//		printk("Last[%d%%4] is %x\n", Count, Last[Count%4]);
+	}
+	
+	if (Last[(Count - 1) % 4] != datum){
+		printk(KERN_WARNING "Last[%ld] is %x, datum is %x\n",(Count - 1) % 4,Last[(Count - 1) % 4],datum);
+	        cfi_send_gen_cmd(0xF0, 0, chip->start, map, cfi, cfi->device_type, NULL);
+		DISABLE_VPP(map);
+		ret = -EIO;
+	}       
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	cfi_spin_unlock(chip->mutex);
+	
+	return ret;
+}
+
+static int cfi_amdstd_write (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs, chipstart;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
+	chipstart = cfi->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, bus_ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				bus_ofs, datum, 0);
+		if (ret) 
+			return ret;
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+	
+	if (cfi->fast_prog) {
+		/* Go into unlock bypass mode */
+		cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+		cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	}
+
+	/* We are now aligned, write as much as possible */
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				       ofs, datum, cfi->fast_prog);
+		if (ret) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi, cfi->device_type, NULL);
+			}
+			return ret;
+		}
+
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
+
+		if (ofs >> cfi->chipshift) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi, cfi->device_type, NULL);
+			}
+
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+			chipstart = cfi->chips[chipnum].start;
+			if (cfi->fast_prog){
+				/* Go into unlock bypass mode for next set of chips */
+				cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+				cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+				cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi, CFI_DEVICETYPE_X8, NULL);
+			}
+		}
+	}
+
+	if (cfi->fast_prog){
+		/* Get out of unlock bypass mode */
+		cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi, cfi->device_type, NULL);
+	}
+
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				ofs, datum, 0);
+		if (ret) 
+			return ret;
+		
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+static inline int do_erase_chip(struct map_info *map, struct flchip *chip)
+{
+	unsigned int oldstatus, status;
+	unsigned int dq6, dq5;
+	unsigned long timeo = jiffies + HZ;
+	unsigned int adr;
+	struct cfi_private *cfi = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+ retry:
+	cfi_spin_lock(chip->mutex);
+
+	if (chip->state != FL_READY){
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		cfi_spin_unlock(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+#if 0
+		if(signal_pending(current))
+			return -EINTR;
+#endif
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_ERASING;
+	
+	/* Handle devices with one erase region, that only implement
+	 * the chip erase command.
+	 */
+	ENABLE_VPP(map);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	timeo = jiffies + (HZ*20);
+	adr = cfi->addr_unlock1;
+
+	/* Wait for the end of programing/erasure by using the toggle method.
+	 * As long as there is a programming procedure going on, bit 6 of the last
+	 * written byte is toggling it's state with each consectuve read.
+	 * The toggling stops as soon as the procedure is completed.
+	 *
+	 * If the process has gone on for too long on the chip bit 5 gets.
+	 * After bit5 is set you can kill the operation by sending a reset
+	 * command to the chip.
+	 */
+	dq6 = CMD(1<<6);
+	dq5 = CMD(1<<5);
+
+	oldstatus = cfi_read(map, adr);
+	status = cfi_read(map, adr);
+	while( ((status & dq6) != (oldstatus & dq6)) && 
+		((status & dq5) != dq5) &&
+		!time_after(jiffies, timeo)) {
+		int wait_reps;
+
+		/* an initial short sleep */
+		cfi_spin_unlock(chip->mutex);
+		schedule_timeout(HZ/100);
+		cfi_spin_lock(chip->mutex);
+		
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			
+			cfi_spin_unlock(chip->mutex);
+			printk("erase suspended. Sleeping\n");
+			
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+#if 0			
+			if (signal_pending(current))
+				return -EINTR;
+#endif			
+			timeo = jiffies + (HZ*2); /* FIXME */
+			cfi_spin_lock(chip->mutex);
+			continue;
+		}
+
+		/* Busy wait for 1/10 of a milisecond */
+		for(wait_reps = 0;
+		    	(wait_reps < 100) &&
+			((status & dq6) != (oldstatus & dq6)) && 
+			((status & dq5) != dq5);
+			wait_reps++) {
+			
+			/* Latency issues. Drop the lock, wait a while and retry */
+			cfi_spin_unlock(chip->mutex);
+			
+			cfi_udelay(1);
+		
+			cfi_spin_lock(chip->mutex);
+			oldstatus = cfi_read(map, adr);
+			status = cfi_read(map, adr);
+		}
+		oldstatus = cfi_read(map, adr);
+		status = cfi_read(map, adr);
+	}
+	if ((status & dq6) != (oldstatus & dq6)) {
+		/* The erasing didn't stop?? */
+		if ((status & dq5) == dq5) {
+			/* dq5 is active so we can do a reset and stop the erase */
+			cfi_write(map, CMD(0xF0), chip->start);
+		}
+		chip->state = FL_READY;
+		wake_up(&chip->wq);
+		cfi_spin_unlock(chip->mutex);
+		printk("waiting for erase to complete timed out.");
+		DISABLE_VPP(map);
+		return -EIO;
+	}
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	cfi_spin_unlock(chip->mutex);
+	return 0;
+	
+}
+
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	unsigned int oldstatus, status;
+	unsigned int dq6, dq5;
+	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+ retry:
+	cfi_spin_lock(chip->mutex);
+
+	if (chip->state != FL_READY){
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		cfi_spin_unlock(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+#if 0
+		if(signal_pending(current))
+			return -EINTR;
+#endif
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_ERASING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_write(map, CMD(0x30), adr);
+	
+	timeo = jiffies + (HZ*20);
+
+	/* Wait for the end of programing/erasure by using the toggle method.
+	 * As long as there is a programming procedure going on, bit 6 of the last
+	 * written byte is toggling it's state with each consectuve read.
+	 * The toggling stops as soon as the procedure is completed.
+	 *
+	 * If the process has gone on for too long on the chip bit 5 gets.
+	 * After bit5 is set you can kill the operation by sending a reset
+	 * command to the chip.
+	 */
+	dq6 = CMD(1<<6);
+	dq5 = CMD(1<<5);
+
+	oldstatus = cfi_read(map, adr);
+	status = cfi_read(map, adr);
+	while( ((status & dq6) != (oldstatus & dq6)) && 
+		((status & dq5) != dq5) &&
+		!time_after(jiffies, timeo)) {
+		int wait_reps;
+
+		/* an initial short sleep */
+		cfi_spin_unlock(chip->mutex);
+		schedule_timeout(HZ/100);
+		cfi_spin_lock(chip->mutex);
+		
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			
+			cfi_spin_unlock(chip->mutex);
+			printk(KERN_DEBUG "erase suspended. Sleeping\n");
+			
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+#if 0			
+			if (signal_pending(current))
+				return -EINTR;
+#endif			
+			timeo = jiffies + (HZ*2); /* FIXME */
+			cfi_spin_lock(chip->mutex);
+			continue;
+		}
+
+		/* Busy wait for 1/10 of a milisecond */
+		for(wait_reps = 0;
+		    	(wait_reps < 100) &&
+			((status & dq6) != (oldstatus & dq6)) && 
+			((status & dq5) != dq5);
+			wait_reps++) {
+			
+			/* Latency issues. Drop the lock, wait a while and retry */
+			cfi_spin_unlock(chip->mutex);
+			
+			cfi_udelay(1);
+		
+			cfi_spin_lock(chip->mutex);
+			oldstatus = cfi_read(map, adr);
+			status = cfi_read(map, adr);
+		}
+		oldstatus = cfi_read(map, adr);
+		status = cfi_read(map, adr);
+	}
+	if ((status & dq6) != (oldstatus & dq6)) {
+		/* The erasing didn't stop?? */
+		if ((status & dq5) == dq5) {
+			/* dq5 is active so we can do a reset and stop the erase */
+			cfi_write(map, CMD(0xF0), chip->start);
+		}
+		chip->state = FL_READY;
+		wake_up(&chip->wq);
+		cfi_spin_unlock(chip->mutex);
+		printk("waiting for erase to complete timed out.");
+		DISABLE_VPP(map);
+		return -EIO;
+	}
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	cfi_spin_unlock(chip->mutex);
+	return 0;
+}
+
+static int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+	
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static int cfi_amdstd_erase_onesize(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
+
+	if (instr->addr & (mtd->erasesize - 1))
+		return -EINVAL;
+
+	if (instr->len & (mtd->erasesize -1))
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+
+		if (ret)
+			return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+		
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static int cfi_amdstd_erase_chip(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int ret = 0;
+
+	if (instr->addr != 0)
+		return -EINVAL;
+
+	if (instr->len != mtd->size)
+		return -EINVAL;
+
+	ret = do_erase_chip(map, &cfi->chips[0]);
+	if (ret)
+		return ret;
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static void cfi_amdstd_sync (struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i=0; !ret && i<cfi->numchips; i++) {
+		chip = &cfi->chips[i];
+
+	retry:
+		cfi_spin_lock(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_SYNCING:
+			cfi_spin_unlock(chip->mutex);
+			break;
+
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+			
+			cfi_spin_unlock(chip->mutex);
+
+			schedule();
+
+		        remove_wait_queue(&chip->wq, &wait);
+			
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+
+	for (i--; i >=0; i--) {
+		chip = &cfi->chips[i];
+
+		cfi_spin_lock(chip->mutex);
+		
+		if (chip->state == FL_SYNCING) {
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		cfi_spin_unlock(chip->mutex);
+	}
+}
+
+
+static int cfi_amdstd_suspend(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+//printk("suspend\n");
+
+	for (i=0; !ret && i<cfi->numchips; i++) {
+		chip = &cfi->chips[i];
+
+		cfi_spin_lock(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_PM_SUSPENDED;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_PM_SUSPENDED:
+			break;
+
+		default:
+			ret = -EAGAIN;
+			break;
+		}
+		cfi_spin_unlock(chip->mutex);
+	}
+
+	/* Unlock the chips again */
+
+	if (ret) {
+    		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
+
+			cfi_spin_lock(chip->mutex);
+		
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			cfi_spin_unlock(chip->mutex);
+		}
+	}
+	
+	return ret;
+}
+
+static void cfi_amdstd_resume(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+//printk("resume\n");
+
+	for (i=0; i<cfi->numchips; i++) {
+	
+		chip = &cfi->chips[i];
+
+		cfi_spin_lock(chip->mutex);
+		
+		if (chip->state == FL_PM_SUSPENDED) {
+			chip->state = FL_READY;
+			cfi_write(map, CMD(0xF0), chip->start);
+			wake_up(&chip->wq);
+		}
+		else
+			printk(KERN_ERR "Argh. Chip not in PM_SUSPENDED state upon resume()\n");
+
+		cfi_spin_unlock(chip->mutex);
+	}
+}
+
+static void cfi_amdstd_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	kfree(cfi->cmdset_priv);
+	kfree(cfi);
+}
+
+static char im_name[]="cfi_cmdset_0002";
+
+int __init cfi_amdstd_init(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0002);
+	return 0;
+}
+
+static void __exit cfi_amdstd_exit(void)
+{
+	inter_module_unregister(im_name);
+}
+
+module_init(cfi_amdstd_init);
+module_exit(cfi_amdstd_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Crossnet Co. <info@crossnet.co.jp> et al.");
+MODULE_DESCRIPTION("MTD chip driver for AMD/Fujitsu flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/cfi_probe.c linux-2.4.2/drivers/mtd/chips/cfi_probe.c
--- linux-2.4.2.orig/drivers/mtd/chips/cfi_probe.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/cfi_probe.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,341 @@
+/* 
+   Common Flash Interface probe code.
+   (C) 2000 Red Hat. GPL'd.
+   $Id: cfi_probe.c,v 1.67 2002/01/10 20:27:40 eric Exp $
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/gen_probe.h>
+
+//#define DEBUG_CFI 
+
+#ifdef DEBUG_CFI
+static void print_cfi_ident(struct cfi_ident *);
+#endif
+
+static int cfi_probe_chip(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi);
+static int cfi_chip_setup(struct map_info *map, struct cfi_private *cfi);
+
+struct mtd_info *cfi_probe(struct map_info *map);
+
+/* check for QRY.
+   in: interleave,type,mode
+   ret: table index, <0 for error
+ */
+static inline int qry_present(struct map_info *map, __u32 base,
+				struct cfi_private *cfi)
+{
+	int osf = cfi->interleave * cfi->device_type;	// scale factor
+
+	if (cfi_read(map,base+osf*0x10)==cfi_build_cmd('Q',map,cfi) &&
+	    cfi_read(map,base+osf*0x11)==cfi_build_cmd('R',map,cfi) &&
+	    cfi_read(map,base+osf*0x12)==cfi_build_cmd('Y',map,cfi))
+		return 1;	// ok !
+
+	return 0; 	// nothing found
+}
+
+static int cfi_probe_chip(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi)
+{
+	int i;
+	
+	if ((base + 0) >= map->size) {
+		printk(KERN_NOTICE
+			"Probe at base[0x00](0x%08lx) past the end of the map(0x%08lx)\n",
+			base, map->size -1);
+		return 0;
+	}
+	if ((base + 0xff) >= map->size) {
+		printk(KERN_NOTICE
+			"Probe at base[0x55](0x%08lx) past the end of the map(0x%08lx)\n",
+			base + 0x55, map->size -1);
+		return 0;
+	}
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+
+	if (!qry_present(map,base,cfi))
+		return 0;
+
+	if (!cfi->numchips) {
+		/* This is the first time we're called. Set up the CFI 
+		   stuff accordingly and return */
+		return cfi_chip_setup(map, cfi);
+	}
+
+	/* Check each previous chip to see if it's an alias */
+	for (i=0; i<cfi->numchips; i++) {
+		/* This chip should be in read mode if it's one
+		   we've already touched. */
+		if (qry_present(map,chips[i].start,cfi)) {
+			/* Eep. This chip also had the QRY marker. 
+			 * Is it an alias for the new one? */
+			cfi_send_gen_cmd(0xF0, 0, chips[i].start, map, cfi, cfi->device_type, NULL);
+
+			/* If the QRY marker goes away, it's an alias */
+			if (!qry_present(map, chips[i].start, cfi)) {
+				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+				       map->name, base, chips[i].start);
+				return 0;
+			}
+			/* Yes, it's actually got QRY for data. Most 
+			 * unfortunate. Stick the new chip in read mode
+			 * too and if it's the same, assume it's an alias. */
+			/* FIXME: Use other modes to do a proper check */
+			cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+			
+			if (qry_present(map, base, cfi)) {
+				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+				       map->name, base, chips[i].start);
+				return 0;
+			}
+		}
+	}
+	
+	/* OK, if we got to here, then none of the previous chips appear to
+	   be aliases for the current one. */
+	if (cfi->numchips == MAX_CFI_CHIPS) {
+		printk(KERN_WARNING"%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
+		/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
+		return -1;
+	}
+	chips[cfi->numchips].start = base;
+	chips[cfi->numchips].state = FL_READY;
+	cfi->numchips++;
+	
+	/* Put it back into Read Mode */
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+
+	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit mode\n",
+	       map->name, cfi->interleave, cfi->device_type*8, base,
+	       map->buswidth*8);
+	
+	return 1;
+}
+
+static int cfi_chip_setup(struct map_info *map, 
+		   struct cfi_private *cfi)
+{
+	int ofs_factor = cfi->interleave*cfi->device_type;
+	__u32 base = 0;
+	int num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);
+	int i;
+
+#ifdef DEBUG_CFI
+	printk("Number of erase regions: %d\n", num_erase_regions);
+#endif
+	if (!num_erase_regions)
+		return 0;
+
+	cfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+	if (!cfi->cfiq) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+		return 0;
+	}
+	
+	memset(cfi->cfiq,0,sizeof(struct cfi_ident));	
+	
+	cfi->cfi_mode = CFI_MODE_CFI;
+	cfi->fast_prog=1;		/* CFI supports fast programming */
+	
+	/* Read the CFI info structure */
+	for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++) {
+		((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);
+	}
+	
+	/* Do any necessary byteswapping */
+	cfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);
+	
+	cfi->cfiq->P_ADR = le16_to_cpu(cfi->cfiq->P_ADR);
+	cfi->cfiq->A_ID = le16_to_cpu(cfi->cfiq->A_ID);
+	cfi->cfiq->A_ADR = le16_to_cpu(cfi->cfiq->A_ADR);
+	cfi->cfiq->InterfaceDesc = le16_to_cpu(cfi->cfiq->InterfaceDesc);
+	cfi->cfiq->MaxBufWriteSize = le16_to_cpu(cfi->cfiq->MaxBufWriteSize);
+
+#ifdef DEBUG_CFI
+	/* Dump the information therein */
+	print_cfi_ident(cfi->cfiq);
+#endif
+
+	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+		cfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);
+		
+#ifdef DEBUG_CFI		
+		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
+		       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff, 
+		       (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1);
+#endif
+	}
+	/* Put it back into Read Mode */
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+
+	return 1;
+}
+
+#ifdef DEBUG_CFI
+static char *vendorname(__u16 vendor) 
+{
+	switch (vendor) {
+	case P_ID_NONE:
+		return "None";
+		
+	case P_ID_INTEL_EXT:
+		return "Intel/Sharp Extended";
+		
+	case P_ID_AMD_STD:
+		return "AMD/Fujitsu Standard";
+		
+	case P_ID_INTEL_STD:
+		return "Intel/Sharp Standard";
+		
+	case P_ID_AMD_EXT:
+		return "AMD/Fujitsu Extended";
+		
+	case P_ID_MITSUBISHI_STD:
+		return "Mitsubishi Standard";
+		
+	case P_ID_MITSUBISHI_EXT:
+		return "Mitsubishi Extended";
+		
+	case P_ID_RESERVED:
+		return "Not Allowed / Reserved for Future Use";
+		
+	default:
+		return "Unknown";
+	}
+}
+
+
+static void print_cfi_ident(struct cfi_ident *cfip)
+{
+#if 0
+	if (cfip->qry[0] != 'Q' || cfip->qry[1] != 'R' || cfip->qry[2] != 'Y') {
+		printk("Invalid CFI ident structure.\n");
+		return;
+	}	
+#endif		
+	printk("Primary Vendor Command Set: %4.4X (%s)\n", cfip->P_ID, vendorname(cfip->P_ID));
+	if (cfip->P_ADR)
+		printk("Primary Algorithm Table at %4.4X\n", cfip->P_ADR);
+	else
+		printk("No Primary Algorithm Table\n");
+	
+	printk("Alternative Vendor Command Set: %4.4X (%s)\n", cfip->A_ID, vendorname(cfip->A_ID));
+	if (cfip->A_ADR)
+		printk("Alternate Algorithm Table at %4.4X\n", cfip->A_ADR);
+	else
+		printk("No Alternate Algorithm Table\n");
+		
+		
+	printk("Vcc Minimum: %x.%x V\n", cfip->VccMin >> 4, cfip->VccMin & 0xf);
+	printk("Vcc Maximum: %x.%x V\n", cfip->VccMax >> 4, cfip->VccMax & 0xf);
+	if (cfip->VppMin) {
+		printk("Vpp Minimum: %x.%x V\n", cfip->VppMin >> 4, cfip->VppMin & 0xf);
+		printk("Vpp Maximum: %x.%x V\n", cfip->VppMax >> 4, cfip->VppMax & 0xf);
+	}
+	else
+		printk("No Vpp line\n");
+	
+	printk("Typical byte/word write timeout: %d s\n", 1<<cfip->WordWriteTimeoutTyp);
+	printk("Maximum byte/word write timeout: %d s\n", (1<<cfip->WordWriteTimeoutMax) * (1<<cfip->WordWriteTimeoutTyp));
+	
+	if (cfip->BufWriteTimeoutTyp || cfip->BufWriteTimeoutMax) {
+		printk("Typical full buffer write timeout: %d s\n", 1<<cfip->BufWriteTimeoutTyp);
+		printk("Maximum full buffer write timeout: %d s\n", (1<<cfip->BufWriteTimeoutMax) * (1<<cfip->BufWriteTimeoutTyp));
+	}
+	else
+		printk("Full buffer write not supported\n");
+	
+	printk("Typical block erase timeout: %d s\n", 1<<cfip->BlockEraseTimeoutTyp);
+	printk("Maximum block erase timeout: %d s\n", (1<<cfip->BlockEraseTimeoutMax) * (1<<cfip->BlockEraseTimeoutTyp));
+	if (cfip->ChipEraseTimeoutTyp || cfip->ChipEraseTimeoutMax) {
+		printk("Typical chip erase timeout: %d s\n", 1<<cfip->ChipEraseTimeoutTyp); 
+		printk("Maximum chip erase timeout: %d s\n", (1<<cfip->ChipEraseTimeoutMax) * (1<<cfip->ChipEraseTimeoutTyp));
+	}
+	else
+		printk("Chip erase not supported\n");
+	
+	printk("Device size: 0x%X bytes (%d MiB)\n", 1 << cfip->DevSize, 1<< (cfip->DevSize - 20));
+	printk("Flash Device Interface description: 0x%4.4X\n", cfip->InterfaceDesc);
+	switch(cfip->InterfaceDesc) {
+	case 0:
+		printk("  - x8-only asynchronous interface\n");
+		break;
+		
+	case 1:
+		printk("  - x16-only asynchronous interface\n");
+		break;
+		
+	case 2:
+		printk("  - supports x8 and x16 via BYTE# with asynchronous interface\n");
+		break;
+		
+	case 3:
+		printk("  - x32-only asynchronous interface\n");
+		break;
+		
+	case 65535:
+		printk("  - Not Allowed / Reserved\n");
+		break;
+		
+	default:
+		printk("  - Unknown\n");
+		break;
+	}
+	
+	printk("Max. bytes in buffer write: 0x%x\n", 1<< cfip->MaxBufWriteSize);
+	printk("Number of Erase Block Regions: %d\n", cfip->NumEraseRegions);
+	
+}
+#endif /* DEBUG_CFI */
+
+static struct chip_probe cfi_chip_probe = {
+	name: "CFI",
+	probe_chip: cfi_probe_chip
+};
+
+struct mtd_info *cfi_probe(struct map_info *map)
+{
+	/*
+	 * Just use the generic probe stuff to call our CFI-specific
+	 * chip_probe routine in all the possible permutations, etc.
+	 */
+	return mtd_do_chip_probe(map, &cfi_chip_probe);
+}
+
+static struct mtd_chip_driver cfi_chipdrv = {
+	probe: cfi_probe,
+	name: "cfi_probe",
+	module: THIS_MODULE
+};
+
+int __init cfi_probe_init(void)
+{
+	register_mtd_chip_driver(&cfi_chipdrv);
+	return 0;
+}
+
+static void __exit cfi_probe_exit(void)
+{
+	unregister_mtd_chip_driver(&cfi_chipdrv);
+}
+
+module_init(cfi_probe_init);
+module_exit(cfi_probe_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
+MODULE_DESCRIPTION("Probe code for CFI-compliant flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/chipreg.c linux-2.4.2/drivers/mtd/chips/chipreg.c
--- linux-2.4.2.orig/drivers/mtd/chips/chipreg.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/chipreg.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,96 @@
+/*
+ * $Id: chipreg.c,v 1.12 2001/10/02 15:29:53 dwmw2 Exp $
+ *
+ * Registration for chip drivers
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/kmod.h>
+#include <linux/spinlock.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/mtd/map.h>
+
+spinlock_t chip_drvs_lock = SPIN_LOCK_UNLOCKED;
+static LIST_HEAD(chip_drvs_list);
+
+void register_mtd_chip_driver(struct mtd_chip_driver *drv)
+{
+	spin_lock(&chip_drvs_lock);
+	list_add(&drv->list, &chip_drvs_list);
+	spin_unlock(&chip_drvs_lock);
+}
+
+void unregister_mtd_chip_driver(struct mtd_chip_driver *drv)
+{
+	spin_lock(&chip_drvs_lock);
+	list_del(&drv->list);
+	spin_unlock(&chip_drvs_lock);
+}
+
+static struct mtd_chip_driver *get_mtd_chip_driver (char *name)
+{
+	struct list_head *pos;
+	struct mtd_chip_driver *ret = NULL, *this;
+
+	spin_lock(&chip_drvs_lock);
+
+	list_for_each(pos, &chip_drvs_list) {
+		this = list_entry(pos, typeof(*this), list);
+		
+		if (!strcmp(this->name, name)) {
+			ret = this;
+			break;
+		}
+	}
+	if (ret && !try_inc_mod_count(ret->module)) {
+		/* Eep. Failed. */
+		ret = NULL;
+	}
+
+	spin_unlock(&chip_drvs_lock);
+
+	return ret;
+}
+
+	/* Hide all the horrid details, like some silly person taking
+	   get_module_symbol() away from us, from the caller. */
+
+struct mtd_info *do_map_probe(char *name, struct map_info *map)
+{
+	struct mtd_chip_driver *drv;
+	struct mtd_info *ret;
+
+	drv = get_mtd_chip_driver(name);
+
+	if (!drv && !request_module(name))
+		drv = get_mtd_chip_driver(name);
+
+	if (!drv)
+		return NULL;
+
+	ret = drv->probe(map);
+#ifdef CONFIG_MODULES
+	/* We decrease the use count here. It may have been a 
+	   probe-only module, which is no longer required from this
+	   point, having given us a handle on (and increased the use
+	   count of) the actual driver code.
+	*/
+	if(drv->module)
+		__MOD_DEC_USE_COUNT(drv->module);
+#endif
+
+	if (ret)
+		return ret;
+	
+	return NULL;
+}
+
+EXPORT_SYMBOL(register_mtd_chip_driver);
+EXPORT_SYMBOL(unregister_mtd_chip_driver);
+EXPORT_SYMBOL(do_map_probe);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Core routines for registering and invoking MTD chip drivers");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/gen_probe.c linux-2.4.2/drivers/mtd/chips/gen_probe.c
--- linux-2.4.2.orig/drivers/mtd/chips/gen_probe.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/gen_probe.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,299 @@
+/*
+ * Routines common to all CFI-type probes.
+ * (C) 2001, 2001 Red Hat, Inc.
+ * GPL'd
+ * $Id: gen_probe.c,v 1.6 2002/01/10 20:27:40 eric Exp $
+ */
+
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/gen_probe.h>
+
+static struct mtd_info *check_cmd_set(struct map_info *, int);
+static struct cfi_private *genprobe_ident_chips(struct map_info *map,
+						struct chip_probe *cp);
+static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
+			     struct cfi_private *cfi);
+
+struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
+{
+	struct mtd_info *mtd = NULL;
+	struct cfi_private *cfi;
+
+	/* First probe the map to see if we have CFI stuff there. */
+	cfi = genprobe_ident_chips(map, cp);
+	
+	if (!cfi)
+		return NULL;
+
+	map->fldrv_priv = cfi;
+	/* OK we liked it. Now find a driver for the command set it talks */
+
+	mtd = check_cmd_set(map, 1); /* First the primary cmdset */
+	if (!mtd)
+		mtd = check_cmd_set(map, 0); /* Then the secondary */
+	
+	if (mtd)
+		return mtd;
+
+	printk(KERN_WARNING"gen_probe: No supported Vendor Command Set found\n");
+	
+	kfree(cfi->cfiq);
+	kfree(cfi);
+	map->fldrv_priv = NULL;
+	return NULL;
+}
+EXPORT_SYMBOL(mtd_do_chip_probe);
+
+
+struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chip_probe *cp)
+{
+	unsigned long base=0;
+	struct cfi_private cfi;
+	struct cfi_private *retcfi;
+	struct flchip chip[MAX_CFI_CHIPS];
+	int i;
+
+	memset(&cfi, 0, sizeof(cfi));
+
+	/* Call the probetype-specific code with all permutations of 
+	   interleave and device type, etc. */
+	if (!genprobe_new_chip(map, cp, &cfi)) {
+		/* The probe didn't like it */
+		printk(KERN_WARNING "%s: Found no %s device at location zero\n",
+		       cp->name, map->name);
+		return NULL;
+	}		
+
+#if 0 /* Let the CFI probe routine do this sanity check. The Intel and AMD
+	 probe routines won't ever return a broken CFI structure anyway,
+	 because they make them up themselves.
+      */
+	if (cfi.cfiq->NumEraseRegions == 0) {
+		printk(KERN_WARNING "Number of erase regions is zero\n");
+		kfree(cfi.cfiq);
+		return NULL;
+	}
+#endif
+	chip[0].start = 0;
+	chip[0].state = FL_READY;
+	cfi.chipshift = cfi.cfiq->DevSize;
+
+	switch(cfi.interleave) {
+#ifdef CFIDEV_INTERLEAVE_1
+	case 1:
+		break;
+#endif
+#ifdef CFIDEV_INTERLEAVE_2
+	case 2:
+		cfi.chipshift++;
+		break;
+#endif
+#ifdef CFIDEV_INTERLEAVE_4
+	case 4:
+		cfi.chipshift+=2;
+		break;
+#endif
+	default:
+		BUG();
+	}
+		
+	cfi.numchips = 1;
+
+	/*
+	 * Now probe for other chips, checking sensibly for aliases while
+	 * we're at it. The new_chip probe above should have let the first
+	 * chip in read mode.
+	 */
+
+	for (base = (1<<cfi.chipshift); base + (1<<cfi.chipshift) < map->size;
+	     base += (1<<cfi.chipshift))
+		cp->probe_chip(map, base, &chip[0], &cfi);
+
+	/*
+	 * Now allocate the space for the structures we need to return to 
+	 * our caller, and copy the appropriate data into them.
+	 */
+
+	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
+
+	if (!retcfi) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);
+		kfree(cfi.cfiq);
+		return NULL;
+	}
+
+	memcpy(retcfi, &cfi, sizeof(cfi));
+	memcpy(&retcfi->chips[0], chip, sizeof(struct flchip) * cfi.numchips);
+
+	/* Fix up the stuff that breaks when you move it */
+	for (i=0; i< retcfi->numchips; i++) {
+		init_waitqueue_head(&retcfi->chips[i].wq);
+		spin_lock_init(&retcfi->chips[i]._spinlock);
+		retcfi->chips[i].mutex = &retcfi->chips[i]._spinlock;
+	}
+
+	return retcfi;
+}
+
+	
+static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
+			     struct cfi_private *cfi)
+{
+	switch (map->buswidth) {
+#ifdef CFIDEV_BUSWIDTH_1		
+	case CFIDEV_BUSWIDTH_1:
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+		break;			
+#endif /* CFIDEV_BUSWITDH_1 */
+
+#ifdef CFIDEV_BUSWIDTH_2		
+	case CFIDEV_BUSWIDTH_2:
+#ifdef CFIDEV_INTERLEAVE_1
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif /* CFIDEV_INTERLEAVE_1 */
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif /* CFIDEV_INTERLEAVE_2 */
+		break;			
+#endif /* CFIDEV_BUSWIDTH_2 */
+
+#ifdef CFIDEV_BUSWIDTH_4
+	case CFIDEV_BUSWIDTH_4:
+#if defined(CFIDEV_INTERLEAVE_1) && defined(SOMEONE_ACTUALLY_MAKES_THESE)
+                cfi->interleave = CFIDEV_INTERLEAVE_1;
+
+                cfi->device_type = CFI_DEVICETYPE_X32;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif /* CFIDEV_INTERLEAVE_1 */
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+
+#ifdef SOMEONE_ACTUALLY_MAKES_THESE
+		cfi->device_type = CFI_DEVICETYPE_X32;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif /* CFIDEV_INTERLEAVE_2 */
+#ifdef CFIDEV_INTERLEAVE_4
+		cfi->interleave = CFIDEV_INTERLEAVE_4;
+
+#ifdef SOMEONE_ACTUALLY_MAKES_THESE
+		cfi->device_type = CFI_DEVICETYPE_X32;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		if (cp->probe_chip(map, 0, NULL, cfi))
+			return 1;
+#endif /* CFIDEV_INTERLEAVE_4 */
+		break;
+#endif /* CFIDEV_BUSWIDTH_4 */
+
+	default:
+		printk(KERN_WARNING "genprobe_new_chip called with unsupported buswidth %d\n", map->buswidth);
+		return 0;
+	}
+	return 0;
+}
+
+
+typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);
+
+extern cfi_cmdset_fn_t cfi_cmdset_0001;
+extern cfi_cmdset_fn_t cfi_cmdset_0002;
+
+static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map, 
+						  int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+#if defined(CONFIG_MODULES) && defined(HAVE_INTER_MODULE)
+	char probename[32];
+	cfi_cmdset_fn_t *probe_function;
+
+	sprintf(probename, "cfi_cmdset_%4.4X", type);
+		
+	probe_function = inter_module_get_request(probename, probename);
+
+	if (probe_function) {
+		struct mtd_info *mtd;
+
+		mtd = (*probe_function)(map, primary);
+		/* If it was happy, it'll have increased its own use count */
+		inter_module_put(probename);
+		return mtd;
+	}
+#endif
+	printk(KERN_NOTICE "Support for command set %04X not present\n",
+	       type);
+
+	return NULL;
+}
+
+static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+	
+	if (type == P_ID_NONE || type == P_ID_RESERVED)
+		return NULL;
+
+	switch(type){
+		/* Urgh. Ifdefs. The version with weak symbols was
+		 * _much_ nicer. Shame it didn't seem to work on
+		 * anything but x86, really.
+		 * But we can't rely in inter_module_get() because
+		 * that'd mean we depend on link order.
+		 */
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	case 0x0001:
+	case 0x0003:
+		return cfi_cmdset_0001(map, primary);
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	case 0x0002:
+		return cfi_cmdset_0002(map, primary);
+#endif
+	}
+
+	return cfi_cmdset_unknown(map, primary);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Helper routines for flash chip probe code");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/jedec.c linux-2.4.2/drivers/mtd/chips/jedec.c
--- linux-2.4.2.orig/drivers/mtd/chips/jedec.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/jedec.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,893 @@
+
+/* JEDEC Flash Interface.
+ * This is an older type of interface for self programming flash. It is 
+ * commonly use in older AMD chips and is obsolete compared with CFI.
+ * It is called JEDEC because the JEDEC association distributes the ID codes
+ * for the chips.
+ *
+ * See the AMD flash databook for information on how to operate the interface.
+ *
+ * This code does not support anything wider than 8 bit flash chips, I am
+ * not going to guess how to send commands to them, plus I expect they will
+ * all speak CFI..
+ *
+ * $Id: jedec.c,v 1.12 2001/11/06 14:37:35 dwmw2 Exp $
+ */
+
+#include <linux/mtd/jedec.h>
+
+static struct mtd_info *jedec_probe(struct map_info *);
+static int jedec_probe8(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv);
+static int jedec_probe16(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv);
+static int jedec_probe32(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv);
+static void jedec_flash_chip_scan(struct jedec_private *priv,unsigned long start,
+			    unsigned long len);
+static int flash_erase(struct mtd_info *mtd, struct erase_info *instr);
+static int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf);
+
+static unsigned long my_bank_size;
+
+/* Listing of parts and sizes. We need this table to learn the sector
+   size of the chip and the total length */
+static const struct JEDECTable JEDEC_table[] = 
+  {{0x013D,"AMD Am29F017D",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01A4,"AMD Am29F040",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x20E3,"AMD Am29W040B",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0xC2AD,"Macronix MX29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {}};
+
+static const struct JEDECTable *jedec_idtoinf(__u8 mfr,__u8 id);
+static void jedec_sync(struct mtd_info *mtd) {};
+static int jedec_read(struct mtd_info *mtd, loff_t from, size_t len, 
+		      size_t *retlen, u_char *buf);
+static int jedec_read_banked(struct mtd_info *mtd, loff_t from, size_t len, 
+			     size_t *retlen, u_char *buf);
+
+static struct mtd_info *jedec_probe(struct map_info *map);
+
+
+
+static struct mtd_chip_driver jedec_chipdrv = {
+	probe: jedec_probe,
+	name: "jedec",
+	module: THIS_MODULE
+};
+
+/* Probe entry point */
+
+static struct mtd_info *jedec_probe(struct map_info *map)
+{
+   struct mtd_info *MTD;
+   struct jedec_private *priv;
+   unsigned long Base;
+   unsigned long SectorSize;
+   unsigned count;
+   unsigned I,Uniq;
+   char Part[200];
+   memset(&priv,0,sizeof(priv));
+
+   MTD = kmalloc(sizeof(struct mtd_info) + sizeof(struct jedec_private), GFP_KERNEL);
+   if (!MTD)
+	   return NULL;
+
+   memset(MTD, 0, sizeof(struct mtd_info) + sizeof(struct jedec_private));
+   priv = (struct jedec_private *)&MTD[1];
+   
+   my_bank_size = map->size;
+
+   if (map->size/my_bank_size > MAX_JEDEC_CHIPS)
+   {
+      printk("mtd: Increase MAX_JEDEC_CHIPS, too many banks.\n");
+      kfree(MTD);
+      return 0;
+   }
+   
+   for (Base = 0; Base < map->size; Base += my_bank_size)
+   {
+      // Perhaps zero could designate all tests?
+      if (map->buswidth == 0)
+	 map->buswidth = 1;
+      
+      if (map->buswidth == 1){
+	 if (jedec_probe8(map,Base,priv) == 0) {
+		 printk("did recognize jedec chip\n");
+		 kfree(MTD);
+	         return 0;
+	 }
+      }
+      if (map->buswidth == 2)
+	 jedec_probe16(map,Base,priv);
+      if (map->buswidth == 4)
+	 jedec_probe32(map,Base,priv);
+   }
+   
+   // Get the biggest sector size
+   SectorSize = 0;
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+	   //	   printk("priv->chips[%d].jedec is %x\n",I,priv->chips[I].jedec);
+	   //	   printk("priv->chips[%d].sectorsize is %lx\n",I,priv->chips[I].sectorsize);
+      if (priv->chips[I].sectorsize > SectorSize)
+	 SectorSize = priv->chips[I].sectorsize;
+   }
+   
+   // Quickly ensure that the other sector sizes are factors of the largest
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+      if ((SectorSize/priv->chips[I].sectorsize)*priv->chips[I].sectorsize != SectorSize)
+      {
+	 printk("mtd: Failed. Device has incompatible mixed sector sizes\n");
+	 kfree(MTD);
+	 return 0;
+      }      
+   }
+   
+   /* Generate a part name that includes the number of different chips and
+      other configuration information */
+   count = 1;
+   strncpy(Part,map->name,sizeof(Part)-10);
+   Part[sizeof(Part)-11] = 0;
+   strcat(Part," ");
+   Uniq = 0;
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+      const struct JEDECTable *JEDEC;
+      
+      if (priv->chips[I+1].jedec == priv->chips[I].jedec)
+      {
+	 count++;
+	 continue;
+      }
+      
+      // Locate the chip in the jedec table
+      JEDEC = jedec_idtoinf(priv->chips[I].jedec >> 8,priv->chips[I].jedec);
+      if (JEDEC == 0)
+      {
+	 printk("mtd: Internal Error, JEDEC not set\n");
+	 kfree(MTD);
+	 return 0;
+      }
+      
+      if (Uniq != 0)
+	 strcat(Part,",");
+      Uniq++;
+      
+      if (count != 1)
+	 sprintf(Part+strlen(Part),"%x*[%s]",count,JEDEC->name);
+      else
+	 sprintf(Part+strlen(Part),"%s",JEDEC->name);
+      if (strlen(Part) > sizeof(Part)*2/3)
+	 break;
+      count = 1;
+   }   
+
+   /* Determine if the chips are organized in a linear fashion, or if there
+      are empty banks. Note, the last bank does not count here, only the
+      first banks are important. Holes on non-bank boundaries can not exist
+      due to the way the detection algorithm works. */
+   if (priv->size < my_bank_size)
+      my_bank_size = priv->size;
+   priv->is_banked = 0;
+   //printk("priv->size is %x, my_bank_size is %x\n",priv->size,my_bank_size);
+   //printk("priv->bank_fill[0] is %x\n",priv->bank_fill[0]);
+   if (!priv->size) {
+	   printk("priv->size is zero\n");
+	   kfree(MTD);
+	   return 0;
+   }
+   if (priv->size/my_bank_size) {
+	   if (priv->size/my_bank_size == 1) {
+		   priv->size = my_bank_size;
+	   }
+	   else {
+		   for (I = 0; I != priv->size/my_bank_size - 1; I++)
+		   {
+		      if (priv->bank_fill[I] != my_bank_size)
+			 priv->is_banked = 1;
+		      
+		      /* This even could be eliminated, but new de-optimized read/write
+			 functions have to be written */
+		      printk("priv->bank_fill[%d] is %lx, priv->bank_fill[0] is %lx\n",I,priv->bank_fill[I],priv->bank_fill[0]);
+		      if (priv->bank_fill[I] != priv->bank_fill[0])
+		      {
+			 printk("mtd: Failed. Cannot handle unsymmetric banking\n");
+			 kfree(MTD);
+			 return 0;
+		      }      
+		   }
+	   }
+   }
+   if (priv->is_banked == 1)
+      strcat(Part,", banked");
+
+   //   printk("Part: '%s'\n",Part);
+   
+   memset(MTD,0,sizeof(*MTD));
+  // strncpy(MTD->name,Part,sizeof(MTD->name));
+  // MTD->name[sizeof(MTD->name)-1] = 0;
+   MTD->name = map->name;
+   MTD->type = MTD_NORFLASH;
+   MTD->flags = MTD_CAP_NORFLASH;
+   MTD->erasesize = SectorSize*(map->buswidth);
+   //   printk("MTD->erasesize is %x\n",(unsigned int)MTD->erasesize);
+   MTD->size = priv->size;
+   //   printk("MTD->size is %x\n",(unsigned int)MTD->size);
+   //MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
+   MTD->erase = flash_erase;
+   if (priv->is_banked == 1)
+      MTD->read = jedec_read_banked;
+   else
+      MTD->read = jedec_read;
+   MTD->write = flash_write;
+   MTD->sync = jedec_sync;
+   MTD->priv = map;
+   map->fldrv_priv = priv;
+   map->fldrv = &jedec_chipdrv;
+   MOD_INC_USE_COUNT;
+   return MTD;
+}
+
+/* Helper for the JEDEC function, JEDEC numbers all have odd parity */
+static int checkparity(u_char C)
+{
+   u_char parity = 0;
+   while (C != 0)
+   {
+      parity ^= C & 1;
+      C >>= 1;
+   }
+
+   return parity == 1;
+}
+
+
+/* Take an array of JEDEC numbers that represent interleved flash chips
+   and process them. Check to make sure they are good JEDEC numbers, look
+   them up and then add them to the chip list */   
+static int handle_jedecs(struct map_info *map,__u8 *Mfg,__u8 *Id,unsigned Count,
+		  unsigned long base,struct jedec_private *priv)
+{
+   unsigned I,J;
+   unsigned long Size;
+   unsigned long SectorSize;
+   const struct JEDECTable *JEDEC;
+
+   // Test #2 JEDEC numbers exhibit odd parity
+   for (I = 0; I != Count; I++)
+   {
+      if (checkparity(Mfg[I]) == 0 || checkparity(Id[I]) == 0)
+	 return 0;
+   }
+   
+   // Finally, just make sure all the chip sizes are the same
+   JEDEC = jedec_idtoinf(Mfg[0],Id[0]);
+   
+   if (JEDEC == 0)
+   {
+      printk("mtd: Found JEDEC flash chip, but do not have a table entry for %x:%x\n",Mfg[0],Mfg[1]);
+      return 0;
+   }
+   
+   Size = JEDEC->size;
+   SectorSize = JEDEC->sectorsize;
+   for (I = 0; I != Count; I++)
+   {
+      JEDEC = jedec_idtoinf(Mfg[0],Id[0]);
+      if (JEDEC == 0)
+      {
+	 printk("mtd: Found JEDEC flash chip, but do not have a table entry for %x:%x\n",Mfg[0],Mfg[1]);
+	 return 0;
+      }
+
+      if (Size != JEDEC->size || SectorSize != JEDEC->sectorsize)
+      {
+	 printk("mtd: Failed. Interleved flash does not have matching characteristics\n");
+	 return 0;
+      }      
+   }
+
+   // Load the Chips
+   for (I = 0; I != MAX_JEDEC_CHIPS; I++)
+   {
+      if (priv->chips[I].jedec == 0)
+	 break;
+   }
+
+   if (I + Count > MAX_JEDEC_CHIPS)
+   {
+      printk("mtd: Device has too many chips. Increase MAX_JEDEC_CHIPS\n");
+      return 0;
+   }      
+   
+   // Add them to the table
+   for (J = 0; J != Count; J++)
+   {
+      unsigned long Bank;
+	 
+      JEDEC = jedec_idtoinf(Mfg[J],Id[J]);
+      priv->chips[I].jedec = (Mfg[J] << 8) | Id[J];
+      priv->chips[I].size = JEDEC->size;
+      priv->chips[I].sectorsize = JEDEC->sectorsize;
+      priv->chips[I].base = base + J;
+      priv->chips[I].datashift = J*8;
+      priv->chips[I].capabilities = JEDEC->capabilities;
+      priv->chips[I].offset = priv->size + J;
+
+      // log2 n :|
+      priv->chips[I].addrshift = 0;
+      for (Bank = Count; Bank != 1; Bank >>= 1, priv->chips[I].addrshift++);
+      
+      // Determine how filled this bank is.
+      Bank = base & (~(my_bank_size-1));
+      if (priv->bank_fill[Bank/my_bank_size] < base + 
+	  (JEDEC->size << priv->chips[I].addrshift) - Bank)
+	 priv->bank_fill[Bank/my_bank_size] =  base + (JEDEC->size << priv->chips[I].addrshift) - Bank;
+      I++;
+   }
+
+   priv->size += priv->chips[I-1].size*Count;
+	 
+   return priv->chips[I-1].size;
+}
+
+/* Lookup the chip information from the JEDEC ID table. */
+static const struct JEDECTable *jedec_idtoinf(__u8 mfr,__u8 id)
+{
+   __u16 Id = (mfr << 8) | id;
+   unsigned long I = 0;
+   for (I = 0; JEDEC_table[I].jedec != 0; I++)
+      if (JEDEC_table[I].jedec == Id)
+	 return JEDEC_table + I;
+   return 0;
+}
+
+// Look for flash using an 8 bit bus interface
+static int jedec_probe8(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv)
+{ 
+   #define flread(x) map->read8(map,base+x)
+   #define flwrite(v,x) map->write8(map,v,base+x)
+
+   const unsigned long AutoSel1 = 0xAA;
+   const unsigned long AutoSel2 = 0x55;
+   const unsigned long AutoSel3 = 0x90;
+   const unsigned long Reset = 0xF0;
+   __u32 OldVal;
+   __u8 Mfg[1];
+   __u8 Id[1];
+   unsigned I;
+   unsigned long Size;
+
+   // Wait for any write/erase operation to settle
+   OldVal = flread(base);
+   for (I = 0; OldVal != flread(base) && I < 10000; I++)
+      OldVal = flread(base);
+   
+   // Reset the chip
+   flwrite(Reset,0x555); 
+   
+   // Send the sequence
+   flwrite(AutoSel1,0x555);
+   flwrite(AutoSel2,0x2AA);
+   flwrite(AutoSel3,0x555);
+   
+   //  Get the JEDEC numbers
+   Mfg[0] = flread(0);
+   Id[0] = flread(1);
+   //   printk("Mfg is %x, Id is %x\n",Mfg[0],Id[0]);
+      
+   Size = handle_jedecs(map,Mfg,Id,1,base,priv);
+   //   printk("handle_jedecs Size is %x\n",(unsigned int)Size);
+   if (Size == 0)
+   {
+      flwrite(Reset,0x555);
+      return 0;
+   }
+   
+
+   // Reset.
+   flwrite(Reset,0x555);
+   
+   return 1;
+   
+   #undef flread
+   #undef flwrite
+}
+
+// Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
+static int jedec_probe16(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv)
+{
+   return 0;
+}
+
+// Look for flash using a 32 bit bus interface (ie 4 8-bit chips)
+static int jedec_probe32(struct map_info *map,unsigned long base,
+		  struct jedec_private *priv)
+{
+   #define flread(x) map->read32(map,base+((x)<<2))
+   #define flwrite(v,x) map->write32(map,v,base+((x)<<2))
+
+   const unsigned long AutoSel1 = 0xAAAAAAAA;
+   const unsigned long AutoSel2 = 0x55555555;
+   const unsigned long AutoSel3 = 0x90909090;
+   const unsigned long Reset = 0xF0F0F0F0;
+   __u32 OldVal;
+   __u8 Mfg[4];
+   __u8 Id[4];
+   unsigned I;
+   unsigned long Size;
+
+   // Wait for any write/erase operation to settle
+   OldVal = flread(base);
+   for (I = 0; OldVal != flread(base) && I < 10000; I++)
+      OldVal = flread(base);
+   
+   // Reset the chip
+   flwrite(Reset,0x555); 
+   
+   // Send the sequence
+   flwrite(AutoSel1,0x555);
+   flwrite(AutoSel2,0x2AA);
+   flwrite(AutoSel3,0x555);
+   
+   // Test #1, JEDEC numbers are readable from 0x??00/0x??01
+   if (flread(0) != flread(0x100) || 
+       flread(1) != flread(0x101))
+   {
+      flwrite(Reset,0x555);
+      return 0;
+   }
+
+   // Split up the JEDEC numbers
+   OldVal = flread(0);
+   for (I = 0; I != 4; I++)
+      Mfg[I] = (OldVal >> (I*8));
+   OldVal = flread(1);
+   for (I = 0; I != 4; I++)
+      Id[I] = (OldVal >> (I*8));
+      
+   Size = handle_jedecs(map,Mfg,Id,4,base,priv);
+   if (Size == 0)
+   {
+      flwrite(Reset,0x555);
+      return 0;
+   }
+   
+   /* Check if there is address wrap around within a single bank, if this
+      returns JEDEC numbers then we assume that it is wrap around. Notice
+      we call this routine with the JEDEC return still enabled, if two or
+      more flashes have a truncated address space the probe test will still
+      work */
+   if (base + Size+0x555 < map->size &&
+       base + Size+0x555 < (base & (~(my_bank_size-1))) + my_bank_size)
+   {
+      if (flread(base+Size) != flread(base+Size + 0x100) ||
+	  flread(base+Size + 1) != flread(base+Size + 0x101))
+      {
+	 jedec_probe32(map,base+Size,priv);
+      }
+   }
+
+   // Reset.
+   flwrite(0xF0F0F0F0,0x555);
+   
+   return 1;
+   
+   #undef flread
+   #undef flwrite
+}
+
+/* Linear read. */
+static int jedec_read(struct mtd_info *mtd, loff_t from, size_t len, 
+		      size_t *retlen, u_char *buf)
+{
+   struct map_info *map = (struct map_info *)mtd->priv;
+   
+   map->copy_from(map, buf, from, len);
+   *retlen = len;
+   return 0;   
+}
+
+/* Banked read. Take special care to jump past the holes in the bank
+   mapping. This version assumes symetry in the holes.. */
+static int jedec_read_banked(struct mtd_info *mtd, loff_t from, size_t len, 
+			     size_t *retlen, u_char *buf)
+{
+   struct map_info *map = (struct map_info *)mtd->priv;
+   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+
+   *retlen = 0;
+   while (len > 0)
+   {
+      // Determine what bank and offset into that bank the first byte is
+      unsigned long bank = from & (~(priv->bank_fill[0]-1));
+      unsigned long offset = from & (priv->bank_fill[0]-1);
+      unsigned long get = len;
+      if (priv->bank_fill[0] - offset < len)
+	 get = priv->bank_fill[0] - offset;
+
+      bank /= priv->bank_fill[0];      
+      map->copy_from(map,buf + *retlen,bank*my_bank_size + offset,get);
+      
+      len -= get;
+      *retlen += get;
+      from += get;
+   }   
+   return 0;   
+}
+
+/* Pass the flags value that the flash return before it re-entered read 
+   mode. */
+static void jedec_flash_failed(unsigned char code)
+{
+   /* Bit 5 being high indicates that there was an internal device
+      failure, erasure time limits exceeded or something */
+   if ((code & (1 << 5)) != 0)
+   {
+      printk("mtd: Internal Flash failure\n");
+      return;
+   }
+   printk("mtd: Programming didn't take\n");
+}
+
+/* This uses the erasure function described in the AMD Flash Handbook, 
+   it will work for flashes with a fixed sector size only. Flashes with
+   a selection of sector sizes (ie the AMD Am29F800B) will need a different
+   routine. This routine tries to parallize erasing multiple chips/sectors 
+   where possible */
+static int flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+   // Does IO to the currently selected chip
+   #define flread(x) map->read8(map,chip->base+((x)<<chip->addrshift))
+   #define flwrite(v,x) map->write8(map,v,chip->base+((x)<<chip->addrshift))
+   
+   unsigned long Time = 0;
+   unsigned long NoTime = 0;
+   unsigned long start = instr->addr, len = instr->len;
+   unsigned int I;
+   struct map_info *map = (struct map_info *)mtd->priv;
+   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+
+   // Verify the arguments..
+   if (start + len > mtd->size ||
+       (start % mtd->erasesize) != 0 ||
+       (len % mtd->erasesize) != 0 ||
+       (len/mtd->erasesize) == 0)
+      return -EINVAL;
+   
+   jedec_flash_chip_scan(priv,start,len);
+
+   // Start the erase sequence on each chip
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+      unsigned long off;
+      struct jedec_flash_chip *chip = priv->chips + I;
+      
+      if (chip->length == 0)
+	 continue;
+      
+      if (chip->start + chip->length > chip->size)
+      {
+	 printk("DIE\n");
+	 return -EIO;
+      }     
+      
+      flwrite(0xF0,chip->start + 0x555);
+      flwrite(0xAA,chip->start + 0x555);
+      flwrite(0x55,chip->start + 0x2AA);
+      flwrite(0x80,chip->start + 0x555);
+      flwrite(0xAA,chip->start + 0x555);
+      flwrite(0x55,chip->start + 0x2AA);
+
+      /* Once we start selecting the erase sectors the delay between each 
+         command must not exceed 50us or it will immediately start erasing 
+         and ignore the other sectors */
+      for (off = 0; off < len; off += chip->sectorsize)
+      {
+	 // Check to make sure we didn't timeout
+	 flwrite(0x30,chip->start + off);
+	 if (off == 0)
+	    continue;
+	 if ((flread(chip->start + off) & (1 << 3)) != 0)
+	 {
+	    printk("mtd: Ack! We timed out the erase timer!\n");
+	    return -EIO;
+	 }       	 
+      }
+   }   
+
+   /* We could split this into a timer routine and return early, performing
+      background erasure.. Maybe later if the need warrents */
+
+   /* Poll the flash for erasure completion, specs say this can take as long
+      as 480 seconds to do all the sectors (for a 2 meg flash). 
+      Erasure time is dependant on chip age, temp and wear.. */
+   
+   /* This being a generic routine assumes a 32 bit bus. It does read32s
+      and bundles interleved chips into the same grouping. This will work 
+      for all bus widths */
+   Time = 0;
+   NoTime = 0;
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+      struct jedec_flash_chip *chip = priv->chips + I;
+      unsigned long off = 0;
+      unsigned todo[4] = {0,0,0,0};
+      unsigned todo_left = 0;
+      unsigned J;
+      
+      if (chip->length == 0)
+	 continue;
+
+      /* Find all chips in this data line, realistically this is all 
+         or nothing up to the interleve count */
+      for (J = 0; priv->chips[J].jedec != 0 && J < MAX_JEDEC_CHIPS; J++)
+      {
+	 if ((priv->chips[J].base & (~((1<<chip->addrshift)-1))) == 
+	     (chip->base & (~((1<<chip->addrshift)-1))))
+	 {
+	    todo_left++;
+	    todo[priv->chips[J].base & ((1<<chip->addrshift)-1)] = 1;
+	 }	 
+      }
+
+      /*      printk("todo: %x %x %x %x\n",(short)todo[0],(short)todo[1],
+	      (short)todo[2],(short)todo[3]);
+      */
+      while (1)
+      {
+	 __u32 Last[4];
+	 unsigned long Count = 0;
+	 
+	 /* During erase bit 7 is held low and bit 6 toggles, we watch this,
+	    should it stop toggling or go high then the erase is completed,
+  	    or this is not really flash ;> */
+	 switch (map->buswidth) {
+	 case 1:
+	    Last[0] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 2:
+	    Last[0] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 3:
+	    Last[0] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 }
+	 Count = 3;
+	 while (todo_left != 0)
+	 {
+	    for (J = 0; J != 4; J++)
+	    {
+	       __u8 Byte1 = (Last[(Count-1)%4] >> (J*8)) & 0xFF;
+	       __u8 Byte2 = (Last[(Count-2)%4] >> (J*8)) & 0xFF;
+	       __u8 Byte3 = (Last[(Count-3)%4] >> (J*8)) & 0xFF;
+	       if (todo[J] == 0)
+		  continue;
+	       
+	       if ((Byte1 & (1 << 7)) == 0 && Byte1 != Byte2)
+	       {
+//		  printk("Check %x %x %x\n",(short)J,(short)Byte1,(short)Byte2);
+		  continue;
+	       }
+	       
+	       if (Byte1 == Byte2)
+	       {
+		  jedec_flash_failed(Byte3);
+		  return -EIO;
+	       }
+	       
+	       todo[J] = 0;
+	       todo_left--;
+	    }
+	    
+/*	    if (NoTime == 0)
+	       Time += HZ/10 - schedule_timeout(HZ/10);*/
+	    NoTime = 0;
+
+	    switch (map->buswidth) {
+	    case 1:
+	       Last[Count % 4] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 2:
+	       Last[Count % 4] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 4:
+	       Last[Count % 4] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    }
+	    Count++;
+	    
+/*	    // Count time, max of 15s per sector (according to AMD)
+	    if (Time > 15*len/mtd->erasesize*HZ)
+	    {
+	       printk("mtd: Flash Erase Timed out\n");
+	       return -EIO;
+	    }	    */
+	 }
+	 	 
+	 // Skip to the next chip if we used chip erase
+	 if (chip->length == chip->size)
+	    off = chip->size;
+	 else
+	    off += chip->sectorsize;
+	 
+	 if (off >= chip->length)
+	    break;
+	 NoTime = 1;
+      }
+      
+      for (J = 0; priv->chips[J].jedec != 0 && J < MAX_JEDEC_CHIPS; J++)
+      {
+	 if ((priv->chips[J].base & (~((1<<chip->addrshift)-1))) ==
+	     (chip->base & (~((1<<chip->addrshift)-1))))
+	    priv->chips[J].length = 0;
+      }      
+   }
+       	    
+   //printk("done\n");
+   if (instr->callback)
+	instr->callback(instr);
+   return 0;
+   
+   #undef flread
+   #undef flwrite
+}
+
+/* This is the simple flash writing function. It writes to every byte, in
+   sequence. It takes care of how to properly address the flash if
+   the flash is interleved. It can only be used if all the chips in the 
+   array are identical!*/
+static int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf)
+{
+   /* Does IO to the currently selected chip. It takes the bank addressing
+      base (which is divisable by the chip size) adds the necesary lower bits
+      of addrshift (interleve index) and then adds the control register index. */
+   #define flread(x) map->read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+   #define flwrite(v,x) map->write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+   
+   struct map_info *map = (struct map_info *)mtd->priv;
+   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   unsigned long base;
+   unsigned long off;
+   size_t save_len = len;
+   
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   //printk("Here");
+   
+   //printk("flash_write: start is %x, len is %x\n",start,(unsigned long)len);
+   while (len != 0)
+   {
+      struct jedec_flash_chip *chip = priv->chips;
+      unsigned long bank;
+      unsigned long boffset;
+	 
+      // Compute the base of the flash.
+      off = ((unsigned long)start) % (chip->size << chip->addrshift);
+      base = start - off;
+
+      // Perform banked addressing translation.
+      bank = base & (~(priv->bank_fill[0]-1));
+      boffset = base & (priv->bank_fill[0]-1);
+      bank = (bank/priv->bank_fill[0])*my_bank_size;
+      base = bank + boffset;
+      
+    //  printk("Flasing %X %X %X\n",base,chip->size,len);
+     // printk("off is %x, compare with %x\n",off,chip->size << chip->addrshift);
+      
+      // Loop over this page
+      for (; off != (chip->size << chip->addrshift) && len != 0; start++, len--, off++,buf++)
+      {
+	 unsigned char oldbyte = map->read8(map,base+off);
+	 unsigned char Last[4];
+	 unsigned long Count = 0;
+
+	 if (oldbyte == *buf) {
+	//	 printk("oldbyte and *buf is %x,len is %x\n",oldbyte,len);
+	    continue;
+	 }
+	 if (((~oldbyte) & *buf) != 0)
+	    printk("mtd: warn: Trying to set a 0 to a 1\n");
+	     
+	 // Write
+	 flwrite(0xAA,0x555);
+	 flwrite(0x55,0x2AA);
+	 flwrite(0xA0,0x555);
+	 map->write8(map,*buf,base + off);
+	 Last[0] = map->read8(map,base + off);
+	 Last[1] = map->read8(map,base + off);
+	 Last[2] = map->read8(map,base + off);
+	 
+	 /* Wait for the flash to finish the operation. We store the last 4
+	    status bytes that have been retrieved so we can determine why
+	    it failed. The toggle bits keep toggling when there is a 
+	    failure */
+	 for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] &&
+	      Count < 10000; Count++)
+	    Last[Count % 4] = map->read8(map,base + off);
+	 if (Last[(Count - 1) % 4] != *buf)
+	 {
+	    jedec_flash_failed(Last[(Count - 3) % 4]);
+	    return -EIO;
+	 }	 
+      }
+   }
+   *retlen = save_len;
+   return 0;
+}
+
+/* This is used to enhance the speed of the erase routine,
+   when things are being done to multiple chips it is possible to
+   parallize the operations, particularly full memory erases of multi
+   chip memories benifit */
+static void jedec_flash_chip_scan(struct jedec_private *priv,unsigned long start,
+		     unsigned long len)
+{
+   unsigned int I;
+
+   // Zero the records
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+      priv->chips[I].start = priv->chips[I].length = 0;
+   
+   // Intersect the region with each chip
+   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   {
+      struct jedec_flash_chip *chip = priv->chips + I;
+      unsigned long ByteStart;
+      unsigned long ChipEndByte = chip->offset + (chip->size << chip->addrshift);
+      
+      // End is before this chip or the start is after it
+      if (start+len < chip->offset ||
+	  ChipEndByte - (1 << chip->addrshift) < start)
+	 continue;
+      
+      if (start < chip->offset)
+      {
+	 ByteStart = chip->offset;
+	 chip->start = 0;
+      }      
+      else
+      {
+	 chip->start = (start - chip->offset + (1 << chip->addrshift)-1) >> chip->addrshift;
+	 ByteStart = start;
+      }
+
+      if (start + len >= ChipEndByte)
+	 chip->length = (ChipEndByte - ByteStart) >> chip->addrshift;
+      else
+	 chip->length = (start + len - ByteStart + (1 << chip->addrshift)-1) >> chip->addrshift;
+   }
+}
+
+int __init jedec_init(void)
+{
+	register_mtd_chip_driver(&jedec_chipdrv);
+	return 0;
+}
+
+static void __exit jedec_exit(void)
+{
+	unregister_mtd_chip_driver(&jedec_chipdrv);
+}
+
+module_init(jedec_init);
+module_exit(jedec_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jason Gunthorpe <jgg@deltatee.com> et al.");
+MODULE_DESCRIPTION("Old MTD chip driver for JEDEC-compliant flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/jedec_probe.c linux-2.4.2/drivers/mtd/chips/jedec_probe.c
--- linux-2.4.2.orig/drivers/mtd/chips/jedec_probe.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/jedec_probe.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,927 @@
+/* 
+   Common Flash Interface probe code.
+   (C) 2000 Red Hat. GPL'd.
+   $Id: jedec_probe.c,v 1.10 2002/01/21 18:09:01 rkaiser Exp $
+   See JEDEC (http://www.jedec.org/) standard JESD21C (section 3.5)
+   for the standard this probe goes back to.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/gen_probe.h>
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_ATMEL	0x001f
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_INTEL	0x0089
+#define MANUFACTURER_MACRONIX	0x00C2
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+#define AM29F017D	0x003D
+#define AM29F016	0x00AD
+#define AM29F080	0x00D5
+#define AM29F040	0x00A4
+
+/* Atmel */
+#define AT49BV512	0x0003
+#define AT49BV16X4	0x00c0
+#define AT49BV16X4T	0x00c2
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+#define MBM29LV800BA	0x225B
+#define MBM29LV800TA	0x22DA
+
+/* Intel */
+#define I28F004B3T	0x00d4
+#define I28F004B3B	0x00d5
+#define I28F400B3T	0x8894
+#define I28F400B3B	0x8895
+#define I28F008S5	0x00a6
+#define I28F008SA	0x00a2
+#define I28F008B3T	0x00d2
+#define I28F008B3B	0x00d3
+#define I28F800B3T	0x8892
+#define I28F800B3B	0x8893
+#define I28F016S3	0x00aa
+#define I28F016B3T	0x00d0
+#define I28F016B3B	0x00d1
+#define I28F160B3T	0x8890
+#define I28F160B3B	0x8891
+#define I28F320B3T	0x8896
+#define I28F320B3B	0x8897
+#define I28F640B3T	0x8898
+#define I28F640B3B	0x8899
+#define I82802AB	0x00ad
+#define I82802AC	0x00ac
+
+/* Macronix */
+#define MX29F016	0x00AD
+#define MX29F004T	0x0045
+#define MX29F004B	0x0046
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+#define M29W040B	0x00E3
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+#define SST39SF010A	0x00B5
+#define SST39SF020A	0x00B6
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const int DevSize;
+	const int InterfaceDesc;
+	const int NumEraseRegions;
+	const int CmdSet;
+	const ulong regions[4];
+};
+
+#define ERASEINFO(size,blocks) (size<<8)|(blocks-1)
+
+#define SIZE_64KiB  16
+#define SIZE_128KiB 17
+#define SIZE_256KiB 18
+#define SIZE_512KiB 19
+#define SIZE_1MiB   20
+#define SIZE_2MiB   21
+#define SIZE_4MiB   22
+#define SIZE_8MiB   23
+
+static const struct amd_flash_info jedec_table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV800BA,
+		name: "Fujitsu MBM29LV800BA",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV800TA,
+		name: "Fujitsu MBM29LV800TA",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+ 			  ERASEINFO(0x08000,1),
+ 			  ERASEINFO(0x02000,2),
+ 			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F004B3B,
+		name:			"Intel 28F004B3B",
+		DevSize:		SIZE_512KiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 7),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F004B3T,
+		name:			"Intel 28F004B3T",
+		DevSize:		SIZE_512KiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 7),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F400B3B,
+		name:			"Intel 28F400B3B",
+		DevSize:		SIZE_512KiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 7),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F400B3T,
+		name:			"Intel 28F400B3T",
+		DevSize:		SIZE_512KiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 7),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F008B3B,
+		name:			"Intel 28F008B3B",
+		DevSize:		SIZE_1MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 15),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F008B3T,
+		name:			"Intel 28F008B3T",
+		DevSize:		SIZE_1MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 15),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id: MANUFACTURER_INTEL,
+		dev_id: I28F008S5,
+		name: "Intel 28F008S5",
+		DevSize: SIZE_1MiB,
+		CmdSet: P_ID_INTEL_EXT,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,16),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F008SA,
+		name:			"Intel 28F008SA",
+		DevSize:		SIZE_1MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	1,
+		regions: {
+			ERASEINFO(0x10000, 16),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F800B3B,
+		name:			"Intel 28F800B3B",
+		DevSize:		SIZE_1MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 15),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F800B3T,
+		name:			"Intel 28F800B3T",
+		DevSize:		SIZE_1MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 15),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F016B3B,
+		name:			"Intel 28F016B3B",
+		DevSize:		SIZE_2MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 31),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F016S3,
+		name:			"Intel I28F016S3",
+		DevSize:		SIZE_2MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	1,
+		regions: {
+			ERASEINFO(0x10000, 32),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F016B3T,
+		name:			"Intel 28F016B3T",
+		DevSize:		SIZE_2MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 31),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F160B3B,
+		name:			"Intel 28F160B3B",
+		DevSize:		SIZE_2MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 31),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F160B3T,
+		name:			"Intel 28F160B3T",
+		DevSize:		SIZE_2MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 31),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F320B3B,
+		name:			"Intel 28F320B3B",
+		DevSize:		SIZE_4MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 63),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F320B3T,
+		name:			"Intel 28F320B3T",
+		DevSize:		SIZE_4MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 63),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F640B3B,
+		name:			"Intel 28F640B3B",
+		DevSize:		SIZE_8MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 127),
+		}
+	}, {
+		mfr_id:			MANUFACTURER_INTEL,
+		dev_id:			I28F640B3T,
+		name:			"Intel 28F640B3T",
+		DevSize:		SIZE_8MiB,
+		CmdSet:			P_ID_INTEL_STD,
+		NumEraseRegions:	2,
+		regions: {
+			ERASEINFO(0x10000, 127),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		mfr_id: MANUFACTURER_INTEL,
+		dev_id: I82802AB,
+		name: "Intel 82802AB",
+		DevSize: SIZE_512KiB,
+		CmdSet: P_ID_INTEL_EXT,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,8),
+		}
+	}, {
+		mfr_id: MANUFACTURER_INTEL,
+		dev_id: I82802AC,
+		name: "Intel 82802AC",
+		DevSize: SIZE_1MiB,
+		CmdSet: P_ID_INTEL_EXT,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,16),
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		DevSize: SIZE_1MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ATMEL,
+		dev_id: AT49BV512,
+		name: "Atmel AT49BV512",
+		DevSize: SIZE_64KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ATMEL,
+		dev_id: AT49BV16X4,
+		name: "Atmel AT49BV16X4",
+		DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 3,
+		regions: {ERASEINFO(0x02000,8),
+			  ERASEINFO(0x08000,2),
+			  ERASEINFO(0x10000,30)
+		}
+	}, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16X4T,
+                name: "Atmel AT49BV16X4T",
+                DevSize: SIZE_2MiB,
+		CmdSet:	P_ID_AMD_STD,
+                NumEraseRegions: 3,
+                regions: {ERASEINFO(0x10000,30),
+                          ERASEINFO(0x08000,2),
+			  ERASEINFO(0x02000,8)
+                }
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F017D,
+		name: "AMD AM29F017D",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,32),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F016,
+		name: "AMD AM29F016",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,32),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F080,
+		name: "AMD AM29F080",
+		DevSize: SIZE_1MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,16),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F040,
+		name: "AMD AM29F040",
+		DevSize: SIZE_512KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,8),
+		}
+        }, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W040B,
+		name: "ST M29W040B",
+		DevSize: SIZE_512KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,8),
+		}
+	}, {
+		mfr_id: MANUFACTURER_MACRONIX,
+		dev_id: MX29F016,
+		name: "AMD AM29F016",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,32),
+		}
+	}, {
+		mfr_id: MANUFACTURER_MACRONIX,
+		dev_id: MX29F016,
+		name: "Macronix MX29F016",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x10000,32),
+		}
+        }, {
+		mfr_id: MANUFACTURER_MACRONIX,
+		dev_id: MX29F004T,
+		name: "Macronix MX29F004T",
+		DevSize: SIZE_512KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,7),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1),
+		}
+        }, {
+		mfr_id: MANUFACTURER_MACRONIX,
+		dev_id: MX29F004T,
+		name: "Macronix MX29F004B",
+		DevSize: SIZE_512KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,7),
+		}
+        }, {
+		mfr_id: MANUFACTURER_SST,
+		dev_id: SST39SF010A,
+		name: "SST 39SF010A",
+		DevSize: SIZE_128KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x01000,32),
+		}
+        }, {
+		mfr_id: MANUFACTURER_SST,
+		dev_id: SST39SF020A,
+		name: "SST 39SF020A",
+		DevSize: SIZE_256KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x01000,64),
+		}
+	} 
+};
+
+
+static int cfi_jedec_setup(struct cfi_private *p_cfi, int index);
+
+static int jedec_probe_chip(struct map_info *map, __u32 base,
+			    struct flchip *chips, struct cfi_private *cfi);
+
+struct mtd_info *jedec_probe(struct map_info *map);
+
+static inline u32 jedec_read_mfr(struct map_info *map, __u32 base, 
+	struct cfi_private *cfi)
+{
+	u32 result, mask;
+	mask = (1 << (cfi->device_type * 8)) -1;
+	result = cfi_read(map, base);
+	result &= mask;
+	return result;
+}
+
+static inline u32 jedec_read_id(struct map_info *map, __u32 base, 
+	struct cfi_private *cfi)
+{
+	int osf;
+	u32 result, mask;
+	osf = cfi->interleave *cfi->device_type;
+	mask = (1 << (cfi->device_type * 8)) -1;
+	result = cfi_read(map, base + osf);
+	result &= mask;
+	return result;
+}
+
+static inline void jedec_reset(u32 base, struct map_info *map, 
+	struct cfi_private *cfi)
+{
+	/* Reset */
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+	/* Some misdesigned intel chips do not respond for 0xF0 for a reset,
+	 * so ensure we're in read mode.  Send both the Intel and the AMD command
+	 * for this.  Intel uses 0xff for this, AMD uses 0xff for NOP, so
+	 * this should be safe.
+	 */ 
+	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
+
+}
+static int cfi_jedec_setup(struct cfi_private *p_cfi, int index)
+{
+	int i,num_erase_regions;
+
+	printk("Found: %s\n",jedec_table[index].name);
+
+	num_erase_regions = jedec_table[index].NumEraseRegions;
+	
+	p_cfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+	if (!p_cfi->cfiq) {
+		//xx printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+		return 0;
+	}
+
+	memset(p_cfi->cfiq,0,sizeof(struct cfi_ident));	
+
+	p_cfi->cfiq->P_ID = jedec_table[index].CmdSet;
+	p_cfi->cfiq->NumEraseRegions = jedec_table[index].NumEraseRegions;
+	p_cfi->cfiq->DevSize = jedec_table[index].DevSize;
+	p_cfi->cfi_mode = CFI_MODE_JEDEC;
+
+	for (i=0; i<num_erase_regions; i++){
+		p_cfi->cfiq->EraseRegionInfo[i] = jedec_table[index].regions[i];
+	}
+	p_cfi->cmdset_priv = 0;
+	return 1; 	/* ok */
+}
+
+static int jedec_probe_chip(struct map_info *map, __u32 base,
+			      struct flchip *chips, struct cfi_private *cfi)
+{
+	int i;
+	int retried = 0;
+
+	if (!cfi->numchips) {
+		switch (cfi->device_type) {
+		case CFI_DEVICETYPE_X8:
+			cfi->addr_unlock1 = 0x555; 
+			cfi->addr_unlock2 = 0x2aa; 
+			break;
+		case CFI_DEVICETYPE_X16:
+			cfi->addr_unlock1 = 0xaaa;
+			if (map->buswidth == cfi->interleave) {
+				/* X16 chip(s) in X8 mode */
+				cfi->addr_unlock2 = 0x555;
+			} else {
+				cfi->addr_unlock2 = 0x554;
+			}
+			break;
+		case CFI_DEVICETYPE_X32:
+			cfi->addr_unlock1 = 0x1555; 
+			cfi->addr_unlock2 = 0xaaa; 
+			break;
+		default:
+			printk(KERN_NOTICE "Eep. Unknown jedec_probe device type %d\n", cfi->device_type);
+		return 0;
+		}
+	}
+
+ retry:
+	/* Make certain we aren't probing past the end of map */
+	if (base >= map->size) {
+		printk(KERN_NOTICE
+			"Probe at base(0x%08x) past the end of the map(0x%08lx)\n",
+			base, map->size -1);
+		return 0;
+		
+	}
+	if ((base + cfi->addr_unlock1) >= map->size) {
+		printk(KERN_NOTICE
+			"Probe at addr_unlock1(0x%08x + 0x%08x) past the end of the map(0x%08lx)\n",
+			base, cfi->addr_unlock1, map->size -1);
+
+		return 0;
+	}
+	if ((base + cfi->addr_unlock2) >= map->size) {
+		printk(KERN_NOTICE
+			"Probe at addr_unlock2(0x%08x + 0x%08x) past the end of the map(0x%08lx)\n",
+			base, cfi->addr_unlock2, map->size -1);
+		return 0;
+		
+	}
+
+	/* Reset */
+	jedec_reset(base, map, cfi);
+
+	/* Autoselect Mode */
+	cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+
+	if (!cfi->numchips) {
+		/* This is the first time we're called. Set up the CFI 
+		   stuff accordingly and return */
+		
+		cfi->mfr = jedec_read_mfr(map, base, cfi);
+		cfi->id = jedec_read_id(map, base, cfi);
+		printk(KERN_INFO "Search for id:(%02x %02x) interleave(%d) type(%d)\n", 
+			cfi->mfr, cfi->id, cfi->interleave, cfi->device_type);
+		for (i=0; i<sizeof(jedec_table)/sizeof(jedec_table[0]); i++) {
+			if (cfi->mfr == jedec_table[i].mfr_id &&
+			    cfi->id == jedec_table[i].dev_id) {
+				if (!cfi_jedec_setup(cfi, i))
+					return 0;
+				goto ok_out;
+			}
+		}
+		if (!retried++) {
+			cfi->addr_unlock1 |= cfi->addr_unlock1 << 4;
+			cfi->addr_unlock2 |= cfi->addr_unlock2 << 4;
+			goto retry;
+		}
+		return 0;
+	}
+	
+	/* Check each previous chip to see if it's an alias */
+	for (i=0; i<cfi->numchips; i++) {
+		/* This chip should be in read mode if it's one
+		   we've already touched. */
+		if (jedec_read_mfr(map, chips[i].start, cfi) == cfi->mfr &&
+		    jedec_read_id(map, chips[i].start, cfi) == cfi->id) {
+			/* Eep. This chip also looks like it's in autoselect mode.
+			   Is it an alias for the new one? */
+			jedec_reset(chips[i].start, map, cfi);
+
+			/* If the device IDs go away, it's an alias */
+			if (jedec_read_mfr(map, base, cfi) != cfi->mfr ||
+			    jedec_read_id(map, base, cfi) != cfi->id) {
+				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+				       map->name, base, chips[i].start);
+				return 0;
+			}
+			
+			/* Yes, it's actually got the device IDs as data. Most
+			 * unfortunate. Stick the new chip in read mode
+			 * too and if it's the same, assume it's an alias. */
+			/* FIXME: Use other modes to do a proper check */
+			jedec_reset(base, map, cfi);
+			if (jedec_read_mfr(map, base, cfi) == cfi->mfr &&
+			    jedec_read_id(map, base, cfi) == cfi->id) {
+				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+				       map->name, base, chips[i].start);
+				return 0;
+			}
+		}
+	}
+		
+	/* OK, if we got to here, then none of the previous chips appear to
+	   be aliases for the current one. */
+	if (cfi->numchips == MAX_CFI_CHIPS) {
+		printk(KERN_WARNING"%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
+		/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
+		return -1;
+	}
+	chips[cfi->numchips].start = base;
+	chips[cfi->numchips].state = FL_READY;
+	cfi->numchips++;
+		
+ok_out:
+	/* Put it back into Read Mode */
+	jedec_reset(base, map, cfi);
+
+	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit mode\n",
+	       map->name, cfi->interleave, cfi->device_type*8, base, 
+	       map->buswidth*8);
+	
+	return 1;
+}
+
+static struct chip_probe jedec_chip_probe = {
+	name: "JEDEC",
+	probe_chip: jedec_probe_chip
+};
+
+struct mtd_info *jedec_probe(struct map_info *map)
+{
+	/*
+	 * Just use the generic probe stuff to call our CFI-specific
+	 * chip_probe routine in all the possible permutations, etc.
+	 */
+	return mtd_do_chip_probe(map, &jedec_chip_probe);
+}
+
+static struct mtd_chip_driver jedec_chipdrv = {
+	probe: jedec_probe,
+	name: "jedec_probe",
+	module: THIS_MODULE
+};
+
+int __init jedec_probe_init(void)
+{
+	register_mtd_chip_driver(&jedec_chipdrv);
+	return 0;
+}
+
+static void __exit jedec_probe_exit(void)
+{
+	unregister_mtd_chip_driver(&jedec_chipdrv);
+}
+
+module_init(jedec_probe_init);
+module_exit(jedec_probe_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Erwin Authried <eauth@softsys.co.at> et al.");
+MODULE_DESCRIPTION("Probe code for JEDEC-compliant flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/map_absent.c linux-2.4.2/drivers/mtd/chips/map_absent.c
--- linux-2.4.2.orig/drivers/mtd/chips/map_absent.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/map_absent.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,116 @@
+/*
+ * Common code to handle absent "placeholder" devices
+ * Copyright 2001 Resilience Corporation <ebrower@resilience.com>
+ * $Id: map_absent.c,v 1.2 2001/10/02 15:05:12 dwmw2 Exp $
+ *
+ * This map driver is used to allocate "placeholder" MTD
+ * devices on systems that have socketed/removable media. 
+ * Use of this driver as a fallback preserves the expected 
+ * registration of MTD device nodes regardless of probe outcome.
+ * A usage example is as follows:
+ *
+ *		my_dev[i] = do_map_probe("cfi", &my_map[i]);
+ *		if(NULL == my_dev[i]) {
+ *			my_dev[i] = do_map_probe("map_absent", &my_map[i]);
+ *		}
+ *
+ * Any device 'probed' with this driver will return -ENODEV
+ * upon open.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/map.h>
+
+
+static int map_absent_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int map_absent_write (struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int map_absent_erase (struct mtd_info *, struct erase_info *);
+static void map_absent_sync (struct mtd_info *);
+static struct mtd_info *map_absent_probe(struct map_info *map);
+static void map_absent_destroy (struct mtd_info *);
+
+
+static struct mtd_chip_driver map_absent_chipdrv = {
+	probe: 		map_absent_probe,
+	destroy:	map_absent_destroy,
+	name: 		"map_absent",
+	module: 	THIS_MODULE
+};
+
+static struct mtd_info *map_absent_probe(struct map_info *map)
+{
+	struct mtd_info *mtd;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		return NULL;
+	}
+
+	memset(mtd, 0, sizeof(*mtd));
+
+	map->fldrv 	= &map_absent_chipdrv;
+	mtd->priv 	= map;
+	mtd->name 	= map->name;
+	mtd->type 	= MTD_ABSENT;
+	mtd->size 	= map->size;
+	mtd->erase 	= map_absent_erase;
+	mtd->read 	= map_absent_read;
+	mtd->write 	= map_absent_write;
+	mtd->sync 	= map_absent_sync;
+	mtd->flags 	= 0;
+	mtd->erasesize = PAGE_SIZE;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+
+static int map_absent_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	*retlen = 0;
+	return -ENODEV;
+}
+
+static int map_absent_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	*retlen = 0;
+	return -ENODEV; 
+}
+
+static int map_absent_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	return -ENODEV;
+}
+
+static void map_absent_sync(struct mtd_info *mtd)
+{
+	/* nop */
+}
+
+static void map_absent_destroy(struct mtd_info *mtd)
+{
+	/* nop */
+}
+
+int __init map_absent_init(void)
+{
+	register_mtd_chip_driver(&map_absent_chipdrv);
+	return 0;
+}
+
+static void __exit map_absent_exit(void)
+{
+	unregister_mtd_chip_driver(&map_absent_chipdrv);
+}
+
+module_init(map_absent_init);
+module_exit(map_absent_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Resilience Corporation - Eric Brower <ebrower@resilience.com>");
+MODULE_DESCRIPTION("Placeholder MTD chip driver for 'absent' chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/map_ram.c linux-2.4.2/drivers/mtd/chips/map_ram.c
--- linux-2.4.2.orig/drivers/mtd/chips/map_ram.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/map_ram.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,137 @@
+/*
+ * Common code to handle map devices which are simple RAM
+ * (C) 2000 Red Hat. GPL'd.
+ * $Id: map_ram.c,v 1.14 2001/10/02 15:05:12 dwmw2 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/map.h>
+
+
+static int mapram_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int mapram_write (struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int mapram_erase (struct mtd_info *, struct erase_info *);
+static void mapram_nop (struct mtd_info *);
+static struct mtd_info *map_ram_probe(struct map_info *map);
+
+
+static struct mtd_chip_driver mapram_chipdrv = {
+	probe: map_ram_probe,
+	name: "map_ram",
+	module: THIS_MODULE
+};
+
+static struct mtd_info *map_ram_probe(struct map_info *map)
+{
+	struct mtd_info *mtd;
+
+	/* Check the first byte is RAM */
+#if 0
+	map->write8(map, 0x55, 0);
+	if (map->read8(map, 0) != 0x55)
+		return NULL;
+
+	map->write8(map, 0xAA, 0);
+	if (map->read8(map, 0) != 0xAA)
+		return NULL;
+
+	/* Check the last byte is RAM */
+	map->write8(map, 0x55, map->size-1);
+	if (map->read8(map, map->size-1) != 0x55)
+		return NULL;
+
+	map->write8(map, 0xAA, map->size-1);
+	if (map->read8(map, map->size-1) != 0xAA)
+		return NULL;
+#endif
+	/* OK. It seems to be RAM. */
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+
+	map->fldrv = &mapram_chipdrv;
+	mtd->priv = map;
+	mtd->name = map->name;
+	mtd->type = MTD_RAM;
+	mtd->size = map->size;
+	mtd->erase = mapram_erase;
+	mtd->read = mapram_read;
+	mtd->write = mapram_write;
+	mtd->sync = mapram_nop;
+	mtd->flags = MTD_CAP_RAM | MTD_VOLATILE;
+
+	mtd->erasesize = PAGE_SIZE;
+ 	while(mtd->size & (mtd->erasesize - 1))
+		mtd->erasesize >>= 1;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+
+static int mapram_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = (struct map_info *)mtd->priv;
+
+	map->copy_from(map, buf, from, len);
+	*retlen = len;
+	return 0;
+}
+
+static int mapram_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = (struct map_info *)mtd->priv;
+
+	map->copy_to(map, to, buf, len);
+	*retlen = len;
+	return 0;
+}
+
+static int mapram_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	/* Yeah, it's inefficient. Who cares? It's faster than a _real_
+	   flash erase. */
+	struct map_info *map = (struct map_info *)mtd->priv;
+	unsigned long i;
+
+	for (i=0; i<instr->len; i++)
+		map->write8(map, 0xFF, instr->addr + i);
+
+	if (instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+static void mapram_nop(struct mtd_info *mtd)
+{
+	/* Nothing to see here */
+}
+
+int __init map_ram_init(void)
+{
+	register_mtd_chip_driver(&mapram_chipdrv);
+	return 0;
+}
+
+static void __exit map_ram_exit(void)
+{
+	unregister_mtd_chip_driver(&mapram_chipdrv);
+}
+
+module_init(map_ram_init);
+module_exit(map_ram_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD chip driver for RAM chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/map_rom.c linux-2.4.2/drivers/mtd/chips/map_rom.c
--- linux-2.4.2.orig/drivers/mtd/chips/map_rom.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/map_rom.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,93 @@
+/*
+ * Common code to handle map devices which are simple ROM
+ * (C) 2000 Red Hat. GPL'd.
+ * $Id: map_rom.c,v 1.17 2001/10/02 15:05:12 dwmw2 Exp $
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/map.h>
+
+static int maprom_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int maprom_write (struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static void maprom_nop (struct mtd_info *);
+struct mtd_info *map_rom_probe(struct map_info *map);
+
+static struct mtd_chip_driver maprom_chipdrv = {
+	probe: map_rom_probe,
+	name: "map_rom",
+	module: THIS_MODULE
+};
+
+struct mtd_info *map_rom_probe(struct map_info *map)
+{
+	struct mtd_info *mtd;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+
+	map->fldrv = &maprom_chipdrv;
+	mtd->priv = map;
+	mtd->name = map->name;
+	mtd->type = MTD_ROM;
+	mtd->size = map->size;
+	mtd->read = maprom_read;
+	mtd->write = maprom_write;
+	mtd->sync = maprom_nop;
+	mtd->flags = MTD_CAP_ROM;
+	mtd->erasesize = 131072;
+ 	while(mtd->size & (mtd->erasesize - 1))
+		mtd->erasesize >>= 1;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+
+static int maprom_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = (struct map_info *)mtd->priv;
+
+	map->copy_from(map, buf, from, len);
+	*retlen = len;
+	return 0;
+}
+
+static void maprom_nop(struct mtd_info *mtd)
+{
+	/* Nothing to see here */
+}
+
+static int maprom_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	printk(KERN_NOTICE "maprom_write called\n");
+	return -EIO;
+}
+
+int __init map_rom_init(void)
+{
+	register_mtd_chip_driver(&maprom_chipdrv);
+	return 0;
+}
+
+static void __exit map_rom_exit(void)
+{
+	unregister_mtd_chip_driver(&maprom_chipdrv);
+}
+
+module_init(map_rom_init);
+module_exit(map_rom_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD chip driver for ROM chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/chips/sharp.c linux-2.4.2/drivers/mtd/chips/sharp.c
--- linux-2.4.2.orig/drivers/mtd/chips/sharp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/chips/sharp.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,593 @@
+/*
+ * MTD chip driver for pre-CFI Sharp flash chips
+ *
+ * Copyright 2000,2001 David A. Schleef <ds@schleef.org>
+ *           2000,2001 Lineo, Inc.
+ *
+ * $Id: sharp.c,v 1.6 2001/10/02 15:05:12 dwmw2 Exp $
+ *
+ * Devices supported:
+ *   LH28F016SCT Symmetrical block flash memory, 2Mx8
+ *   LH28F008SCT Symmetrical block flash memory, 1Mx8
+ *
+ * Documentation:
+ *   http://www.sharpmeg.com/datasheets/memic/flashcmp/
+ *   http://www.sharpmeg.com/datasheets/memic/flashcmp/01symf/16m/016sctl9.pdf
+ *   016sctl9.pdf
+ *
+ * Limitations:
+ *   This driver only supports 4x1 arrangement of chips.
+ *   Not tested on anything but PowerPC.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/delay.h>
+
+#define CMD_RESET		0xffffffff
+#define CMD_READ_ID		0x90909090
+#define CMD_READ_STATUS		0x70707070
+#define CMD_CLEAR_STATUS	0x50505050
+#define CMD_BLOCK_ERASE_1	0x20202020
+#define CMD_BLOCK_ERASE_2	0xd0d0d0d0
+#define CMD_BYTE_WRITE		0x40404040
+#define CMD_SUSPEND		0xb0b0b0b0
+#define CMD_RESUME		0xd0d0d0d0
+#define CMD_SET_BLOCK_LOCK_1	0x60606060
+#define CMD_SET_BLOCK_LOCK_2	0x01010101
+#define CMD_SET_MASTER_LOCK_1	0x60606060
+#define CMD_SET_MASTER_LOCK_2	0xf1f1f1f1
+#define CMD_CLEAR_BLOCK_LOCKS_1	0x60606060
+#define CMD_CLEAR_BLOCK_LOCKS_2	0xd0d0d0d0
+
+#define SR_READY		0x80808080 // 1 = ready
+#define SR_ERASE_SUSPEND	0x40404040 // 1 = block erase suspended
+#define SR_ERROR_ERASE		0x20202020 // 1 = error in block erase or clear lock bits
+#define SR_ERROR_WRITE		0x10101010 // 1 = error in byte write or set lock bit
+#define	SR_VPP			0x08080808 // 1 = Vpp is low
+#define SR_WRITE_SUSPEND	0x04040404 // 1 = byte write suspended
+#define SR_PROTECT		0x02020202 // 1 = lock bit set
+#define SR_RESERVED		0x01010101
+
+#define SR_ERRORS (SR_ERROR_ERASE|SR_ERROR_WRITE|SR_VPP|SR_PROTECT)
+
+/* Configuration options */
+
+#undef AUTOUNLOCK  /* automatically unlocks blocks before erasing */
+
+struct mtd_info *sharp_probe(struct map_info *);
+
+static int sharp_probe_map(struct map_info *map,struct mtd_info *mtd);
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf);
+static int sharp_write(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, const u_char *buf);
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr);
+static void sharp_sync(struct mtd_info *mtd);
+static int sharp_suspend(struct mtd_info *mtd);
+static void sharp_resume(struct mtd_info *mtd);
+static void sharp_destroy(struct mtd_info *mtd);
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum);
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+#ifdef AUTOUNLOCK
+static void sharp_unlock_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+#endif
+
+
+struct sharp_info{
+	struct flchip *chip;
+	int bogus;
+	int chipshift;
+	int numchips;
+	struct flchip chips[1];
+};
+
+struct mtd_info *sharp_probe(struct map_info *map);
+static void sharp_destroy(struct mtd_info *mtd);
+
+static struct mtd_chip_driver sharp_chipdrv = {
+	probe: sharp_probe,
+	destroy: sharp_destroy,
+	name: "sharp",
+	module: THIS_MODULE
+};
+
+
+struct mtd_info *sharp_probe(struct map_info *map)
+{
+	struct mtd_info *mtd = NULL;
+	struct sharp_info *sharp = NULL;
+	int width;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if(!mtd)
+		return NULL;
+
+	sharp = kmalloc(sizeof(*sharp), GFP_KERNEL);
+	if(!sharp)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+
+	width = sharp_probe_map(map,mtd);
+	if(!width){
+		kfree(mtd);
+		kfree(sharp);
+		return NULL;
+	}
+
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	mtd->erase = sharp_erase;
+	mtd->read = sharp_read;
+	mtd->write = sharp_write;
+	mtd->sync = sharp_sync;
+	mtd->suspend = sharp_suspend;
+	mtd->resume = sharp_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+
+	memset(sharp, 0, sizeof(*sharp));
+	sharp->chipshift = 23;
+	sharp->numchips = 1;
+	sharp->chips[0].start = 0;
+	sharp->chips[0].state = FL_READY;
+	sharp->chips[0].mutex = &sharp->chips[0]._spinlock;
+	sharp->chips[0].word_write_time = 0;
+	init_waitqueue_head(&sharp->chips[0].wq);
+	spin_lock_init(&sharp->chips[0]._spinlock);
+
+	map->fldrv = &sharp_chipdrv;
+	map->fldrv_priv = sharp;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+static int sharp_probe_map(struct map_info *map,struct mtd_info *mtd)
+{
+	unsigned long tmp;
+	unsigned long base = 0;
+	u32 read0, read4;
+	int width = 4;
+
+	tmp = map->read32(map, base+0);
+
+	map->write32(map, CMD_READ_ID, base+0);
+
+	read0=map->read32(map, base+0);
+	read4=map->read32(map, base+4);
+	if(read0 == 0x89898989){
+		printk("Looks like sharp flash\n");
+		switch(read4){
+		case 0xaaaaaaaa:
+		case 0xa0a0a0a0:
+			/* aa - LH28F016SCT-L95 2Mx8, 32 64k blocks*/
+			/* a0 - LH28F016SCT-Z4  2Mx8, 32 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x200000 * width;
+			return width;
+		case 0xa6a6a6a6:
+			/* a6 - LH28F008SCT-L12 1Mx8, 16 64k blocks*/
+			/* a6 - LH28F008SCR-L85 1Mx8, 16 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x100000 * width;
+			return width;
+#if 0
+		case 0x00000000: /* unknown */
+			/* XX - LH28F004SCT 512kx8, 8 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x80000 * width;
+			return width;
+#endif
+		default:
+			printk("Sort-of looks like sharp flash, 0x%08x 0x%08x\n",
+				read0,read4);
+		}
+	}else if((map->read32(map, base+0) == CMD_READ_ID)){
+		/* RAM, probably */
+		printk("Looks like RAM\n");
+		map->write32(map, tmp, base+0);
+	}else{
+		printk("Doesn't look like sharp flash, 0x%08x 0x%08x\n",
+			read0,read4);
+	}
+
+	return 0;
+}
+
+/* This function returns with the chip->mutex lock held. */
+static int sharp_wait(struct map_info *map, struct flchip *chip)
+{
+	__u16 status;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+	int adr = 0;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	switch(chip->state){
+	case FL_READY:
+		map->write32(map,CMD_READ_STATUS,adr);
+		chip->state = FL_STATUS;
+	case FL_STATUS:
+		status = map->read32(map,adr);
+//printk("status=%08x\n",status);
+
+		udelay(100);
+		if((status & SR_READY)!=SR_READY){
+//printk(".status=%08x\n",status);
+			udelay(100);
+		}
+		break;
+	default:
+		printk("Waiting for chip\n");
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	map->write32(map,CMD_RESET, adr);
+
+	chip->state = FL_READY;
+
+	return 0;
+}
+
+static void sharp_release(struct flchip *chip)
+{
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+}
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int chipnum;
+	int ret = 0;
+	int ofs = 0;
+
+	chipnum = (from >> sharp->chipshift);
+	ofs = from & ((1 << sharp->chipshift)-1);
+
+	*retlen = 0;
+
+	while(len){
+		unsigned long thislen;
+
+		if(chipnum>=sharp->numchips)
+			break;
+
+		thislen = len;
+		if(ofs+thislen >= (1<<sharp->chipshift))
+			thislen = (1<<sharp->chipshift) - ofs;
+
+		ret = sharp_wait(map,&sharp->chips[chipnum]);
+		if(ret<0)
+			break;
+
+		map->copy_from(map,buf,ofs,thislen);
+
+		sharp_release(&sharp->chips[chipnum]);
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int sharp_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int ret = 0;
+	int i,j;
+	int chipnum;
+	unsigned long ofs;
+	union { u32 l; unsigned char uc[4]; } tbuf;
+
+	*retlen = 0;
+
+	while(len){
+		tbuf.l = 0xffffffff;
+		chipnum = to >> sharp->chipshift;
+		ofs = to & ((1<<sharp->chipshift)-1);
+
+		j=0;
+		for(i=ofs&3;i<4 && len;i++){
+			tbuf.uc[i] = *buf;
+			buf++;
+			to++;
+			len--;
+			j++;
+		}
+		sharp_write_oneword(map, &sharp->chips[chipnum], ofs&~3, tbuf.l);
+		if(ret<0)
+			return ret;
+		(*retlen)+=j;
+	}
+
+	return 0;
+}
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum)
+{
+	int ret;
+	int timeo;
+	int try;
+	int i;
+	int status = 0;
+
+	ret = sharp_wait(map,chip);
+
+	for(try=0;try<10;try++){
+		map->write32(map,CMD_BYTE_WRITE,adr);
+		/* cpu_to_le32 -> hack to fix the writel be->le conversion */
+		map->write32(map,cpu_to_le32(datum),adr);
+
+		chip->state = FL_WRITING;
+
+		timeo = jiffies + (HZ/2);
+
+		map->write32(map,CMD_READ_STATUS,adr);
+		for(i=0;i<100;i++){
+			status = map->read32(map,adr);
+			if((status & SR_READY)==SR_READY)
+				break;
+		}
+		if(i==100){
+			printk("sharp: timed out writing\n");
+		}
+
+		if(!(status&SR_ERRORS))
+			break;
+
+		printk("sharp: error writing byte at addr=%08lx status=%08x\n",adr,status);
+
+		map->write32(map,CMD_CLEAR_STATUS,adr);
+	}
+	map->write32(map,CMD_RESET,adr);
+	chip->state = FL_READY;
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	unsigned long adr,len;
+	int chipnum, ret=0;
+
+//printk("sharp_erase()\n");
+	if(instr->addr & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len + instr->addr > mtd->size)
+		return -EINVAL;
+
+	chipnum = instr->addr >> sharp->chipshift;
+	adr = instr->addr & ((1<<sharp->chipshift)-1);
+	len = instr->len;
+
+	while(len){
+		ret = sharp_erase_oneblock(map, &sharp->chips[chipnum], adr);
+		if(ret)return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+		if(adr >> sharp->chipshift){
+			adr = 0;
+			chipnum++;
+			if(chipnum>=sharp->numchips)
+				break;
+		}
+	}
+
+	if(instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+static int sharp_do_wait_for_ready(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	int timeo;
+	int status;
+	DECLARE_WAITQUEUE(wait, current);
+
+	map->write32(map,CMD_READ_STATUS,adr);
+	status = map->read32(map,adr);
+
+	timeo = jiffies + HZ;
+
+	while(jiffies<timeo){
+		map->write32(map,CMD_READ_STATUS,adr);
+		status = map->read32(map,adr);
+		if((status & SR_READY)==SR_READY){
+			ret = 0;
+			goto out;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		//spin_unlock_bh(chip->mutex);
+
+		schedule_timeout(1);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		//spin_lock_bh(chip->mutex);
+		
+		if (signal_pending(current)){
+			ret = -EINTR;
+			goto out;
+		}
+		
+	}
+	ret = -ETIME;
+out:
+	return ret;
+}
+
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	//int timeo;
+	int status;
+	//int i;
+
+//printk("sharp_erase_oneblock()\n");
+
+#ifdef AUTOUNLOCK
+	/* This seems like a good place to do an unlock */
+	sharp_unlock_oneblock(map,chip,adr);
+#endif
+
+	map->write32(map,CMD_BLOCK_ERASE_1,adr);
+	map->write32(map,CMD_BLOCK_ERASE_2,adr);
+
+	chip->state = FL_ERASING;
+
+	ret = sharp_do_wait_for_ready(map,chip,adr);
+	if(ret<0)return ret;
+
+	map->write32(map,CMD_READ_STATUS,adr);
+	status = map->read32(map,adr);
+
+	if(!(status&SR_ERRORS)){
+		map->write32(map,CMD_RESET,adr);
+		chip->state = FL_READY;
+		//spin_unlock_bh(chip->mutex);
+		return 0;
+	}
+
+	printk("sharp: error erasing block at addr=%08lx status=%08x\n",adr,status);
+	map->write32(map,CMD_CLEAR_STATUS,adr);
+
+	//spin_unlock_bh(chip->mutex);
+
+	return -EIO;
+}
+
+#ifdef AUTOUNLOCK
+static void sharp_unlock_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int i;
+	int status;
+
+	map->write32(map,CMD_CLEAR_BLOCK_LOCKS_1,adr);
+	map->write32(map,CMD_CLEAR_BLOCK_LOCKS_2,adr);
+
+	udelay(100);
+
+	status = map->read32(map,adr);
+	printk("status=%08x\n",status);
+
+	for(i=0;i<1000;i++){
+		//map->write32(map,CMD_READ_STATUS,adr);
+		status = map->read32(map,adr);
+		if((status & SR_READY)==SR_READY)
+			break;
+		udelay(100);
+	}
+	if(i==1000){
+		printk("sharp: timed out unlocking block\n");
+	}
+
+	if(!(status&SR_ERRORS)){
+		map->write32(map,CMD_RESET,adr);
+		chip->state = FL_READY;
+		return;
+	}
+
+	printk("sharp: error unlocking block at addr=%08lx status=%08x\n",adr,status);
+	map->write32(map,CMD_CLEAR_STATUS,adr);
+}
+#endif
+
+static void sharp_sync(struct mtd_info *mtd)
+{
+	//printk("sharp_sync()\n");
+}
+
+static int sharp_suspend(struct mtd_info *mtd)
+{
+	printk("sharp_suspend()\n");
+	return -EINVAL;
+}
+
+static void sharp_resume(struct mtd_info *mtd)
+{
+	printk("sharp_resume()\n");
+	
+}
+
+static void sharp_destroy(struct mtd_info *mtd)
+{
+	printk("sharp_destroy()\n");
+
+}
+
+int __init sharp_probe_init(void)
+{
+	printk("MTD Sharp chip driver <ds@lineo.com>\n");
+
+	register_mtd_chip_driver(&sharp_chipdrv);
+
+	return 0;
+}
+
+static void __exit sharp_probe_exit(void)
+{
+	unregister_mtd_chip_driver(&sharp_chipdrv);
+}
+
+module_init(sharp_probe_init);
+module_exit(sharp_probe_exit);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Schleef <ds@schleef.org>");
+MODULE_DESCRIPTION("Old MTD chip driver for pre-CFI Sharp flash chips");
diff -Naur linux-2.4.2.orig/drivers/mtd/cstm_cfi_jedec.c linux-2.4.2/drivers/mtd/cstm_cfi_jedec.c
--- linux-2.4.2.orig/drivers/mtd/cstm_cfi_jedec.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cstm_cfi_jedec.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,339 @@
+/*
+ * $Id: cstm_cfi_jedec.c,v 1.5 2001/03/17 19:18:42 dwmw2 Exp $
+ *
+ * Mapping of a custom board with both AMD CFI and JEDEC flash in partitions.
+ * Config with both CFI and JEDEC device support.
+ *
+ * Basically physmap.c with the addition of partitions and 
+ * an array of mapping info to accomodate more than one flash type per board.
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#include <linux/delay.h>
+#endif
+
+__u8 cstm_cfi_jedec_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+__u16 cstm_cfi_jedec_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+__u32 cstm_cfi_jedec_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+void cstm_cfi_jedec_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cstm_cfi_jedec_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define CC_GCR             0xB4013818
+#define CC_GPBCR           0xB401380A
+#define CC_GPBDR           0xB4013808
+#define CC_M68K_DEVICE     1
+#define CC_M68K_FUNCTION   6
+#define CC_CONFADDR        0xB8004000
+#define CC_CONFDATA        0xB8004004
+#define CC_FC_FCR          0xB8002004
+#define CC_FC_DCR          0xB8002008
+#define CC_GPACR           0xB4013802
+#define CC_GPAICR          0xB4013804
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+void cstm_cfi_jedec_set_vpp(struct map_info *map,int vpp)
+{
+  if (vpp) {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+        __u8	data1;
+	static u8 first = 1;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff0f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) | 0x08;
+	if (first) {
+		first = 0;
+		/* need to have this delay for first
+		   enabling vpp after powerup */
+		udelay(40);
+	}
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+  else {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff3f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) & 0xf7;
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+}
+
+const struct map_info basic_cstm_cfi_jedec_map = {
+	NULL,
+	0,
+	0,
+	cstm_cfi_jedec_read8,
+	cstm_cfi_jedec_read16,
+	cstm_cfi_jedec_read32,
+	cstm_cfi_jedec_copy_from,
+	cstm_cfi_jedec_write8,
+	cstm_cfi_jedec_write16,
+	cstm_cfi_jedec_write32,
+	cstm_cfi_jedec_copy_to,
+        cstm_cfi_jedec_set_vpp,
+	0,
+	0
+};
+
+/* board and partition description */
+
+#define MAX_PHYSMAP_PARTITIONS    8
+struct cstm_cfi_jedec_info {
+	char *name;
+	unsigned long window_addr;
+	unsigned long window_size;
+	int buswidth;
+	int num_partitions;
+};
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define PHYSMAP_NUMBER  1  // number of physmap_info structs needed
+const struct cstm_cfi_jedec_info cstm_cfi_jedec_board_desc[PHYSMAP_NUMBER] = 
+{
+    {   // 28F128J3A in 2x16 configuration
+        "big flash",     // name
+	0x08000000,      // window_addr
+	0x02000000,      // window_size
+        4,               // buswidth
+	1,               // num_partitions
+    }
+
+};
+static struct mtd_partition cstm_cfi_jedec_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{   // 28F128J3A in 2x16 configuration
+	{
+		name: "main partition ",
+		size: 0x02000000, // 128 x 2 x 128k byte sectors
+		offset: 0,
+	},
+},
+};
+#else /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+#define PHYSMAP_NUMBER  2  // number of cstm_cfi_jedec_info structs needed, one per contiguous flash type 
+const struct cstm_cfi_jedec_info cstm_cfi_jedec_board_desc[PHYSMAP_NUMBER] = 
+{
+    {   // Am29DL323D in 2x16 configuration - CFI flash
+        "big flash",                   // name
+	0x40000000,      // window_addr
+	0x00800000,      // window_size
+        4,               // buswidth
+	2,                             // num_partitions
+    },
+    {   // Am29W040B in 1x8 configuration - JEDEC flash
+        "boot flash",    // name
+	0xfff80000,      // window_addr
+	0x00060000,      // window_size
+        1,               // buswidth
+	2,               // num_partitions
+    },
+
+};
+static struct mtd_partition cstm_cfi_jedec_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{  // Am29DL323D in 2x16 configuration
+	{
+		name: "big flash 128k sectors",
+		size: 0x007E0000, // 63 x (2 x 64k) byte sectors
+		offset: 0,
+	},
+	{
+		name: "big flash 16k sectors",
+		size: 0x00020000, // 8  x (2 x 8k)  byte sectors
+		offset: 0x007E0000,
+	},
+},
+{  // Am29W040B in 1x8 configuration  
+	{
+		name: "boot environment",
+		size: 0x00010000, // 1 x 64k byte sectors
+		offset: 0
+	},
+	{
+		name: "boot flash sectors",
+		size: 0x00050000, // 5 x 64k byte sectors
+		offset: 0x10000
+	},
+	// leaving last 2 sectors of flash unaccessable by this driver
+}
+};
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+struct map_info cstm_cfi_jedec_map[PHYSMAP_NUMBER];
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_cstm_cfi_jedec init_module
+#define cleanup_cstm_cfi_jedec cleanup_module
+#endif
+
+int __init init_cstm_cfi_jedec(void)
+{
+	int i;
+	int jedec;
+        struct mtd_info *mymtd;
+        struct mtd_partition *parts;
+
+	/* Initialize mapping */
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+		printk(KERN_NOTICE "cstm_cfi_jedec flash device: %lx at %lx\n", cstm_cfi_jedec_board_desc[i].window_size, cstm_cfi_jedec_board_desc[i].window_addr);
+                memcpy((char *)&cstm_cfi_jedec_map[i],(char *)&basic_cstm_cfi_jedec_map,sizeof(struct map_info));
+		cstm_cfi_jedec_map[i].map_priv_1 = (unsigned long)ioremap(cstm_cfi_jedec_board_desc[i].window_addr, cstm_cfi_jedec_board_desc[i].window_size);
+		if (!cstm_cfi_jedec_map[i].map_priv_1) {
+			printk(KERN_WARNING "Failed to ioremap\n");
+			return -EIO;
+	        }
+		cstm_cfi_jedec_map[i].name = cstm_cfi_jedec_board_desc[i].name;
+		cstm_cfi_jedec_map[i].size = cstm_cfi_jedec_board_desc[i].window_size;
+		cstm_cfi_jedec_map[i].buswidth = cstm_cfi_jedec_board_desc[i].buswidth;
+		//printk(KERN_NOTICE "cstm_cfi_jedec: ioremap is %x\n",(unsigned int)(cstm_cfi_jedec_map[i].map_priv_1));
+	}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        setup_ITE_IVR_flash();
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+                parts = &cstm_cfi_jedec_partitions[i][0];
+		jedec = 0;
+		mymtd = (struct mtd_info *)do_cfi_probe(&cstm_cfi_jedec_map[i]);
+		//printk(KERN_NOTICE "phymap %d cfi_probe: mymtd is %x\n",i,(unsigned int)mymtd);
+		if (!mymtd) {
+			jedec = 1;
+			mymtd = (struct mtd_info *)do_jedec_probe(&cstm_cfi_jedec_map[i]);
+		        printk(KERN_NOTICE "cstm_cfi_jedec %d jedec: mymtd is %x\n",i,(unsigned int)mymtd);
+		}
+		if (mymtd) {
+			mymtd->module = THIS_MODULE;
+
+	                cstm_cfi_jedec_map[i].map_priv_2 = (unsigned long)mymtd;
+		        add_mtd_partitions(mymtd, parts, cstm_cfi_jedec_board_desc[i].num_partitions);
+		}
+		else
+	           return -ENXIO;
+	}
+	return 0;
+}
+
+static void __exit cleanup_cstm_cfi_jedec(void)
+{
+	int i;
+        struct mtd_info *mymtd;
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+	        mymtd = (struct mtd_info *)cstm_cfi_jedec_map[i].map_priv_2;
+		if (mymtd) {
+			del_mtd_partitions(mymtd);
+			map_destroy(mymtd);
+		}
+		if (cstm_cfi_jedec_map[i].map_priv_1) {
+			iounmap((void *)cstm_cfi_jedec_map[i].map_priv_1);
+			cstm_cfi_jedec_map[i].map_priv_1 = 0;
+		}
+	}
+}
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+void PCISetULongByOffset(__u32 DevNumber, __u32 FuncNumber, __u32 Offset, __u32 data)
+{
+	__u32	offset;
+
+	offset = ( unsigned long )( 0x80000000 | ( DevNumber << 11 ) + ( FuncNumber << 8 ) + Offset) ;
+
+	*(__u32 *)CC_CONFADDR = offset;	
+	*(__u32 *)CC_CONFDATA = data;
+}
+void setup_ITE_IVR_flash()
+{
+		__u32	size, base;
+
+		size = 0x0e000000;		// 32MB byte
+		base = (0x08000000) >> 8 >>1; // Bug: we must shift one more bit
+
+		/* need to set ITE flash to 32 bits instead of default 8 */
+#ifdef CONFIG_MIPS_IVR
+		*(__u32 *)CC_FC_FCR = 0x55;
+		*(__u32 *)CC_GPACR = 0xfffc;
+#else
+		*(__u32 *)CC_FC_FCR = 0x77;
+#endif
+		/* turn bursting off */
+		*(__u32 *)CC_FC_DCR = 0x0;
+
+		/* setup for one chip 4 byte PCI access */
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x60, size | base);
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x64, 0x02);
+}
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+module_init(init_cstm_cfi_jedec);
+module_exit(cleanup_cstm_cfi_jedec);
diff -Naur linux-2.4.2.orig/drivers/mtd/dc21285.c linux-2.4.2/drivers/mtd/dc21285.c
--- linux-2.4.2.orig/drivers/mtd/dc21285.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/dc21285.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,193 @@
+/*
+ * MTD map driver for flash on the DC21285 (the StrongARM-110 companion chip)
+ *
+ * (C) 2000  Nicolas Pitre <nico@cam.org>
+ *
+ * This code is GPL
+ * 
+ * $Id: dc21285.c,v 1.3 2001/03/17 17:10:21 dwmw2 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/hardware/dec21285.h>
+
+
+static struct mtd_info *mymtd;
+
+__u8 dc21285_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8*)(map->map_priv_1 + ofs);
+}
+
+__u16 dc21285_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16*)(map->map_priv_1 + ofs);
+}
+
+__u32 dc21285_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32*)(map->map_priv_1 + ofs);
+}
+
+void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void*)(map->map_priv_1 + from), len);
+}
+
+void dc21285_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr;
+	adr &= ~3;
+	*(__u8*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr;
+	adr &= ~1;
+	*(__u16*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	switch (map->buswidth) {
+		case 4:
+			while (len > 0) {
+				__u32 d = *((__u32*)from)++;
+				dc21285_write32(map, d, to);
+				to += 4;
+				len -= 4;
+			}
+			break;
+		case 2:
+			while (len > 0) {
+				__u16 d = *((__u16*)from)++;
+				dc21285_write16(map, d, to);
+				to += 2;
+				len -= 2;
+			}
+			break;
+		case 1:
+			while (len > 0) {
+				__u8 d = *((__u8*)from)++;
+				dc21285_write8(map, d, to);
+				to++;
+				len--;
+			}
+			break;
+	}
+}
+
+struct map_info dc21285_map = {
+	name: "DC21285 flash",
+	size: 16*1024*1024,
+	read8: dc21285_read8,
+	read16: dc21285_read16,
+	read32: dc21285_read32,
+	copy_from: dc21285_copy_from,
+	write8: dc21285_write8,
+	write16: dc21285_write16,
+	write32: dc21285_write32,
+	copy_to: dc21285_copy_to
+};
+
+
+/* Partition stuff */
+static struct mtd_partition *dc21285_parts;
+		      
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+
+int __init init_dc21285(void)
+{
+	/* Determine buswidth */
+	switch (*CSR_SA110_CNTL & (3<<14)) {
+		case SA110_CNTL_ROMWIDTH_8: 
+			dc21285_map.buswidth = 1;
+			break;
+		case SA110_CNTL_ROMWIDTH_16: 
+			dc21285_map.buswidth = 2; 
+			break;
+		case SA110_CNTL_ROMWIDTH_32: 
+			dc21285_map.buswidth = 4; 
+			break;
+		default:
+			printk (KERN_ERR "DC21285 flash: undefined buswidth\n");
+			return -ENXIO;
+	}
+	printk (KERN_NOTICE "DC21285 flash support (%d-bit buswidth)\n",
+		dc21285_map.buswidth*8);
+
+	/* Let's map the flash area */
+	dc21285_map.map_priv_1 = (unsigned long)__ioremap(DC21285_FLASH, 16*1024*1024, 0);
+	if (!dc21285_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	mymtd = do_cfi_probe(&dc21285_map);
+	if (mymtd) {
+		int nrparts;
+
+		mymtd->module = THIS_MODULE;
+			
+		/* partition fixup */
+
+		nrparts = parse_redboot_partitions(mymtd, &dc21285_parts);
+		if (nrparts <=0) {
+			printk(KERN_NOTICE "RedBoot partition table failed\n");
+			iounmap((void *)dc21285_map.map_priv_1);
+			return -ENXIO;
+		}
+
+		add_mtd_partitions(mymtd, dc21285_parts, nrparts);
+
+		/* 
+		 * Flash timing is determined with bits 19-16 of the
+		 * CSR_SA110_CNTL.  The value is the number of wait cycles, or
+		 * 0 for 16 cycles (the default).  Cycles are 20 ns.
+		 * Here we use 7 for 140 ns flash chips.
+		 */
+		/* access time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x000f0000) | (7 << 16));
+		/* burst time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x00f00000) | (7 << 20));
+		/* tristate time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x0f000000) | (7 << 24));
+
+		return 0;
+	}
+
+	iounmap((void *)dc21285_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dc21285(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+		mymtd = NULL;
+	}
+	if (dc21285_map.map_priv_1) {
+		iounmap((void *)dc21285_map.map_priv_1);
+		dc21285_map.map_priv_1 = 0;
+	}
+	if(dc21285_parts)
+		kfree(dc21285_parts);
+}
+
+module_init(init_dc21285);
+module_exit(cleanup_dc21285);
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/Config.in linux-2.4.2/drivers/mtd/devices/Config.in
--- linux-2.4.2.orig/drivers/mtd/devices/Config.in	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/Config.in	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,55 @@
+# drivers/mtd/maps/Config.in
+
+# $Id: Config.in,v 1.5 2001/09/23 15:33:10 dwmw2 Exp $
+
+mainmenu_option next_comment
+
+comment 'Self-contained MTD device drivers'
+dep_tristate '  Ramix PMC551 PCI Mezzanine RAM card support' CONFIG_MTD_PMC551 $CONFIG_MTD $CONFIG_PCI
+if [ "$CONFIG_MTD_PMC551" = "y" -o  "$CONFIG_MTD_PMC551" = "m" ]; then
+   bool '    PMC551 256M DRAM Bugfix' CONFIG_MTD_PMC551_BUGFIX
+   bool '    PMC551 Debugging' CONFIG_MTD_PMC551_DEBUG
+fi
+dep_tristate '  Uncached system RAM' CONFIG_MTD_SLRAM $CONFIG_MTD
+if [ "$CONFIG_SA1100_LART" = "y" ]; then
+  dep_tristate '  28F160xx flash driver for LART' CONFIG_MTD_LART $CONFIG_MTD
+fi
+dep_tristate '  Test driver using RAM' CONFIG_MTD_MTDRAM $CONFIG_MTD
+if [ "$CONFIG_MTD_MTDRAM" = "y" -o "$CONFIG_MTD_MTDRAM" = "m" ]; then
+   int 'MTDRAM device size in KiB' CONFIG_MTDRAM_TOTAL_SIZE 4096
+   int 'MTDRAM erase block size in KiB' CONFIG_MTDRAM_ERASE_SIZE 128
+   if [ "$CONFIG_MTD_MTDRAM" = "y" ]; then #If not a module (I don't want to test it as a module)
+      hex 'SRAM Hexadecimal Absolute position or 0' CONFIG_MTDRAM_ABS_POS 0
+   fi
+fi
+dep_tristate '  MTD emulation using block device' CONFIG_MTD_BLKMTD $CONFIG_MTD
+
+comment 'Disk-On-Chip Device Drivers'
+   dep_tristate '  M-Systems Disk-On-Chip 1000' CONFIG_MTD_DOC1000 $CONFIG_MTD
+   dep_tristate '  M-Systems Disk-On-Chip 2000 and Millennium' CONFIG_MTD_DOC2000 $CONFIG_MTD
+   dep_tristate '  M-Systems Disk-On-Chip Millennium-only alternative driver (see help)' CONFIG_MTD_DOC2001 $CONFIG_MTD
+   if [ "$CONFIG_MTD_DOC2001" = "y" -o "$CONFIG_MTD_DOC2000" = "y" ]; then
+      define_bool CONFIG_MTD_DOCPROBE y
+   else
+      if [ "$CONFIG_MTD_DOC2001" = "m" -o "$CONFIG_MTD_DOC2000" = "m" ]; then
+	 define_bool CONFIG_MTD_DOCPROBE m
+      else
+	 define_bool CONFIG_MTD_DOCPROBE n
+      fi
+   fi
+
+   if [ "$CONFIG_MTD_DOCPROBE" = "y" -o "$CONFIG_MTD_DOCPROBE" = "m" ]; then
+      bool '    Advanced detection options for DiskOnChip' CONFIG_MTD_DOCPROBE_ADVANCED
+      if [ "$CONFIG_MTD_DOCPROBE_ADVANCED" = "n" ]; then
+         define_hex CONFIG_MTD_DOCPROBE_ADDRESS 0
+         define_bool CONFIG_MTD_DOCPROBE_HIGH n
+         define_bool CONFIG_MTD_DOCPROBE_55AA n
+      else
+         hex  '    Physical address of DiskOnChip' CONFIG_MTD_DOCPROBE_ADDRESS 0x0000
+         bool '    Probe high addresses' CONFIG_MTD_DOCPROBE_HIGH
+         bool '    Probe for 0x55 0xAA BIOS Extension Signature' CONFIG_MTD_DOCPROBE_55AA
+      fi
+   fi
+
+
+endmenu
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/GNUmakefile linux-2.4.2/drivers/mtd/devices/GNUmakefile
--- linux-2.4.2.orig/drivers/mtd/devices/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/GNUmakefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,32 @@
+# $Id: GNUmakefile,v 1.4 2001/06/23 19:34:05 dwmw2 Exp $
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+
+CONFIG_MTD_DOC1000 := m
+CONFIG_MTD_DOC2000 := m
+CONFIG_MTD_DOC2001 := m
+CONFIG_MTD_DOCPROBE := m
+CONFIG_MTD_SLRAM := m
+CONFIG_MTD_PMC551 := m
+CONFIG_MTD_MTDRAM := m
+
+CFLAGS_mtdram.o := -DCONFIG_MTDRAM_TOTAL_SIZE=4096 -DCONFIG_MTDRAM_ERASE_SIZE=128
+
+endif
+
+# Normal case - build in-kernel
+
+ifeq ($(VERSION),2)
+ ifneq ($(PATCHLEVEL),4)
+  ifneq ($(PATCHLEVEL),5)
+   OLDTOPDIR := $(TOPDIR)
+   TOPDIR := $(shell pwd)/..
+  endif
+ endif
+endif
+
+include Makefile
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/Makefile linux-2.4.2/drivers/mtd/devices/Makefile
--- linux-2.4.2.orig/drivers/mtd/devices/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/Makefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,25 @@
+#
+# linux/drivers/devices/Makefile
+#
+# $Id: Makefile,v 1.4 2001/06/26 21:10:05 spse Exp $
+
+O_TARGET	:= devlink.o
+
+#                       *** BIG UGLY NOTE ***
+#
+# The removal of get_module_symbol() and replacement with
+# inter_module_register() et al has introduced a link order dependency
+# here where previously there was none.  We now have to ensure that
+# doc200[01].o are linked before docprobe.o
+
+obj-$(CONFIG_MTD_DOC1000)	+= doc1000.o
+obj-$(CONFIG_MTD_DOC2000)	+= doc2000.o
+obj-$(CONFIG_MTD_DOC2001)	+= doc2001.o
+obj-$(CONFIG_MTD_DOCPROBE)	+= docprobe.o docecc.o
+obj-$(CONFIG_MTD_SLRAM)		+= slram.o
+obj-$(CONFIG_MTD_PMC551)	+= pmc551.o
+obj-$(CONFIG_MTD_MTDRAM)	+= mtdram.o
+obj-$(CONFIG_MTD_LART)		+= lart.o
+obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/blkmtd.c linux-2.4.2/drivers/mtd/devices/blkmtd.c
--- linux-2.4.2.orig/drivers/mtd/devices/blkmtd.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/blkmtd.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1313 @@
+/* 
+ * $Id: blkmtd.c,v 1.7 2001/11/10 17:06:30 spse Exp $
+ *
+ * blkmtd.c - use a block device as a fake MTD
+ *
+ * Author: Simon Evans <spse@secret.org.uk>
+ *
+ * Copyright (C) 2001 Simon Evans
+ * 
+ * Licence: GPL
+ *
+ * How it works:
+ *       The driver uses raw/io to read/write the device and the page
+ *       cache to cache access. Writes update the page cache with the
+ *       new data but make a copy of the new page(s) and then a kernel
+ *       thread writes pages out to the device in the background. This
+ *       ensures that writes are order even if a page is updated twice.
+ *       Also, since pages in the page cache are never marked as dirty,
+ *       we dont have to worry about writepage() being called on some 
+ *       random page which may not be in the write order.
+ * 
+ *       Erases are handled like writes, so the callback is called after
+ *       the page cache has been updated. Sync()ing will wait until it is 
+ *       all done.
+ *
+ *       It can be loaded Read-Only to prevent erases and writes to the 
+ *       medium.
+ *
+ * Todo:
+ *       Make the write queue size dynamic so this it is not too big on
+ *       small memory systems and too small on large memory systems.
+ * 
+ *       Page cache usage may still be a bit wrong. Check we are doing
+ *       everything properly.
+ * 
+ *       Somehow allow writes to dirty the page cache so we dont use too
+ *       much memory making copies of outgoing pages. Need to handle case
+ *       where page x is written to, then page y, then page x again before
+ *       any of them have been committed to disk.
+ * 
+ *       Reading should read multiple pages at once rather than using 
+ *       readpage() for each one. This is easy and will be fixed asap.
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/iobuf.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/mtd/mtd.h>
+
+#ifdef CONFIG_MTD_DEBUG
+#ifdef CONFIG_PROC_FS
+#  include <linux/proc_fs.h>
+#  define BLKMTD_PROC_DEBUG
+   static struct proc_dir_entry *blkmtd_proc;
+#endif
+#endif
+
+
+/* Default erase size in K, always make it a multiple of PAGE_SIZE */
+#define CONFIG_MTD_BLKDEV_ERASESIZE 128
+#define VERSION "1.7"
+extern int *blk_size[];
+extern int *blksize_size[];
+
+/* Info for the block device */
+typedef struct mtd_raw_dev_data_s {
+  struct block_device *binding;
+  int sector_size, sector_bits;
+  int partial_last_page;   // 0 if device ends on page boundary, else page no of last page
+  int last_page_sectors;   // Number of sectors in last page if partial_last_page != 0
+  size_t totalsize;
+  int readonly;
+  struct address_space as;
+  struct mtd_info mtd_info;
+} mtd_raw_dev_data_t;
+
+/* Info for each queue item in the write queue */
+typedef struct mtdblkdev_write_queue_s {
+  mtd_raw_dev_data_t *rawdevice;
+  struct page **pages;
+  int pagenr;
+  int pagecnt;
+  int iserase;
+} mtdblkdev_write_queue_t;
+
+
+/* Our erase page - always remains locked. */
+static struct page *erase_page;
+
+/* Static info about the MTD, used in cleanup_module */
+static mtd_raw_dev_data_t *mtd_rawdevice;
+
+/* Write queue fixed size */
+#define WRITE_QUEUE_SZ 512
+
+/* Storage for the write queue */
+static mtdblkdev_write_queue_t *write_queue;
+static int write_queue_sz = WRITE_QUEUE_SZ;
+static int volatile write_queue_head;
+static int volatile write_queue_tail;
+static int volatile write_queue_cnt;
+static spinlock_t mbd_writeq_lock = SPIN_LOCK_UNLOCKED;
+
+/* Tell the write thread to finish */
+static volatile int write_task_finish;
+
+/* ipc with the write thread */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+static DECLARE_MUTEX_LOCKED(thread_sem);
+static DECLARE_WAIT_QUEUE_HEAD(thr_wq);
+static DECLARE_WAIT_QUEUE_HEAD(mtbd_sync_wq);
+#else
+static struct semaphore thread_sem = MUTEX_LOCKED;
+DECLARE_WAIT_QUEUE_HEAD(thr_wq);
+DECLARE_WAIT_QUEUE_HEAD(mtbd_sync_wq);
+#endif
+
+
+/* Module parameters passed by insmod/modprobe */
+char *device;    /* the block device to use */
+int erasesz;     /* optional default erase size */
+int ro;          /* optional read only flag */
+int bs;          /* optionally force the block size (avoid using) */
+int count;       /* optionally force the block count (avoid using) */
+int wqs;         /* optionally set the write queue size */
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Simon Evans <spse@secret.org.uk>");
+MODULE_DESCRIPTION("Emulate an MTD using a block device");
+MODULE_PARM(device, "s");
+MODULE_PARM_DESC(device, "block device to use");
+MODULE_PARM(erasesz, "i");
+MODULE_PARM_DESC(erasesz, "optional erase size to use in KB. eg 4=4K.");
+MODULE_PARM(ro, "i");
+MODULE_PARM_DESC(ro, "1=Read only, writes and erases cause errors");
+MODULE_PARM(bs, "i");
+MODULE_PARM_DESC(bs, "force the block size in bytes");
+MODULE_PARM(count, "i");
+MODULE_PARM_DESC(count, "force the block count");
+MODULE_PARM(wqs, "i");
+#endif
+
+
+/* Page cache stuff */
+
+/* writepage() - should never be called - catch it anyway */
+static int blkmtd_writepage(struct page *page)
+{
+  printk("blkmtd: writepage called!!!\n");
+  return -EIO;
+}
+
+
+/* readpage() - reads one page from the block device */                 
+static int blkmtd_readpage(mtd_raw_dev_data_t *rawdevice, struct page *page)
+{  
+  int err;
+  int sectornr, sectors, i;
+  struct kiobuf *iobuf;
+  kdev_t dev;
+  unsigned long *blocks;
+
+  if(!rawdevice) {
+    printk("blkmtd: readpage: PANIC file->private_data == NULL\n");
+    return -EIO;
+  }
+  dev = to_kdev_t(rawdevice->binding->bd_dev);
+
+  DEBUG(2, "blkmtd: readpage called, dev = `%s' page = %p index = %ld\n",
+	bdevname(dev), page, page->index);
+
+  if(Page_Uptodate(page)) {
+    DEBUG(2, "blkmtd: readpage page %ld is already upto date\n", page->index);
+    UnlockPage(page);
+    return 0;
+  }
+
+  ClearPageUptodate(page);
+  ClearPageError(page);
+
+  /* see if page is in the outgoing write queue */
+  spin_lock(&mbd_writeq_lock);
+  if(write_queue_cnt) {
+    int i = write_queue_tail;
+    while(i != write_queue_head) {
+      mtdblkdev_write_queue_t *item = &write_queue[i];
+      if(page->index >= item->pagenr && page->index < item->pagenr+item->pagecnt) {
+	/* yes it is */
+	int index = page->index - item->pagenr;
+		
+	DEBUG(2, "blkmtd: readpage: found page %ld in outgoing write queue\n",
+	      page->index);
+	if(item->iserase) {
+	  memset(page_address(page), 0xff, PAGE_SIZE);
+	} else {
+	  memcpy(page_address(page), page_address(item->pages[index]), PAGE_SIZE);
+	}
+	SetPageUptodate(page);
+	flush_dcache_page(page);
+	UnlockPage(page);
+	spin_unlock(&mbd_writeq_lock);
+	return 0;
+      }
+      i++;
+      i %= write_queue_sz;
+    }
+  }
+  spin_unlock(&mbd_writeq_lock);
+
+
+  DEBUG(3, "blkmtd: readpage: getting kiovec\n");
+  err = alloc_kiovec(1, &iobuf);
+  if (err) {
+    printk("blkmtd: cant allocate kiobuf\n");
+    SetPageError(page);
+    return err;
+  }
+
+  /* Pre 2.4.4 doesnt have space for the block list in the kiobuf */ 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+  blocks = kmalloc(KIO_MAX_SECTORS * sizeof(unsigned long));
+  if(blocks == NULL) {
+    printk("blkmtd: cant allocate iobuf blocks\n");
+    free_kiovec(1, &iobuf);
+    SetPageError(page);
+    return -ENOMEM;
+  }
+#else 
+  blocks = iobuf->blocks;
+#endif
+
+  iobuf->offset = 0;
+  iobuf->nr_pages = 1;
+  iobuf->length = PAGE_SIZE;
+  iobuf->locked = 1;
+  iobuf->maplist[0] = page;
+  sectornr = page->index << (PAGE_SHIFT - rawdevice->sector_bits);
+  sectors = 1 << (PAGE_SHIFT - rawdevice->sector_bits);
+  if(rawdevice->partial_last_page && page->index == rawdevice->partial_last_page) {
+    DEBUG(3, "blkmtd: handling partial last page\n");
+    sectors = rawdevice->last_page_sectors;
+  }
+  DEBUG(3, "blkmtd: readpage: sectornr = %d sectors = %d\n", sectornr, sectors);
+  for(i = 0; i < sectors; i++) {
+    blocks[i] = sectornr++;
+  }
+  /* If only a partial page read in, clear the rest of the page */
+  if(rawdevice->partial_last_page && page->index == rawdevice->partial_last_page) {
+    int offset = rawdevice->last_page_sectors << rawdevice->sector_bits;
+    int count = PAGE_SIZE-offset;
+    DEBUG(3, "blkmtd: clear last partial page: offset = %d count = %d\n", offset, count);
+    memset(page_address(page)+offset, 0, count);
+    sectors = rawdevice->last_page_sectors;
+  }
+
+
+  DEBUG(3, "bklmtd: readpage: starting brw_kiovec\n");
+  err = brw_kiovec(READ, 1, &iobuf, dev, blocks, rawdevice->sector_size);
+  DEBUG(3, "blkmtd: readpage: finished, err = %d\n", err);
+  iobuf->locked = 0;
+  free_kiovec(1, &iobuf);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+  kfree(blocks);
+#endif
+
+  if(err != PAGE_SIZE) {
+    printk("blkmtd: readpage: error reading page %ld\n", page->index);
+    memset(page_address(page), 0, PAGE_SIZE);
+    SetPageError(page);
+    err = -EIO;
+  } else {
+    DEBUG(3, "blkmtd: readpage: setting page upto date\n");
+    SetPageUptodate(page);
+    err = 0;
+  }
+  flush_dcache_page(page);
+  UnlockPage(page);
+  DEBUG(2, "blkmtd: readpage: finished, err = %d\n", err);
+  return 0;
+}
+
+                    
+static struct address_space_operations blkmtd_aops = {
+  writepage:     blkmtd_writepage,
+  readpage:      NULL,
+}; 
+
+
+/* This is the kernel thread that empties the write queue to disk */
+static int write_queue_task(void *data)
+{
+  int err;
+  struct task_struct *tsk = current;
+  struct kiobuf *iobuf;
+  unsigned long *blocks;
+
+  DECLARE_WAITQUEUE(wait, tsk);
+  DEBUG(1, "blkmtd: writetask: starting (pid = %d)\n", tsk->pid);
+  daemonize();
+  strcpy(tsk->comm, "blkmtdd");
+  tsk->tty = NULL;
+  spin_lock_irq(&tsk->sigmask_lock);
+  sigfillset(&tsk->blocked);
+  recalc_sigpending(tsk);
+  spin_unlock_irq(&tsk->sigmask_lock);
+  exit_sighand(tsk);
+
+  if(alloc_kiovec(1, &iobuf)) {
+    printk("blkmtd: write_queue_task cant allocate kiobuf\n");
+    return 0;
+  }
+
+  /* Pre 2.4.4 doesnt have space for the block list in the kiobuf */ 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+  blocks = kmalloc(KIO_MAX_SECTORS * sizeof(unsigned long));
+  if(blocks == NULL) {
+    printk("blkmtd: write_queue_task cant allocate iobuf blocks\n");
+    free_kiovec(1, &iobuf);
+    return 0;
+  }
+#else 
+  blocks = iobuf->blocks;
+#endif
+
+  DEBUG(2, "blkmtd: writetask: entering main loop\n");
+  add_wait_queue(&thr_wq, &wait);
+
+  while(1) {
+    spin_lock(&mbd_writeq_lock);
+
+    if(!write_queue_cnt) {
+      /* If nothing in the queue, wake up anyone wanting to know when there
+	 is space in the queue then sleep for 2*HZ */
+      spin_unlock(&mbd_writeq_lock);
+      DEBUG(4, "blkmtd: writetask: queue empty\n");
+      if(waitqueue_active(&mtbd_sync_wq))
+	 wake_up(&mtbd_sync_wq);
+      interruptible_sleep_on_timeout(&thr_wq, 2*HZ);
+      DEBUG(4, "blkmtd: writetask: woken up\n");
+      if(write_task_finish)
+	break;
+    } else {
+      /* we have stuff to write */
+      mtdblkdev_write_queue_t *item = &write_queue[write_queue_tail];
+      struct page **pages = item->pages;
+
+      int i;
+      int sectornr = item->pagenr << (PAGE_SHIFT - item->rawdevice->sector_bits);
+      int sectorcnt = item->pagecnt << (PAGE_SHIFT - item->rawdevice->sector_bits);
+      int max_sectors = KIO_MAX_SECTORS >> (item->rawdevice->sector_bits - 9);
+      kdev_t dev = to_kdev_t(item->rawdevice->binding->bd_dev);
+
+      /* If we are writing to the last page on the device and it doesnt end
+       * on a page boundary, subtract the number of sectors that dont exist.
+       */
+      if(item->rawdevice->partial_last_page && 
+	 (item->pagenr + item->pagecnt -1) == item->rawdevice->partial_last_page) {
+	sectorcnt -= (1 << (PAGE_SHIFT - item->rawdevice->sector_bits));
+	sectorcnt += item->rawdevice->last_page_sectors;
+      }
+
+      DEBUG(3, "blkmtd: writetask: got %d queue items\n", write_queue_cnt);
+      set_current_state(TASK_RUNNING);
+      spin_unlock(&mbd_writeq_lock);
+
+      DEBUG(2, "blkmtd: writetask: writing pagenr = %d pagecnt = %d sectornr = %d sectorcnt = %d\n", 
+	    item->pagenr, item->pagecnt, sectornr, sectorcnt);
+
+      iobuf->offset = 0;
+      iobuf->locked = 1;
+
+      /* Loop through all the pages to be written in the queue item, remembering
+	 we can only write KIO_MAX_SECTORS at a time */
+	 
+      while(sectorcnt) {
+	int cursectors = (sectorcnt < max_sectors) ? sectorcnt : max_sectors;
+	int cpagecnt = (cursectors << item->rawdevice->sector_bits) + PAGE_SIZE-1;
+	cpagecnt >>= PAGE_SHIFT;
+	
+	for(i = 0; i < cpagecnt; i++) {
+	  if(item->iserase) {
+	    iobuf->maplist[i] = erase_page;
+	  } else {
+	    iobuf->maplist[i] = *(pages++);
+	  }
+	}
+	
+	for(i = 0; i < cursectors; i++) {
+	  blocks[i] = sectornr++;
+	}
+	
+	iobuf->nr_pages = cpagecnt;
+	iobuf->length = cursectors << item->rawdevice->sector_bits;
+	DEBUG(3, "blkmtd: write_task: about to kiovec\n");
+	err = brw_kiovec(WRITE, 1, &iobuf, dev, blocks, item->rawdevice->sector_size);
+	DEBUG(3, "bklmtd: write_task: done, err = %d\n", err);
+	if(err != (cursectors << item->rawdevice->sector_bits)) {
+	  /* if an error occured - set this to exit the loop */
+	  sectorcnt = 0;
+	} else {
+	  sectorcnt -= cursectors;
+	}
+      }
+
+      /* free up the pages used in the write and list of pages used in the write
+	 queue item */
+      iobuf->locked = 0;
+      spin_lock(&mbd_writeq_lock);
+      write_queue_cnt--;
+      write_queue_tail++;
+      write_queue_tail %= write_queue_sz;
+      if(!item->iserase) {
+	for(i = 0 ; i < item->pagecnt; i++) {
+	  UnlockPage(item->pages[i]);
+	  __free_pages(item->pages[i], 0);
+	}
+	kfree(item->pages);
+      }
+      item->pages = NULL;
+      spin_unlock(&mbd_writeq_lock);
+      /* Tell others there is some space in the write queue */
+      if(waitqueue_active(&mtbd_sync_wq))
+	wake_up(&mtbd_sync_wq);
+    }
+  }
+  remove_wait_queue(&thr_wq, &wait);
+  DEBUG(1, "blkmtd: writetask: exiting\n");
+  free_kiovec(1, &iobuf);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+  kfree(blocks);
+#endif
+
+  /* Tell people we have exitd */
+  up(&thread_sem);
+  return 0;
+}
+
+
+/* Add a range of pages into the outgoing write queue, making copies of them */
+static int queue_page_write(mtd_raw_dev_data_t *rawdevice, struct page **pages,
+			    int pagenr, int pagecnt, int iserase)
+{
+  struct page *outpage;
+  struct page **new_pages = NULL;
+  mtdblkdev_write_queue_t *item;
+  int i;
+  DECLARE_WAITQUEUE(wait, current);
+  DEBUG(2, "blkmtd: queue_page_write: adding pagenr = %d pagecnt = %d\n", pagenr, pagecnt);
+
+  if(!pagecnt)
+    return 0;
+
+  if(pages == NULL && !iserase)
+    return -EINVAL;
+
+  /* create a array for the list of pages */
+  if(!iserase) {
+    new_pages = kmalloc(pagecnt * sizeof(struct page *), GFP_KERNEL);
+    if(new_pages == NULL)
+      return -ENOMEM;
+
+    /* make copies of the pages in the page cache */
+    for(i = 0; i < pagecnt; i++) {
+      outpage = alloc_pages(GFP_KERNEL, 0);
+      if(!outpage) {
+	while(i--) {
+	  UnlockPage(new_pages[i]);
+	  __free_pages(new_pages[i], 0);
+	}
+	kfree(new_pages);
+	return -ENOMEM;
+      }
+      lock_page(outpage);
+      memcpy(page_address(outpage), page_address(pages[i]), PAGE_SIZE);
+      new_pages[i] = outpage;
+    }
+  }
+
+  /* wait until there is some space in the write queue */
+ test_lock:
+  spin_lock(&mbd_writeq_lock);
+  if(write_queue_cnt == write_queue_sz) {
+    spin_unlock(&mbd_writeq_lock);
+    DEBUG(3, "blkmtd: queue_page: Queue full\n");
+    current->state = TASK_UNINTERRUPTIBLE;
+    add_wait_queue(&mtbd_sync_wq, &wait);
+    wake_up_interruptible(&thr_wq);
+    schedule();
+    current->state = TASK_RUNNING;
+    remove_wait_queue(&mtbd_sync_wq, &wait);
+    DEBUG(3, "blkmtd: queue_page_write: Queue has %d items in it\n", write_queue_cnt);
+    goto test_lock;
+  }
+
+  DEBUG(3, "blkmtd: queue_page_write: qhead: %d qtail: %d qcnt: %d\n", 
+	write_queue_head, write_queue_tail, write_queue_cnt);
+
+  /* fix up the queue item */
+  item = &write_queue[write_queue_head];
+  item->pages = new_pages;
+  item->pagenr = pagenr;
+  item->pagecnt = pagecnt;
+  item->rawdevice = rawdevice;
+  item->iserase = iserase;
+
+  write_queue_head++;
+  write_queue_head %= write_queue_sz;
+  write_queue_cnt++;
+  DEBUG(3, "blkmtd: queue_page_write: qhead: %d qtail: %d qcnt: %d\n", 
+	write_queue_head, write_queue_tail, write_queue_cnt);
+  spin_unlock(&mbd_writeq_lock);
+  DEBUG(2, "blkmtd: queue_page_write: finished\n");
+  return 0;
+}
+
+
+/* erase a specified part of the device */
+static int blkmtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+  mtd_raw_dev_data_t *rawdevice = mtd->priv;
+  struct mtd_erase_region_info *einfo = mtd->eraseregions;
+  int numregions = mtd->numeraseregions;
+  size_t from;
+  u_long len;
+  int err = 0;
+
+  /* check readonly */
+  if(rawdevice->readonly) {
+    printk("blkmtd: error: trying to erase readonly device %s\n", device);
+    instr->state = MTD_ERASE_FAILED;
+    goto erase_callback;
+  }
+
+  instr->state = MTD_ERASING;
+  from = instr->addr;
+  len = instr->len;
+
+  /* check erase region has valid start and length */
+  DEBUG(2, "blkmtd: erase: dev = `%s' from = 0x%x len = 0x%lx\n",
+	bdevname(rawdevice->binding->bd_dev), from, len);
+  while(numregions) {
+    DEBUG(3, "blkmtd: checking erase region = 0x%08X size = 0x%X num = 0x%x\n",
+	  einfo->offset, einfo->erasesize, einfo->numblocks);
+    if(from >= einfo->offset && from < einfo->offset + (einfo->erasesize * einfo->numblocks)) {
+      if(len == einfo->erasesize && ( (from - einfo->offset) % einfo->erasesize == 0))
+	break;
+    }
+    numregions--;
+    einfo++;
+  }
+
+  if(!numregions) {
+    /* Not a valid erase block */
+    printk("blkmtd: erase: invalid erase request 0x%lX @ 0x%08X\n", len, from);
+    instr->state = MTD_ERASE_FAILED;
+    err = -EIO;
+  }
+  
+  if(instr->state != MTD_ERASE_FAILED) {
+    /* start the erase */
+    int pagenr, pagecnt;
+    struct page *page, **pages;
+    int i = 0;
+
+    /* Handle the last page of the device not being whole */
+    if(len < PAGE_SIZE)
+      len = PAGE_SIZE;
+
+    pagenr = from >> PAGE_SHIFT;
+    pagecnt = len >> PAGE_SHIFT;
+    DEBUG(3, "blkmtd: erase: pagenr = %d pagecnt = %d\n", pagenr, pagecnt);
+
+    pages = kmalloc(pagecnt * sizeof(struct page *), GFP_KERNEL);
+    if(pages == NULL) {
+      err = -ENOMEM;
+      instr->state = MTD_ERASE_FAILED;
+      goto erase_out;
+    }
+
+
+    while(pagecnt) {
+      /* get the page via the page cache */
+      DEBUG(3, "blkmtd: erase: doing grab_cache_page() for page %d\n", pagenr);
+      page = grab_cache_page(&rawdevice->as, pagenr);
+      if(!page) {
+	DEBUG(3, "blkmtd: erase: grab_cache_page() failed for page %d\n", pagenr);
+	kfree(pages);
+	err = -EIO;
+	instr->state = MTD_ERASE_FAILED;
+	goto erase_out;
+      }
+      memset(page_address(page), 0xff, PAGE_SIZE);
+      pages[i] = page;
+      pagecnt--;
+      pagenr++;
+      i++;
+    }
+    DEBUG(3, "blkmtd: erase: queuing page write\n");
+    err = queue_page_write(rawdevice, NULL, from >> PAGE_SHIFT, len >> PAGE_SHIFT, 1);
+    pagecnt = len >> PAGE_SHIFT;
+    if(!err) {
+      while(pagecnt--) {
+	SetPageUptodate(pages[pagecnt]);
+	UnlockPage(pages[pagecnt]);
+	page_cache_release(pages[pagecnt]);
+	flush_dcache_page(pages[pagecnt]);
+      }
+      kfree(pages);
+      instr->state = MTD_ERASE_DONE;
+    } else {
+      while(pagecnt--) {
+	SetPageError(pages[pagecnt]);
+	page_cache_release(pages[pagecnt]);
+      }
+      kfree(pages);
+      instr->state = MTD_ERASE_FAILED;
+    }
+  }
+ erase_out:
+  DEBUG(3, "blkmtd: erase: checking callback\n");
+ erase_callback:
+  if (instr->callback) {
+    (*(instr->callback))(instr);
+  }
+  DEBUG(2, "blkmtd: erase: finished (err = %d)\n", err);
+  return err;
+}
+
+
+/* read a range of the data via the page cache */
+static int blkmtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+	     size_t *retlen, u_char *buf)
+{
+  mtd_raw_dev_data_t *rawdevice = mtd->priv;
+  int err = 0;
+  int offset;
+  int pagenr, pages;
+
+  *retlen = 0;
+
+  DEBUG(2, "blkmtd: read: dev = `%s' from = %ld len = %d buf = %p\n",
+	bdevname(rawdevice->binding->bd_dev), (long int)from, len, buf);
+
+  pagenr = from >> PAGE_SHIFT;
+  offset = from - (pagenr << PAGE_SHIFT);
+  
+  pages = (offset+len+PAGE_SIZE-1) >> PAGE_SHIFT;
+  DEBUG(3, "blkmtd: read: pagenr = %d offset = %d, pages = %d\n", pagenr, offset, pages);
+
+  /* just loop through each page, getting it via readpage() - slow but easy */
+  while(pages) {
+    struct page *page;
+    int cpylen;
+    DEBUG(3, "blkmtd: read: looking for page: %d\n", pagenr);
+    page = read_cache_page(&rawdevice->as, pagenr, (filler_t *)blkmtd_readpage, rawdevice);
+    if(IS_ERR(page)) {
+      return PTR_ERR(page);
+    }
+    wait_on_page(page);
+    if(!Page_Uptodate(page)) {
+      /* error reading page */
+      printk("blkmtd: read: page not uptodate\n");
+      page_cache_release(page);
+      return -EIO;
+    }
+
+    cpylen = (PAGE_SIZE > len) ? len : PAGE_SIZE;
+    if(offset+cpylen > PAGE_SIZE)
+      cpylen = PAGE_SIZE-offset;
+    
+    memcpy(buf + *retlen, page_address(page) + offset, cpylen);
+    offset = 0;
+    len -= cpylen;
+    *retlen += cpylen;
+    pagenr++;
+    pages--;
+    page_cache_release(page);
+  }
+  
+  DEBUG(2, "blkmtd: end read: retlen = %d, err = %d\n", *retlen, err);
+  return err;
+}
+
+    
+/* write a range of the data via the page cache.
+ *
+ * Basic operation. break the write into three parts. 
+ *
+ * 1. From a page unaligned start up until the next page boundary
+ * 2. Page sized, page aligned blocks
+ * 3. From end of last aligned block to end of range
+ *
+ * 1,3 are read via the page cache and readpage() since these are partial
+ * pages, 2 we just grab pages from the page cache, not caring if they are
+ * already in memory or not since they will be completly overwritten.
+ *
+ */
+ 
+static int blkmtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+	      size_t *retlen, const u_char *buf)
+{
+  mtd_raw_dev_data_t *rawdevice = mtd->priv;
+  int err = 0;
+  int offset;
+  int pagenr;
+  size_t len1 = 0, len2 = 0, len3 = 0;
+  struct page **pages;
+  int pagecnt = 0;
+
+  *retlen = 0;
+  DEBUG(2, "blkmtd: write: dev = `%s' to = %ld len = %d buf = %p\n",
+	bdevname(rawdevice->binding->bd_dev), (long int)to, len, buf);
+
+  /* handle readonly and out of range numbers */
+
+  if(rawdevice->readonly) {
+    printk("blkmtd: error: trying to write to a readonly device %s\n", device);
+    return -EROFS;
+  }
+
+  if(to >= rawdevice->totalsize) {
+    return -ENOSPC;
+  }
+
+  if(to + len > rawdevice->totalsize) {
+    len = (rawdevice->totalsize - to);
+  }
+
+
+  pagenr = to >> PAGE_SHIFT;
+  offset = to - (pagenr << PAGE_SHIFT);
+
+  /* see if we have to do a partial write at the start */
+  if(offset) {
+    if((offset + len) > PAGE_SIZE) {
+      len1 = PAGE_SIZE - offset;
+      len -= len1;
+    } else {
+      len1 = len;
+      len = 0;
+    }
+  }
+
+  /* calculate the length of the other two regions */
+  len3 = len & ~PAGE_MASK;
+  len -= len3;
+  len2 = len;
+
+
+  if(len1)
+    pagecnt++;
+  if(len2)
+    pagecnt += len2 >> PAGE_SHIFT;
+  if(len3)
+    pagecnt++;
+
+  DEBUG(3, "blkmtd: write: len1 = %d len2 = %d len3 = %d pagecnt = %d\n", len1, len2, len3, pagecnt);
+  
+  /* get space for list of pages */
+  pages = kmalloc(pagecnt * sizeof(struct page *), GFP_KERNEL);
+  if(pages == NULL) {
+    return -ENOMEM;
+  }
+  pagecnt = 0;
+
+  if(len1) {
+    /* do partial start region */
+    struct page *page;
+    
+    DEBUG(3, "blkmtd: write: doing partial start, page = %d len = %d offset = %d\n", pagenr, len1, offset);
+    page = read_cache_page(&rawdevice->as, pagenr, (filler_t *)blkmtd_readpage, rawdevice);
+
+    if(IS_ERR(page)) {
+      kfree(pages);
+      return PTR_ERR(page);
+    }
+    memcpy(page_address(page)+offset, buf, len1);
+    pages[pagecnt++] = page;
+    buf += len1;
+    *retlen = len1;
+    err = 0;
+    pagenr++;
+  }
+
+  /* Now do the main loop to a page aligned, n page sized output */
+  if(len2) {
+    int pagesc = len2 >> PAGE_SHIFT;
+    DEBUG(3, "blkmtd: write: whole pages start = %d, count = %d\n", pagenr, pagesc);
+    while(pagesc) {
+      struct page *page;
+
+      /* see if page is in the page cache */
+      DEBUG(3, "blkmtd: write: grabbing page %d from page cache\n", pagenr);
+      page = grab_cache_page(&rawdevice->as, pagenr);
+      DEBUG(3, "blkmtd: write: got page %d from page cache\n", pagenr);
+      if(!page) {
+	printk("blkmtd: write: cant grab cache page %d\n", pagenr);
+	err = -EIO;
+	goto write_err;
+      }
+      memcpy(page_address(page), buf, PAGE_SIZE);
+      pages[pagecnt++] = page;
+      UnlockPage(page);
+      SetPageUptodate(page);
+      pagenr++;
+      pagesc--;
+      buf += PAGE_SIZE;
+      *retlen += PAGE_SIZE;
+    }
+  }
+
+
+  if(len3) {
+    /* do the third region */
+    struct page *page;
+    DEBUG(3, "blkmtd: write: doing partial end, page = %d len = %d\n", pagenr, len3);
+    page = read_cache_page(&rawdevice->as, pagenr, (filler_t *)blkmtd_readpage, rawdevice);
+    if(IS_ERR(page)) {
+      err = PTR_ERR(page);
+      goto write_err;
+    }
+    memcpy(page_address(page), buf, len3);
+    DEBUG(3, "blkmtd: write: writing out partial end\n");
+    pages[pagecnt++] = page;
+    *retlen += len3;
+    err = 0;
+  }
+  DEBUG(2, "blkmtd: write: end, retlen = %d, err = %d\n", *retlen, err);
+  /* submit it to the write task */
+  err = queue_page_write(rawdevice, pages, to >> PAGE_SHIFT, pagecnt, 0);
+  if(!err) {
+    while(pagecnt--) {
+      SetPageUptodate(pages[pagecnt]);
+      flush_dcache_page(pages[pagecnt]);
+      page_cache_release(pages[pagecnt]);
+    }
+    kfree(pages);
+    return 0;
+  }
+
+ write_err:
+  while(--pagecnt) {
+    SetPageError(pages[pagecnt]);
+    page_cache_release(pages[pagecnt]);
+  }
+  kfree(pages);
+  return err;
+}
+
+
+/* sync the device - wait until the write queue is empty */
+static void blkmtd_sync(struct mtd_info *mtd)
+{
+  DECLARE_WAITQUEUE(wait, current);
+  mtd_raw_dev_data_t *rawdevice = mtd->priv;
+  if(rawdevice->readonly)
+    return;
+
+  DEBUG(2, "blkmtd: sync: called\n");
+
+ stuff_inq:
+  spin_lock(&mbd_writeq_lock);
+  if(write_queue_cnt) {
+    spin_unlock(&mbd_writeq_lock);
+    current->state = TASK_UNINTERRUPTIBLE;
+    add_wait_queue(&mtbd_sync_wq, &wait);
+    DEBUG(3, "blkmtd: sync: waking up task\n");
+    wake_up_interruptible(&thr_wq);
+    schedule();
+    current->state = TASK_RUNNING;
+    remove_wait_queue(&mtbd_sync_wq, &wait);
+    DEBUG(3, "blkmtd: sync: waking up after write task\n");
+    goto stuff_inq;
+  }
+  spin_unlock(&mbd_writeq_lock);
+
+  DEBUG(2, "blkmtd: sync: finished\n");
+}
+
+
+#ifdef BLKMTD_PROC_DEBUG
+/* procfs stuff */
+static int blkmtd_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+  int clean = 0, dirty = 0, locked = 0;
+  struct list_head *temp;
+  int i, len, pages = 0, cnt;
+  MOD_INC_USE_COUNT;
+  spin_lock(&mbd_writeq_lock);
+  cnt = write_queue_cnt;
+  i = write_queue_tail;
+  while(cnt) {
+    if(!write_queue[i].iserase)
+      pages += write_queue[i].pagecnt;
+    i++;
+    i %= write_queue_sz;
+    cnt--;
+  }
+
+  /* Count the size of the page lists */
+  list_for_each(temp, &mtd_rawdevice->as.clean_pages) {
+    clean++;
+  }
+  list_for_each(temp, &mtd_rawdevice->as.dirty_pages) {
+    dirty++;
+  }
+  list_for_each(temp, &mtd_rawdevice->as.locked_pages) {
+    locked++;
+  }
+
+  len = sprintf(page, "Write queue head: %d\nWrite queue tail: %d\nWrite queue count: %d\nPages in queue: %d (%dK)\nClean Pages: %d\nDirty Pages: %d\nLocked Pages: %d\nnrpages: %ld\n",
+		write_queue_head, write_queue_tail, write_queue_cnt,
+		pages, pages << (PAGE_SHIFT-10), clean, dirty, locked,
+		mtd_rawdevice->as.nrpages);
+  if(len <= count)
+    *eof = 1;
+  spin_unlock(&mbd_writeq_lock);
+  MOD_DEC_USE_COUNT;
+  return len;
+}
+#endif
+
+
+/* Cleanup and exit - sync the device and kill of the kernel thread */
+static void __exit cleanup_blkmtd(void)
+{
+#ifdef BLKMTD_PROC_DEBUG
+  if(blkmtd_proc) {
+    remove_proc_entry("blkmtd_debug", NULL);
+  }
+#endif
+
+  if (mtd_rawdevice) {
+    /* sync the device */
+    if (!mtd_rawdevice->readonly) {
+      blkmtd_sync(&mtd_rawdevice->mtd_info);
+      write_task_finish = 1;
+      wake_up_interruptible(&thr_wq);
+      down(&thread_sem);
+    }
+    del_mtd_device(&mtd_rawdevice->mtd_info);
+    if(mtd_rawdevice->binding != NULL)
+      blkdev_put(mtd_rawdevice->binding, BDEV_RAW);
+
+    if(mtd_rawdevice->mtd_info.eraseregions)
+      kfree(mtd_rawdevice->mtd_info.eraseregions);
+    if(mtd_rawdevice->mtd_info.name)
+      kfree(mtd_rawdevice->mtd_info.name);
+
+    kfree(mtd_rawdevice);
+  }
+  if(write_queue)
+    kfree(write_queue);
+
+  if(erase_page) {
+    UnlockPage(erase_page);
+    __free_pages(erase_page, 0);
+  }
+  printk("blkmtd: unloaded for %s\n", device);
+}
+
+extern struct module __this_module;
+
+#ifndef MODULE
+
+/* Handle kernel boot params */
+
+
+static int __init param_blkmtd_device(char *str)
+{
+  device = str;
+  return 1;
+}
+
+
+static int __init param_blkmtd_erasesz(char *str)
+{
+  erasesz = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+
+static int __init param_blkmtd_ro(char *str)
+{
+  ro = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+
+static int __init param_blkmtd_bs(char *str)
+{
+  bs = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+
+static int __init param_blkmtd_count(char *str)
+{
+  count = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+__setup("blkmtd_device=", param_blkmtd_device);
+__setup("blkmtd_erasesz=", param_blkmtd_erasesz);
+__setup("blkmtd_ro=", param_blkmtd_ro);
+__setup("blkmtd_bs=", param_blkmtd_bs);
+__setup("blkmtd_count=", param_blkmtd_count);
+
+#endif
+
+
+/* for a given size and initial erase size, calculate the number and size of each
+   erase region */
+static int __init calc_erase_regions(struct mtd_erase_region_info *info, size_t erase_size, size_t total_size)
+{
+  int count = 0;
+  int offset = 0;
+  int regions = 0;
+
+   while(total_size) {
+     count = total_size / erase_size;
+     if(count) {
+       total_size = total_size % erase_size;
+       if(info) {
+	 info->offset = offset;
+	 info->erasesize = erase_size;
+	 info->numblocks = count;
+	 info++;
+       }
+       offset += (count * erase_size);
+       regions++;
+     }
+     while(erase_size > total_size)
+       erase_size >>= 1;
+   }
+   return regions;
+}
+
+
+extern kdev_t name_to_kdev_t(char *line) __init;
+
+/* Startup */
+static int __init init_blkmtd(void)
+{
+#ifdef MODULE
+  struct file *file = NULL;
+  struct inode *inode;
+#endif
+
+  int maj, min;
+  int i, blocksize, blocksize_bits;
+  loff_t size = 0;
+  int readonly = 0;
+  int erase_size = CONFIG_MTD_BLKDEV_ERASESIZE;
+  kdev_t rdev;
+  int err;
+  int mode;
+  int regions;
+
+  /* Check args */
+  if(device == 0) {
+    printk("blkmtd: error, missing `device' name\n");
+    return -EINVAL;
+  }
+
+  if(ro)
+    readonly = 1;
+
+  if(erasesz)
+    erase_size = erasesz;
+
+  if(wqs) {
+    if(wqs < 16) 
+      wqs = 16;
+    if(wqs > 4*WRITE_QUEUE_SZ)
+      wqs = 4*WRITE_QUEUE_SZ;
+    write_queue_sz = wqs;
+  }
+
+  DEBUG(1, "blkmtd: device = `%s' erase size = %dK readonly = %s queue size = %d\n", device, erase_size, readonly ? "yes" : "no", write_queue_sz);
+  /* Get a handle on the device */
+  mode = (readonly) ? O_RDONLY : O_RDWR;
+
+#ifdef MODULE
+
+  file = filp_open(device, mode, 0);
+  if(IS_ERR(file)) {
+    printk("blkmtd: error, cant open device %s\n", device);
+    DEBUG(2, "blkmtd: filp_open returned %ld\n", PTR_ERR(file));
+    return 1;
+  }
+  
+  /* determine is this is a block device and if so get its major and minor
+     numbers */
+  inode = file->f_dentry->d_inode;
+  if(!S_ISBLK(inode->i_mode)) {
+    printk("blkmtd: %s not a block device\n", device);
+    filp_close(file, NULL);
+    return 1;
+  }
+  rdev = inode->i_rdev;
+  filp_close(file, NULL);
+#else
+  rdev = name_to_kdev_t(device);
+#endif
+
+  maj = MAJOR(rdev);
+  min = MINOR(rdev);
+  DEBUG(1, "blkmtd: found a block device major = %d, minor = %d\n", maj, min);
+
+  if(!rdev) {
+    printk("blkmtd: bad block device: `%s'\n", device);
+    return 1;
+  }
+
+  if(maj == MTD_BLOCK_MAJOR) {
+    printk("blkmtd: attempting to use an MTD device as a block device\n");
+    return 1;
+  }
+
+  DEBUG(1, "blkmtd: devname = %s\n", bdevname(rdev));
+  blocksize = BLOCK_SIZE;
+
+  if(bs) {
+    blocksize = bs;
+  } else {
+    if (blksize_size[maj] && blksize_size[maj][min]) {
+      DEBUG(2, "blkmtd: blksize_size = %d\n", blksize_size[maj][min]);
+      blocksize = blksize_size[maj][min];
+    }
+  }
+  i = blocksize;
+  blocksize_bits = 0;
+  while(i != 1) {
+    blocksize_bits++;
+    i >>= 1;
+  }
+
+  if(count) {
+    size = count;
+  } else {
+    if (blk_size[maj]) {
+      size = ((loff_t) blk_size[maj][min] << BLOCK_SIZE_BITS) >> blocksize_bits;
+    }
+  }
+  size *= blocksize;
+  DEBUG(1, "blkmtd: size = %ld\n", (long int)size);
+
+  if(size == 0) {
+    printk("blkmtd: cant determine size\n");
+    return 1;
+  }
+
+  mtd_rawdevice = (mtd_raw_dev_data_t *)kmalloc(sizeof(mtd_raw_dev_data_t), GFP_KERNEL);
+  if(mtd_rawdevice == NULL) {
+    err = -ENOMEM;
+    goto init_err;
+  }
+  memset(mtd_rawdevice, 0, sizeof(mtd_raw_dev_data_t));
+  /* get the block device */
+  mtd_rawdevice->binding = bdget(kdev_t_to_nr(MKDEV(maj, min)));
+  err = blkdev_get(mtd_rawdevice->binding, mode, 0, BDEV_RAW);
+  if (err) {
+    goto init_err;
+  }
+  mtd_rawdevice->totalsize = size;
+  mtd_rawdevice->sector_size = blocksize;
+  mtd_rawdevice->sector_bits = blocksize_bits;
+  mtd_rawdevice->readonly = readonly;
+
+  /* See if device ends on page boundary */
+  if(size % PAGE_SIZE) {
+    mtd_rawdevice->partial_last_page = size >> PAGE_SHIFT;
+    mtd_rawdevice->last_page_sectors = (size & (PAGE_SIZE-1)) >> blocksize_bits;
+  }
+
+  DEBUG(2, "sector_size = %d, sector_bits = %d, partial_last_page = %d last_page_sectors = %d\n", 
+	mtd_rawdevice->sector_size, mtd_rawdevice->sector_bits,
+	mtd_rawdevice->partial_last_page, mtd_rawdevice->last_page_sectors);
+
+  /* Setup the MTD structure */
+  /* make the name contain the block device in */
+  mtd_rawdevice->mtd_info.name = kmalloc(9 + strlen(device), GFP_KERNEL);
+  if(mtd_rawdevice->mtd_info.name == NULL)
+    goto init_err;
+
+  sprintf(mtd_rawdevice->mtd_info.name, "blkmtd: %s", device);
+  if(readonly) {
+    mtd_rawdevice->mtd_info.type = MTD_ROM;
+    mtd_rawdevice->mtd_info.flags = MTD_CAP_ROM;
+    mtd_rawdevice->mtd_info.erasesize = erase_size << 10;
+  } else {
+    mtd_rawdevice->mtd_info.type = MTD_RAM;
+    mtd_rawdevice->mtd_info.flags = MTD_CAP_RAM;
+    mtd_rawdevice->mtd_info.erasesize = erase_size << 10;
+  }
+  mtd_rawdevice->mtd_info.size = size;
+  mtd_rawdevice->mtd_info.erase = blkmtd_erase;
+  mtd_rawdevice->mtd_info.read = blkmtd_read;
+  mtd_rawdevice->mtd_info.write = blkmtd_write;
+  mtd_rawdevice->mtd_info.sync = blkmtd_sync;
+  mtd_rawdevice->mtd_info.point = 0;
+  mtd_rawdevice->mtd_info.unpoint = 0;
+
+  mtd_rawdevice->mtd_info.priv = mtd_rawdevice;
+  regions = calc_erase_regions(NULL, erase_size << 10, size);
+  DEBUG(1, "blkmtd: init: found %d erase regions\n", regions);
+  mtd_rawdevice->mtd_info.eraseregions = kmalloc(regions * sizeof(struct mtd_erase_region_info), GFP_KERNEL);
+  if(mtd_rawdevice->mtd_info.eraseregions == NULL) {
+    err = -ENOMEM;
+    goto init_err;
+  }
+  mtd_rawdevice->mtd_info.numeraseregions = regions;
+  calc_erase_regions(mtd_rawdevice->mtd_info.eraseregions, erase_size << 10, size);
+
+  /* setup the page cache info */
+  
+  mtd_rawdevice->as.nrpages = 0;
+  INIT_LIST_HEAD(&mtd_rawdevice->as.clean_pages);
+  INIT_LIST_HEAD(&mtd_rawdevice->as.dirty_pages);
+  INIT_LIST_HEAD(&mtd_rawdevice->as.locked_pages);
+  mtd_rawdevice->as.host = NULL;
+  spin_lock_init(&(mtd_rawdevice->as.i_shared_lock));
+
+  mtd_rawdevice->as.a_ops = &blkmtd_aops;
+  mtd_rawdevice->as.i_mmap = NULL;
+  mtd_rawdevice->as.i_mmap_shared = NULL;
+  mtd_rawdevice->as.gfp_mask = GFP_KERNEL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+  mtd_rawdevice->mtd_info.module = THIS_MODULE;			
+#endif
+  if (add_mtd_device(&mtd_rawdevice->mtd_info)) {
+    err = -EIO;
+    goto init_err;
+  }
+
+  if(!mtd_rawdevice->readonly) {
+    /* Allocate the write queue */
+    write_queue = kmalloc(write_queue_sz * sizeof(mtdblkdev_write_queue_t), GFP_KERNEL);
+    if(!write_queue) {
+      err = -ENOMEM;
+      goto init_err;
+    }
+    /* Set up the erase page */
+    erase_page = alloc_pages(GFP_KERNEL, 0);
+    if(erase_page == NULL) {
+      err = -ENOMEM;
+      goto init_err;
+    }
+    memset(page_address(erase_page), 0xff, PAGE_SIZE);
+    lock_page(erase_page);
+
+    init_waitqueue_head(&thr_wq);
+    init_waitqueue_head(&mtbd_sync_wq);
+    DEBUG(3, "blkmtd: init: kernel task @ %p\n", write_queue_task);
+    DEBUG(2, "blkmtd: init: starting kernel task\n");
+    kernel_thread(write_queue_task, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+    DEBUG(2, "blkmtd: init: started\n");
+    printk("blkmtd loaded: version = %s using %s erase_size = %dK %s\n",
+	   VERSION, device, erase_size, (readonly) ? "(read-only)" : "");
+  }
+
+#ifdef BLKMTD_PROC_DEBUG
+  /* create proc entry */
+  DEBUG(2, "Creating /proc/blkmtd_debug\n");
+  blkmtd_proc = create_proc_read_entry("blkmtd_debug", 0444,
+				       NULL, blkmtd_proc_read, NULL);
+  if(blkmtd_proc == NULL) {
+    printk("Cant create /proc/blkmtd_debug\n");
+  } else {
+    blkmtd_proc->owner = THIS_MODULE;
+  }
+#endif
+  
+  /* Everything is ok if we got here */
+  return 0;
+  
+ init_err:
+
+  if(mtd_rawdevice) {
+    if(mtd_rawdevice->mtd_info.eraseregions)
+      kfree(mtd_rawdevice->mtd_info.eraseregions);
+    if(mtd_rawdevice->mtd_info.name)
+      kfree(mtd_rawdevice->mtd_info.name);
+    if(mtd_rawdevice->binding) 
+      blkdev_put(mtd_rawdevice->binding, BDEV_RAW);
+    kfree(mtd_rawdevice);
+  }
+
+  if(write_queue) {
+    kfree(write_queue);
+    write_queue = NULL;
+  }
+
+  if(erase_page) 
+    __free_pages(erase_page, 0);
+  return err;
+}
+
+module_init(init_blkmtd);
+module_exit(cleanup_blkmtd);
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/doc1000.c linux-2.4.2/drivers/mtd/devices/doc1000.c
--- linux-2.4.2.orig/drivers/mtd/devices/doc1000.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/doc1000.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,595 @@
+/*======================================================================
+
+  $Id: doc1000.c,v 1.16 2001/12/28 22:45:17 dwmw2 Exp $
+
+======================================================================*/
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <stdarg.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/iflash.h>
+
+/* Parameters that can be set with 'insmod' */
+
+static u_long base              = 0xe0000;
+static int erase_timeout	= 10*HZ;	/* in ticks */
+static int retry_limit		= 4;		/* write retries */
+static u_long max_tries       	= 4096;		/* status polling */
+
+MODULE_PARM(base,"l");
+MODULE_PARM(erase_timeout, "i");
+MODULE_PARM(retry_limit, "i");
+MODULE_PARM(max_tries, "i");
+
+#define WINDOW_SIZE 0x2000
+#define WINDOW_MASK (WINDOW_SIZE - 1)
+#define PAGEREG_LO (WINDOW_SIZE)
+#define PAGEREG_HI (WINDOW_SIZE + 2)
+
+static struct mtd_info *mymtd;
+static struct timer_list flashcard_timer;
+
+#define MAX_CELLS		32
+#define MAX_FLASH_DEVICES       8
+
+/* A flash region is composed of one or more "cells", where we allow
+   simultaneous erases if they are in different cells */
+
+
+
+struct mypriv {
+	u_char *baseaddr;
+	u_short curpage;
+	u_char locked;
+	u_short numdevices;
+	u_char interleave;
+	struct erase_info *cur_erases;
+	wait_queue_head_t wq;
+	u_char devstat[MAX_FLASH_DEVICES];
+	u_long devshift;
+};
+
+
+static void flashcard_periodic(u_long data);
+static int flashcard_erase (struct mtd_info *mtd, struct erase_info *instr);
+static int flashcard_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+static int flashcard_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+static void flashcard_sync (struct mtd_info *mtd);
+
+static inline void resume_erase(volatile u_char *addr);
+static inline int suspend_erase(volatile u_char *addr);
+static inline int byte_write (volatile u_char *addr, u_char byte);
+static inline int word_write (volatile u_char *addr, __u16 word);
+static inline int check_write(volatile u_char *addr);
+static inline void block_erase (volatile u_char *addr);
+static inline int check_erase(volatile u_char *addr);
+
+#ifdef CONFIG_SMP
+#warning This is definitely not SMP safe. Lock the paging mechanism.
+#endif
+
+static u_char *pagein(struct mtd_info *mtd, u_long addr)
+{
+  struct mypriv *priv=mtd->priv;
+  u_short page = addr >> 13;
+
+  priv->baseaddr[PAGEREG_LO] = page & 0xff;
+  priv->baseaddr[PAGEREG_HI] = page >> 8;
+  priv->curpage = page;
+  
+  return &priv->baseaddr[addr & WINDOW_MASK];
+}
+
+
+void flashcard_sync (struct mtd_info *mtd)
+{
+	struct mypriv *priv=mtd->priv;
+
+	flashcard_periodic((u_long) mtd);
+	printk("sync...");
+	if (priv->cur_erases)
+		interruptible_sleep_on(&priv->wq);
+	printk("Done.\n");
+}
+
+int flashcard_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	u_char *pageaddr;
+	struct mypriv *priv=mtd->priv;
+	struct erase_info **tmp=&priv->cur_erases;
+	
+	if (instr->len != mtd->erasesize)
+		return -EINVAL;
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+
+	pageaddr=pagein(mtd,instr->addr);
+	instr->mtd = mtd;
+	instr->dev = instr->addr >> priv->devshift;
+	instr->cell = (instr->addr - (instr->dev << priv->devshift)) / mtd->erasesize;
+	instr->next = NULL;
+	instr->state = MTD_ERASE_PENDING;
+	
+	while (*tmp)
+	{
+		tmp = &((*tmp) -> next);
+	}
+	
+	*tmp = instr;
+	flashcard_periodic((u_long)mtd);
+	return 0;
+}
+
+
+int flashcard_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+ 	u_char *pageaddr=pagein(mtd,from);
+	struct mypriv *priv=mtd->priv;
+	u_char device = from >> priv->devshift;
+	u_char cell = (int) (from - (device << priv->devshift)) / mtd->erasesize;
+	int ret = 0, timeron = 0;
+
+	if ((from & WINDOW_MASK) + len <= WINDOW_SIZE)
+		*retlen = len;
+	else
+		*retlen = WINDOW_SIZE - (from & WINDOW_MASK);
+
+	if (priv->devstat[device])
+	{
+		
+		/* There is an erase in progress or pending for this device. Stop it */
+		timeron = del_timer(&flashcard_timer);
+		
+		if (priv->cur_erases && priv->cur_erases->cell == cell) 
+			
+		{
+			/* The erase is on the current cell. Just return all 0xff */ 
+			add_timer(&flashcard_timer);
+			
+			
+			printk("Cell %d currently erasing. Setting to all 0xff\n",cell);
+			memset(buf, 0xff, *retlen);
+			return 0;
+		}
+		if (priv->devstat[device] == MTD_ERASING)
+		{
+			ret = suspend_erase(pageaddr);
+			priv->devstat[device] = MTD_ERASE_SUSPEND;
+		       
+			if (ret) 
+			{
+				printk("flashcard: failed to suspend erase\n");
+				add_timer (&flashcard_timer);
+				return ret;
+			}
+		}
+
+	}
+
+	writew(IF_READ_ARRAY, (u_long)pageaddr & ~1);
+	
+	ret = 0;
+	memcpy (buf, pageaddr, *retlen);
+	
+	writew(IF_READ_CSR, (u_long)pageaddr & ~1);
+	
+	
+	if (priv->devstat[device] & MTD_ERASE_SUSPEND)
+	{
+		resume_erase(pageaddr);
+		priv->devstat[device]=MTD_ERASING;
+	}
+
+
+	if (timeron) add_timer (&flashcard_timer);
+		
+	return ret;
+}
+
+
+int flashcard_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct mypriv *priv = (struct mypriv *)mtd->priv;
+ 	u_char *endaddr, *startaddr;
+	register u_char *pageaddr;
+	u_char device = to >> priv->devshift;
+/*	jiffies_t oldj=jiffies;*/
+	int ret;
+
+	while (priv->devstat[device])
+	{
+		flashcard_sync(mtd);
+	}
+
+	if ((to & WINDOW_MASK) + len <= WINDOW_SIZE)
+		*retlen = len;
+	else
+		*retlen = WINDOW_SIZE - (to & WINDOW_MASK);
+	
+	pageaddr = pagein(mtd, to);
+	startaddr = (u_char *)((u_long) pageaddr & ~1);
+	endaddr = pageaddr+(*retlen);
+
+
+
+	/* Set up to read */
+	writew(IF_READ_CSR, startaddr);
+	
+	/* Make sure it's aligned by reading the first byte if necessary */
+	if (to & 1)
+	{
+		/* Unaligned access */
+
+		u_char cbuf;
+
+		cbuf = *buf;
+
+		if (!((u_long)pageaddr & 0xf))
+			schedule();
+			
+		ret = byte_write(pageaddr, cbuf);
+		if (ret) return ret;
+
+		pageaddr++; buf++;
+	}
+
+
+	for ( ; pageaddr + 1 < endaddr; buf += 2, pageaddr += 2)
+		{
+			/* if ((u_long)pageaddr & 0xf) schedule();*/
+			
+			ret = word_write(pageaddr, *(__u16 *)buf);
+			if (ret) 
+				return ret;
+		}
+	
+	if (pageaddr != endaddr)
+	{
+		/* One more byte to write at the end. */
+		u_char cbuf;
+
+		cbuf = *buf;
+
+		ret = byte_write(pageaddr, cbuf);
+
+		if (ret) return ret;
+	}
+
+	return check_write(startaddr);
+/*	printk("Time taken in flashcard_write: %lx jiffies\n",jiffies - oldj);*/
+}
+
+
+
+
+/*====================================================================*/
+
+static inline int byte_write (volatile u_char *addr, u_char byte)
+{
+	register u_char status;
+	register u_short i = 0;
+
+	do {
+		status = readb(addr);
+		if (status & CSR_WR_READY)
+		{
+			writeb(IF_WRITE & 0xff, addr);
+			writeb(byte, addr);
+			return 0;
+		}
+		i++;
+	} while(i < max_tries);
+
+		
+	printk(KERN_NOTICE "flashcard: byte_write timed out, status 0x%x\n",status);
+	return -EIO;
+}
+
+static inline int word_write (volatile u_char *addr, __u16 word)
+{
+	register u_short status;
+	register u_short i = 0;
+	
+	do {
+		status = readw(addr);
+		if ((status & CSR_WR_READY) == CSR_WR_READY)
+		{
+			writew(IF_WRITE, addr);
+			writew(word, addr);
+			return 0;
+		}
+		i++;
+	} while(i < max_tries);
+		
+	printk(KERN_NOTICE "flashcard: word_write timed out at %p, status 0x%x\n", addr, status);
+	return -EIO;
+}
+
+static inline void block_erase (volatile u_char *addr)
+{
+	writew(IF_BLOCK_ERASE, addr);
+	writew(IF_CONFIRM, addr);
+}
+
+
+static inline int check_erase(volatile u_char *addr)
+{
+	__u16 status;
+	
+/*	writew(IF_READ_CSR, addr);*/
+	status = readw(addr);
+	
+
+	if ((status & CSR_WR_READY) != CSR_WR_READY)
+		return -EBUSY;
+	
+	if (status & (CSR_ERA_ERR | CSR_VPP_LOW | CSR_WR_ERR)) 
+	{
+		printk(KERN_NOTICE "flashcard: erase failed, status 0x%x\n",
+		       status);
+		return -EIO;
+	}
+	
+	return 0;
+}
+
+static inline int suspend_erase(volatile u_char *addr)
+{
+	__u16 status;
+	u_long i = 0;
+	
+	writew(IF_ERASE_SUSPEND, addr);
+	writew(IF_READ_CSR, addr);
+	
+	do {
+		status = readw(addr);
+		if ((status & CSR_WR_READY) == CSR_WR_READY)
+			return 0;
+		i++;
+	} while(i < max_tries);
+
+	printk(KERN_NOTICE "flashcard: suspend_erase timed out, status 0x%x\n", status);
+	return -EIO;
+
+}
+
+static inline void resume_erase(volatile u_char *addr)
+{
+	__u16 status;
+	
+	writew(IF_READ_CSR, addr);
+	status = readw(addr);
+	
+	/* Only give resume signal if the erase is really suspended */
+	if (status & CSR_ERA_SUSPEND)
+		writew(IF_CONFIRM, addr);
+}
+
+static inline void reset_block(volatile u_char *addr)
+{
+	u_short i;
+	__u16 status;
+
+	writew(IF_CLEAR_CSR, addr);
+
+	for (i = 0; i < 100; i++) {
+		writew(IF_READ_CSR, addr);
+		status = readw(addr);
+		if (status != 0xffff) break;
+		udelay(1000);
+	}
+
+	writew(IF_READ_CSR, addr);
+}
+
+static inline int check_write(volatile u_char *addr)
+{
+	u_short status, i = 0;
+	
+	writew(IF_READ_CSR, addr);
+	
+	do {
+		status = readw(addr);
+		if (status & (CSR_WR_ERR | CSR_VPP_LOW))
+		{
+			printk(KERN_NOTICE "flashcard: write failure at %p, status 0x%x\n", addr, status);
+			reset_block(addr);
+			return -EIO;
+		}
+		if ((status & CSR_WR_READY) == CSR_WR_READY)
+			return 0;
+		i++;
+	} while (i < max_tries);
+
+	printk(KERN_NOTICE "flashcard: write timed out at %p, status 0x%x\n", addr, status);
+	return -EIO;
+}
+
+
+/*====================================================================*/
+
+
+
+static void flashcard_periodic(unsigned long data)
+{
+	register struct mtd_info *mtd = (struct mtd_info *)data;
+	register struct mypriv *priv = mtd->priv;
+	struct erase_info *erase = priv->cur_erases;
+	u_char *pageaddr;
+
+	del_timer (&flashcard_timer);
+
+	if (!erase)
+		return;
+
+	pageaddr = pagein(mtd, erase->addr);
+	
+	if (erase->state == MTD_ERASE_PENDING)
+	{
+		block_erase(pageaddr);
+		priv->devstat[erase->dev] = erase->state = MTD_ERASING;
+		erase->time = jiffies;
+		erase->retries = 0;
+	}
+	else if (erase->state == MTD_ERASING)
+	{
+		/* It's trying to erase. Check whether it's finished */
+
+		int ret = check_erase(pageaddr);
+
+		if (!ret)
+		{
+			/* It's finished OK */
+			priv->devstat[erase->dev] = 0;
+			priv->cur_erases = erase->next;
+			erase->state = MTD_ERASE_DONE;
+			if (erase->callback)
+				(*(erase->callback))(erase);
+			else
+				kfree(erase);
+		}
+		else if (ret == -EIO)
+		{
+			if (++erase->retries > retry_limit)
+			{
+				printk("Failed too many times. Giving up\n");
+				priv->cur_erases = erase->next;
+				priv->devstat[erase->dev] = 0;
+				erase->state = MTD_ERASE_FAILED;
+				if (erase->callback)
+					(*(erase->callback))(erase);
+				else
+					kfree(erase);
+			}
+			else
+				priv->devstat[erase->dev] = erase->state = MTD_ERASE_PENDING;
+		}
+		else if (time_after(jiffies, erase->time + erase_timeout))
+		{
+			printk("Flash erase timed out. The world is broken.\n");
+
+			/* Just ignore and hope it goes away. For a while, read ops will give the CSR
+			   and writes won't work. */
+
+			priv->cur_erases = erase->next;
+			priv->devstat[erase->dev] = 0;
+			erase->state = MTD_ERASE_FAILED;
+			if (erase->callback)
+					(*(erase->callback))(erase);
+				else
+					kfree(erase);
+		}
+	}
+
+	if (priv->cur_erases)
+	{
+		flashcard_timer.expires = jiffies + HZ;
+		add_timer (&flashcard_timer);
+	}
+	else 
+		wake_up_interruptible(&priv->wq);
+
+}
+
+int __init init_doc1000(void)
+{
+	struct mypriv *priv;
+
+	if (!base)
+	{
+		printk(KERN_NOTICE "flashcard: No start address for memory device.\n");
+		return -EINVAL;
+	}
+
+	mymtd  = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+
+	if (!mymtd)
+	{
+		printk(KERN_NOTICE "physmem: Cannot allocate memory for new MTD device.\n");
+		return -ENOMEM;
+	}
+
+	memset(mymtd,0,sizeof(struct mtd_info));
+
+	mymtd->priv = (void *) kmalloc (sizeof(struct mypriv), GFP_KERNEL);
+	if (!mymtd->priv)
+	  {
+	    kfree(mymtd);
+	    printk(KERN_NOTICE "physmem: Cannot allocate memory for new MTD device's private data.\n");
+	    return -ENOMEM;
+	  }
+	
+
+
+
+	priv=mymtd->priv;
+	init_waitqueue_head(&priv->wq);
+
+	memset (priv,0,sizeof(struct mypriv));
+
+	priv->baseaddr = phys_to_virt(base);
+	priv->numdevices = 4;
+	
+	mymtd->name = "M-Systems DiskOnChip 1000";
+
+	mymtd->size = 0x100000;
+	mymtd->flags = MTD_CLEAR_BITS | MTD_ERASEABLE;
+        mymtd->erase = flashcard_erase;
+	mymtd->point = NULL;
+	mymtd->unpoint = NULL;
+	mymtd->read = flashcard_read;
+	mymtd->write = flashcard_write;
+
+	mymtd->sync = flashcard_sync;
+	mymtd->erasesize = 0x10000;
+	//	mymtd->interleave = 2;
+	priv->devshift =  24;
+	mymtd->type = MTD_NORFLASH;
+	
+	if (add_mtd_device(mymtd))
+	{
+		printk(KERN_NOTICE "MTD device registration failed!\n");
+		kfree(mymtd->priv);
+		kfree(mymtd);
+		return -EAGAIN;
+	}
+	
+	init_timer(&flashcard_timer);
+	flashcard_timer.function = flashcard_periodic;
+	flashcard_timer.data = (u_long)mymtd;
+	return 0;
+}
+
+static void __init cleanup_doc1000(void)
+{
+	kfree (mymtd->priv);
+	del_mtd_device(mymtd);
+	kfree(mymtd);
+}
+
+module_init(init_doc1000);
+module_exit(cleanup_doc1000);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD driver for DiskOnChip 1000");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/doc2000.c linux-2.4.2/drivers/mtd/devices/doc2000.c
--- linux-2.4.2.orig/drivers/mtd/devices/doc2000.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/doc2000.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,1174 @@
+
+/*
+ * Linux driver for Disk-On-Chip 2000 and Millennium
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ *
+ * $Id: doc2000.c,v 1.46 2001/10/02 15:05:13 dwmw2 Exp $
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ids.h>
+#include <linux/mtd/doc2000.h>
+
+#define DOC_SUPPORT_2000
+#define DOC_SUPPORT_MILLENNIUM
+
+#ifdef DOC_SUPPORT_2000
+#define DoC_is_2000(doc) (doc->ChipID == DOC_ChipID_Doc2k)
+#else
+#define DoC_is_2000(doc) (0)
+#endif
+
+#ifdef DOC_SUPPORT_MILLENNIUM
+#define DoC_is_Millennium(doc) (doc->ChipID == DOC_ChipID_DocMil)
+#else
+#define DoC_is_Millennium(doc) (0)
+#endif
+
+/* #define ECC_DEBUG */
+
+/* I have no idea why some DoC chips can not use memcpy_from|to_io().
+ * This may be due to the different revisions of the ASIC controller built-in or
+ * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment
+ * this:
+ #undef USE_MEMCPY
+*/
+
+static int doc_read(struct mtd_info *mtd, loff_t from, size_t len,
+		    size_t *retlen, u_char *buf);
+static int doc_write(struct mtd_info *mtd, loff_t to, size_t len,
+		     size_t *retlen, const u_char *buf);
+static int doc_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf, u_char *eccbuf);
+static int doc_write_ecc(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t *retlen, const u_char *buf, u_char *eccbuf);
+static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			size_t *retlen, u_char *buf);
+static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			 size_t *retlen, const u_char *buf);
+static int doc_write_oob_nolock(struct mtd_info *mtd, loff_t ofs, size_t len,
+			 size_t *retlen, const u_char *buf);
+static int doc_erase (struct mtd_info *mtd, struct erase_info *instr);
+
+static struct mtd_info *doc2klist = NULL;
+
+/* Perform the required delay cycles by reading from the appropriate register */
+static void DoC_Delay(struct DiskOnChip *doc, unsigned short cycles)
+{
+	volatile char dummy;
+	int i;
+	
+	for (i = 0; i < cycles; i++) {
+		if (DoC_is_Millennium(doc))
+			dummy = ReadDOC(doc->virtadr, NOP);
+		else
+			dummy = ReadDOC(doc->virtadr, DOCStatus);
+	}
+	
+}
+
+/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
+static int _DoC_WaitReady(struct DiskOnChip *doc)
+{
+	unsigned long docptr = doc->virtadr;
+	unsigned long timeo = jiffies + (HZ * 10);
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "_DoC_WaitReady called for out-of-line wait\n");
+
+	/* Out-of-line routine to wait for chip response */
+	while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
+		if (time_after(jiffies, timeo)) {
+			DEBUG(MTD_DEBUG_LEVEL2, "_DoC_WaitReady timed out.\n");
+			return -EIO;
+		}
+		if (current->need_resched) {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+		else
+			udelay(1);
+	}
+
+	return 0;
+}
+
+static inline int DoC_WaitReady(struct DiskOnChip *doc)
+{
+	unsigned long docptr = doc->virtadr;
+	/* This is inline, to optimise the common case, where it's ready instantly */
+	int ret = 0;
+
+	/* 4 read form NOP register should be issued in prior to the read from CDSNControl
+	   see Software Requirement 11.4 item 2. */
+	DoC_Delay(doc, 4);
+
+	if (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))
+		/* Call the out-of-line routine to wait */
+		ret = _DoC_WaitReady(doc);
+
+	/* issue 2 read from NOP register after reading from CDSNControl register
+	   see Software Requirement 11.4 item 2. */
+	DoC_Delay(doc, 2);
+
+	return ret;
+}
+
+/* DoC_Command: Send a flash command to the flash chip through the CDSN Slow IO register to
+   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
+   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
+
+static inline int DoC_Command(struct DiskOnChip *doc, unsigned char command,
+			      unsigned char xtraflags)
+{
+	unsigned long docptr = doc->virtadr;
+
+	if (DoC_is_2000(doc))
+		xtraflags |= CDSN_CTRL_FLASH_IO;
+
+	/* Assert the CLE (Command Latch Enable) line to the flash chip */
+	WriteDOC(xtraflags | CDSN_CTRL_CLE | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	if (DoC_is_Millennium(doc))
+		WriteDOC(command, docptr, CDSNSlowIO);
+
+	/* Send the command */
+	WriteDOC_(command, docptr, doc->ioreg);
+
+	/* Lower the CLE line */
+	WriteDOC(xtraflags | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	/* Wait for the chip to respond - Software requirement 11.4.1 (extended for any command) */
+	return DoC_WaitReady(doc);
+}
+
+/* DoC_Address: Set the current address for the flash chip through the CDSN Slow IO register to
+   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
+   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
+
+static int DoC_Address(struct DiskOnChip *doc, int numbytes, unsigned long ofs,
+		       unsigned char xtraflags1, unsigned char xtraflags2)
+{
+	unsigned long docptr;
+	int i;
+
+	docptr = doc->virtadr;
+
+	if (DoC_is_2000(doc))
+		xtraflags1 |= CDSN_CTRL_FLASH_IO;
+
+	/* Assert the ALE (Address Latch Enable) line to the flash chip */
+	WriteDOC(xtraflags1 | CDSN_CTRL_ALE | CDSN_CTRL_CE, docptr, CDSNControl);
+
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	/* Send the address */
+	/* Devices with 256-byte page are addressed as:
+	   Column (bits 0-7), Page (bits 8-15, 16-23, 24-31)
+	   * there is no device on the market with page256
+	   and more than 24 bits.
+	   Devices with 512-byte page are addressed as:
+	   Column (bits 0-7), Page (bits 9-16, 17-24, 25-31)
+	   * 25-31 is sent only if the chip support it.
+	   * bit 8 changes the read command to be sent
+	   (NAND_CMD_READ0 or NAND_CMD_READ1).
+	 */
+
+	if (numbytes == ADDR_COLUMN || numbytes == ADDR_COLUMN_PAGE) {
+		if (DoC_is_Millennium(doc))
+			WriteDOC(ofs & 0xff, docptr, CDSNSlowIO);
+		WriteDOC_(ofs & 0xff, docptr, doc->ioreg);
+	}
+
+	if (doc->page256) {
+		ofs = ofs >> 8;
+	} else {
+		ofs = ofs >> 9;
+	}
+
+	if (numbytes == ADDR_PAGE || numbytes == ADDR_COLUMN_PAGE) {
+		for (i = 0; i < doc->pageadrlen; i++, ofs = ofs >> 8) {
+			if (DoC_is_Millennium(doc))
+				WriteDOC(ofs & 0xff, docptr, CDSNSlowIO);
+			WriteDOC_(ofs & 0xff, docptr, doc->ioreg);
+		}
+	}
+
+	DoC_Delay(doc, 2);	/* Needed for some slow flash chips. mf. */
+	
+	/* FIXME: The SlowIO's for millennium could be replaced by 
+	   a single WritePipeTerm here. mf. */
+
+	/* Lower the ALE line */
+	WriteDOC(xtraflags1 | xtraflags2 | CDSN_CTRL_CE, docptr,
+		 CDSNControl);
+
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	/* Wait for the chip to respond - Software requirement 11.4.1 */
+	return DoC_WaitReady(doc);
+}
+
+/* Read a buffer from DoC, taking care of Millennium odditys */
+static void DoC_ReadBuf(struct DiskOnChip *doc, u_char * buf, int len)
+{
+	volatile int dummy;
+	int modulus = 0xffff;
+	unsigned long docptr;
+	int i;
+
+	docptr = doc->virtadr;
+
+	if (len <= 0)
+		return;
+
+	if (DoC_is_Millennium(doc)) {
+		/* Read the data via the internal pipeline through CDSN IO register,
+		   see Pipelined Read Operations 11.3 */
+		dummy = ReadDOC(docptr, ReadPipeInit);
+
+		/* Millennium should use the LastDataRead register - Pipeline Reads */
+		len--;
+
+		/* This is needed for correctly ECC calculation */
+		modulus = 0xff;
+	}
+
+	for (i = 0; i < len; i++)
+		buf[i] = ReadDOC_(docptr, doc->ioreg + (i & modulus));
+
+	if (DoC_is_Millennium(doc)) {
+		buf[i] = ReadDOC(docptr, LastDataRead);
+	}
+}
+
+/* Write a buffer to DoC, taking care of Millennium odditys */
+static void DoC_WriteBuf(struct DiskOnChip *doc, const u_char * buf, int len)
+{
+	unsigned long docptr;
+	int i;
+
+	docptr = doc->virtadr;
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len; i++)
+		WriteDOC_(buf[i], docptr, doc->ioreg + i);
+
+	if (DoC_is_Millennium(doc)) {
+		WriteDOC(0x00, docptr, WritePipeTerm);
+	}
+}
+
+
+/* DoC_SelectChip: Select a given flash chip within the current floor */
+
+static inline int DoC_SelectChip(struct DiskOnChip *doc, int chip)
+{
+	unsigned long docptr = doc->virtadr;
+
+	/* Software requirement 11.4.4 before writing DeviceSelect */
+	/* Deassert the CE line to eliminate glitches on the FCE# outputs */
+	WriteDOC(CDSN_CTRL_WP, docptr, CDSNControl);
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	/* Select the individual flash chip requested */
+	WriteDOC(chip, docptr, CDSNDeviceSelect);
+	DoC_Delay(doc, 4);
+
+	/* Reassert the CE line */
+	WriteDOC(CDSN_CTRL_CE | CDSN_CTRL_FLASH_IO | CDSN_CTRL_WP, docptr,
+		 CDSNControl);
+	DoC_Delay(doc, 4);	/* Software requirement 11.4.3 for Millennium */
+
+	/* Wait for it to be ready */
+	return DoC_WaitReady(doc);
+}
+
+/* DoC_SelectFloor: Select a given floor (bank of flash chips) */
+
+static inline int DoC_SelectFloor(struct DiskOnChip *doc, int floor)
+{
+	unsigned long docptr = doc->virtadr;
+
+	/* Select the floor (bank) of chips required */
+	WriteDOC(floor, docptr, FloorSelect);
+
+	/* Wait for the chip to be ready */
+	return DoC_WaitReady(doc);
+}
+
+/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */
+
+static int DoC_IdentChip(struct DiskOnChip *doc, int floor, int chip)
+{
+	int mfr, id, i;
+	volatile char dummy;
+
+	/* Page in the required floor/chip */
+	DoC_SelectFloor(doc, floor);
+	DoC_SelectChip(doc, chip);
+
+	/* Reset the chip */
+	if (DoC_Command(doc, NAND_CMD_RESET, CDSN_CTRL_WP)) {
+		DEBUG(MTD_DEBUG_LEVEL2,
+		      "DoC_Command (reset) for %d,%d returned true\n",
+		      floor, chip);
+		return 0;
+	}
+
+
+	/* Read the NAND chip ID: 1. Send ReadID command */
+	if (DoC_Command(doc, NAND_CMD_READID, CDSN_CTRL_WP)) {
+		DEBUG(MTD_DEBUG_LEVEL2,
+		      "DoC_Command (ReadID) for %d,%d returned true\n",
+		      floor, chip);
+		return 0;
+	}
+
+	/* Read the NAND chip ID: 2. Send address byte zero */
+	DoC_Address(doc, ADDR_COLUMN, 0, CDSN_CTRL_WP, 0);
+
+	/* Read the manufacturer and device id codes from the device */
+
+	/* CDSN Slow IO register see Software Requirement 11.4 item 5. */
+	dummy = ReadDOC(doc->virtadr, CDSNSlowIO);
+	DoC_Delay(doc, 2);
+	mfr = ReadDOC_(doc->virtadr, doc->ioreg);
+
+	/* CDSN Slow IO register see Software Requirement 11.4 item 5. */
+	dummy = ReadDOC(doc->virtadr, CDSNSlowIO);
+	DoC_Delay(doc, 2);
+	id = ReadDOC_(doc->virtadr, doc->ioreg);
+
+	/* No response - return failure */
+	if (mfr == 0xff || mfr == 0)
+		return 0;
+
+	/* Check it's the same as the first chip we identified. 
+	 * M-Systems say that any given DiskOnChip device should only
+	 * contain _one_ type of flash part, although that's not a 
+	 * hardware restriction. */
+	if (doc->mfr) {
+		if (doc->mfr == mfr && doc->id == id)
+			return 1;	/* This is another the same the first */
+		else
+			printk(KERN_WARNING
+			       "Flash chip at floor %d, chip %d is different:\n",
+			       floor, chip);
+	}
+
+	/* Print and store the manufacturer and ID codes. */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (mfr == nand_flash_ids[i].manufacture_id &&
+		    id == nand_flash_ids[i].model_id) {
+			printk(KERN_INFO
+			       "Flash chip found: Manufacturer ID: %2.2X, "
+			       "Chip ID: %2.2X (%s)\n", mfr, id,
+			       nand_flash_ids[i].name);
+			if (!doc->mfr) {
+				doc->mfr = mfr;
+				doc->id = id;
+				doc->chipshift =
+				    nand_flash_ids[i].chipshift;
+				doc->page256 = nand_flash_ids[i].page256;
+				doc->pageadrlen =
+				    nand_flash_ids[i].pageadrlen;
+				doc->erasesize =
+				    nand_flash_ids[i].erasesize;
+				return 1;
+			}
+			return 0;
+		}
+	}
+
+
+	/* We haven't fully identified the chip. Print as much as we know. */
+	printk(KERN_WARNING "Unknown flash chip found: %2.2X %2.2X\n",
+	       id, mfr);
+
+	printk(KERN_WARNING "Please report to dwmw2@infradead.org\n");
+	return 0;
+}
+
+/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */
+
+static void DoC_ScanChips(struct DiskOnChip *this)
+{
+	int floor, chip;
+	int numchips[MAX_FLOORS];
+	int maxchips = MAX_CHIPS;
+	int ret = 1;
+
+	this->numchips = 0;
+	this->mfr = 0;
+	this->id = 0;
+
+	if (DoC_is_Millennium(this))
+		maxchips = MAX_CHIPS_MIL;
+
+	/* For each floor, find the number of valid chips it contains */
+	for (floor = 0; floor < MAX_FLOORS; floor++) {
+		ret = 1;
+		numchips[floor] = 0;
+		for (chip = 0; chip < maxchips && ret != 0; chip++) {
+
+			ret = DoC_IdentChip(this, floor, chip);
+			if (ret) {
+				numchips[floor]++;
+				this->numchips++;
+			}
+		}
+	}
+
+	/* If there are none at all that we recognise, bail */
+	if (!this->numchips) {
+		printk(KERN_NOTICE "No flash chips recognised.\n");
+		return;
+	}
+
+	/* Allocate an array to hold the information for each chip */
+	this->chips = kmalloc(sizeof(struct Nand) * this->numchips, GFP_KERNEL);
+	if (!this->chips) {
+		printk(KERN_NOTICE "No memory for allocating chip info structures\n");
+		return;
+	}
+
+	ret = 0;
+
+	/* Fill out the chip array with {floor, chipno} for each 
+	 * detected chip in the device. */
+	for (floor = 0; floor < MAX_FLOORS; floor++) {
+		for (chip = 0; chip < numchips[floor]; chip++) {
+			this->chips[ret].floor = floor;
+			this->chips[ret].chip = chip;
+			this->chips[ret].curadr = 0;
+			this->chips[ret].curmode = 0x50;
+			ret++;
+		}
+	}
+
+	/* Calculate and print the total size of the device */
+	this->totlen = this->numchips * (1 << this->chipshift);
+
+	printk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",
+	       this->numchips, this->totlen >> 20);
+}
+
+static int DoC2k_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)
+{
+	int tmp1, tmp2, retval;
+	if (doc1->physadr == doc2->physadr)
+		return 1;
+
+	/* Use the alias resolution register which was set aside for this
+	 * purpose. If it's value is the same on both chips, they might
+	 * be the same chip, and we write to one and check for a change in
+	 * the other. It's unclear if this register is usuable in the
+	 * DoC 2000 (it's in the Millennium docs), but it seems to work. */
+	tmp1 = ReadDOC(doc1->virtadr, AliasResolution);
+	tmp2 = ReadDOC(doc2->virtadr, AliasResolution);
+	if (tmp1 != tmp2)
+		return 0;
+
+	WriteDOC((tmp1 + 1) % 0xff, doc1->virtadr, AliasResolution);
+	tmp2 = ReadDOC(doc2->virtadr, AliasResolution);
+	if (tmp2 == (tmp1 + 1) % 0xff)
+		retval = 1;
+	else
+		retval = 0;
+
+	/* Restore register contents.  May not be necessary, but do it just to
+	 * be safe. */
+	WriteDOC(tmp1, doc1->virtadr, AliasResolution);
+
+	return retval;
+}
+
+static const char im_name[] = "DoC2k_init";
+
+/* This routine is made available to other mtd code via
+ * inter_module_register.  It must only be accessed through
+ * inter_module_get which will bump the use count of this module.  The
+ * addresses passed back in mtd are valid as long as the use count of
+ * this module is non-zero, i.e. between inter_module_get and
+ * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
+ */
+static void DoC2k_init(struct mtd_info *mtd)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *old = NULL;
+
+	/* We must avoid being called twice for the same device. */
+
+	if (doc2klist)
+		old = (struct DiskOnChip *) doc2klist->priv;
+
+	while (old) {
+		if (DoC2k_is_alias(old, this)) {
+			printk(KERN_NOTICE
+			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
+			       this->physadr);
+			iounmap((void *) this->virtadr);
+			kfree(mtd);
+			return;
+		}
+		if (old->nextdoc)
+			old = (struct DiskOnChip *) old->nextdoc->priv;
+		else
+			old = NULL;
+	}
+
+
+	switch (this->ChipID) {
+	case DOC_ChipID_Doc2k:
+		mtd->name = "DiskOnChip 2000";
+		this->ioreg = DoC_2k_CDSN_IO;
+		break;
+	case DOC_ChipID_DocMil:
+		mtd->name = "DiskOnChip Millennium";
+		this->ioreg = DoC_Mil_CDSN_IO;
+		break;
+	}
+
+	printk(KERN_NOTICE "%s found at address 0x%lX\n", mtd->name,
+	       this->physadr);
+
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->size = 0;
+	mtd->erasesize = 0;
+	mtd->oobblock = 512;
+	mtd->oobsize = 16;
+	mtd->module = THIS_MODULE;
+	mtd->erase = doc_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = doc_read;
+	mtd->write = doc_write;
+	mtd->read_ecc = doc_read_ecc;
+	mtd->write_ecc = doc_write_ecc;
+	mtd->read_oob = doc_read_oob;
+	mtd->write_oob = doc_write_oob;
+	mtd->sync = NULL;
+
+	this->totlen = 0;
+	this->numchips = 0;
+
+	this->curfloor = -1;
+	this->curchip = -1;
+	init_MUTEX(&this->lock);
+
+	/* Ident all the chips present. */
+	DoC_ScanChips(this);
+
+	if (!this->totlen) {
+		kfree(mtd);
+		iounmap((void *) this->virtadr);
+	} else {
+		this->nextdoc = doc2klist;
+		doc2klist = mtd;
+		mtd->size = this->totlen;
+		mtd->erasesize = this->erasesize;
+		add_mtd_device(mtd);
+		return;
+	}
+}
+
+static int doc_read(struct mtd_info *mtd, loff_t from, size_t len,
+		    size_t * retlen, u_char * buf)
+{
+	/* Just a special case of doc_read_ecc */
+	return doc_read_ecc(mtd, from, len, retlen, buf, NULL);
+}
+
+static int doc_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t * retlen, u_char * buf, u_char * eccbuf)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	unsigned long docptr;
+	struct Nand *mychip;
+	unsigned char syndrome[6];
+	volatile char dummy;
+	int i, len256 = 0, ret=0;
+
+	docptr = this->virtadr;
+
+	/* Don't allow read past end of device */
+	if (from >= this->totlen)
+		return -EINVAL;
+
+	down(&this->lock);
+
+	/* Don't allow a single read to cross a 512-byte block boundary */
+	if (from + len > ((from | 0x1ff) + 1))
+		len = ((from | 0x1ff) + 1) - from;
+
+	/* The ECC will not be calculated correctly if less than 512 is read */
+	if (len != 0x200 && eccbuf)
+		printk(KERN_WARNING
+		       "ECC needs a full sector read (adr: %lx size %lx)\n",
+		       (long) from, (long) len);
+
+	/* printk("DoC_Read (adr: %lx size %lx)\n", (long) from, (long) len); */
+
+
+	/* Find the chip which is to be used and select it */
+	mychip = &this->chips[from >> (this->chipshift)];
+
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(this, mychip->floor);
+		DoC_SelectChip(this, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(this, mychip->chip);
+	}
+
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	DoC_Command(this,
+		    (!this->page256
+		     && (from & 0x100)) ? NAND_CMD_READ1 : NAND_CMD_READ0,
+		    CDSN_CTRL_WP);
+	DoC_Address(this, ADDR_COLUMN_PAGE, from, CDSN_CTRL_WP,
+		    CDSN_CTRL_ECC_IO);
+
+	if (eccbuf) {
+		/* Prime the ECC engine */
+		WriteDOC(DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC(DOC_ECC_EN, docptr, ECCConf);
+	} else {
+		/* disable the ECC engine */
+		WriteDOC(DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC(DOC_ECC_DIS, docptr, ECCConf);
+	}
+
+	/* treat crossing 256-byte sector for 2M x 8bits devices */
+	if (this->page256 && from + len > (from | 0xff) + 1) {
+		len256 = (from | 0xff) + 1 - from;
+		DoC_ReadBuf(this, buf, len256);
+
+		DoC_Command(this, NAND_CMD_READ0, CDSN_CTRL_WP);
+		DoC_Address(this, ADDR_COLUMN_PAGE, from + len256,
+			    CDSN_CTRL_WP, CDSN_CTRL_ECC_IO);
+	}
+
+	DoC_ReadBuf(this, &buf[len256], len - len256);
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+
+	if (eccbuf) {
+		/* Read the ECC data through the DiskOnChip ECC logic */
+		/* Note: this will work even with 2M x 8bit devices as   */
+		/*       they have 8 bytes of OOB per 256 page. mf.      */
+		DoC_ReadBuf(this, eccbuf, 6);
+
+		/* Flush the pipeline */
+		if (DoC_is_Millennium(this)) {
+			dummy = ReadDOC(docptr, ECCConf);
+			dummy = ReadDOC(docptr, ECCConf);
+			i = ReadDOC(docptr, ECCConf);
+		} else {
+			dummy = ReadDOC(docptr, 2k_ECCStatus);
+			dummy = ReadDOC(docptr, 2k_ECCStatus);
+			i = ReadDOC(docptr, 2k_ECCStatus);
+		}
+
+		/* Check the ECC Status */
+		if (i & 0x80) {
+			int nb_errors;
+			/* There was an ECC error */
+#ifdef ECC_DEBUG
+			printk(KERN_ERR "DiskOnChip ECC Error: Read at %lx\n", (long)from);
+#endif
+			/* Read the ECC syndrom through the DiskOnChip ECC logic.
+			   These syndrome will be all ZERO when there is no error */
+			for (i = 0; i < 6; i++) {
+				syndrome[i] =
+				    ReadDOC(docptr, ECCSyndrome0 + i);
+			}
+                        nb_errors = doc_decode_ecc(buf, syndrome);
+
+#ifdef ECC_DEBUG
+			printk(KERN_ERR "Errors corrected: %x\n", nb_errors);
+#endif
+                        if (nb_errors < 0) {
+				/* We return error, but have actually done the read. Not that
+				   this can be told to user-space, via sys_read(), but at least
+				   MTD-aware stuff can know about it by checking *retlen */
+				ret = -EIO;
+                        }
+		}
+
+#ifdef PSYCHO_DEBUG
+		printk(KERN_DEBUG "ECC DATA at %lxB: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",
+			     (long)from, eccbuf[0], eccbuf[1], eccbuf[2],
+			     eccbuf[3], eccbuf[4], eccbuf[5]);
+#endif
+		
+		/* disable the ECC engine */
+		WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
+	}
+
+	/* according to 11.4.1, we need to wait for the busy line 
+         * drop if we read to the end of the page.  */
+	if(0 == ((from + *retlen) & 0x1ff))
+	{
+	    DoC_WaitReady(this);
+	}
+
+	up(&this->lock);
+
+	return ret;
+}
+
+static int doc_write(struct mtd_info *mtd, loff_t to, size_t len,
+		     size_t * retlen, const u_char * buf)
+{
+	char eccbuf[6];
+	return doc_write_ecc(mtd, to, len, retlen, buf, eccbuf);
+}
+
+static int doc_write_ecc(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t * retlen, const u_char * buf,
+			 u_char * eccbuf)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	int di; /* Yes, DI is a hangover from when I was disassembling the binary driver */
+	unsigned long docptr;
+	volatile char dummy;
+	int len256 = 0;
+	struct Nand *mychip;
+
+	docptr = this->virtadr;
+
+	/* Don't allow write past end of device */
+	if (to >= this->totlen)
+		return -EINVAL;
+
+	down(&this->lock);
+
+	/* Don't allow a single write to cross a 512-byte block boundary */
+	if (to + len > ((to | 0x1ff) + 1))
+		len = ((to | 0x1ff) + 1) - to;
+
+	/* The ECC will not be calculated correctly if less than 512 is written */
+	if (len != 0x200 && eccbuf)
+		printk(KERN_WARNING
+		       "ECC needs a full sector write (adr: %lx size %lx)\n",
+		       (long) to, (long) len);
+
+	/* printk("DoC_Write (adr: %lx size %lx)\n", (long) to, (long) len); */
+
+	/* Find the chip which is to be used and select it */
+	mychip = &this->chips[to >> (this->chipshift)];
+
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(this, mychip->floor);
+		DoC_SelectChip(this, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(this, mychip->chip);
+	}
+
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* Set device to main plane of flash */
+	DoC_Command(this, NAND_CMD_RESET, CDSN_CTRL_WP);
+	DoC_Command(this,
+		    (!this->page256
+		     && (to & 0x100)) ? NAND_CMD_READ1 : NAND_CMD_READ0,
+		    CDSN_CTRL_WP);
+
+	DoC_Command(this, NAND_CMD_SEQIN, 0);
+	DoC_Address(this, ADDR_COLUMN_PAGE, to, 0, CDSN_CTRL_ECC_IO);
+
+	if (eccbuf) {
+		/* Prime the ECC engine */
+		WriteDOC(DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);
+	} else {
+		/* disable the ECC engine */
+		WriteDOC(DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC(DOC_ECC_DIS, docptr, ECCConf);
+	}
+
+	/* treat crossing 256-byte sector for 2M x 8bits devices */
+	if (this->page256 && to + len > (to | 0xff) + 1) {
+		len256 = (to | 0xff) + 1 - to;
+		DoC_WriteBuf(this, buf, len256);
+
+		DoC_Command(this, NAND_CMD_PAGEPROG, 0);
+
+		DoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);
+		/* There's an implicit DoC_WaitReady() in DoC_Command */
+
+		dummy = ReadDOC(docptr, CDSNSlowIO);
+		DoC_Delay(this, 2);
+
+		if (ReadDOC_(docptr, this->ioreg) & 1) {
+			printk(KERN_ERR "Error programming flash\n");
+			/* Error in programming */
+			*retlen = 0;
+			up(&this->lock);
+			return -EIO;
+		}
+
+		DoC_Command(this, NAND_CMD_SEQIN, 0);
+		DoC_Address(this, ADDR_COLUMN_PAGE, to + len256, 0,
+			    CDSN_CTRL_ECC_IO);
+	}
+
+	DoC_WriteBuf(this, &buf[len256], len - len256);
+
+	if (eccbuf) {
+		WriteDOC(CDSN_CTRL_ECC_IO | CDSN_CTRL_CE, docptr,
+			 CDSNControl);
+
+		if (DoC_is_Millennium(this)) {
+			WriteDOC(0, docptr, NOP);
+			WriteDOC(0, docptr, NOP);
+			WriteDOC(0, docptr, NOP);
+		} else {
+			WriteDOC_(0, docptr, this->ioreg);
+			WriteDOC_(0, docptr, this->ioreg);
+			WriteDOC_(0, docptr, this->ioreg);
+		}
+
+		/* Read the ECC data through the DiskOnChip ECC logic */
+		for (di = 0; di < 6; di++) {
+			eccbuf[di] = ReadDOC(docptr, ECCSyndrome0 + di);
+		}
+
+		/* Reset the ECC engine */
+		WriteDOC(DOC_ECC_DIS, docptr, ECCConf);
+
+#ifdef PSYCHO_DEBUG
+		printk
+		    ("OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",
+		     (long) to, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],
+		     eccbuf[4], eccbuf[5]);
+#endif
+	}
+
+	DoC_Command(this, NAND_CMD_PAGEPROG, 0);
+
+	DoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);
+	/* There's an implicit DoC_WaitReady() in DoC_Command */
+
+	dummy = ReadDOC(docptr, CDSNSlowIO);
+	DoC_Delay(this, 2);
+
+	if (ReadDOC_(docptr, this->ioreg) & 1) {
+		printk(KERN_ERR "Error programming flash\n");
+		/* Error in programming */
+		*retlen = 0;
+		up(&this->lock);
+		return -EIO;
+	}
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+		
+	if (eccbuf) {
+		unsigned char x[8];
+		size_t dummy;
+		int ret;
+
+		/* Write the ECC data to flash */
+		for (di=0; di<6; di++)
+			x[di] = eccbuf[di];
+		
+		x[6]=0x55;
+		x[7]=0x55;
+		
+		ret = doc_write_oob_nolock(mtd, to, 8, &dummy, x);
+		up(&this->lock);
+		return ret;
+	}
+	up(&this->lock);
+	return 0;
+}
+
+static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			size_t * retlen, u_char * buf)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	int len256 = 0, ret;
+	unsigned long docptr;
+	struct Nand *mychip;
+
+	down(&this->lock);
+
+	docptr = this->virtadr;
+
+	mychip = &this->chips[ofs >> this->chipshift];
+
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(this, mychip->floor);
+		DoC_SelectChip(this, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(this, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* update address for 2M x 8bit devices. OOB starts on the second */
+	/* page to maintain compatibility with doc_read_ecc. */
+	if (this->page256) {
+		if (!(ofs & 0x8))
+			ofs += 0x100;
+		else
+			ofs -= 0x8;
+	}
+
+	DoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);
+	DoC_Address(this, ADDR_COLUMN_PAGE, ofs, CDSN_CTRL_WP, 0);
+
+	/* treat crossing 8-byte OOB data for 2M x 8bit devices */
+	/* Note: datasheet says it should automaticaly wrap to the */
+	/*       next OOB block, but it didn't work here. mf.      */
+	if (this->page256 && ofs + len > (ofs | 0x7) + 1) {
+		len256 = (ofs | 0x7) + 1 - ofs;
+		DoC_ReadBuf(this, buf, len256);
+
+		DoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);
+		DoC_Address(this, ADDR_COLUMN_PAGE, ofs & (~0x1ff),
+			    CDSN_CTRL_WP, 0);
+	}
+
+	DoC_ReadBuf(this, &buf[len256], len - len256);
+
+	*retlen = len;
+	/* Reading the full OOB data drops us off of the end of the page,
+         * causing the flash device to go into busy mode, so we need
+         * to wait until ready 11.4.1 and Toshiba TC58256FT docs */
+	
+	ret = DoC_WaitReady(this);
+
+	up(&this->lock);
+	return ret;
+
+}
+
+static int doc_write_oob_nolock(struct mtd_info *mtd, loff_t ofs, size_t len,
+				size_t * retlen, const u_char * buf)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	int len256 = 0;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
+	volatile int dummy;
+
+	//      printk("doc_write_oob(%lx, %d): %2.2X %2.2X %2.2X %2.2X ... %2.2X %2.2X .. %2.2X %2.2X\n",(long)ofs, len,
+	//   buf[0], buf[1], buf[2], buf[3], buf[8], buf[9], buf[14],buf[15]);
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(this, mychip->floor);
+		DoC_SelectChip(this, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(this, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* disable the ECC engine */
+	WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+	WriteDOC (DOC_ECC_DIS, docptr, ECCConf);
+
+	/* Reset the chip, see Software Requirement 11.4 item 1. */
+	DoC_Command(this, NAND_CMD_RESET, CDSN_CTRL_WP);
+
+	/* issue the Read2 command to set the pointer to the Spare Data Area. */
+	DoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);
+
+	/* update address for 2M x 8bit devices. OOB starts on the second */
+	/* page to maintain compatibility with doc_read_ecc. */
+	if (this->page256) {
+		if (!(ofs & 0x8))
+			ofs += 0x100;
+		else
+			ofs -= 0x8;
+	}
+
+	/* issue the Serial Data In command to initial the Page Program process */
+	DoC_Command(this, NAND_CMD_SEQIN, 0);
+	DoC_Address(this, ADDR_COLUMN_PAGE, ofs, 0, 0);
+
+	/* treat crossing 8-byte OOB data for 2M x 8bit devices */
+	/* Note: datasheet says it should automaticaly wrap to the */
+	/*       next OOB block, but it didn't work here. mf.      */
+	if (this->page256 && ofs + len > (ofs | 0x7) + 1) {
+		len256 = (ofs | 0x7) + 1 - ofs;
+		DoC_WriteBuf(this, buf, len256);
+
+		DoC_Command(this, NAND_CMD_PAGEPROG, 0);
+		DoC_Command(this, NAND_CMD_STATUS, 0);
+		/* DoC_WaitReady() is implicit in DoC_Command */
+
+		dummy = ReadDOC(docptr, CDSNSlowIO);
+		DoC_Delay(this, 2);
+
+		if (ReadDOC_(docptr, this->ioreg) & 1) {
+			printk(KERN_ERR "Error programming oob data\n");
+			/* There was an error */
+			*retlen = 0;
+			return -EIO;
+		}
+		DoC_Command(this, NAND_CMD_SEQIN, 0);
+		DoC_Address(this, ADDR_COLUMN_PAGE, ofs & (~0x1ff), 0, 0);
+	}
+
+	DoC_WriteBuf(this, &buf[len256], len - len256);
+
+	DoC_Command(this, NAND_CMD_PAGEPROG, 0);
+	DoC_Command(this, NAND_CMD_STATUS, 0);
+	/* DoC_WaitReady() is implicit in DoC_Command */
+
+	dummy = ReadDOC(docptr, CDSNSlowIO);
+	DoC_Delay(this, 2);
+
+	if (ReadDOC_(docptr, this->ioreg) & 1) {
+		printk(KERN_ERR "Error programming oob data\n");
+		/* There was an error */
+		*retlen = 0;
+		return -EIO;
+	}
+
+	*retlen = len;
+	return 0;
+
+}
+ 
+static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+ 			 size_t * retlen, const u_char * buf)
+{
+ 	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+ 	int ret;
+
+ 	down(&this->lock);
+ 	ret = doc_write_oob_nolock(mtd, ofs, len, retlen, buf);
+
+ 	up(&this->lock);
+ 	return ret;
+}
+
+static int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
+	volatile int dummy;
+	unsigned long docptr;
+	struct Nand *mychip;
+
+ 	down(&this->lock);
+
+	if (ofs & (mtd->erasesize-1) || len & (mtd->erasesize-1)) {
+		up(&this->lock);
+		return -EINVAL;
+	}
+
+	instr->state = MTD_ERASING;
+		
+	docptr = this->virtadr;
+
+	/* FIXME: Do this in the background. Use timers or schedule_task() */
+	while(len) {
+		mychip = &this->chips[ofs >> this->chipshift];
+
+		if (this->curfloor != mychip->floor) {
+			DoC_SelectFloor(this, mychip->floor);
+			DoC_SelectChip(this, mychip->chip);
+		} else if (this->curchip != mychip->chip) {
+			DoC_SelectChip(this, mychip->chip);
+		}
+		this->curfloor = mychip->floor;
+		this->curchip = mychip->chip;
+
+		DoC_Command(this, NAND_CMD_ERASE1, 0);
+		DoC_Address(this, ADDR_PAGE, ofs, 0, 0);
+		DoC_Command(this, NAND_CMD_ERASE2, 0);
+
+		DoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);
+
+		dummy = ReadDOC(docptr, CDSNSlowIO);
+		DoC_Delay(this, 2);
+		
+		if (ReadDOC_(docptr, this->ioreg) & 1) {
+			printk(KERN_ERR "Error erasing at 0x%x\n", ofs);
+			/* There was an error */
+			instr->state = MTD_ERASE_FAILED;
+			goto callback;
+		}
+		ofs += mtd->erasesize;
+		len -= mtd->erasesize;
+	}
+	instr->state = MTD_ERASE_DONE;
+
+ callback:
+	if (instr->callback)
+		instr->callback(instr);
+
+	up(&this->lock);
+	return 0;
+}
+
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+
+int __init init_doc2000(void)
+{
+       inter_module_register(im_name, THIS_MODULE, &DoC2k_init);
+       return 0;
+}
+
+static void __exit cleanup_doc2000(void)
+{
+	struct mtd_info *mtd;
+	struct DiskOnChip *this;
+
+	while ((mtd = doc2klist)) {
+		this = (struct DiskOnChip *) mtd->priv;
+		doc2klist = this->nextdoc;
+
+		del_mtd_device(mtd);
+
+		iounmap((void *) this->virtadr);
+		kfree(this->chips);
+		kfree(mtd);
+	}
+	inter_module_unregister(im_name);
+}
+
+module_exit(cleanup_doc2000);
+module_init(init_doc2000);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
+MODULE_DESCRIPTION("MTD driver for DiskOnChip 2000 and Millennium");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/doc2001.c linux-2.4.2/drivers/mtd/devices/doc2001.c
--- linux-2.4.2.orig/drivers/mtd/devices/doc2001.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/doc2001.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,880 @@
+
+/*
+ * Linux driver for Disk-On-Chip Millennium
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ *
+ * $Id: doc2001.c,v 1.35 2001/10/02 15:05:13 dwmw2 Exp $
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ids.h>
+#include <linux/mtd/doc2000.h>
+
+/* #define ECC_DEBUG */
+
+/* I have no idea why some DoC chips can not use memcop_form|to_io().
+ * This may be due to the different revisions of the ASIC controller built-in or
+ * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment
+ * this:*/
+#undef USE_MEMCPY
+
+static int doc_read(struct mtd_info *mtd, loff_t from, size_t len,
+		    size_t *retlen, u_char *buf);
+static int doc_write(struct mtd_info *mtd, loff_t to, size_t len,
+		     size_t *retlen, const u_char *buf);
+static int doc_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf, u_char *eccbuf);
+static int doc_write_ecc(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t *retlen, const u_char *buf, u_char *eccbuf);
+static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			size_t *retlen, u_char *buf);
+static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			 size_t *retlen, const u_char *buf);
+static int doc_erase (struct mtd_info *mtd, struct erase_info *instr);
+
+static struct mtd_info *docmillist = NULL;
+
+/* Perform the required delay cycles by reading from the NOP register */
+static void DoC_Delay(unsigned long docptr, unsigned short cycles)
+{
+	volatile char dummy;
+	int i;
+
+	for (i = 0; i < cycles; i++)
+		dummy = ReadDOC(docptr, NOP);
+}
+
+/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
+static int _DoC_WaitReady(unsigned long docptr)
+{
+	unsigned short c = 0xffff;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "_DoC_WaitReady called for out-of-line wait\n");
+
+	/* Out-of-line routine to wait for chip response */
+	while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B) && --c)
+		;
+
+	if (c == 0)
+		DEBUG(MTD_DEBUG_LEVEL2, "_DoC_WaitReady timed out.\n");
+
+	return (c == 0);
+}
+
+static inline int DoC_WaitReady(unsigned long docptr)
+{
+	/* This is inline, to optimise the common case, where it's ready instantly */
+	int ret = 0;
+
+	/* 4 read form NOP register should be issued in prior to the read from CDSNControl
+	   see Software Requirement 11.4 item 2. */
+	DoC_Delay(docptr, 4);
+
+	if (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))
+		/* Call the out-of-line routine to wait */
+		ret = _DoC_WaitReady(docptr);
+
+	/* issue 2 read from NOP register after reading from CDSNControl register
+	   see Software Requirement 11.4 item 2. */
+	DoC_Delay(docptr, 2);
+
+	return ret;
+}
+
+/* DoC_Command: Send a flash command to the flash chip through the CDSN IO register
+   with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
+   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
+
+static inline void DoC_Command(unsigned long docptr, unsigned char command,
+			       unsigned char xtraflags)
+{
+	/* Assert the CLE (Command Latch Enable) line to the flash chip */
+	WriteDOC(xtraflags | CDSN_CTRL_CLE | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(docptr, 4);
+
+	/* Send the command */
+	WriteDOC(command, docptr, Mil_CDSN_IO);
+	WriteDOC(0x00, docptr, WritePipeTerm);
+
+	/* Lower the CLE line */
+	WriteDOC(xtraflags | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(docptr, 4);
+}
+
+/* DoC_Address: Set the current address for the flash chip through the CDSN IO register
+   with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
+   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
+
+static inline void DoC_Address(unsigned long docptr, int numbytes, unsigned long ofs,
+			       unsigned char xtraflags1, unsigned char xtraflags2)
+{
+	/* Assert the ALE (Address Latch Enable) line to the flash chip */
+	WriteDOC(xtraflags1 | CDSN_CTRL_ALE | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(docptr, 4);
+
+	/* Send the address */
+	switch (numbytes)
+	    {
+	    case 1:
+		    /* Send single byte, bits 0-7. */
+		    WriteDOC(ofs & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC(0x00, docptr, WritePipeTerm);
+		    break;
+	    case 2:
+		    /* Send bits 9-16 followed by 17-23 */
+		    WriteDOC((ofs >> 9)  & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC((ofs >> 17) & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC(0x00, docptr, WritePipeTerm);
+		break;
+	    case 3:
+		    /* Send 0-7, 9-16, then 17-23 */
+		    WriteDOC(ofs & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC((ofs >> 9)  & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC((ofs >> 17) & 0xff, docptr, Mil_CDSN_IO);
+		    WriteDOC(0x00, docptr, WritePipeTerm);
+		break;
+	    default:
+		return;
+	    }
+
+	/* Lower the ALE line */
+	WriteDOC(xtraflags1 | xtraflags2 | CDSN_CTRL_CE, docptr, CDSNControl);
+	DoC_Delay(docptr, 4);
+}
+
+/* DoC_SelectChip: Select a given flash chip within the current floor */
+static int DoC_SelectChip(unsigned long docptr, int chip)
+{
+	/* Select the individual flash chip requested */
+	WriteDOC(chip, docptr, CDSNDeviceSelect);
+	DoC_Delay(docptr, 4);
+
+	/* Wait for it to be ready */
+	return DoC_WaitReady(docptr);
+}
+
+/* DoC_SelectFloor: Select a given floor (bank of flash chips) */
+static int DoC_SelectFloor(unsigned long docptr, int floor)
+{
+	/* Select the floor (bank) of chips required */
+	WriteDOC(floor, docptr, FloorSelect);
+
+	/* Wait for the chip to be ready */
+	return DoC_WaitReady(docptr);
+}
+
+/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */
+static int DoC_IdentChip(struct DiskOnChip *doc, int floor, int chip)
+{
+	int mfr, id, i;
+	volatile char dummy;
+
+	/* Page in the required floor/chip
+	   FIXME: is this supported by Millennium ?? */
+	DoC_SelectFloor(doc->virtadr, floor);
+	DoC_SelectChip(doc->virtadr, chip);
+
+	/* Reset the chip, see Software Requirement 11.4 item 1. */
+	DoC_Command(doc->virtadr, NAND_CMD_RESET, CDSN_CTRL_WP);
+	DoC_WaitReady(doc->virtadr);
+
+	/* Read the NAND chip ID: 1. Send ReadID command */ 
+	DoC_Command(doc->virtadr, NAND_CMD_READID, CDSN_CTRL_WP);
+
+	/* Read the NAND chip ID: 2. Send address byte zero */ 
+	DoC_Address(doc->virtadr, 1, 0x00, CDSN_CTRL_WP, 0x00);
+
+	/* Read the manufacturer and device id codes of the flash device through
+	   CDSN IO register see Software Requirement 11.4 item 5.*/
+	dummy = ReadDOC(doc->virtadr, ReadPipeInit);
+	DoC_Delay(doc->virtadr, 2);
+	mfr = ReadDOC(doc->virtadr, Mil_CDSN_IO);
+
+	DoC_Delay(doc->virtadr, 2);
+	id  = ReadDOC(doc->virtadr, Mil_CDSN_IO);
+	dummy = ReadDOC(doc->virtadr, LastDataRead);
+
+	/* No response - return failure */
+	if (mfr == 0xff || mfr == 0)
+		return 0;
+
+	/* FIXME: to deal with multi-flash on multi-Millennium case more carefully */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (mfr == nand_flash_ids[i].manufacture_id &&
+		    id == nand_flash_ids[i].model_id) {
+			printk(KERN_INFO "Flash chip found: Manufacturer ID: %2.2X, "
+			       "Chip ID: %2.2X (%s)\n",
+			       mfr, id, nand_flash_ids[i].name);
+			doc->mfr = mfr;
+			doc->id = id;
+			doc->chipshift = nand_flash_ids[i].chipshift;
+			break;
+		}
+	}
+
+	if (nand_flash_ids[i].name == NULL)
+		return 0;
+	else
+		return 1;
+}
+
+/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */
+static void DoC_ScanChips(struct DiskOnChip *this)
+{
+	int floor, chip;
+	int numchips[MAX_FLOORS_MIL];
+	int ret;
+
+	this->numchips = 0;
+	this->mfr = 0;
+	this->id = 0;
+
+	/* For each floor, find the number of valid chips it contains */
+	for (floor = 0,ret = 1; floor < MAX_FLOORS_MIL; floor++) {
+		numchips[floor] = 0;
+		for (chip = 0; chip < MAX_CHIPS_MIL && ret != 0; chip++) {
+			ret = DoC_IdentChip(this, floor, chip);
+			if (ret) {
+				numchips[floor]++;
+				this->numchips++;
+			}
+		}
+	}
+	/* If there are none at all that we recognise, bail */
+	if (!this->numchips) {
+		printk("No flash chips recognised.\n");
+		return;
+	}
+
+	/* Allocate an array to hold the information for each chip */
+	this->chips = kmalloc(sizeof(struct Nand) * this->numchips, GFP_KERNEL);
+	if (!this->chips){
+		printk("No memory for allocating chip info structures\n");
+		return;
+	}
+
+	/* Fill out the chip array with {floor, chipno} for each 
+	 * detected chip in the device. */
+	for (floor = 0, ret = 0; floor < MAX_FLOORS_MIL; floor++) {
+		for (chip = 0 ; chip < numchips[floor] ; chip++) {
+			this->chips[ret].floor = floor;
+			this->chips[ret].chip = chip;
+			this->chips[ret].curadr = 0;
+			this->chips[ret].curmode = 0x50;
+			ret++;
+		}
+	}
+
+	/* Calculate and print the total size of the device */
+	this->totlen = this->numchips * (1 << this->chipshift);
+	printk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",
+	       this->numchips ,this->totlen >> 20);
+}
+
+static int DoCMil_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)
+{
+	int tmp1, tmp2, retval;
+
+	if (doc1->physadr == doc2->physadr)
+		return 1;
+
+	/* Use the alias resolution register which was set aside for this
+	 * purpose. If it's value is the same on both chips, they might
+	 * be the same chip, and we write to one and check for a change in
+	 * the other. It's unclear if this register is usuable in the
+	 * DoC 2000 (it's in the Millenium docs), but it seems to work. */
+	tmp1 = ReadDOC(doc1->virtadr, AliasResolution);
+	tmp2 = ReadDOC(doc2->virtadr, AliasResolution);
+	if (tmp1 != tmp2)
+		return 0;
+	
+	WriteDOC((tmp1+1) % 0xff, doc1->virtadr, AliasResolution);
+	tmp2 = ReadDOC(doc2->virtadr, AliasResolution);
+	if (tmp2 == (tmp1+1) % 0xff)
+		retval = 1;
+	else
+		retval = 0;
+
+	/* Restore register contents.  May not be necessary, but do it just to
+	 * be safe. */
+	WriteDOC(tmp1, doc1->virtadr, AliasResolution);
+
+	return retval;
+}
+
+static const char im_name[] = "DoCMil_init";
+
+/* This routine is made available to other mtd code via
+ * inter_module_register.  It must only be accessed through
+ * inter_module_get which will bump the use count of this module.  The
+ * addresses passed back in mtd are valid as long as the use count of
+ * this module is non-zero, i.e. between inter_module_get and
+ * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
+ */
+static void DoCMil_init(struct mtd_info *mtd)
+{
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *old = NULL;
+
+	/* We must avoid being called twice for the same device. */
+	if (docmillist)
+		old = (struct DiskOnChip *)docmillist->priv;
+
+	while (old) {
+		if (DoCMil_is_alias(this, old)) {
+			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
+			       "0x%lX - already configured\n", this->physadr);
+			iounmap((void *)this->virtadr);
+			kfree(mtd);
+			return;
+		}
+		if (old->nextdoc)
+			old = (struct DiskOnChip *)old->nextdoc->priv;
+		else
+			old = NULL;
+	}
+
+	mtd->name = "DiskOnChip Millennium";
+	printk(KERN_NOTICE "DiskOnChip Millennium found at address 0x%lX\n",
+	       this->physadr);
+
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->size = 0;
+
+	/* FIXME: erase size is not always 8kB */
+	mtd->erasesize = 0x2000;
+
+	mtd->oobblock = 512;
+	mtd->oobsize = 16;
+	mtd->module = THIS_MODULE;
+	mtd->erase = doc_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = doc_read;
+	mtd->write = doc_write;
+	mtd->read_ecc = doc_read_ecc;
+	mtd->write_ecc = doc_write_ecc;
+	mtd->read_oob = doc_read_oob;
+	mtd->write_oob = doc_write_oob;
+	mtd->sync = NULL;
+
+	this->totlen = 0;
+	this->numchips = 0;
+	this->curfloor = -1;
+	this->curchip = -1;
+
+	/* Ident all the chips present. */
+	DoC_ScanChips(this);
+
+	if (!this->totlen) {
+		kfree(mtd);
+		iounmap((void *)this->virtadr);
+	} else {
+		this->nextdoc = docmillist;
+		docmillist = mtd;
+		mtd->size  = this->totlen;
+		add_mtd_device(mtd);
+		return;
+	}
+}
+
+static int doc_read (struct mtd_info *mtd, loff_t from, size_t len,
+		     size_t *retlen, u_char *buf)
+{
+	/* Just a special case of doc_read_ecc */
+	return doc_read_ecc(mtd, from, len, retlen, buf, NULL);
+}
+
+static int doc_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf, u_char *eccbuf)
+{
+	int i, ret;
+	volatile char dummy;
+	unsigned char syndrome[6];
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
+
+	/* Don't allow read past end of device */
+	if (from >= this->totlen)
+		return -EINVAL;
+
+	/* Don't allow a single read to cross a 512-byte block boundary */
+	if (from + len > ((from | 0x1ff) + 1)) 
+		len = ((from | 0x1ff) + 1) - from;
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(docptr, mychip->floor);
+		DoC_SelectChip(docptr, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(docptr, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* issue the Read0 or Read1 command depend on which half of the page
+	   we are accessing. Polling the Flash Ready bit after issue 3 bytes
+	   address in Sequence Read Mode, see Software Requirement 11.4 item 1.*/
+	DoC_Command(docptr, (from >> 8) & 1, CDSN_CTRL_WP);
+	DoC_Address(docptr, 3, from, CDSN_CTRL_WP, 0x00);
+	DoC_WaitReady(docptr);
+
+	if (eccbuf) {
+		/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/
+		WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC (DOC_ECC_EN, docptr, ECCConf);
+	} else {
+		/* disable the ECC engine */
+		WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC (DOC_ECC_DIS, docptr, ECCConf);
+	}
+
+	/* Read the data via the internal pipeline through CDSN IO register,
+	   see Pipelined Read Operations 11.3 */
+	dummy = ReadDOC(docptr, ReadPipeInit);
+#ifndef USE_MEMCPY
+	for (i = 0; i < len-1; i++) {
+		/* N.B. you have to increase the source address in this way or the
+		   ECC logic will not work properly */
+		buf[i] = ReadDOC(docptr, Mil_CDSN_IO + (i & 0xff));
+	}
+#else
+	memcpy_fromio(buf, docptr + DoC_Mil_CDSN_IO, len - 1);
+#endif
+	buf[len - 1] = ReadDOC(docptr, LastDataRead);
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+        ret = 0;
+
+	if (eccbuf) {
+		/* Read the ECC data from Spare Data Area,
+		   see Reed-Solomon EDC/ECC 11.1 */
+		dummy = ReadDOC(docptr, ReadPipeInit);
+#ifndef USE_MEMCPY
+		for (i = 0; i < 5; i++) {
+			/* N.B. you have to increase the source address in this way or the
+			   ECC logic will not work properly */
+			eccbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + i);
+		}
+#else
+		memcpy_fromio(eccbuf, docptr + DoC_Mil_CDSN_IO, 5);
+#endif
+		eccbuf[5] = ReadDOC(docptr, LastDataRead);
+
+		/* Flush the pipeline */
+		dummy = ReadDOC(docptr, ECCConf);
+		dummy = ReadDOC(docptr, ECCConf);
+
+		/* Check the ECC Status */
+		if (ReadDOC(docptr, ECCConf) & 0x80) {
+                        int nb_errors;
+			/* There was an ECC error */
+#ifdef ECC_DEBUG
+			printk("DiskOnChip ECC Error: Read at %lx\n", (long)from);
+#endif
+			/* Read the ECC syndrom through the DiskOnChip ECC logic.
+			   These syndrome will be all ZERO when there is no error */
+			for (i = 0; i < 6; i++) {
+				syndrome[i] = ReadDOC(docptr, ECCSyndrome0 + i);
+			}
+                        nb_errors = doc_decode_ecc(buf, syndrome);
+#ifdef ECC_DEBUG
+			printk("ECC Errors corrected: %x\n", nb_errors);
+#endif
+                        if (nb_errors < 0) {
+				/* We return error, but have actually done the read. Not that
+				   this can be told to user-space, via sys_read(), but at least
+				   MTD-aware stuff can know about it by checking *retlen */
+				ret = -EIO;
+                        }
+		}
+
+#ifdef PSYCHO_DEBUG
+		printk("ECC DATA at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",
+		       (long)from, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],
+		       eccbuf[4], eccbuf[5]);
+#endif
+
+		/* disable the ECC engine */
+		WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
+	}
+
+	return ret;
+}
+
+static int doc_write (struct mtd_info *mtd, loff_t to, size_t len,
+		      size_t *retlen, const u_char *buf)
+{
+	char eccbuf[6];
+	return doc_write_ecc(mtd, to, len, retlen, buf, eccbuf);
+}
+
+static int doc_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const u_char *buf, u_char *eccbuf)
+{
+	int i,ret = 0;
+	volatile char dummy;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[to >> (this->chipshift)];
+
+	/* Don't allow write past end of device */
+	if (to >= this->totlen)
+		return -EINVAL;
+
+#if 0
+	/* Don't allow a single write to cross a 512-byte block boundary */
+	if (to + len > ( (to | 0x1ff) + 1)) 
+		len = ((to | 0x1ff) + 1) - to;
+#else
+	/* Don't allow writes which aren't exactly one block */
+	if (to & 0x1ff || len != 0x200)
+		return -EINVAL;
+#endif
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(docptr, mychip->floor);
+		DoC_SelectChip(docptr, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(docptr, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* Reset the chip, see Software Requirement 11.4 item 1. */
+	DoC_Command(docptr, NAND_CMD_RESET, 0x00);
+	DoC_WaitReady(docptr);
+	/* Set device to main plane of flash */
+	DoC_Command(docptr, NAND_CMD_READ0, 0x00);
+
+	/* issue the Serial Data In command to initial the Page Program process */
+	DoC_Command(docptr, NAND_CMD_SEQIN, 0x00);
+	DoC_Address(docptr, 3, to, 0x00, 0x00);
+	DoC_WaitReady(docptr);
+
+	if (eccbuf) {
+		/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/
+		WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC (DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);
+	} else {
+		/* disable the ECC engine */
+		WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+		WriteDOC (DOC_ECC_DIS, docptr, ECCConf);
+	}
+
+	/* Write the data via the internal pipeline through CDSN IO register,
+	   see Pipelined Write Operations 11.2 */
+#ifndef USE_MEMCPY
+	for (i = 0; i < len; i++) {
+		/* N.B. you have to increase the source address in this way or the
+		   ECC logic will not work properly */
+		WriteDOC(buf[i], docptr, Mil_CDSN_IO + i);
+	}
+#else
+	memcpy_toio(docptr + DoC_Mil_CDSN_IO, buf, len);
+#endif
+	WriteDOC(0x00, docptr, WritePipeTerm);
+
+	if (eccbuf) {
+		/* Write ECC data to flash, the ECC info is generated by the DiskOnChip ECC logic
+		   see Reed-Solomon EDC/ECC 11.1 */
+		WriteDOC(0, docptr, NOP);
+		WriteDOC(0, docptr, NOP);
+		WriteDOC(0, docptr, NOP);
+
+		/* Read the ECC data through the DiskOnChip ECC logic */
+		for (i = 0; i < 6; i++) {
+			eccbuf[i] = ReadDOC(docptr, ECCSyndrome0 + i);
+		}
+
+		/* ignore the ECC engine */
+		WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
+
+#ifndef USE_MEMCPY
+		/* Write the ECC data to flash */
+		for (i = 0; i < 6; i++) {
+			/* N.B. you have to increase the source address in this way or the
+			   ECC logic will not work properly */
+			WriteDOC(eccbuf[i], docptr, Mil_CDSN_IO + i);
+		}
+#else
+		memcpy_toio(docptr + DoC_Mil_CDSN_IO, eccbuf, 6);
+#endif
+
+		/* write the block status BLOCK_USED (0x5555) at the end of ECC data
+		   FIXME: this is only a hack for programming the IPL area for LinuxBIOS
+		   and should be replace with proper codes in user space utilities */ 
+		WriteDOC(0x55, docptr, Mil_CDSN_IO);
+		WriteDOC(0x55, docptr, Mil_CDSN_IO + 1);
+
+		WriteDOC(0x00, docptr, WritePipeTerm);
+
+#ifdef PSYCHO_DEBUG
+		printk("OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",
+		       (long) to, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],
+		       eccbuf[4], eccbuf[5]);
+#endif
+	}
+
+	/* Commit the Page Program command and wait for ready
+	   see Software Requirement 11.4 item 1.*/
+	DoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);
+	DoC_WaitReady(docptr);
+
+	/* Read the status of the flash device through CDSN IO register
+	   see Software Requirement 11.4 item 5.*/
+	DoC_Command(docptr, NAND_CMD_STATUS, CDSN_CTRL_WP);
+	dummy = ReadDOC(docptr, ReadPipeInit);
+	DoC_Delay(docptr, 2);
+	if (ReadDOC(docptr, Mil_CDSN_IO) & 1) {
+		printk("Error programming flash\n");
+		/* Error in programming
+		   FIXME: implement Bad Block Replacement (in nftl.c ??) */
+		*retlen = 0;
+		ret = -EIO;
+	}
+	dummy = ReadDOC(docptr, LastDataRead);
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+
+	return ret;
+}
+
+static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			size_t *retlen, u_char *buf)
+{
+#ifndef USE_MEMCPY
+	int i;
+#endif
+	volatile char dummy;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(docptr, mychip->floor);
+		DoC_SelectChip(docptr, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(docptr, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* disable the ECC engine */
+	WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+	WriteDOC (DOC_ECC_DIS, docptr, ECCConf);
+
+	/* issue the Read2 command to set the pointer to the Spare Data Area.
+	   Polling the Flash Ready bit after issue 3 bytes address in
+	   Sequence Read Mode, see Software Requirement 11.4 item 1.*/
+	DoC_Command(docptr, NAND_CMD_READOOB, CDSN_CTRL_WP);
+	DoC_Address(docptr, 3, ofs, CDSN_CTRL_WP, 0x00);
+	DoC_WaitReady(docptr);
+
+	/* Read the data out via the internal pipeline through CDSN IO register,
+	   see Pipelined Read Operations 11.3 */
+	dummy = ReadDOC(docptr, ReadPipeInit);
+#ifndef USE_MEMCPY
+	for (i = 0; i < len-1; i++) {
+		/* N.B. you have to increase the source address in this way or the
+		   ECC logic will not work properly */
+		buf[i] = ReadDOC(docptr, Mil_CDSN_IO + i);
+	}
+#else
+	memcpy_fromio(buf, docptr + DoC_Mil_CDSN_IO, len - 1);
+#endif
+	buf[len - 1] = ReadDOC(docptr, LastDataRead);
+
+	*retlen = len;
+
+	return 0;
+}
+
+static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
+			 size_t *retlen, const u_char *buf)
+{
+#ifndef USE_MEMCPY
+	int i;
+#endif
+	volatile char dummy;
+	int ret = 0;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(docptr, mychip->floor);
+		DoC_SelectChip(docptr, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(docptr, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	/* disable the ECC engine */
+	WriteDOC (DOC_ECC_RESET, docptr, ECCConf);
+	WriteDOC (DOC_ECC_DIS, docptr, ECCConf);
+
+	/* Reset the chip, see Software Requirement 11.4 item 1. */
+	DoC_Command(docptr, NAND_CMD_RESET, CDSN_CTRL_WP);
+	DoC_WaitReady(docptr);
+	/* issue the Read2 command to set the pointer to the Spare Data Area. */
+	DoC_Command(docptr, NAND_CMD_READOOB, CDSN_CTRL_WP);
+
+	/* issue the Serial Data In command to initial the Page Program process */
+	DoC_Command(docptr, NAND_CMD_SEQIN, 0x00);
+	DoC_Address(docptr, 3, ofs, 0x00, 0x00);
+
+	/* Write the data via the internal pipeline through CDSN IO register,
+	   see Pipelined Write Operations 11.2 */
+#ifndef USE_MEMCPY
+	for (i = 0; i < len; i++) {
+		/* N.B. you have to increase the source address in this way or the
+		   ECC logic will not work properly */
+		WriteDOC(buf[i], docptr, Mil_CDSN_IO + i);
+	}
+#else
+	memcpy_toio(docptr + DoC_Mil_CDSN_IO, buf, len);
+#endif
+	WriteDOC(0x00, docptr, WritePipeTerm);
+
+	/* Commit the Page Program command and wait for ready
+	   see Software Requirement 11.4 item 1.*/
+	DoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);
+	DoC_WaitReady(docptr);
+
+	/* Read the status of the flash device through CDSN IO register
+	   see Software Requirement 11.4 item 5.*/
+	DoC_Command(docptr, NAND_CMD_STATUS, 0x00);
+	dummy = ReadDOC(docptr, ReadPipeInit);
+	DoC_Delay(docptr, 2);
+	if (ReadDOC(docptr, Mil_CDSN_IO) & 1) {
+		printk("Error programming oob data\n");
+		/* FIXME: implement Bad Block Replacement (in nftl.c ??) */
+		*retlen = 0;
+		ret = -EIO;
+	}
+	dummy = ReadDOC(docptr, LastDataRead);
+
+	*retlen = len;
+
+	return ret;
+}
+
+int doc_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	volatile char dummy;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
+	unsigned long docptr = this->virtadr;
+	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
+
+	if (len != mtd->erasesize) 
+		printk(KERN_WARNING "Erase not right size (%x != %x)n",
+		       len, mtd->erasesize);
+
+	/* Find the chip which is to be used and select it */
+	if (this->curfloor != mychip->floor) {
+		DoC_SelectFloor(docptr, mychip->floor);
+		DoC_SelectChip(docptr, mychip->chip);
+	} else if (this->curchip != mychip->chip) {
+		DoC_SelectChip(docptr, mychip->chip);
+	}
+	this->curfloor = mychip->floor;
+	this->curchip = mychip->chip;
+
+	instr->state = MTD_ERASE_PENDING;
+
+	/* issue the Erase Setup command */
+	DoC_Command(docptr, NAND_CMD_ERASE1, 0x00);
+	DoC_Address(docptr, 2, ofs, 0x00, 0x00);
+
+	/* Commit the Erase Start command and wait for ready
+	   see Software Requirement 11.4 item 1.*/
+	DoC_Command(docptr, NAND_CMD_ERASE2, 0x00);
+	DoC_WaitReady(docptr);
+
+	instr->state = MTD_ERASING;
+
+	/* Read the status of the flash device through CDSN IO register
+	   see Software Requirement 11.4 item 5.
+	   FIXME: it seems that we are not wait long enough, some blocks are not
+	   erased fully */
+	DoC_Command(docptr, NAND_CMD_STATUS, CDSN_CTRL_WP);
+	dummy = ReadDOC(docptr, ReadPipeInit);
+	DoC_Delay(docptr, 2);
+	if (ReadDOC(docptr, Mil_CDSN_IO) & 1) {
+		printk("Error Erasing at 0x%x\n", ofs);
+		/* There was an error
+		   FIXME: implement Bad Block Replacement (in nftl.c ??) */
+		instr->state = MTD_ERASE_FAILED;
+	} else
+		instr->state = MTD_ERASE_DONE;
+	dummy = ReadDOC(docptr, LastDataRead);
+
+	if (instr->callback) 
+		instr->callback(instr);
+
+	return 0;
+}
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+
+int __init init_doc2001(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &DoCMil_init);
+	return 0;
+}
+
+static void __exit cleanup_doc2001(void)
+{
+	struct mtd_info *mtd;
+	struct DiskOnChip *this;
+
+	while ((mtd=docmillist)) {
+		this = (struct DiskOnChip *)mtd->priv;
+		docmillist = this->nextdoc;
+			
+		del_mtd_device(mtd);
+			
+		iounmap((void *)this->virtadr);
+		kfree(this->chips);
+		kfree(mtd);
+	}
+	inter_module_unregister(im_name);
+}
+
+module_exit(cleanup_doc2001);
+module_init(init_doc2001);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org> et al.");
+MODULE_DESCRIPTION("Alternative driver for DiskOnChip Millennium");
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/docecc.c linux-2.4.2/drivers/mtd/devices/docecc.c
--- linux-2.4.2.orig/drivers/mtd/devices/docecc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/docecc.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,524 @@
+/*
+ * ECC algorithm for M-systems disk on chip. We use the excellent Reed
+ * Solmon code of Phil Karn (karn@ka9q.ampr.org) available under the
+ * GNU GPL License. The rest is simply to convert the disk on chip
+ * syndrom into a standard syndom.
+ *
+ * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
+ * Copyright (C) 2000 Netgem S.A.
+ *
+ * $Id: docecc.c,v 1.4 2001/10/02 15:05:13 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <linux/mtd/compatmac.h> /* for min() in older kernels */
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/doc2000.h>
+
+/* need to undef it (from asm/termbits.h) */
+#undef B0
+
+#define MM 10 /* Symbol size in bits */
+#define KK (1023-4) /* Number of data symbols per block */
+#define B0 510 /* First root of generator polynomial, alpha form */
+#define PRIM 1 /* power of alpha used to generate roots of generator poly */
+#define	NN ((1 << MM) - 1)
+
+typedef unsigned short dtype;
+
+/* 1+x^3+x^10 */
+static const int Pp[MM+1] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };
+
+/* This defines the type used to store an element of the Galois Field
+ * used by the code. Make sure this is something larger than a char if
+ * if anything larger than GF(256) is used.
+ *
+ * Note: unsigned char will work up to GF(256) but int seems to run
+ * faster on the Pentium.
+ */
+typedef int gf;
+
+/* No legal value in index form represents zero, so
+ * we need a special value for this purpose
+ */
+#define A0	(NN)
+
+/* Compute x % NN, where NN is 2**MM - 1,
+ * without a slow divide
+ */
+static inline gf
+modnn(int x)
+{
+  while (x >= NN) {
+    x -= NN;
+    x = (x >> MM) + (x & NN);
+  }
+  return x;
+}
+
+#define	CLEAR(a,n) {\
+int ci;\
+for(ci=(n)-1;ci >=0;ci--)\
+(a)[ci] = 0;\
+}
+
+#define	COPY(a,b,n) {\
+int ci;\
+for(ci=(n)-1;ci >=0;ci--)\
+(a)[ci] = (b)[ci];\
+}
+
+#define	COPYDOWN(a,b,n) {\
+int ci;\
+for(ci=(n)-1;ci >=0;ci--)\
+(a)[ci] = (b)[ci];\
+}
+
+#define Ldec 1
+
+/* generate GF(2**m) from the irreducible polynomial p(X) in Pp[0]..Pp[m]
+   lookup tables:  index->polynomial form   alpha_to[] contains j=alpha**i;
+                   polynomial form -> index form  index_of[j=alpha**i] = i
+   alpha=2 is the primitive element of GF(2**m)
+   HARI's COMMENT: (4/13/94) alpha_to[] can be used as follows:
+        Let @ represent the primitive element commonly called "alpha" that
+   is the root of the primitive polynomial p(x). Then in GF(2^m), for any
+   0 <= i <= 2^m-2,
+        @^i = a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)
+   where the binary vector (a(0),a(1),a(2),...,a(m-1)) is the representation
+   of the integer "alpha_to[i]" with a(0) being the LSB and a(m-1) the MSB. Thus for
+   example the polynomial representation of @^5 would be given by the binary
+   representation of the integer "alpha_to[5]".
+                   Similarily, index_of[] can be used as follows:
+        As above, let @ represent the primitive element of GF(2^m) that is
+   the root of the primitive polynomial p(x). In order to find the power
+   of @ (alpha) that has the polynomial representation
+        a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)
+   we consider the integer "i" whose binary representation with a(0) being LSB
+   and a(m-1) MSB is (a(0),a(1),...,a(m-1)) and locate the entry
+   "index_of[i]". Now, @^index_of[i] is that element whose polynomial 
+    representation is (a(0),a(1),a(2),...,a(m-1)).
+   NOTE:
+        The element alpha_to[2^m-1] = 0 always signifying that the
+   representation of "@^infinity" = 0 is (0,0,0,...,0).
+        Similarily, the element index_of[0] = A0 always signifying
+   that the power of alpha which has the polynomial representation
+   (0,0,...,0) is "infinity".
+ 
+*/
+
+static void
+generate_gf(dtype Alpha_to[NN + 1], dtype Index_of[NN + 1])
+{
+  register int i, mask;
+
+  mask = 1;
+  Alpha_to[MM] = 0;
+  for (i = 0; i < MM; i++) {
+    Alpha_to[i] = mask;
+    Index_of[Alpha_to[i]] = i;
+    /* If Pp[i] == 1 then, term @^i occurs in poly-repr of @^MM */
+    if (Pp[i] != 0)
+      Alpha_to[MM] ^= mask;	/* Bit-wise EXOR operation */
+    mask <<= 1;	/* single left-shift */
+  }
+  Index_of[Alpha_to[MM]] = MM;
+  /*
+   * Have obtained poly-repr of @^MM. Poly-repr of @^(i+1) is given by
+   * poly-repr of @^i shifted left one-bit and accounting for any @^MM
+   * term that may occur when poly-repr of @^i is shifted.
+   */
+  mask >>= 1;
+  for (i = MM + 1; i < NN; i++) {
+    if (Alpha_to[i - 1] >= mask)
+      Alpha_to[i] = Alpha_to[MM] ^ ((Alpha_to[i - 1] ^ mask) << 1);
+    else
+      Alpha_to[i] = Alpha_to[i - 1] << 1;
+    Index_of[Alpha_to[i]] = i;
+  }
+  Index_of[0] = A0;
+  Alpha_to[NN] = 0;
+}
+
+/*
+ * Performs ERRORS+ERASURES decoding of RS codes. bb[] is the content
+ * of the feedback shift register after having processed the data and
+ * the ECC.
+ *
+ * Return number of symbols corrected, or -1 if codeword is illegal
+ * or uncorrectable. If eras_pos is non-null, the detected error locations
+ * are written back. NOTE! This array must be at least NN-KK elements long.
+ * The corrected data are written in eras_val[]. They must be xor with the data
+ * to retrieve the correct data : data[erase_pos[i]] ^= erase_val[i] .
+ * 
+ * First "no_eras" erasures are declared by the calling program. Then, the
+ * maximum # of errors correctable is t_after_eras = floor((NN-KK-no_eras)/2).
+ * If the number of channel errors is not greater than "t_after_eras" the
+ * transmitted codeword will be recovered. Details of algorithm can be found
+ * in R. Blahut's "Theory ... of Error-Correcting Codes".
+
+ * Warning: the eras_pos[] array must not contain duplicate entries; decoder failure
+ * will result. The decoder *could* check for this condition, but it would involve
+ * extra time on every decoding operation.
+ * */
+static int
+eras_dec_rs(dtype Alpha_to[NN + 1], dtype Index_of[NN + 1],
+            gf bb[NN - KK + 1], gf eras_val[NN-KK], int eras_pos[NN-KK], 
+            int no_eras)
+{
+  int deg_lambda, el, deg_omega;
+  int i, j, r,k;
+  gf u,q,tmp,num1,num2,den,discr_r;
+  gf lambda[NN-KK + 1], s[NN-KK + 1];	/* Err+Eras Locator poly
+					 * and syndrome poly */
+  gf b[NN-KK + 1], t[NN-KK + 1], omega[NN-KK + 1];
+  gf root[NN-KK], reg[NN-KK + 1], loc[NN-KK];
+  int syn_error, count;
+
+  syn_error = 0;
+  for(i=0;i<NN-KK;i++)
+      syn_error |= bb[i];
+
+  if (!syn_error) {
+    /* if remainder is zero, data[] is a codeword and there are no
+     * errors to correct. So return data[] unmodified
+     */
+    count = 0;
+    goto finish;
+  }
+  
+  for(i=1;i<=NN-KK;i++){
+    s[i] = bb[0];
+  }
+  for(j=1;j<NN-KK;j++){
+    if(bb[j] == 0)
+      continue;
+    tmp = Index_of[bb[j]];
+    
+    for(i=1;i<=NN-KK;i++)
+      s[i] ^= Alpha_to[modnn(tmp + (B0+i-1)*PRIM*j)];
+  }
+
+  /* undo the feedback register implicit multiplication and convert
+     syndromes to index form */
+
+  for(i=1;i<=NN-KK;i++) {
+      tmp = Index_of[s[i]];
+      if (tmp != A0)
+          tmp = modnn(tmp + 2 * KK * (B0+i-1)*PRIM);
+      s[i] = tmp;
+  }
+  
+  CLEAR(&lambda[1],NN-KK);
+  lambda[0] = 1;
+
+  if (no_eras > 0) {
+    /* Init lambda to be the erasure locator polynomial */
+    lambda[1] = Alpha_to[modnn(PRIM * eras_pos[0])];
+    for (i = 1; i < no_eras; i++) {
+      u = modnn(PRIM*eras_pos[i]);
+      for (j = i+1; j > 0; j--) {
+	tmp = Index_of[lambda[j - 1]];
+	if(tmp != A0)
+	  lambda[j] ^= Alpha_to[modnn(u + tmp)];
+      }
+    }
+#if DEBUG >= 1
+    /* Test code that verifies the erasure locator polynomial just constructed
+       Needed only for decoder debugging. */
+    
+    /* find roots of the erasure location polynomial */
+    for(i=1;i<=no_eras;i++)
+      reg[i] = Index_of[lambda[i]];
+    count = 0;
+    for (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {
+      q = 1;
+      for (j = 1; j <= no_eras; j++)
+	if (reg[j] != A0) {
+	  reg[j] = modnn(reg[j] + j);
+	  q ^= Alpha_to[reg[j]];
+	}
+      if (q != 0)
+	continue;
+      /* store root and error location number indices */
+      root[count] = i;
+      loc[count] = k;
+      count++;
+    }
+    if (count != no_eras) {
+      printf("\n lambda(x) is WRONG\n");
+      count = -1;
+      goto finish;
+    }
+#if DEBUG >= 2
+    printf("\n Erasure positions as determined by roots of Eras Loc Poly:\n");
+    for (i = 0; i < count; i++)
+      printf("%d ", loc[i]);
+    printf("\n");
+#endif
+#endif
+  }
+  for(i=0;i<NN-KK+1;i++)
+    b[i] = Index_of[lambda[i]];
+  
+  /*
+   * Begin Berlekamp-Massey algorithm to determine error+erasure
+   * locator polynomial
+   */
+  r = no_eras;
+  el = no_eras;
+  while (++r <= NN-KK) {	/* r is the step number */
+    /* Compute discrepancy at the r-th step in poly-form */
+    discr_r = 0;
+    for (i = 0; i < r; i++){
+      if ((lambda[i] != 0) && (s[r - i] != A0)) {
+	discr_r ^= Alpha_to[modnn(Index_of[lambda[i]] + s[r - i])];
+      }
+    }
+    discr_r = Index_of[discr_r];	/* Index form */
+    if (discr_r == A0) {
+      /* 2 lines below: B(x) <-- x*B(x) */
+      COPYDOWN(&b[1],b,NN-KK);
+      b[0] = A0;
+    } else {
+      /* 7 lines below: T(x) <-- lambda(x) - discr_r*x*b(x) */
+      t[0] = lambda[0];
+      for (i = 0 ; i < NN-KK; i++) {
+	if(b[i] != A0)
+	  t[i+1] = lambda[i+1] ^ Alpha_to[modnn(discr_r + b[i])];
+	else
+	  t[i+1] = lambda[i+1];
+      }
+      if (2 * el <= r + no_eras - 1) {
+	el = r + no_eras - el;
+	/*
+	 * 2 lines below: B(x) <-- inv(discr_r) *
+	 * lambda(x)
+	 */
+	for (i = 0; i <= NN-KK; i++)
+	  b[i] = (lambda[i] == 0) ? A0 : modnn(Index_of[lambda[i]] - discr_r + NN);
+      } else {
+	/* 2 lines below: B(x) <-- x*B(x) */
+	COPYDOWN(&b[1],b,NN-KK);
+	b[0] = A0;
+      }
+      COPY(lambda,t,NN-KK+1);
+    }
+  }
+
+  /* Convert lambda to index form and compute deg(lambda(x)) */
+  deg_lambda = 0;
+  for(i=0;i<NN-KK+1;i++){
+    lambda[i] = Index_of[lambda[i]];
+    if(lambda[i] != A0)
+      deg_lambda = i;
+  }
+  /*
+   * Find roots of the error+erasure locator polynomial by Chien
+   * Search
+   */
+  COPY(&reg[1],&lambda[1],NN-KK);
+  count = 0;		/* Number of roots of lambda(x) */
+  for (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {
+    q = 1;
+    for (j = deg_lambda; j > 0; j--){
+      if (reg[j] != A0) {
+	reg[j] = modnn(reg[j] + j);
+	q ^= Alpha_to[reg[j]];
+      }
+    }
+    if (q != 0)
+      continue;
+    /* store root (index-form) and error location number */
+    root[count] = i;
+    loc[count] = k;
+    /* If we've already found max possible roots,
+     * abort the search to save time
+     */
+    if(++count == deg_lambda)
+      break;
+  }
+  if (deg_lambda != count) {
+    /*
+     * deg(lambda) unequal to number of roots => uncorrectable
+     * error detected
+     */
+    count = -1;
+    goto finish;
+  }
+  /*
+   * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
+   * x**(NN-KK)). in index form. Also find deg(omega).
+   */
+  deg_omega = 0;
+  for (i = 0; i < NN-KK;i++){
+    tmp = 0;
+    j = (deg_lambda < i) ? deg_lambda : i;
+    for(;j >= 0; j--){
+      if ((s[i + 1 - j] != A0) && (lambda[j] != A0))
+	tmp ^= Alpha_to[modnn(s[i + 1 - j] + lambda[j])];
+    }
+    if(tmp != 0)
+      deg_omega = i;
+    omega[i] = Index_of[tmp];
+  }
+  omega[NN-KK] = A0;
+  
+  /*
+   * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
+   * inv(X(l))**(B0-1) and den = lambda_pr(inv(X(l))) all in poly-form
+   */
+  for (j = count-1; j >=0; j--) {
+    num1 = 0;
+    for (i = deg_omega; i >= 0; i--) {
+      if (omega[i] != A0)
+	num1  ^= Alpha_to[modnn(omega[i] + i * root[j])];
+    }
+    num2 = Alpha_to[modnn(root[j] * (B0 - 1) + NN)];
+    den = 0;
+    
+    /* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
+    for (i = min(deg_lambda,NN-KK-1) & ~1; i >= 0; i -=2) {
+      if(lambda[i+1] != A0)
+	den ^= Alpha_to[modnn(lambda[i+1] + i * root[j])];
+    }
+    if (den == 0) {
+#if DEBUG >= 1
+      printf("\n ERROR: denominator = 0\n");
+#endif
+      /* Convert to dual- basis */
+      count = -1;
+      goto finish;
+    }
+    /* Apply error to data */
+    if (num1 != 0) {
+        eras_val[j] = Alpha_to[modnn(Index_of[num1] + Index_of[num2] + NN - Index_of[den])];
+    } else {
+        eras_val[j] = 0;
+    }
+  }
+ finish:
+  for(i=0;i<count;i++)
+      eras_pos[i] = loc[i];
+  return count;
+}
+
+/***************************************************************************/
+/* The DOC specific code begins here */
+
+#define SECTOR_SIZE 512
+/* The sector bytes are packed into NB_DATA MM bits words */
+#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / MM)
+
+/* 
+ * Correct the errors in 'sector[]' by using 'ecc1[]' which is the
+ * content of the feedback shift register applyied to the sector and
+ * the ECC. Return the number of errors corrected (and correct them in
+ * sector), or -1 if error 
+ */
+int doc_decode_ecc(unsigned char sector[SECTOR_SIZE], unsigned char ecc1[6])
+{
+    int parity, i, nb_errors;
+    gf bb[NN - KK + 1];
+    gf error_val[NN-KK];
+    int error_pos[NN-KK], pos, bitpos, index, val;
+    dtype *Alpha_to, *Index_of;
+
+    /* init log and exp tables here to save memory. However, it is slower */
+    Alpha_to = kmalloc((NN + 1) * sizeof(dtype), GFP_KERNEL);
+    if (!Alpha_to)
+        return -1;
+    
+    Index_of = kmalloc((NN + 1) * sizeof(dtype), GFP_KERNEL);
+    if (!Index_of) {
+        kfree(Alpha_to);
+        return -1;
+    }
+
+    generate_gf(Alpha_to, Index_of);
+
+    parity = ecc1[1];
+
+    bb[0] =  (ecc1[4] & 0xff) | ((ecc1[5] & 0x03) << 8);
+    bb[1] = ((ecc1[5] & 0xfc) >> 2) | ((ecc1[2] & 0x0f) << 6);
+    bb[2] = ((ecc1[2] & 0xf0) >> 4) | ((ecc1[3] & 0x3f) << 4);
+    bb[3] = ((ecc1[3] & 0xc0) >> 6) | ((ecc1[0] & 0xff) << 2);
+
+    nb_errors = eras_dec_rs(Alpha_to, Index_of, bb, 
+                            error_val, error_pos, 0);
+    if (nb_errors <= 0)
+        goto the_end;
+
+    /* correct the errors */
+    for(i=0;i<nb_errors;i++) {
+        pos = error_pos[i];
+        if (pos >= NB_DATA && pos < KK) {
+            nb_errors = -1;
+            goto the_end;
+        }
+        if (pos < NB_DATA) {
+            /* extract bit position (MSB first) */
+            pos = 10 * (NB_DATA - 1 - pos) - 6;
+            /* now correct the following 10 bits. At most two bytes
+               can be modified since pos is even */
+            index = (pos >> 3) ^ 1;
+            bitpos = pos & 7;
+            if ((index >= 0 && index < SECTOR_SIZE) || 
+                index == (SECTOR_SIZE + 1)) {
+                val = error_val[i] >> (2 + bitpos);
+                parity ^= val;
+                if (index < SECTOR_SIZE)
+                    sector[index] ^= val;
+            }
+            index = ((pos >> 3) + 1) ^ 1;
+            bitpos = (bitpos + 10) & 7;
+            if (bitpos == 0)
+                bitpos = 8;
+            if ((index >= 0 && index < SECTOR_SIZE) || 
+                index == (SECTOR_SIZE + 1)) {
+                val = error_val[i] << (8 - bitpos);
+                parity ^= val;
+                if (index < SECTOR_SIZE)
+                    sector[index] ^= val;
+            }
+        }
+    }
+    
+    /* use parity to test extra errors */
+    if ((parity & 0xff) != 0)
+        nb_errors = -1;
+
+ the_end:
+    kfree(Alpha_to);
+    kfree(Index_of);
+    return nb_errors;
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fabrice Bellard <fabrice.bellard@netgem.com>");
+MODULE_DESCRIPTION("ECC code for correcting errors detected by DiskOnChip 2000 and Millennium ECC hardware");
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/docprobe.c linux-2.4.2/drivers/mtd/devices/docprobe.c
--- linux-2.4.2.orig/drivers/mtd/devices/docprobe.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/docprobe.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,286 @@
+
+/* Linux driver for Disk-On-Chip devices			*/
+/* Probe routines common to all DoC devices			*/
+/* (c) 1999 Machine Vision Holdings, Inc.			*/
+/* Author: David Woodhouse <dwmw2@infradead.org>		*/
+/* $Id: docprobe.c,v 1.30 2001/10/02 15:05:13 dwmw2 Exp $	*/
+
+
+
+/* DOC_PASSIVE_PROBE:
+   In order to ensure that the BIOS checksum is correct at boot time, and 
+   hence that the onboard BIOS extension gets executed, the DiskOnChip 
+   goes into reset mode when it is read sequentially: all registers 
+   return 0xff until the chip is woken up again by writing to the 
+   DOCControl register. 
+
+   Unfortunately, this means that the probe for the DiskOnChip is unsafe, 
+   because one of the first things it does is write to where it thinks 
+   the DOCControl register should be - which may well be shared memory 
+   for another device. I've had machines which lock up when this is 
+   attempted. Hence the possibility to do a passive probe, which will fail 
+   to detect a chip in reset mode, but is at least guaranteed not to lock
+   the machine.
+
+   If you have this problem, uncomment the following line:
+#define DOC_PASSIVE_PROBE
+*/
+
+
+/* DOC_SINGLE_DRIVER:
+   Millennium driver has been merged into DOC2000 driver.
+
+   The newly-merged driver doesn't appear to work for writing. It's the
+   same with the DiskOnChip 2000 and the Millennium. If you have a 
+   Millennium and you want write support to work, remove the definition
+   of DOC_SINGLE_DRIVER below to use the old doc2001-specific driver.
+
+   Otherwise, it's left on in the hope that it'll annoy someone with
+   a Millennium enough that they go through and work out what the 
+   difference is :)
+*/
+#define DOC_SINGLE_DRIVER
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/doc2000.h>
+
+/* Where to look for the devices? */
+#ifndef CONFIG_MTD_DOCPROBE_ADDRESS
+#define CONFIG_MTD_DOCPROBE_ADDRESS 0
+#endif
+
+
+static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
+MODULE_PARM(doc_config_location, "l");
+
+
+static unsigned long __initdata doc_locations[] = {
+#if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
+#ifdef CONFIG_MTD_DOCPROBE_HIGH
+	0xfffc8000, 0xfffca000, 0xfffcc000, 0xfffce000, 
+	0xfffd0000, 0xfffd2000, 0xfffd4000, 0xfffd6000,
+	0xfffd8000, 0xfffda000, 0xfffdc000, 0xfffde000, 
+	0xfffe0000, 0xfffe2000, 0xfffe4000, 0xfffe6000, 
+	0xfffe8000, 0xfffea000, 0xfffec000, 0xfffee000,
+#else /*  CONFIG_MTD_DOCPROBE_HIGH */
+	0xc8000, 0xca000, 0xcc000, 0xce000, 
+	0xd0000, 0xd2000, 0xd4000, 0xd6000,
+	0xd8000, 0xda000, 0xdc000, 0xde000, 
+	0xe0000, 0xe2000, 0xe4000, 0xe6000, 
+	0xe8000, 0xea000, 0xec000, 0xee000,
+#endif /*  CONFIG_MTD_DOCPROBE_HIGH */
+#elif defined(__ppc__)
+	0xe4000000,
+#elif defined(CONFIG_MOMENCO_OCELOT)
+	0x2f000000,
+#else
+#warning Unknown architecture for DiskOnChip. No default probe locations defined
+#endif
+	0 };
+
+/* doccheck: Probe a given memory window to see if there's a DiskOnChip present */
+
+static inline int __init doccheck(unsigned long potential, unsigned long physadr)
+{
+	unsigned long window=potential;
+	unsigned char tmp, ChipID;
+#ifndef DOC_PASSIVE_PROBE
+	unsigned char tmp2;
+#endif
+
+	/* Routine copied from the Linux DOC driver */
+
+#ifdef CONFIG_MTD_DOCPROBE_55AA
+	/* Check for 0x55 0xAA signature at beginning of window,
+	   this is no longer true once we remove the IPL (for Millennium */
+	if (ReadDOC(window, Sig1) != 0x55 || ReadDOC(window, Sig2) != 0xaa)
+		return 0;
+#endif /* CONFIG_MTD_DOCPROBE_55AA */
+
+#ifndef DOC_PASSIVE_PROBE	
+	/* It's not possible to cleanly detect the DiskOnChip - the
+	 * bootup procedure will put the device into reset mode, and
+	 * it's not possible to talk to it without actually writing
+	 * to the DOCControl register. So we store the current contents
+	 * of the DOCControl register's location, in case we later decide
+	 * that it's not a DiskOnChip, and want to put it back how we
+	 * found it. 
+	 */
+	tmp2 = ReadDOC(window, DOCControl);
+	
+	/* Reset the DiskOnChip ASIC */
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, 
+		 window, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, 
+		 window, DOCControl);
+	
+	/* Enable the DiskOnChip ASIC */
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, 
+		 window, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, 
+		 window, DOCControl);
+#endif /* !DOC_PASSIVE_PROBE */	
+
+	ChipID = ReadDOC(window, ChipID);
+  
+	switch (ChipID) {
+	case DOC_ChipID_Doc2k:
+		/* Check the TOGGLE bit in the ECC register */
+		tmp = ReadDOC(window, 2k_ECCStatus) & DOC_TOGGLE_BIT;
+		if ((ReadDOC(window, 2k_ECCStatus) & DOC_TOGGLE_BIT) != tmp)
+				return ChipID;
+		break;
+		
+	case DOC_ChipID_DocMil:
+		/* Check the TOGGLE bit in the ECC register */
+		tmp = ReadDOC(window, ECCConf) & DOC_TOGGLE_BIT;
+		if ((ReadDOC(window, ECCConf) & DOC_TOGGLE_BIT) != tmp)
+				return ChipID;
+		break;
+		
+	default:
+#ifndef CONFIG_MTD_DOCPROBE_55AA
+		printk(KERN_WARNING "Possible DiskOnChip with unknown ChipID %2.2X found at 0x%lx\n",
+		       ChipID, physadr);
+#endif
+#ifndef DOC_PASSIVE_PROBE
+		/* Put back the contents of the DOCControl register, in case it's not
+		 * actually a DiskOnChip.
+		 */
+		WriteDOC(tmp2, window, DOCControl);
+#endif
+		return 0;
+	}
+
+	printk(KERN_WARNING "DiskOnChip failed TOGGLE test, dropping.\n");
+
+#ifndef DOC_PASSIVE_PROBE
+	/* Put back the contents of the DOCControl register: it's not a DiskOnChip */
+	WriteDOC(tmp2, window, DOCControl);
+#endif
+	return 0;
+}   
+
+static int docfound;
+
+static void __init DoC_Probe(unsigned long physadr)
+{
+	unsigned long docptr;
+	struct DiskOnChip *this;
+	struct mtd_info *mtd;
+	int ChipID;
+	char namebuf[15];
+	char *name = namebuf;
+	char *im_funcname = NULL;
+	char *im_modname = NULL;
+	void (*initroutine)(struct mtd_info *) = NULL;
+
+	docptr = (unsigned long)ioremap(physadr, DOC_IOREMAP_LEN);
+	
+	if (!docptr)
+		return;
+	
+	if ((ChipID = doccheck(docptr, physadr))) {
+		docfound = 1;
+		mtd = kmalloc(sizeof(struct DiskOnChip) + sizeof(struct mtd_info), GFP_KERNEL);
+
+		if (!mtd) {
+			printk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");
+			iounmap((void *)docptr);
+			return;
+		}
+		
+		this = (struct DiskOnChip *)(&mtd[1]);
+		
+		memset((char *)mtd,0, sizeof(struct mtd_info));
+		memset((char *)this, 0, sizeof(struct DiskOnChip));
+
+		mtd->priv = this;
+		this->virtadr = docptr;
+		this->physadr = physadr;
+		this->ChipID = ChipID;
+		sprintf(namebuf, "with ChipID %2.2X", ChipID);
+
+		switch(ChipID) {
+		case DOC_ChipID_Doc2k:
+			name="2000";
+			im_funcname = "DoC2k_init";
+			im_modname = "doc2000";
+			break;
+			
+		case DOC_ChipID_DocMil:
+			name="Millennium";
+#ifdef DOC_SINGLE_DRIVER
+			im_funcname = "DoC2k_init";
+			im_modname = "doc2000";
+#else
+			im_funcname = "DoCMil_init";
+			im_modname = "doc2001";
+#endif /* DOC_SINGLE_DRIVER */
+			break;
+		}
+
+		if (im_funcname)
+			initroutine = inter_module_get_request(im_funcname, im_modname);
+
+		if (initroutine) {
+			(*initroutine)(mtd);
+			inter_module_put(im_funcname);
+			return;
+		}
+		printk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);
+	}
+	iounmap((void *)docptr);
+}
+
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+
+int __init init_doc(void)
+{
+	int i;
+	
+	if (doc_config_location) {
+		printk(KERN_INFO "Using configured DiskOnChip probe address 0x%lx\n", doc_config_location);
+		DoC_Probe(doc_config_location);
+	} else {
+		for (i=0; doc_locations[i]; i++) {
+			DoC_Probe(doc_locations[i]);
+		}
+	}
+	/* No banner message any more. Print a message if no DiskOnChip
+	   found, so the user knows we at least tried. */
+	if (!docfound)
+		printk(KERN_INFO "No recognised DiskOnChip devices found\n");
+	/* So it looks like we've been used and we get unloaded */
+	MOD_INC_USE_COUNT;
+	MOD_DEC_USE_COUNT;
+	return 0;
+	
+}
+
+module_init(init_doc);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Probe code for DiskOnChip 2000 and Millennium devices");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/lart.c linux-2.4.2/drivers/mtd/devices/lart.c
--- linux-2.4.2.orig/drivers/mtd/devices/lart.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/lart.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,716 @@
+
+/*
+ * MTD driver for the 28F160F3 Flash Memory (non-CFI) on LART.
+ *
+ * $Id: lart.c,v 1.2 2001/10/02 15:05:13 dwmw2 Exp $
+ *
+ * Author: Abraham vd Merwe <abraham@2d3d.co.za>
+ *
+ * Copyright (c) 2001, 2d3D, Inc.
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * References:
+ *
+ *    [1] 3 Volt Fast Boot Block Flash Memory" Intel Datasheet
+ *           - Order Number: 290644-005
+ *           - January 2000
+ *
+ *    [2] MTD internal API documentation
+ *           - http://www.linux-mtd.infradead.org/tech/
+ *
+ * Limitations:
+ *
+ *    Even though this driver is written for 3 Volt Fast Boot
+ *    Block Flash Memory, it is rather specific to LART. With
+ *    Minor modifications, notably the without data/address line
+ *    mangling and different bus settings, etc. it should be
+ *    trivial to adapt to other platforms.
+ *
+ *    If somebody would sponsor me a different board, I'll
+ *    adapt the driver (:
+ */
+
+/* debugging */
+//#define LART_DEBUG
+
+/* partition support */
+#define HAVE_PARTITIONS
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/mtd/mtd.h>
+#ifdef HAVE_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+
+#ifndef CONFIG_SA1100_LART
+#error This is for LART architecture only
+#endif
+
+static char module_name[] = "lart";
+
+/*
+ * These values is specific to 28Fxxxx3 flash memory.
+ * See section 2.3.1 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
+ */
+#define FLASH_BLOCKSIZE_PARAM		(4096 * BUSWIDTH)
+#define FLASH_NUMBLOCKS_16m_PARAM	8
+#define FLASH_NUMBLOCKS_8m_PARAM	8
+
+/*
+ * These values is specific to 28Fxxxx3 flash memory.
+ * See section 2.3.2 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
+ */
+#define FLASH_BLOCKSIZE_MAIN		(32768 * BUSWIDTH)
+#define FLASH_NUMBLOCKS_16m_MAIN	31
+#define FLASH_NUMBLOCKS_8m_MAIN		15
+
+/*
+ * These values are specific to LART
+ */
+
+/* general */
+#define BUSWIDTH			4				/* don't change this - a lot of the code _will_ break if you change this */
+#define FLASH_OFFSET		0xe8000000		/* see linux/arch/arm/mach-sa1100/lart.c */
+
+/* blob */
+#define NUM_BLOB_BLOCKS		FLASH_NUMBLOCKS_16m_PARAM
+#define BLOB_START			0x00000000
+#define BLOB_LEN			(NUM_BLOB_BLOCKS * FLASH_BLOCKSIZE_PARAM)
+
+/* kernel */
+#define NUM_KERNEL_BLOCKS	7
+#define KERNEL_START		(BLOB_START + BLOB_LEN)
+#define KERNEL_LEN			(NUM_KERNEL_BLOCKS * FLASH_BLOCKSIZE_MAIN)
+
+/* initial ramdisk */
+#define NUM_INITRD_BLOCKS	24
+#define INITRD_START		(KERNEL_START + KERNEL_LEN)
+#define INITRD_LEN			(NUM_INITRD_BLOCKS * FLASH_BLOCKSIZE_MAIN)
+
+/*
+ * See section 4.0 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
+ */
+#define READ_ARRAY			0x00FF00FF		/* Read Array/Reset */
+#define READ_ID_CODES		0x00900090		/* Read Identifier Codes */
+#define ERASE_SETUP			0x00200020		/* Block Erase */
+#define ERASE_CONFIRM		0x00D000D0		/* Block Erase and Program Resume */
+#define PGM_SETUP			0x00400040		/* Program */
+#define STATUS_READ			0x00700070		/* Read Status Register */
+#define STATUS_CLEAR		0x00500050		/* Clear Status Register */
+#define STATUS_BUSY			0x00800080		/* Write State Machine Status (WSMS) */
+#define STATUS_ERASE_ERR	0x00200020		/* Erase Status (ES) */
+#define STATUS_PGM_ERR		0x00100010		/* Program Status (PS) */
+
+/*
+ * See section 4.2 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
+ */
+#define FLASH_MANUFACTURER			0x00890089
+#define FLASH_DEVICE_8mbit_TOP		0x88f188f1
+#define FLASH_DEVICE_8mbit_BOTTOM	0x88f288f2
+#define FLASH_DEVICE_16mbit_TOP		0x88f388f3
+#define FLASH_DEVICE_16mbit_BOTTOM	0x88f488f4
+
+/***************************************************************************************************/
+
+/*
+ * The data line mapping on LART is as follows:
+ * 
+ *   	 U2  CPU |   U3  CPU
+ *   	 -------------------
+ *   	  0  20  |   0   12
+ *   	  1  22  |   1   14
+ *   	  2  19  |   2   11
+ *   	  3  17  |   3   9
+ *   	  4  24  |   4   0
+ *   	  5  26  |   5   2
+ *   	  6  31  |   6   7
+ *   	  7  29  |   7   5
+ *   	  8  21  |   8   13
+ *   	  9  23  |   9   15
+ *   	  10 18  |   10  10
+ *   	  11 16  |   11  8
+ *   	  12 25  |   12  1
+ *   	  13 27  |   13  3
+ *   	  14 30  |   14  6
+ *   	  15 28  |   15  4
+ */
+
+/* Mangle data (x) */
+#define DATA_TO_FLASH(x)				\
+	(									\
+		(((x) & 0x08009000) >> 11)	+	\
+		(((x) & 0x00002000) >> 10)	+	\
+		(((x) & 0x04004000) >> 8)	+	\
+		(((x) & 0x00000010) >> 4)	+	\
+		(((x) & 0x91000820) >> 3)	+	\
+		(((x) & 0x22080080) >> 2)	+	\
+		((x) & 0x40000400)			+	\
+		(((x) & 0x00040040) << 1)	+	\
+		(((x) & 0x00110000) << 4)	+	\
+		(((x) & 0x00220100) << 5)	+	\
+		(((x) & 0x00800208) << 6)	+	\
+		(((x) & 0x00400004) << 9)	+	\
+		(((x) & 0x00000001) << 12)	+	\
+		(((x) & 0x00000002) << 13)		\
+	)
+
+/* Unmangle data (x) */
+#define FLASH_TO_DATA(x)				\
+	(									\
+		(((x) & 0x00010012) << 11)	+	\
+		(((x) & 0x00000008) << 10)	+	\
+		(((x) & 0x00040040) << 8)	+	\
+		(((x) & 0x00000001) << 4)	+	\
+		(((x) & 0x12200104) << 3)	+	\
+		(((x) & 0x08820020) << 2)	+	\
+		((x) & 0x40000400)			+	\
+		(((x) & 0x00080080) >> 1)	+	\
+		(((x) & 0x01100000) >> 4)	+	\
+		(((x) & 0x04402000) >> 5)	+	\
+		(((x) & 0x20008200) >> 6)	+	\
+		(((x) & 0x80000800) >> 9)	+	\
+		(((x) & 0x00001000) >> 12)	+	\
+		(((x) & 0x00004000) >> 13)		\
+	)
+
+/* 
+ * The address line mapping on LART is as follows:
+ *
+ *   	 U3  CPU |   U2  CPU
+ *   	 -------------------
+ *   	  0  2   |   0   2
+ *   	  1  3   |   1   3
+ *   	  2  9   |   2   9
+ *   	  3  13  |   3   8
+ *   	  4  8   |   4   7
+ *   	  5  12  |   5   6
+ *   	  6  11  |   6   5
+ *   	  7  10  |   7   4
+ *   	  8  4   |   8   10
+ *   	  9  5   |   9   11
+ *   	 10  6   |   10  12
+ *   	 11  7   |   11  13
+ *
+ *   	 BOOT BLOCK BOUNDARY
+ *
+ *   	 12  15  |   12  15
+ *   	 13  14  |   13  14
+ *   	 14  16  |   14  16
+ * 
+ *   	 MAIN BLOCK BOUNDARY
+ *
+ *   	 15  17  |   15  18
+ *   	 16  18  |   16  17
+ *   	 17  20  |   17  20
+ *   	 18  19  |   18  19
+ *   	 19  21  |   19  21
+ *
+ * As we can see from above, the addresses aren't mangled across
+ * block boundaries, so we don't need to worry about address
+ * translations except for sending/reading commands during
+ * initialization
+ */
+
+/* Mangle address (x) on chip U2 */
+#define ADDR_TO_FLASH_U2(x)				\
+	(									\
+		(((x) & 0x00000f00) >> 4)	+	\
+		(((x) & 0x00042000) << 1)	+	\
+		(((x) & 0x0009c003) << 2)	+	\
+		(((x) & 0x00021080) << 3)	+	\
+		(((x) & 0x00000010) << 4)	+	\
+		(((x) & 0x00000040) << 5)	+	\
+		(((x) & 0x00000024) << 7)	+	\
+		(((x) & 0x00000008) << 10)		\
+	)
+
+/* Unmangle address (x) on chip U2 */
+#define FLASH_U2_TO_ADDR(x)				\
+	(									\
+		(((x) << 4) & 0x00000f00)	+	\
+		(((x) >> 1) & 0x00042000)	+	\
+		(((x) >> 2) & 0x0009c003)	+	\
+		(((x) >> 3) & 0x00021080)	+	\
+		(((x) >> 4) & 0x00000010)	+	\
+		(((x) >> 5) & 0x00000040)	+	\
+		(((x) >> 7) & 0x00000024)	+	\
+		(((x) >> 10) & 0x00000008)		\
+	)
+
+/* Mangle address (x) on chip U3 */
+#define ADDR_TO_FLASH_U3(x)				\
+	(									\
+		(((x) & 0x00000080) >> 3)	+	\
+		(((x) & 0x00000040) >> 1)	+	\
+		(((x) & 0x00052020) << 1)	+	\
+		(((x) & 0x00084f03) << 2)	+	\
+		(((x) & 0x00029010) << 3)	+	\
+		(((x) & 0x00000008) << 5)	+	\
+		(((x) & 0x00000004) << 7)		\
+	)
+
+/* Unmangle address (x) on chip U3 */
+#define FLASH_U3_TO_ADDR(x)				\
+	(									\
+		(((x) << 3) & 0x00000080)	+	\
+		(((x) << 1) & 0x00000040)	+	\
+		(((x) >> 1) & 0x00052020)	+	\
+		(((x) >> 2) & 0x00084f03)	+	\
+		(((x) >> 3) & 0x00029010)	+	\
+		(((x) >> 5) & 0x00000008)	+	\
+		(((x) >> 7) & 0x00000004)		\
+	)
+
+/***************************************************************************************************/
+
+static __u8 read8 (__u32 offset)
+{
+   volatile __u8 *data = (__u8 *) (FLASH_OFFSET + offset);
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(): 0x%.8x -> 0x%.2x\n",__FUNCTION__,offset,*data);
+#endif
+   return (*data);
+}
+
+static __u32 read32 (__u32 offset)
+{
+   volatile __u32 *data = (__u32 *) (FLASH_OFFSET + offset);
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(): 0x%.8x -> 0x%.8x\n",__FUNCTION__,offset,*data);
+#endif
+   return (*data);
+}
+
+static void write32 (__u32 x,__u32 offset)
+{
+   volatile __u32 *data = (__u32 *) (FLASH_OFFSET + offset);
+   *data = x;
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(): 0x%.8x <- 0x%.8x\n",__FUNCTION__,offset,*data);
+#endif
+}
+
+/***************************************************************************************************/
+
+/*
+ * Probe for 16mbit flash memory on a LART board without doing
+ * too much damage. Since we need to write 1 dword to memory,
+ * we're f**cked if this happens to be DRAM since we can't
+ * restore the memory (otherwise we might exit Read Array mode).
+ *
+ * Returns 1 if we found 16mbit flash memory on LART, 0 otherwise.
+ */
+static int flash_probe (void)
+{
+   __u32 manufacturer,devtype;
+
+   /* setup "Read Identifier Codes" mode */
+   write32 (DATA_TO_FLASH (READ_ID_CODES),0x00000000);
+
+   /* probe U2. U2/U3 returns the same data since the first 3
+	* address lines is mangled in the same way */
+   manufacturer = FLASH_TO_DATA (read32 (ADDR_TO_FLASH_U2 (0x00000000)));
+   devtype = FLASH_TO_DATA (read32 (ADDR_TO_FLASH_U2 (0x00000001)));
+
+   /* put the flash back into command mode */
+   write32 (DATA_TO_FLASH (READ_ARRAY),0x00000000);
+
+   return (manufacturer == FLASH_MANUFACTURER && (devtype == FLASH_DEVICE_16mbit_TOP || FLASH_DEVICE_16mbit_BOTTOM));
+}
+
+/*
+ * Erase one block of flash memory at offset ``offset'' which is any
+ * address within the block which should be erased.
+ *
+ * Returns 1 if successful, 0 otherwise.
+ */
+static inline int erase_block (__u32 offset)
+{
+   __u32 status;
+
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(): 0x%.8x\n",__FUNCTION__,offset);
+#endif
+
+   /* erase and confirm */
+   write32 (DATA_TO_FLASH (ERASE_SETUP),offset);
+   write32 (DATA_TO_FLASH (ERASE_CONFIRM),offset);
+
+   /* wait for block erase to finish */
+   do
+	 {
+		write32 (DATA_TO_FLASH (STATUS_READ),offset);
+		status = FLASH_TO_DATA (read32 (offset));
+	 }
+   while ((~status & STATUS_BUSY) != 0);
+
+   /* put the flash back into command mode */
+   write32 (DATA_TO_FLASH (READ_ARRAY),offset);
+
+   /* was the erase successfull? */
+   if ((status & STATUS_ERASE_ERR))
+	 {
+		printk (KERN_WARNING "%s: erase error at address 0x%.8x.\n",module_name,offset);
+		return (0);
+	 }
+
+   return (1);
+}
+
+static int flash_erase (struct mtd_info *mtd,struct erase_info *instr)
+{
+   __u32 addr,len;
+   int i,first;
+
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(addr = 0x%.8x, len = %d)\n",__FUNCTION__,instr->addr,instr->len);
+#endif
+
+   /* sanity checks */
+   if (instr->addr + instr->len > mtd->size) return (-EINVAL);
+
+   /*
+	* check that both start and end of the requested erase are
+	* aligned with the erasesize at the appropriate addresses.
+	*
+	* skip all erase regions which are ended before the start of
+	* the requested erase. Actually, to save on the calculations,
+	* we skip to the first erase region which starts after the
+	* start of the requested erase, and then go back one.
+	*/
+   for (i = 0; i < mtd->numeraseregions && instr->addr >= mtd->eraseregions[i].offset; i++) ;
+   i--;
+
+   /*
+	* ok, now i is pointing at the erase region in which this
+	* erase request starts. Check the start of the requested
+	* erase range is aligned with the erase size which is in
+	* effect here.
+	*/
+   if (instr->addr & (mtd->eraseregions[i].erasesize - 1)) return (-EINVAL);
+
+   /* Remember the erase region we start on */
+   first = i;
+
+   /*
+	* next, check that the end of the requested erase is aligned
+	* with the erase region at that address.
+	*
+	* as before, drop back one to point at the region in which
+	* the address actually falls
+	*/
+   for (; i < mtd->numeraseregions && instr->addr + instr->len >= mtd->eraseregions[i].offset; i++) ;
+   i--;
+
+   /* is the end aligned on a block boundary? */
+   if ((instr->addr + instr->len) & (mtd->eraseregions[i].erasesize - 1)) return (-EINVAL);
+
+   addr = instr->addr;
+   len = instr->len;
+
+   i = first;
+
+   /* now erase those blocks */
+   while (len)
+	 {
+		if (!erase_block (addr))
+		  {
+			 instr->state = MTD_ERASE_FAILED;
+			 return (-EIO);
+		  }
+
+		addr += mtd->eraseregions[i].erasesize;
+		len -= mtd->eraseregions[i].erasesize;
+
+		if (addr == mtd->eraseregions[i].offset + (mtd->eraseregions[i].erasesize * mtd->eraseregions[i].numblocks)) i++;
+	 }
+
+   instr->state = MTD_ERASE_DONE;
+   if (instr->callback) instr->callback (instr);
+
+   return (0);
+}
+
+static int flash_read (struct mtd_info *mtd,loff_t from,size_t len,size_t *retlen,u_char *buf)
+{
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(from = 0x%.8x, len = %d)\n",__FUNCTION__,(__u32) from,len);
+#endif
+
+   /* sanity checks */
+   if (!len) return (0);
+   if (from + len > mtd->size) return (-EINVAL);
+
+   /* we always read len bytes */
+   *retlen = len;
+
+   /* first, we read bytes until we reach a dword boundary */
+   if (from & (BUSWIDTH - 1))
+	 {
+		int gap = BUSWIDTH - (from & (BUSWIDTH - 1));
+
+		while (len && gap--) *buf++ = read8 (from++), len--;
+	 }
+
+   /* now we read dwords until we reach a non-dword boundary */
+   while (len >= BUSWIDTH)
+	 {
+		*((__u32 *) buf) = read32 (from);
+
+		buf += BUSWIDTH;
+		from += BUSWIDTH;
+		len -= BUSWIDTH;
+	 }
+
+   /* top up the last unaligned bytes */
+   if (len & (BUSWIDTH - 1))
+	 while (len--) *buf++ = read8 (from++);
+
+   return (0);
+}
+
+/*
+ * Write one dword ``x'' to flash memory at offset ``offset''. ``offset''
+ * must be 32 bits, i.e. it must be on a dword boundary.
+ *
+ * Returns 1 if successful, 0 otherwise.
+ */
+static inline int write_dword (__u32 offset,__u32 x)
+{
+   __u32 status;
+
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(): 0x%.8x <- 0x%.8x\n",__FUNCTION__,offset,x);
+#endif
+
+   /* setup writing */
+   write32 (DATA_TO_FLASH (PGM_SETUP),offset);
+
+   /* write the data */
+   write32 (x,offset);
+
+   /* wait for the write to finish */
+   do
+	 {
+		write32 (DATA_TO_FLASH (STATUS_READ),offset);
+		status = FLASH_TO_DATA (read32 (offset));
+	 }
+   while ((~status & STATUS_BUSY) != 0);
+
+   /* put the flash back into command mode */
+   write32 (DATA_TO_FLASH (READ_ARRAY),offset);
+
+   /* was the write successfull? */
+   if ((status & STATUS_PGM_ERR) || read32 (offset) != x)
+	 {
+		printk (KERN_WARNING "%s: write error at address 0x%.8x.\n",module_name,offset);
+		return (0);
+	 }
+
+   return (1);
+}
+
+static int flash_write (struct mtd_info *mtd,loff_t to,size_t len,size_t *retlen,const u_char *buf)
+{
+   __u8 tmp[4];
+   int i,n;
+
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG "%s(to = 0x%.8x, len = %d)\n",__FUNCTION__,(__u32) to,len);
+#endif
+
+   *retlen = 0;
+
+   /* sanity checks */
+   if (!len) return (0);
+   if (to + len > mtd->size) return (-EINVAL);
+
+   /* first, we write a 0xFF.... padded byte until we reach a dword boundary */
+   if (to & (BUSWIDTH - 1))
+	 {
+		__u32 aligned = to & ~(BUSWIDTH - 1);
+		int gap = to - aligned;
+
+		i = n = 0;
+
+		while (gap--) tmp[i++] = 0xFF;
+		while (len && i < BUSWIDTH) tmp[i++] = buf[n++], len--;
+		while (i < BUSWIDTH) tmp[i++] = 0xFF;
+
+		if (!write_dword (aligned,*((__u32 *) tmp))) return (-EIO);
+
+		to += n;
+		buf += n;
+		*retlen += n;
+	 }
+
+   /* now we write dwords until we reach a non-dword boundary */
+   while (len >= BUSWIDTH)
+	 {
+		if (!write_dword (to,*((__u32 *) buf))) return (-EIO);
+
+		to += BUSWIDTH;
+		buf += BUSWIDTH;
+		*retlen += BUSWIDTH;
+		len -= BUSWIDTH;
+	 }
+
+   /* top up the last unaligned bytes, padded with 0xFF.... */
+   if (len & (BUSWIDTH - 1))
+	 {
+		i = n = 0;
+
+		while (len--) tmp[i++] = buf[n++];
+		while (i < BUSWIDTH) tmp[i++] = 0xFF;
+
+		if (!write_dword (to,*((__u32 *) tmp))) return (-EIO);
+
+		*retlen += n;
+	 }
+
+   return (0);
+}
+
+/***************************************************************************************************/
+
+#define NB_OF(x) (sizeof (x) / sizeof (x[0]))
+
+static struct mtd_info mtd;
+
+static struct mtd_erase_region_info erase_regions[] =
+{
+   /* parameter blocks */
+   {
+	     offset: 0x00000000,
+	  erasesize: FLASH_BLOCKSIZE_PARAM,
+	  numblocks: FLASH_NUMBLOCKS_16m_PARAM
+   },
+   /* main blocks */
+   {
+	     offset: FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM,
+	  erasesize: FLASH_BLOCKSIZE_MAIN,
+	  numblocks: FLASH_NUMBLOCKS_16m_MAIN
+   }
+};
+
+#ifdef HAVE_PARTITIONS
+static struct mtd_partition lart_partitions[] =
+{
+   /* blob */
+   {
+	       name: "blob",
+	     offset: BLOB_START,
+	       size: BLOB_LEN,
+	 mask_flags: 0
+   },
+   /* kernel */
+   {
+	       name: "kernel",
+	     offset: KERNEL_START,			/* MTDPART_OFS_APPEND */
+	       size: KERNEL_LEN,
+	 mask_flags: 0
+   },
+   /* initial ramdisk / file system */
+   {
+	       name: "file system",
+	     offset: INITRD_START,			/* MTDPART_OFS_APPEND */
+	       size: INITRD_LEN,			/* MTDPART_SIZ_FULL */
+	 mask_flags: 0
+   }
+};
+#endif
+
+int __init lart_flash_init (void)
+{
+   int result;
+   memset (&mtd,0,sizeof (mtd));
+   printk ("MTD driver for LART. Written by Abraham vd Merwe <abraham@2d3d.co.za>\n");
+   printk ("%s: Probing for 28F160x3 flash on LART...\n",module_name);
+   if (!flash_probe ())
+	 {
+		printk (KERN_WARNING "%s: Found no LART compatible flash device\n",module_name);
+		return (-ENXIO);
+	 }
+   printk ("%s: This looks like a LART board to me.\n",module_name);
+   mtd.name = module_name;
+   mtd.type = MTD_NORFLASH;
+   mtd.flags = MTD_CAP_NORFLASH;
+   mtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;
+   mtd.erasesize = FLASH_BLOCKSIZE_MAIN;
+   mtd.numeraseregions = NB_OF (erase_regions);
+   mtd.eraseregions = erase_regions;
+   mtd.module = THIS_MODULE;
+   mtd.erase = flash_erase;
+   mtd.read = flash_read;
+   mtd.write = flash_write;
+
+#ifdef LART_DEBUG
+   printk (KERN_DEBUG
+		   "mtd.name = %s\n"
+		   "mtd.size = 0x%.8x (%uM)\n"
+		   "mtd.erasesize = 0x%.8x (%uK)\n"
+		   "mtd.numeraseregions = %d\n",
+		   mtd.name,
+		   mtd.size,mtd.size / (1024*1024),
+		   mtd.erasesize,mtd.erasesize / 1024,
+		   mtd.numeraseregions);
+
+   if (mtd.numeraseregions)
+	 for (result = 0; result < mtd.numeraseregions; result++)
+	   printk (KERN_DEBUG
+			   "\n\n"
+			   "mtd.eraseregions[%d].offset = 0x%.8x\n"
+			   "mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
+			   "mtd.eraseregions[%d].numblocks = %d\n",
+			   result,mtd.eraseregions[result].offset,
+			   result,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,
+			   result,mtd.eraseregions[result].numblocks);
+
+#ifdef HAVE_PARTITIONS
+   printk ("\npartitions = %d\n",NB_OF (lart_partitions));
+
+   for (result = 0; result < NB_OF (lart_partitions); result++)
+	 printk (KERN_DEBUG
+			 "\n\n"
+			 "lart_partitions[%d].name = %s\n"
+			 "lart_partitions[%d].offset = 0x%.8x\n"
+			 "lart_partitions[%d].size = 0x%.8x (%uK)\n",
+			 result,lart_partitions[result].name,
+			 result,lart_partitions[result].offset,
+			 result,lart_partitions[result].size,lart_partitions[result].size / 1024);
+#endif
+#endif
+
+#ifndef HAVE_PARTITIONS
+   result = add_mtd_device (&mtd);
+#else
+   result = add_mtd_partitions (&mtd,lart_partitions,NB_OF (lart_partitions));
+#endif
+
+   return (result);
+}
+
+void __exit lart_flash_exit (void)
+{
+#ifndef HAVE_PARTITIONS
+   del_mtd_device (&mtd);
+#else
+   del_mtd_partitions (&mtd);
+#endif
+}
+
+module_init (lart_flash_init);
+module_exit (lart_flash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Abraham vd Merwe <abraham@2d3d.co.za>");
+MODULE_DESCRIPTION("MTD driver for Intel 28F160F3 on LART board");
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/mtdram.c linux-2.4.2/drivers/mtd/devices/mtdram.c
--- linux-2.4.2.orig/drivers/mtd/devices/mtdram.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/mtdram.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,177 @@
+/*
+ * mtdram - a test mtd device
+ * $Id: mtdram.c,v 1.26 2001/12/01 10:24:18 dwmw2 Exp $
+ * Author: Alexander Larsson <alex@cendio.se>
+ *
+ * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
+ *
+ * This code is GPL
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/mtd/mtd.h>
+
+#ifndef CONFIG_MTDRAM_ABS_POS
+  #define CONFIG_MTDRAM_ABS_POS 0
+#endif
+
+#if CONFIG_MTDRAM_ABS_POS > 0
+  #include <asm/io.h>
+#endif
+
+#ifdef MODULE
+static unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;
+static unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;
+MODULE_PARM(total_size,"l");
+MODULE_PARM(erase_size,"l");
+#define MTDRAM_TOTAL_SIZE (total_size * 1024)
+#define MTDRAM_ERASE_SIZE (erase_size * 1024)
+#else
+#define MTDRAM_TOTAL_SIZE (CONFIG_MTDRAM_TOTAL_SIZE * 1024)
+#define MTDRAM_ERASE_SIZE (CONFIG_MTDRAM_ERASE_SIZE * 1024)
+#endif
+
+
+// We could store these in the mtd structure, but we only support 1 device..
+static struct mtd_info *mtd_info;
+
+
+static int
+ram_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_erase(pos:%ld, len:%ld)\n", (long)instr->addr, (long)instr->len);
+  if (instr->addr + instr->len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_erase() out of bounds (%ld > %ld)\n", (long)(instr->addr + instr->len), (long)mtd->size);
+    return -EINVAL;
+  }
+	
+  memset((char *)mtd->priv + instr->addr, 0xff, instr->len);
+	
+  instr->state = MTD_ERASE_DONE;
+
+  if (instr->callback)
+    (*(instr->callback))(instr);
+  return 0;
+}
+
+static int ram_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf)
+{
+  if (from + len > mtd->size)
+    return -EINVAL;
+	
+  *mtdbuf = mtd->priv + from;
+  *retlen = len;
+  return 0;
+}
+
+static void ram_unpoint (struct mtd_info *mtd, u_char *addr)
+{
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_unpoint\n");
+}
+
+static int ram_read(struct mtd_info *mtd, loff_t from, size_t len,
+	     size_t *retlen, u_char *buf)
+{
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_read(pos:%ld, len:%ld)\n", (long)from, (long)len);
+  if (from + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_read() out of bounds (%ld > %ld)\n", (long)(from + len), (long)mtd->size);
+    return -EINVAL;
+  }
+
+  memcpy(buf, mtd->priv + from, len);
+
+  *retlen=len;
+  return 0;
+}
+
+static int ram_write(struct mtd_info *mtd, loff_t to, size_t len,
+	      size_t *retlen, const u_char *buf)
+{
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_write(pos:%ld, len:%ld)\n", (long)to, (long)len);
+  if (to + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_write() out of bounds (%ld > %ld)\n", (long)(to + len), (long)mtd->size);
+    return -EINVAL;
+  }
+
+  memcpy ((char *)mtd->priv + to, buf, len);
+
+  *retlen=len;
+  return 0;
+}
+
+static void __exit cleanup_mtdram(void)
+{
+  if (mtd_info) {
+    del_mtd_device(mtd_info);
+    if (mtd_info->priv)
+#if CONFIG_MTDRAM_ABS_POS > 0
+      iounmap(mtd_info->priv);
+#else
+      vfree(mtd_info->priv);
+#endif	
+    kfree(mtd_info);
+  }
+}
+
+int __init init_mtdram(void)
+{
+   // Allocate some memory
+   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+   if (!mtd_info)
+      return -ENOMEM;
+   
+   memset(mtd_info, 0, sizeof(*mtd_info));
+
+   // Setup the MTD structure
+   mtd_info->name = "mtdram test device";
+   mtd_info->type = MTD_RAM;
+   mtd_info->flags = MTD_CAP_RAM;
+   mtd_info->size = MTDRAM_TOTAL_SIZE;
+   mtd_info->erasesize = MTDRAM_ERASE_SIZE;
+#if CONFIG_MTDRAM_ABS_POS > 0
+   mtd_info->priv = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
+#else
+   mtd_info->priv = vmalloc(MTDRAM_TOTAL_SIZE);
+#endif
+
+   if (!mtd_info->priv) {
+     DEBUG(MTD_DEBUG_LEVEL1, "Failed to vmalloc(/ioremap) memory region of size %ld (ABS_POS:%ld)\n", (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
+     kfree(mtd_info);
+     mtd_info = NULL;
+     return -ENOMEM;
+   }
+   memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+
+   mtd_info->module = THIS_MODULE;			
+   mtd_info->erase = ram_erase;
+   mtd_info->point = ram_point;
+   mtd_info->unpoint = ram_unpoint;
+   mtd_info->read = ram_read;
+   mtd_info->write = ram_write;
+
+   if (add_mtd_device(mtd_info)) {
+#if CONFIG_MTDRAM_ABS_POS > 0
+     iounmap(mtd_info->priv);
+#else
+     vfree(mtd_info->priv);
+#endif	
+     kfree(mtd_info);
+     mtd_info = NULL;
+     return -EIO;
+   }
+   
+   return 0;
+}
+
+module_init(init_mtdram);
+module_exit(cleanup_mtdram);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Alexander Larsson <alexl@redhat.com>");
+MODULE_DESCRIPTION("Simulated MTD driver for testing");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/pmc551.c linux-2.4.2/drivers/mtd/devices/pmc551.c
--- linux-2.4.2.orig/drivers/mtd/devices/pmc551.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/pmc551.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,856 @@
+/*
+ * $Id: pmc551.c,v 1.19 2001/10/02 15:05:13 dwmw2 Exp $
+ *
+ * PMC551 PCI Mezzanine Ram Device
+ *
+ * Author:
+ *       Mark Ferrell <mferrell@mvista.com>
+ *       Copyright 1999,2000 Nortel Networks
+ *
+ * License:
+ *	 As part of this driver was derived from the slram.c driver it
+ *	 falls under the same license, which is GNU General Public
+ *	 License v2
+ *
+ * Description:
+ *	 This driver is intended to support the PMC551 PCI Ram device
+ *	 from Ramix Inc.  The PMC551 is a PMC Mezzanine module for
+ *	 cPCI embedded systems.  The device contains a single SROM
+ *	 that initially programs the V370PDC chipset onboard the
+ *	 device, and various banks of DRAM/SDRAM onboard.  This driver
+ *	 implements this PCI Ram device as an MTD (Memory Technology
+ *	 Device) so that it can be used to hold a file system, or for
+ *	 added swap space in embedded systems.  Since the memory on
+ *	 this board isn't as fast as main memory we do not try to hook
+ *	 it into main memory as that would simply reduce performance
+ *	 on the system.  Using it as a block device allows us to use
+ *	 it as high speed swap or for a high speed disk device of some
+ *	 sort.  Which becomes very useful on diskless systems in the
+ *	 embedded market I might add.
+ *	 
+ * Notes:
+ *	 Due to what I assume is more buggy SROM, the 64M PMC551 I
+ *	 have available claims that all 4 of it's DRAM banks have 64M
+ *	 of ram configured (making a grand total of 256M onboard).
+ *	 This is slightly annoying since the BAR0 size reflects the
+ *	 aperture size, not the dram size, and the V370PDC supplies no
+ *	 other method for memory size discovery.  This problem is
+ *	 mostly only relevant when compiled as a module, as the
+ *	 unloading of the module with an aperture size smaller then
+ *	 the ram will cause the driver to detect the onboard memory
+ *	 size to be equal to the aperture size when the module is
+ *	 reloaded.  Soooo, to help, the module supports an msize
+ *	 option to allow the specification of the onboard memory, and
+ *	 an asize option, to allow the specification of the aperture
+ *	 size.  The aperture must be equal to or less then the memory
+ *	 size, the driver will correct this if you screw it up.  This
+ *	 problem is not relevant for compiled in drivers as compiled
+ *	 in drivers only init once.
+ *
+ * Credits:
+ *       Saeed Karamooz <saeed@ramix.com> of Ramix INC. for the
+ *       initial example code of how to initialize this device and for
+ *       help with questions I had concerning operation of the device.
+ *
+ *       Most of the MTD code for this driver was originally written
+ *       for the slram.o module in the MTD drivers package which
+ *       allows the mapping of system memory into an MTD device.
+ *       Since the PMC551 memory module is accessed in the same
+ *       fashion as system memory, the slram.c code became a very nice
+ *       fit to the needs of this driver.  All we added was PCI
+ *       detection/initialization to the driver and automatically figure
+ *       out the size via the PCI detection.o, later changes by Corey
+ *       Minyard set up the card to utilize a 1M sliding apature.
+ *
+ *	 Corey Minyard <minyard@nortelnetworks.com>
+ *       * Modified driver to utilize a sliding aperture instead of 
+ *         mapping all memory into kernel space which turned out to
+ *         be very wasteful.
+ *       * Located a bug in the SROM's initialization sequence that 
+ *         made the memory unusable, added a fix to code to touch up
+ *         the DRAM some.
+ *
+ * Bugs/FIXME's:
+ *       * MUST fix the init function to not spin on a register
+ *       waiting for it to set .. this does not safely handle busted
+ *       devices that never reset the register correctly which will
+ *       cause the system to hang w/ a reboot being the only chance at
+ *       recover. [sort of fixed, could be better]
+ *       * Add I2C handling of the SROM so we can read the SROM's information
+ *       about the aperture size.  This should always accurately reflect the
+ *       onboard memory size.
+ *       * Comb the init routine.  It's still a bit cludgy on a few things.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <stdarg.h>
+#include <linux/pci.h>
+
+#ifndef CONFIG_PCI
+#error Enable PCI in your kernel config
+#endif
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/pmc551.h>
+#include <linux/mtd/compatmac.h>
+
+#if LINUX_VERSION_CODE > 0x20300
+#define PCI_BASE_ADDRESS(dev) (dev->resource[0].start)
+#else
+#define PCI_BASE_ADDRESS(dev) (dev->base_address[0])
+#endif
+
+static struct mtd_info *pmc551list;
+
+static int pmc551_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        u32 soff_hi, soff_lo; /* start address offset hi/lo */
+        u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
+        unsigned long end;
+	u_char *ptr;
+	size_t retlen;
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_erase(pos:%ld, len:%ld)\n", (long)instr->addr, (long)instr->len);
+#endif
+
+        end = instr->addr + instr->len - 1;
+
+        /* Is it past the end? */
+        if ( end > mtd->size ) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_erase() out of bounds (%ld > %ld)\n", (long)end, (long)mtd->size);
+#endif
+                return -EINVAL;
+        }
+
+        eoff_hi = end & ~(priv->asize - 1);
+        soff_hi = instr->addr & ~(priv->asize - 1);
+        eoff_lo = end & (priv->asize - 1);
+        soff_lo = instr->addr & (priv->asize - 1);
+
+	pmc551_point (mtd, instr->addr, instr->len, &retlen, &ptr);
+
+        if ( soff_hi == eoff_hi || mtd->size == priv->asize) {
+                /* The whole thing fits within one access, so just one shot
+                   will do it. */
+                memset(ptr, 0xff, instr->len);
+        } else {
+                /* We have to do multiple writes to get all the data
+                   written. */
+                while (soff_hi != eoff_hi) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+			printk( KERN_DEBUG "pmc551_erase() soff_hi: %ld, eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
+#endif
+                        memset(ptr, 0xff, priv->asize);
+                        if (soff_hi + priv->asize >= mtd->size) {
+                                goto out;
+                        }
+                        soff_hi += priv->asize;
+			pmc551_point (mtd,(priv->base_map0|soff_hi),
+				      priv->asize, &retlen, &ptr);
+                }
+                memset (ptr, 0xff, eoff_lo);
+        }
+
+out:
+	instr->state = MTD_ERASE_DONE;
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_erase() done\n");
+#endif
+
+        if (instr->callback) {
+                (*(instr->callback))(instr);
+	}
+        return 0;
+}
+
+
+static int pmc551_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf)
+{
+        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        u32 soff_hi;
+        u32 soff_lo;
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_point(%ld, %ld)\n", (long)from, (long)len);
+#endif
+
+	if (from + len > mtd->size) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+		printk(KERN_DEBUG "pmc551_point() out of bounds (%ld > %ld)\n", (long)from+len, (long)mtd->size);
+#endif
+		return -EINVAL;
+	}
+
+        soff_hi = from & ~(priv->asize - 1);
+        soff_lo = from & (priv->asize - 1);
+
+	/* Cheap hack optimization */
+	if( priv->curr_map0 != from ) {
+        	pci_write_config_dword ( priv->dev, PMC551_PCI_MEM_MAP0,
+                                 	(priv->base_map0 | soff_hi) );
+		priv->curr_map0 = soff_hi;
+	}
+
+	*mtdbuf = priv->start + soff_lo;
+	*retlen = len;
+	return 0;
+}
+
+
+static void pmc551_unpoint (struct mtd_info *mtd, u_char *addr)
+{
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_unpoint()\n");
+#endif
+}
+
+
+static int pmc551_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        u32 soff_hi, soff_lo; /* start address offset hi/lo */
+        u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
+        unsigned long end;
+	u_char *ptr;
+        u_char *copyto = buf;
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_read(pos:%ld, len:%ld) asize: %ld\n", (long)from, (long)len, (long)priv->asize);
+#endif
+
+        end = from + len - 1;
+
+        /* Is it past the end? */
+        if (end > mtd->size) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_read() out of bounds (%ld > %ld)\n", (long) end, (long)mtd->size);
+#endif
+                return -EINVAL;
+        }
+
+        soff_hi = from & ~(priv->asize - 1);
+        eoff_hi = end & ~(priv->asize - 1);
+        soff_lo = from & (priv->asize - 1);
+        eoff_lo = end & (priv->asize - 1);
+
+	pmc551_point (mtd, from, len, retlen, &ptr);
+
+        if (soff_hi == eoff_hi) {
+                /* The whole thing fits within one access, so just one shot
+                   will do it. */
+                memcpy(copyto, ptr, len);
+                copyto += len;
+        } else {
+                /* We have to do multiple writes to get all the data
+                   written. */
+                while (soff_hi != eoff_hi) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+			printk( KERN_DEBUG "pmc551_read() soff_hi: %ld, eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
+#endif
+                        memcpy(copyto, ptr, priv->asize);
+                        copyto += priv->asize;
+                        if (soff_hi + priv->asize >= mtd->size) {
+                                goto out;
+                        }
+                        soff_hi += priv->asize;
+			pmc551_point (mtd, soff_hi, priv->asize, retlen, &ptr);
+                }
+                memcpy(copyto, ptr, eoff_lo);
+                copyto += eoff_lo;
+        }
+
+out:
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_read() done\n");
+#endif
+        *retlen = copyto - buf;
+        return 0;
+}
+
+static int pmc551_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        u32 soff_hi, soff_lo; /* start address offset hi/lo */
+        u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
+        unsigned long end;
+	u_char *ptr;
+        const u_char *copyfrom = buf;
+
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_write(pos:%ld, len:%ld) asize:%ld\n", (long)to, (long)len, (long)priv->asize);
+#endif
+
+        end = to + len - 1;
+        /* Is it past the end?  or did the u32 wrap? */
+        if (end > mtd->size ) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_write() out of bounds (end: %ld, size: %ld, to: %ld)\n", (long) end, (long)mtd->size, (long)to);
+#endif
+                return -EINVAL;
+        }
+
+        soff_hi = to & ~(priv->asize - 1);
+        eoff_hi = end & ~(priv->asize - 1);
+        soff_lo = to & (priv->asize - 1);
+        eoff_lo = end & (priv->asize - 1);
+
+	pmc551_point (mtd, to, len, retlen, &ptr);
+
+        if (soff_hi == eoff_hi) {
+                /* The whole thing fits within one access, so just one shot
+                   will do it. */
+                memcpy(ptr, copyfrom, len);
+                copyfrom += len;
+        } else {
+                /* We have to do multiple writes to get all the data
+                   written. */
+                while (soff_hi != eoff_hi) {
+#ifdef CONFIG_MTD_PMC551_DEBUG
+			printk( KERN_DEBUG "pmc551_write() soff_hi: %ld, eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
+#endif
+                	memcpy(ptr, copyfrom, priv->asize);
+                	copyfrom += priv->asize;
+                        if (soff_hi >= mtd->size) {
+                                goto out;
+                        }
+                        soff_hi += priv->asize;
+			pmc551_point (mtd, soff_hi, priv->asize, retlen, &ptr);
+                }
+                memcpy(ptr, copyfrom, eoff_lo);
+                copyfrom += eoff_lo;
+        }
+
+out:
+#ifdef CONFIG_MTD_PMC551_DEBUG
+	printk(KERN_DEBUG "pmc551_write() done\n");
+#endif
+        *retlen = copyfrom - buf;
+        return 0;
+}
+
+/*
+ * Fixup routines for the V370PDC
+ * PCI device ID 0x020011b0
+ *
+ * This function basicly kick starts the DRAM oboard the card and gets it
+ * ready to be used.  Before this is done the device reads VERY erratic, so
+ * much that it can crash the Linux 2.2.x series kernels when a user cat's
+ * /proc/pci .. though that is mainly a kernel bug in handling the PCI DEVSEL
+ * register.  FIXME: stop spinning on registers .. must implement a timeout
+ * mechanism
+ * returns the size of the memory region found.
+ */
+static u32 fixup_pmc551 (struct pci_dev *dev)
+{
+#ifdef CONFIG_MTD_PMC551_BUGFIX
+        u32 dram_data;
+#endif
+        u32 size, dcmd, cfg, dtmp;
+        u16 cmd, tmp, i;
+	u8 bcmd, counter;
+
+        /* Sanity Check */
+        if(!dev) {
+                return -ENODEV;
+        }
+
+	/*
+	 * Attempt to reset the card
+	 * FIXME: Stop Spinning registers
+	 */
+	counter=0;
+	/* unlock registers */
+	pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, 0xA5 );
+	/* read in old data */
+	pci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd );
+	/* bang the reset line up and down for a few */
+	for(i=0;i<10;i++) {
+		counter=0;
+		bcmd &= ~0x80;
+		while(counter++ < 100) {
+			pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);
+		}
+		counter=0;
+		bcmd |= 0x80;
+		while(counter++ < 100) {
+			pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);
+		}
+	}
+	bcmd |= (0x40|0x20);
+	pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);
+
+        /* 
+	 * Take care and turn off the memory on the device while we
+	 * tweak the configurations
+	 */
+        pci_read_config_word(dev, PCI_COMMAND, &cmd);
+        tmp = cmd & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY);
+        pci_write_config_word(dev, PCI_COMMAND, tmp);
+
+	/*
+	 * Disable existing aperture before probing memory size
+	 */
+	pci_read_config_dword(dev, PMC551_PCI_MEM_MAP0, &dcmd);
+        dtmp=(dcmd|PMC551_PCI_MEM_MAP_ENABLE|PMC551_PCI_MEM_MAP_REG_EN);
+	pci_write_config_dword(dev, PMC551_PCI_MEM_MAP0, dtmp);
+	/*
+	 * Grab old BAR0 config so that we can figure out memory size
+	 * This is another bit of kludge going on.  The reason for the
+	 * redundancy is I am hoping to retain the original configuration
+	 * previously assigned to the card by the BIOS or some previous 
+	 * fixup routine in the kernel.  So we read the old config into cfg,
+	 * then write all 1's to the memory space, read back the result into
+	 * "size", and then write back all the old config.
+	 */
+	pci_read_config_dword( dev, PCI_BASE_ADDRESS_0, &cfg );
+#ifndef CONFIG_MTD_PMC551_BUGFIX
+	pci_write_config_dword( dev, PCI_BASE_ADDRESS_0, ~0 );
+	pci_read_config_dword( dev, PCI_BASE_ADDRESS_0, &size );
+	size = (size&PCI_BASE_ADDRESS_MEM_MASK);
+	size &= ~(size-1);
+	pci_write_config_dword( dev, PCI_BASE_ADDRESS_0, cfg );
+#else
+        /*
+         * Get the size of the memory by reading all the DRAM size values
+         * and adding them up.
+         *
+         * KLUDGE ALERT: the boards we are using have invalid column and
+         * row mux values.  We fix them here, but this will break other
+         * memory configurations.
+         */
+        pci_read_config_dword(dev, PMC551_DRAM_BLK0, &dram_data);
+        size = PMC551_DRAM_BLK_GET_SIZE(dram_data);
+        dram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);
+        dram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);
+        pci_write_config_dword(dev, PMC551_DRAM_BLK0, dram_data);
+
+        pci_read_config_dword(dev, PMC551_DRAM_BLK1, &dram_data);
+        size += PMC551_DRAM_BLK_GET_SIZE(dram_data);
+        dram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);
+        dram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);
+        pci_write_config_dword(dev, PMC551_DRAM_BLK1, dram_data);
+
+        pci_read_config_dword(dev, PMC551_DRAM_BLK2, &dram_data);
+        size += PMC551_DRAM_BLK_GET_SIZE(dram_data);
+        dram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);
+        dram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);
+        pci_write_config_dword(dev, PMC551_DRAM_BLK2, dram_data);
+
+        pci_read_config_dword(dev, PMC551_DRAM_BLK3, &dram_data);
+        size += PMC551_DRAM_BLK_GET_SIZE(dram_data);
+        dram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);
+        dram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);
+        pci_write_config_dword(dev, PMC551_DRAM_BLK3, dram_data);
+
+        /*
+         * Oops .. something went wrong
+         */
+        if( (size &= PCI_BASE_ADDRESS_MEM_MASK) == 0) {
+                return -ENODEV;
+        }
+#endif /* CONFIG_MTD_PMC551_BUGFIX */
+
+	if ((cfg&PCI_BASE_ADDRESS_SPACE) != PCI_BASE_ADDRESS_SPACE_MEMORY) {
+                return -ENODEV;
+	}
+
+        /*
+         * Precharge Dram
+         */
+        pci_write_config_word( dev, PMC551_SDRAM_MA, 0x0400 );
+        pci_write_config_word( dev, PMC551_SDRAM_CMD, 0x00bf );
+
+        /*
+         * Wait until command has gone through
+         * FIXME: register spinning issue
+         */
+        do {	pci_read_config_word( dev, PMC551_SDRAM_CMD, &cmd );
+		if(counter++ > 100)break;
+        } while ( (PCI_COMMAND_IO) & cmd );
+
+        /*
+	 * Turn on auto refresh 
+	 * The loop is taken directly from Ramix's example code.  I assume that
+	 * this must be held high for some duration of time, but I can find no
+	 * documentation refrencing the reasons why.
+         */
+        for ( i = 1; i<=8 ; i++) {
+                pci_write_config_word (dev, PMC551_SDRAM_CMD, 0x0df);
+
+                /*
+                 * Make certain command has gone through
+                 * FIXME: register spinning issue
+                 */
+		counter=0;
+                do {	pci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);
+			if(counter++ > 100)break;
+                } while ( (PCI_COMMAND_IO) & cmd );
+        }
+
+        pci_write_config_word ( dev, PMC551_SDRAM_MA, 0x0020);
+        pci_write_config_word ( dev, PMC551_SDRAM_CMD, 0x0ff);
+
+        /*
+         * Wait until command completes
+         * FIXME: register spinning issue
+         */
+	counter=0;
+        do {	pci_read_config_word ( dev, PMC551_SDRAM_CMD, &cmd);
+		if(counter++ > 100)break;
+        } while ( (PCI_COMMAND_IO) & cmd );
+
+        pci_read_config_dword ( dev, PMC551_DRAM_CFG, &dcmd);
+        dcmd |= 0x02000000;
+        pci_write_config_dword ( dev, PMC551_DRAM_CFG, dcmd);
+
+        /*
+         * Check to make certain fast back-to-back, if not
+         * then set it so
+         */
+        pci_read_config_word( dev, PCI_STATUS, &cmd);
+        if((cmd&PCI_COMMAND_FAST_BACK) == 0) {
+                cmd |= PCI_COMMAND_FAST_BACK;
+                pci_write_config_word( dev, PCI_STATUS, cmd);
+        }
+
+        /*
+         * Check to make certain the DEVSEL is set correctly, this device
+         * has a tendancy to assert DEVSEL and TRDY when a write is performed
+         * to the memory when memory is read-only
+         */
+        if((cmd&PCI_STATUS_DEVSEL_MASK) != 0x0) {
+                cmd &= ~PCI_STATUS_DEVSEL_MASK;
+                pci_write_config_word( dev, PCI_STATUS, cmd );
+        }
+        /*
+         * Set to be prefetchable and put everything back based on old cfg.
+	 * it's possible that the reset of the V370PDC nuked the original
+	 * setup
+         */
+	/*
+        cfg |= PCI_BASE_ADDRESS_MEM_PREFETCH;
+	pci_write_config_dword( dev, PCI_BASE_ADDRESS_0, cfg );
+	*/
+
+        /*
+         * Turn PCI memory and I/O bus access back on
+         */
+        pci_write_config_word( dev, PCI_COMMAND,
+                               PCI_COMMAND_MEMORY | PCI_COMMAND_IO );
+#ifdef CONFIG_MTD_PMC551_DEBUG
+        /*
+         * Some screen fun
+         */
+        printk(KERN_DEBUG "pmc551: %d%c (0x%x) of %sprefetchable memory at 0x%lx\n",
+	       (size<1024)?size:(size<1048576)?size>>10:size>>20,
+               (size<1024)?'B':(size<1048576)?'K':'M',
+	       size, ((dcmd&(0x1<<3)) == 0)?"non-":"",
+               PCI_BASE_ADDRESS(dev)&PCI_BASE_ADDRESS_MEM_MASK );
+
+        /*
+         * Check to see the state of the memory
+         */
+        pci_read_config_dword( dev, PMC551_DRAM_BLK0, &dcmd );
+        printk(KERN_DEBUG "pmc551: DRAM_BLK0 Flags: %s,%s\n"
+			  "pmc551: DRAM_BLK0 Size: %d at %d\n"
+			  "pmc551: DRAM_BLK0 Row MUX: %d, Col MUX: %d\n",
+               (((0x1<<1)&dcmd) == 0)?"RW":"RO",
+               (((0x1<<0)&dcmd) == 0)?"Off":"On",
+	       PMC551_DRAM_BLK_GET_SIZE(dcmd),
+	       ((dcmd>>20)&0x7FF), ((dcmd>>13)&0x7), ((dcmd>>9)&0xF) );
+
+        pci_read_config_dword( dev, PMC551_DRAM_BLK1, &dcmd );
+        printk(KERN_DEBUG "pmc551: DRAM_BLK1 Flags: %s,%s\n"
+			  "pmc551: DRAM_BLK1 Size: %d at %d\n"
+			  "pmc551: DRAM_BLK1 Row MUX: %d, Col MUX: %d\n",
+               (((0x1<<1)&dcmd) == 0)?"RW":"RO",
+               (((0x1<<0)&dcmd) == 0)?"Off":"On",
+	       PMC551_DRAM_BLK_GET_SIZE(dcmd),
+	       ((dcmd>>20)&0x7FF), ((dcmd>>13)&0x7), ((dcmd>>9)&0xF) );
+
+        pci_read_config_dword( dev, PMC551_DRAM_BLK2, &dcmd );
+        printk(KERN_DEBUG "pmc551: DRAM_BLK2 Flags: %s,%s\n"
+			  "pmc551: DRAM_BLK2 Size: %d at %d\n"
+			  "pmc551: DRAM_BLK2 Row MUX: %d, Col MUX: %d\n",
+               (((0x1<<1)&dcmd) == 0)?"RW":"RO",
+               (((0x1<<0)&dcmd) == 0)?"Off":"On",
+	       PMC551_DRAM_BLK_GET_SIZE(dcmd),
+	       ((dcmd>>20)&0x7FF), ((dcmd>>13)&0x7), ((dcmd>>9)&0xF) );
+
+        pci_read_config_dword( dev, PMC551_DRAM_BLK3, &dcmd );
+        printk(KERN_DEBUG "pmc551: DRAM_BLK3 Flags: %s,%s\n"
+			  "pmc551: DRAM_BLK3 Size: %d at %d\n"
+			  "pmc551: DRAM_BLK3 Row MUX: %d, Col MUX: %d\n",
+               (((0x1<<1)&dcmd) == 0)?"RW":"RO",
+               (((0x1<<0)&dcmd) == 0)?"Off":"On",
+	       PMC551_DRAM_BLK_GET_SIZE(dcmd),
+	       ((dcmd>>20)&0x7FF), ((dcmd>>13)&0x7), ((dcmd>>9)&0xF) );
+
+        pci_read_config_word( dev, PCI_COMMAND, &cmd );
+        printk( KERN_DEBUG "pmc551: Memory Access %s\n",
+                (((0x1<<1)&cmd) == 0)?"off":"on" );
+        printk( KERN_DEBUG "pmc551: I/O Access %s\n",
+                (((0x1<<0)&cmd) == 0)?"off":"on" );
+
+        pci_read_config_word( dev, PCI_STATUS, &cmd );
+        printk( KERN_DEBUG "pmc551: Devsel %s\n",
+                ((PCI_STATUS_DEVSEL_MASK&cmd)==0x000)?"Fast":
+                ((PCI_STATUS_DEVSEL_MASK&cmd)==0x200)?"Medium":
+                ((PCI_STATUS_DEVSEL_MASK&cmd)==0x400)?"Slow":"Invalid" );
+
+        printk( KERN_DEBUG "pmc551: %sFast Back-to-Back\n",
+                ((PCI_COMMAND_FAST_BACK&cmd) == 0)?"Not ":"" );
+
+	pci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd );
+	printk( KERN_DEBUG "pmc551: EEPROM is under %s control\n"
+			   "pmc551: System Control Register is %slocked to PCI access\n"
+			   "pmc551: System Control Register is %slocked to EEPROM access\n", 
+		(bcmd&0x1)?"software":"hardware",
+		(bcmd&0x20)?"":"un", (bcmd&0x40)?"":"un");
+#endif
+        return size;
+}
+
+/*
+ * Kernel version specific module stuffages
+ */
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark Ferrell <mferrell@mvista.com>");
+MODULE_DESCRIPTION(PMC551_VERSION);
+MODULE_PARM(msize, "i");
+MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
+MODULE_PARM(asize, "i");
+MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
+
+/*
+ * Stuff these outside the ifdef so as to not bust compiled in driver support
+ */
+static int msize=0;
+#if defined(CONFIG_MTD_PMC551_APERTURE_SIZE)
+static int asize=CONFIG_MTD_PMC551_APERTURE_SIZE
+#else
+static int asize=0;
+#endif
+
+/*
+ * PMC551 Card Initialization
+ */
+int __init init_pmc551(void)
+{
+        struct pci_dev *PCI_Device = NULL;
+        struct mypriv *priv;
+        int count, found=0;
+        struct mtd_info *mtd;
+        u32 length = 0;
+
+	if(msize) {
+		msize = (1 << (ffs(msize) - 1))<<20;
+		if (msize > (1<<30)) {
+			printk(KERN_NOTICE "pmc551: Invalid memory size [%d]\n", msize);
+			return -EINVAL;
+		}
+	}
+
+	if(asize) {
+		asize = (1 << (ffs(asize) - 1))<<20;
+		if (asize > (1<<30) ) {
+			printk(KERN_NOTICE "pmc551: Invalid aperture size [%d]\n", asize);
+			return -EINVAL;
+		}
+	}
+
+        printk(KERN_INFO PMC551_VERSION);
+
+        if(!pci_present()) {
+                printk(KERN_NOTICE "pmc551: PCI not enabled.\n");
+                return -ENODEV;
+        }
+
+        /*
+         * PCU-bus chipset probe.
+         */
+        for( count = 0; count < MAX_MTD_DEVICES; count++ ) {
+
+                if ((PCI_Device = pci_find_device(PCI_VENDOR_ID_V3_SEMI,
+                                                  PCI_DEVICE_ID_V3_SEMI_V370PDC,
+						  PCI_Device ) ) == NULL) {
+                        break;
+                }
+
+                printk(KERN_NOTICE "pmc551: Found PCI V370PDC at 0x%lX\n",
+				    PCI_BASE_ADDRESS(PCI_Device));
+
+                /*
+                 * The PMC551 device acts VERY weird if you don't init it
+                 * first.  i.e. it will not correctly report devsel.  If for
+                 * some reason the sdram is in a wrote-protected state the
+                 * device will DEVSEL when it is written to causing problems
+                 * with the oldproc.c driver in
+                 * some kernels (2.2.*)
+                 */
+                if((length = fixup_pmc551(PCI_Device)) <= 0) {
+                        printk(KERN_NOTICE "pmc551: Cannot init SDRAM\n");
+                        break;
+                }
+
+		/*
+		 * This is needed untill the driver is capable of reading the
+		 * onboard I2C SROM to discover the "real" memory size.
+		 */
+		if(msize) {
+			length = msize;
+			printk(KERN_NOTICE "pmc551: Using specified memory size 0x%x\n", length);
+		} else {
+			msize = length;
+		}
+
+                mtd = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+                if (!mtd) {
+                        printk(KERN_NOTICE "pmc551: Cannot allocate new MTD device.\n");
+                        break;
+                }
+
+                memset(mtd, 0, sizeof(struct mtd_info));
+
+                priv = kmalloc (sizeof(struct mypriv), GFP_KERNEL);
+                if (!priv) {
+                        printk(KERN_NOTICE "pmc551: Cannot allocate new MTD device.\n");
+                        kfree(mtd);
+                        break;
+                }
+                memset(priv, 0, sizeof(*priv));
+                mtd->priv = priv;
+                priv->dev = PCI_Device;
+
+		if(asize > length) {
+			printk(KERN_NOTICE "pmc551: reducing aperture size to fit %dM\n",length>>20);
+			priv->asize = asize = length;
+		} else if (asize == 0 || asize == length) {
+			printk(KERN_NOTICE "pmc551: Using existing aperture size %dM\n", length>>20);
+			priv->asize = asize = length;
+		} else {
+			printk(KERN_NOTICE "pmc551: Using specified aperture size %dM\n", asize>>20);
+			priv->asize = asize;
+		}
+                priv->start = ioremap((PCI_BASE_ADDRESS(PCI_Device)
+                                       & PCI_BASE_ADDRESS_MEM_MASK),
+                                      priv->asize);
+		
+		if (!priv->start) {
+			printk(KERN_NOTICE "pmc551: Unable to map IO space\n");
+                        kfree(mtd->priv);
+                        kfree(mtd);
+			break;
+		}
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+		printk( KERN_DEBUG "pmc551: setting aperture to %d\n",
+			ffs(priv->asize>>20)-1);
+#endif
+
+                priv->base_map0 = ( PMC551_PCI_MEM_MAP_REG_EN
+				  | PMC551_PCI_MEM_MAP_ENABLE
+				  | (ffs(priv->asize>>20)-1)<<4 );
+                priv->curr_map0 = priv->base_map0;
+                pci_write_config_dword ( priv->dev, PMC551_PCI_MEM_MAP0,
+                                         priv->curr_map0 );
+
+#ifdef CONFIG_MTD_PMC551_DEBUG
+		printk( KERN_DEBUG "pmc551: aperture set to %d\n", 
+			(priv->base_map0 & 0xF0)>>4 );
+#endif
+
+                mtd->size 	= msize;
+                mtd->flags 	= MTD_CAP_RAM;
+                mtd->erase 	= pmc551_erase;
+                mtd->read 	= pmc551_read;
+                mtd->write 	= pmc551_write;
+                mtd->point 	= pmc551_point;
+                mtd->unpoint 	= pmc551_unpoint;
+                mtd->module 	= THIS_MODULE;
+                mtd->type 	= MTD_RAM;
+                mtd->name 	= "PMC551 RAM board";
+                mtd->erasesize 	= 0x10000;
+
+                if (add_mtd_device(mtd)) {
+                        printk(KERN_NOTICE "pmc551: Failed to register new device\n");
+			iounmap(priv->start);
+                        kfree(mtd->priv);
+                        kfree(mtd);
+                        break;
+                }
+                printk(KERN_NOTICE "Registered pmc551 memory device.\n");
+                printk(KERN_NOTICE "Mapped %dM of memory from 0x%p to 0x%p\n",
+                       priv->asize>>20,
+                       priv->start,
+                       priv->start + priv->asize);
+                printk(KERN_NOTICE "Total memory is %d%c\n",
+	       		(length<1024)?length:
+				(length<1048576)?length>>10:length>>20,
+               		(length<1024)?'B':(length<1048576)?'K':'M');
+		priv->nextpmc551 = pmc551list;
+		pmc551list = mtd;
+		found++;
+        }
+
+        if( !pmc551list ) {
+                printk(KERN_NOTICE "pmc551: not detected\n");
+                return -ENODEV;
+        } else {
+		printk(KERN_NOTICE "pmc551: %d pmc551 devices loaded\n", found);
+                return 0;
+	}
+}
+
+/*
+ * PMC551 Card Cleanup
+ */
+static void __exit cleanup_pmc551(void)
+{
+        int found=0;
+        struct mtd_info *mtd;
+	struct mypriv *priv;
+
+	while((mtd=pmc551list)) {
+		priv = (struct mypriv *)mtd->priv;
+		pmc551list = priv->nextpmc551;
+		
+		if(priv->start) {
+			printk (KERN_DEBUG "pmc551: unmapping %dM starting at 0x%p\n",
+				priv->asize>>20, priv->start);
+			iounmap (priv->start);
+		}
+		
+		kfree (mtd->priv);
+		del_mtd_device (mtd);
+		kfree (mtd);
+		found++;
+	}
+
+	printk(KERN_NOTICE "pmc551: %d pmc551 devices unloaded\n", found);
+}
+
+module_init(init_pmc551);
+module_exit(cleanup_pmc551);
diff -Naur linux-2.4.2.orig/drivers/mtd/devices/slram.c linux-2.4.2/drivers/mtd/devices/slram.c
--- linux-2.4.2.orig/drivers/mtd/devices/slram.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/devices/slram.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,338 @@
+/*======================================================================
+
+  $Id: slram.c,v 1.25 2001/10/02 15:05:13 dwmw2 Exp $
+
+======================================================================*/
+
+
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <stdarg.h>
+
+#include <linux/mtd/mtd.h>
+
+#define SLRAM_MAX_DEVICES_PARAMS 6		/* 3 parameters / device */
+
+#define T(fmt, args...) printk(KERN_DEBUG fmt, ## args)
+#define E(fmt, args...) printk(KERN_NOTICE fmt, ## args)
+
+typedef struct slram_priv {
+	u_char *start;
+	u_char *end;
+} slram_priv_t;
+
+typedef struct slram_mtd_list {
+	struct mtd_info *mtdinfo;
+	struct slram_mtd_list *next;
+} slram_mtd_list_t;
+
+#ifdef MODULE
+static char *map[SLRAM_MAX_DEVICES_PARAMS];
+#else
+static char *map;
+#endif
+
+MODULE_PARM(map, "3-" __MODULE_STRING(SLRAM_MAX_DEVICES_PARAMS) "s");
+MODULE_PARM_DESC(map, "List of memory regions to map. \"map=<name>, <start>, <length / end>\"");
+
+static slram_mtd_list_t *slram_mtdlist = NULL;
+
+int slram_erase(struct mtd_info *, struct erase_info *);
+int slram_point(struct mtd_info *, loff_t, size_t, size_t *, u_char **);
+void slram_unpoint(struct mtd_info *, u_char *);
+int slram_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+int slram_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+
+int slram_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	slram_priv_t *priv = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return(-EINVAL);
+	}
+	
+	memset(priv->start + instr->addr, 0xff, instr->len);
+
+	/* This'll catch a few races. Free the thing before returning :) 
+	 * I don't feel at all ashamed. This kind of thing is possible anyway
+	 * with flash, but unlikely.
+	 */
+
+	instr->state = MTD_ERASE_DONE;
+
+	if (instr->callback) {
+		(*(instr->callback))(instr);
+	}
+	else {
+		kfree(instr);
+	}
+
+	return(0);
+}
+
+int slram_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+
+	*mtdbuf = priv->start + from;
+	*retlen = len;
+	return(0);
+}
+
+void slram_unpoint(struct mtd_info *mtd, u_char *addr)
+{
+}
+
+int slram_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	
+	memcpy(buf, priv->start + from, len);
+
+	*retlen = len;
+	return(0);
+}
+
+int slram_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+
+	memcpy(priv->start + to, buf, len);
+
+	*retlen = len;
+	return(0);
+}
+
+/*====================================================================*/
+
+int register_device(char *name, unsigned long start, unsigned long length)
+{
+	slram_mtd_list_t **curmtd;
+
+	curmtd = &slram_mtdlist;
+	while (*curmtd) {
+		curmtd = &(*curmtd)->next;
+	}
+
+	*curmtd = kmalloc(sizeof(slram_mtd_list_t), GFP_KERNEL);
+	if (!(*curmtd)) {
+		E("slram: Cannot allocate new MTD device.\n");
+		return(-ENOMEM);
+	}
+	(*curmtd)->mtdinfo = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	(*curmtd)->next = NULL;
+	
+	if ((*curmtd)->mtdinfo)	{
+		memset((char *)(*curmtd)->mtdinfo, 0, sizeof(struct mtd_info));
+		(*curmtd)->mtdinfo->priv =
+			(void *)kmalloc(sizeof(slram_priv_t), GFP_KERNEL);
+		
+		if (!(*curmtd)->mtdinfo->priv) {
+			kfree((*curmtd)->mtdinfo);
+			(*curmtd)->mtdinfo = NULL;
+		} else {
+			memset((*curmtd)->mtdinfo->priv,0,sizeof(slram_priv_t));
+		}
+	}
+
+	if (!(*curmtd)->mtdinfo) {
+		E("slram: Cannot allocate new MTD device.\n");
+		return(-ENOMEM);
+	}
+	
+	if (!(((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start =
+				ioremap(start, length))) {
+		E("slram: ioremap failed\n");
+		return -EIO;
+	}
+	((slram_priv_t *)(*curmtd)->mtdinfo->priv)->end =
+		((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start + length;
+
+
+	(*curmtd)->mtdinfo->name = name;
+	(*curmtd)->mtdinfo->size = length;
+	(*curmtd)->mtdinfo->flags = MTD_CLEAR_BITS | MTD_SET_BITS |
+					MTD_WRITEB_WRITEABLE | MTD_VOLATILE;
+        (*curmtd)->mtdinfo->erase = slram_erase;
+	(*curmtd)->mtdinfo->point = slram_point;
+	(*curmtd)->mtdinfo->unpoint = slram_unpoint;
+	(*curmtd)->mtdinfo->read = slram_read;
+	(*curmtd)->mtdinfo->write = slram_write;
+	(*curmtd)->mtdinfo->module = THIS_MODULE;
+	(*curmtd)->mtdinfo->type = MTD_RAM;
+	(*curmtd)->mtdinfo->erasesize = 0x10000;
+
+	if (add_mtd_device((*curmtd)->mtdinfo))	{
+		E("slram: Failed to register new device\n");
+		iounmap(((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start);
+		kfree((*curmtd)->mtdinfo->priv);
+		kfree((*curmtd)->mtdinfo);
+		return(-EAGAIN);
+	}
+	T("slram: Registered device %s from %luKiB to %luKiB\n", name,
+			(start / 1024), ((start + length) / 1024));
+	T("slram: Mapped from 0x%p to 0x%p\n",
+			((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start,
+			((slram_priv_t *)(*curmtd)->mtdinfo->priv)->end);
+	return(0);	
+}
+
+void unregister_devices(void)
+{
+	slram_mtd_list_t *nextitem;
+
+	while (slram_mtdlist) {
+		nextitem = slram_mtdlist->next;
+		del_mtd_device(slram_mtdlist->mtdinfo);
+		iounmap(((slram_priv_t *)slram_mtdlist->mtdinfo->priv)->start);
+		kfree(slram_mtdlist->mtdinfo->priv);
+		kfree(slram_mtdlist->mtdinfo);
+		kfree(slram_mtdlist);
+		slram_mtdlist = nextitem;
+	}
+}
+
+unsigned long handle_unit(unsigned long value, char *unit)
+{
+	if ((*unit == 'M') || (*unit == 'm')) {
+		return(value * 1024 * 1024);
+	} else if ((*unit == 'K') || (*unit == 'k')) {
+		return(value * 1024);
+	}
+	return(value);
+}
+
+int parse_cmdline(char *devname, char *szstart, char *szlength)
+{
+	char *buffer;
+	unsigned long devstart;
+	unsigned long devlength;
+	
+	if ((!devname) || (!szstart) || (!szlength)) {
+		unregister_devices();
+		return(-EINVAL);
+	}
+
+	devstart = simple_strtoul(szstart, &buffer, 0);
+	devstart = handle_unit(devstart, buffer);
+	
+	if (*(szlength) != '+') {
+		devlength = simple_strtoul(szlength, &buffer, 0);
+		devlength = handle_unit(devlength, buffer) - devstart;
+	} else {
+		devlength = simple_strtoul(szlength + 1, &buffer, 0);
+		devlength = handle_unit(devlength, buffer);
+	}
+	T("slram: devname=%s, devstart=0x%lx, devlength=0x%lx\n",
+			devname, devstart, devlength);
+	if ((devstart < 0) || (devlength < 0)) {
+		E("slram: Illegal start / length parameter.\n");
+		return(-EINVAL);
+	}
+	
+	if ((devstart = register_device(devname, devstart, devlength))){
+		unregister_devices();
+		return((int)devstart);
+	}
+	return(0);
+}
+
+#ifndef MODULE
+
+static int __init mtd_slram_setup(char *str)
+{
+	map = str;
+	return(1);
+}
+
+__setup("slram=", mtd_slram_setup);
+
+#endif
+
+int init_slram(void)
+{
+	char *devname;
+	int i;
+
+#ifndef MODULE
+	char *devstart;
+	char *devlength;
+
+	i = 0;
+
+	if (!map) {
+		E("slram: not enough parameters.\n");
+		return(-EINVAL);
+	}
+	while (map) {
+		devname = devstart = devlength = NULL;
+
+		if (!(devname = strsep(&map, ","))) {
+			E("slram: No devicename specified.\n");
+			break;
+		}
+		T("slram: devname = %s\n", devname);
+		if ((!map) || (!(devstart = strsep(&map, ",")))) {
+			E("slram: No devicestart specified.\n");
+		}
+		T("slram: devstart = %s\n", devstart);
+		if ((!map) || (!(devlength = strsep(&map, ",")))) {
+			E("slram: No devicelength / -end specified.\n");
+		}
+		T("slram: devlength = %s\n", devlength);
+		if (parse_cmdline(devname, devstart, devlength) != 0) {
+			return(-EINVAL);
+		}
+	}
+#else
+	int count;
+	
+	for (count = 0; (map[count]) && (count < SLRAM_MAX_DEVICES_PARAMS);
+			count++) {
+	}
+
+	if ((count % 3 != 0) || (count == 0)) {
+		E("slram: not enough parameters.\n");
+		return(-EINVAL);
+	}
+	for (i = 0; i < (count / 3); i++) {
+		devname = map[i * 3];
+
+		if (parse_cmdline(devname, map[i * 3 + 1], map[i * 3 + 2])!=0) {
+			return(-EINVAL);
+		}
+		
+	}
+#endif /* !MODULE */
+	
+	return(0);
+}
+
+static void __exit cleanup_slram(void)
+{
+	unregister_devices();
+}
+
+module_init(init_slram);
+module_exit(cleanup_slram);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jochen Schaeuble <psionic@psionic.de>");
+MODULE_DESCRIPTION("MTD driver for uncached system RAM");
diff -Naur linux-2.4.2.orig/drivers/mtd/doc1000.c linux-2.4.2/drivers/mtd/doc1000.c
--- linux-2.4.2.orig/drivers/mtd/doc1000.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc1000.c	Fri Feb 15 14:41:15 2002
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: doc1000.c,v 1.11 2000/11/24 13:43:16 dwmw2 Exp $
+  $Id: doc1000.c,v 1.12 2000/11/27 08:50:21 dwmw2 Exp $
 
 ======================================================================*/
 
@@ -12,7 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -286,9 +286,9 @@
 static inline int byte_write (volatile u_char *addr, u_char byte)
 {
 	register u_char status;
- 	register u_short i = 0;
-  	
- 	do {
+	register u_short i = 0;
+	
+	do {
 		status = readb(addr);
 		if (status & CSR_WR_READY)
 		{
@@ -510,7 +510,7 @@
 
 }
 
-#if defined (MODULE) && LINUX_VERSION_CODE < 0x20211
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_doc1000 init_module
 #define cleanup_doc1000 cleanup_module
 #endif
@@ -591,7 +591,5 @@
 	kfree(mymtd);
 }
 
-#if LINUX_VERSION_CODE >= 0x20211
 module_init(init_doc1000);
 module_exit(cleanup_doc1000);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/doc2000.c linux-2.4.2/drivers/mtd/doc2000.c
--- linux-2.4.2.orig/drivers/mtd/doc2000.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc2000.c	Fri Feb 15 14:41:15 2002
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.39 2000/12/01 17:34:29 dwmw2 Exp $
+ * $Id: doc2000.c,v 1.41 2001/03/17 17:10:21 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -15,7 +15,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
@@ -719,6 +719,13 @@
 		WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
 	}
 
+	/* according to 11.4.1, we need to wait for the busy line 
+         * drop if we read to the end of the page.  */
+	if(0 == ((from + *retlen) & 0x1ff))
+	{
+	    DoC_WaitReady(this);
+	}
+
 	return ret;
 }
 
@@ -931,7 +938,10 @@
 	DoC_ReadBuf(this, &buf[len256], len - len256);
 
 	*retlen = len;
-	return 0;
+	/* Reading the full OOB data drops us off of the end of the page,
+         * causing the flash device to go into busy mode, so we need
+         * to wait until ready 11.4.1 and Toshiba TC58256FT docs */
+	return DoC_WaitReady(this);
 
 }
 
@@ -1028,13 +1038,13 @@
 int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
-	unsigned long ofs = instr->addr;
-	unsigned long len = instr->len;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
 	unsigned long docptr;
 	struct Nand *mychip;
 
 	if (len != mtd->erasesize)
-		printk(KERN_WARNING "Erase not right size (%lx != %lx)n",
+		printk(KERN_WARNING "Erase not right size (%x != %x)n",
 		       len, mtd->erasesize);
 
 	docptr = this->virtadr;
diff -Naur linux-2.4.2.orig/drivers/mtd/doc2001.c linux-2.4.2/drivers/mtd/doc2001.c
--- linux-2.4.2.orig/drivers/mtd/doc2001.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc2001.c	Fri Feb 15 14:41:15 2002
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001.c,v 1.24 2000/12/01 13:11:02 dwmw2 Exp $
+ * $Id: doc2001.c,v 1.25 2001/03/17 17:10:21 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -15,7 +15,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
@@ -789,13 +789,13 @@
 {
 	volatile char dummy;
 	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long ofs = instr->addr;
-	unsigned long len = instr->len;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
 	unsigned long docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	if (len != mtd->erasesize) 
-		printk(KERN_WARNING "Erase not right size (%lx != %lx)n",
+		printk(KERN_WARNING "Erase not right size (%x != %x)n",
 		       len, mtd->erasesize);
 
 	/* Find the chip which is to be used and select it */
@@ -829,7 +829,7 @@
 	dummy = ReadDOC(docptr, CDSNSlowIO);
 	DoC_Delay(docptr, 2);
 	if (ReadDOC(docptr, Mil_CDSN_IO) & 1) {
-		printk("Error Erasing at 0x%lx\n", ofs);
+		printk("Error Erasing at 0x%x\n", ofs);
 		/* There was an error
 		   FIXME: implement Bad Block Replacement (in nftl.c ??) */
 		instr->state = MTD_ERASE_FAILED;
diff -Naur linux-2.4.2.orig/drivers/mtd/docecc.c linux-2.4.2/drivers/mtd/docecc.c
--- linux-2.4.2.orig/drivers/mtd/docecc.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/docecc.c	Fri Feb 15 14:41:15 2002
@@ -31,7 +31,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/docprobe.c linux-2.4.2/drivers/mtd/docprobe.c
--- linux-2.4.2.orig/drivers/mtd/docprobe.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/docprobe.c	Fri Feb 15 14:41:15 2002
@@ -41,7 +41,6 @@
 */
 #define DOC_SINGLE_DRIVER
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -50,7 +49,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/elan-104nc.c linux-2.4.2/drivers/mtd/elan-104nc.c
--- linux-2.4.2.orig/drivers/mtd/elan-104nc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/elan-104nc.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,277 @@
+/* elan-104nc.c -- MTD map driver for Arcom Control Systems ELAN-104NC
+ 
+   Copyright (C) 2000 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: elan-104nc.c,v 1.8 2001/03/17 16:25:24 dwmw2 Exp $
+
+The ELAN-104NC has up to 8 Mibyte of Intel StrataFlash (28F320/28F640) in x16
+mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   32 kbyte memory window at 0xb0000-0xb7fff
+   
+   16 bit I/O port (0x22) for some sort of paging.
+
+The single flash device is divided into 3 partition which appear as seperate
+MTD devices.
+
+Linux thinks that the I/O port is used by the PIC and hence check_region() will
+always fail.  So we don't do it.  I just hope it doesn't break anything.
+*/
+#include <linux/module.h>
+#include <linux/malloc.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_START 0xb0000
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 15
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x22
+#define PAGE_IO_SIZE 2
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t elan_104nc_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "ELAN-104NC flash boot partition", 
+      offset: 0, 
+      size: 640*1024 },
+    { name: "ELAN-104NC flash partition 1", 
+      offset: 640*1024, 
+      size: 896*1024 },
+    { name: "ELAN-104NC flash partition 2", 
+      offset: (640+896)*1024 }
+};
+#define NUM_PARTITIONS (sizeof(partition_info)/sizeof(partition_info[0]))
+
+/*
+ * If no idea what is going on here.  This is taken from the FlashFX stuff.
+ */
+#define ROMCS 1
+
+static inline void elan_104nc_setup(void)
+{
+    u16 t;
+
+    outw( 0x0023 + ROMCS*2, PAGE_IO );
+    t=inb( PAGE_IO+1 );
+
+    t=(t & 0xf9) | 0x04;
+
+    outw( ((0x0023 + ROMCS*2) | (t << 8)), PAGE_IO );
+}
+
+static inline void elan_104nc_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+       
+	if( page!=page_in_window ) {
+		int cmd1;
+		int cmd2;
+
+		cmd1=(page & 0x700) + 0x0833 + ROMCS*0x4000;
+		cmd2=((page & 0xff) << 8) + 0x0032;
+
+		outw( cmd1, PAGE_IO );
+		outw( cmd2, PAGE_IO );
+
+		page_in_window = page;
+	}
+}
+
+
+static __u8 elan_104nc_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u16 elan_104nc_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u32 elan_104nc_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static void elan_104nc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&elan_104nc_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void elan_104nc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&elan_104nc_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info elan_104nc_map = {
+	name: "ELAN-104NC flash",
+	size: 8*1024*1024, /* this must be set to a maximum possible amount
+			of flash so the cfi probe routines find all
+			the chips */
+	buswidth: 2,
+	read8: elan_104nc_read8,
+	read16: elan_104nc_read16,
+	read32: elan_104nc_read32,
+	copy_from: elan_104nc_copy_from,
+	write8: elan_104nc_write8,
+	write16: elan_104nc_write16,
+	write32: elan_104nc_write32,
+	copy_to: elan_104nc_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_elan_104nc init_module
+#define cleanup_elan_104nc cleanup_module
+#endif
+
+mod_exit_t cleanup_elan_104nc(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+mod_init_t init_elan_104nc(void)
+{
+	/* Urg! We use I/O port 0x22 without request_region()ing it */
+	/*
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			elan_104nc_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+	*/
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			elan_104nc_map.name );
+		return -EIO;
+	}
+
+	/*
+	request_region( PAGE_IO, PAGE_IO_SIZE, "ELAN-104NC flash" );
+	*/
+
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		elan_104nc_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	elan_104nc_setup();
+
+	/* Probe for chip. */
+	all_mtd = do_cfi_probe( &elan_104nc_map );
+	if( !all_mtd ) {
+		cleanup_elan_104nc();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions( all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_elan_104nc);
+module_exit(cleanup_elan_104nc);
diff -Naur linux-2.4.2.orig/drivers/mtd/ftl.c linux-2.4.2/drivers/mtd/ftl.c
--- linux-2.4.2.orig/drivers/mtd/ftl.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/ftl.c	Fri Feb 15 14:41:15 2002
@@ -1,10 +1,10 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
+ * $Id: ftl.c,v 1.42 2001/11/20 11:42:33 dwmw2 Exp $
  *
- * - Based on Id: ftl.c,v 1.21 2000/08/01 13:07:49 dwmw2 Exp
- * - With the Franz Galiana's set_bam_entry fix from v1.23
- * - Perhaps it's about time I made a branch for the 2.4 series.
-
- * Originally based on:
+ * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
+ *
+ * Based on:
  */
 /*======================================================================
 
@@ -30,8 +30,8 @@
     are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
 
     Alternatively, the contents of this file may be used under the
-    terms of the GNU General Public License version 2 (the "GPL"), in which
-    case the provisions of the GPL are applicable instead of the
+    terms of the GNU General Public License version 2 (the "GPL"), in
+    which case the provisions of the GPL are applicable instead of the
     above.  If you wish to allow the use of your version of this file
     only under the terms of the GPL and not to allow others to use
     your version of this file under the MPL, indicate your decision
@@ -55,11 +55,6 @@
     contact M-Systems (http://www.m-sys.com) directly.
       
 ======================================================================*/
-#define FTL_DEBUG 5
-#ifdef FTL_DEBUG
-#define DEBUGLVL debug
-#endif
-
 #include <linux/module.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/mtd.h>
@@ -104,23 +99,27 @@
 #define request_arg_t           request_queue_t *q
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,14)
+#define BLK_INC_USE_COUNT MOD_INC_USE_COUNT
+#define BLK_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define BLK_INC_USE_COUNT do {} while(0)
+#define BLK_DEC_USE_COUNT do {} while(0)
+#endif
 
 /*====================================================================*/
 
 /* Parameters that can be set with 'insmod' */
-
-/* Major device # for FTL device */
 static int shuffle_freq = 50;
-
 MODULE_PARM(shuffle_freq, "i");
 
 /*====================================================================*/
 
+/* Major device # for FTL device */
 #ifndef FTL_MAJOR
 #define FTL_MAJOR	44
 #endif
 
-
 /* Funky stuff for setting up a block device */
 #define MAJOR_NR		FTL_MAJOR
 #define DEVICE_NAME		"ftl"
@@ -135,17 +134,8 @@
 
 #include <linux/blk.h>
 
-#ifdef FTL_DEBUG
-static int debug = FTL_DEBUG;
-MODULE_PARM(debug, "i");
-#endif
-
 /*====================================================================*/
 
-#ifndef FTL_MAJOR
-#define FTL_MAJOR	44
-#endif
-
 /* Maximum number of separate memory devices we'll allow */
 #define MAX_DEV		4
 
@@ -200,7 +190,10 @@
 
 void ftl_freepart(partition_t *part);
 
-static struct mtd_notifier ftl_notifier={ftl_notify_add, ftl_notify_remove, NULL};
+static struct mtd_notifier ftl_notifier = {
+	add:	ftl_notify_add,
+	remove:	ftl_notify_remove,
+};
 
 /* Partition state flags */
 #define FTL_FORMATTED	0x01
@@ -226,7 +219,6 @@
 #endif
     part:		ftl_hd,
     sizes:		ftl_sizes,
-    nr_real:		0
 };
 
 /*====================================================================*/
@@ -250,6 +242,9 @@
 };
 #else
 static struct block_device_operations ftl_blk_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,14)
+    owner:	THIS_MODULE,
+#endif
     open:	ftl_open,
     release:	ftl_close,
     ioctl:	ftl_ioctl,
@@ -273,8 +268,8 @@
     max_offset = (0x100000<part->mtd->size)?0x100000:part->mtd->size;
     /* Search first megabyte for a valid FTL header */
     for (offset = 0;
-	 offset < max_offset;
-	 offset += part->mtd->erasesize?part->mtd->erasesize:0x2000) {
+	 (offset + sizeof(header)) < max_offset;
+	 offset += part->mtd->erasesize ? : 0x2000) {
 
 	ret = part->mtd->read(part->mtd, offset, sizeof(header), &ret, 
 			      (unsigned char *)&header);
@@ -296,7 +291,7 @@
 	return -1;
     }
     if ((1 << header.EraseUnitSize) != part->mtd->erasesize) {
-	printk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %lx\n",
+	printk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %x\n",
 	       1 << header.EraseUnitSize,part->mtd->erasesize);
 	return -1;
     }
@@ -309,7 +304,7 @@
     erase_unit_header_t header;
     u_int16_t xvalid, xtrans, i;
     u_int blocks, j;
-    int hdr_ok, ret;
+    int hdr_ok, ret = -1;
     ssize_t retval;
     loff_t offset;
 
@@ -318,13 +313,15 @@
 	part->header.NumTransferUnits;
     part->EUNInfo = kmalloc(part->DataUnits * sizeof(struct eun_info_t),
 			    GFP_KERNEL);
-    if (!part->EUNInfo) return -1;
+    if (!part->EUNInfo)
+	    goto out;
     for (i = 0; i < part->DataUnits; i++)
 	part->EUNInfo[i].Offset = 0xffffffff;
     part->XferInfo =
 	kmalloc(part->header.NumTransferUnits * sizeof(struct xfer_info_t),
 		GFP_KERNEL);
-    if (!part->XferInfo) return -1;
+    if (!part->XferInfo)
+	    goto out_EUNInfo;
 
     xvalid = xtrans = 0;
     for (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {
@@ -334,8 +331,9 @@
 			      (unsigned char *)&header);
 	
 	if (ret) 
-	    return ret;
+	    goto out_XferInfo;
 
+	ret = -1;
 	/* Is this a transfer partition? */
 	hdr_ok = (strcmp(header.DataOrgTuple+3, "FTL100") == 0);
 	if (hdr_ok && (le16_to_cpu(header.LogicalEUN) < part->DataUnits) &&
@@ -348,7 +346,7 @@
 	    if (xtrans == part->header.NumTransferUnits) {
 		printk(KERN_NOTICE "ftl_cs: format error: too many "
 		       "transfer units!\n");
-		return -1;
+		goto out_XferInfo;
 	    }
 	    if (hdr_ok && (le16_to_cpu(header.LogicalEUN) == 0xffff)) {
 		part->XferInfo[xtrans].state = XFER_PREPARED;
@@ -369,18 +367,22 @@
 	(xvalid+xtrans != le16_to_cpu(header.NumEraseUnits))) {
 	printk(KERN_NOTICE "ftl_cs: format error: erase units "
 	       "don't add up!\n");
-	return -1;
+	goto out_XferInfo;
     }
     
     /* Set up virtual page map */
     blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;
     part->VirtualBlockMap = vmalloc(blocks * sizeof(u_int32_t));
+    if (!part->VirtualBlockMap)
+	    goto out_XferInfo;
+
     memset(part->VirtualBlockMap, 0xff, blocks * sizeof(u_int32_t));
     part->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;
 
     part->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(u_int32_t),
 			      GFP_KERNEL);
-    if (!part->bam_cache) return -1;
+    if (!part->bam_cache)
+	    goto out_VirtualBlockMap;
 
     part->bam_index = 0xffff;
     part->FreeTotal = 0;
@@ -395,7 +397,7 @@
 			      (unsigned char *)part->bam_cache);
 	
 	if (ret) 
-	    return ret;
+		goto out_bam_cache;
 
 	for (j = 0; j < part->BlocksPerUnit; j++) {
 	    if (BLOCK_FREE(le32_to_cpu(part->bam_cache[j]))) {
@@ -410,8 +412,19 @@
 	}
     }
     
-    return 0;
-    
+    ret = 0;
+    goto out;
+
+out_bam_cache:
+    kfree(part->bam_cache);
+out_VirtualBlockMap:
+    vfree(part->VirtualBlockMap);
+out_XferInfo:
+    kfree(part->XferInfo);
+out_EUNInfo:
+    kfree(part->EUNInfo);
+out:
+    return ret;
 } /* build_maps */
 
 /*======================================================================
@@ -699,7 +712,7 @@
     int queued, ret;
 
     DEBUG(0, "ftl_cs: reclaiming space...\n");
-    DEBUG(4, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
+    DEBUG(3, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
     /* Pick the least erased transfer unit */
     best = 0xffffffff; xfer = 0xffff;
     do {
@@ -707,22 +720,22 @@
 	for (i = 0; i < part->header.NumTransferUnits; i++) {
 	    int n=0;
 	    if (part->XferInfo[i].state == XFER_UNKNOWN) {
-		DEBUG(4,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
+		DEBUG(3,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
 		n=1;
 		erase_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_ERASING) {
-		DEBUG(4,"XferInfo[%d].state == XFER_ERASING\n",i);
+		DEBUG(3,"XferInfo[%d].state == XFER_ERASING\n",i);
 		n=1;
 		queued = 1;
 	    }
 	    else if (part->XferInfo[i].state == XFER_ERASED) {
-		DEBUG(4,"XferInfo[%d].state == XFER_ERASED\n",i);
+		DEBUG(3,"XferInfo[%d].state == XFER_ERASED\n",i);
 		n=1;
 		prepare_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_PREPARED) {
-		DEBUG(4,"XferInfo[%d].state == XFER_PREPARED\n",i);
+		DEBUG(3,"XferInfo[%d].state == XFER_PREPARED\n",i);
 		n=1;
 		if (part->XferInfo[i].EraseCount <= best) {
 		    best = part->XferInfo[i].EraseCount;
@@ -730,7 +743,7 @@
 		}
 	    }
 		if (!n)
-		    DEBUG(4,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
+		    DEBUG(3,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
 
 	}
 	if (xfer == 0xffff) {
@@ -891,16 +904,16 @@
     if (ftl_gendisk.part[minor].nr_sects == 0)
 	return -ENXIO;
 
-    MOD_INC_USE_COUNT;
+    BLK_INC_USE_COUNT;
 
     if (!get_mtd_device(partition->mtd, -1)) {
-	    MOD_DEC_USE_COUNT;
-	    return /* -E'SBUGGEREDOFF */ -ENXIO;
+	    BLK_DEC_USE_COUNT;
+	    return -ENXIO;
     }
     
     if ((file->f_mode & 2) && !(partition->mtd->flags & MTD_CLEAR_BITS) ) {
 	    put_mtd_device(partition->mtd);
-	    MOD_DEC_USE_COUNT;
+	    BLK_DEC_USE_COUNT;
             return -EROFS;
     }
     
@@ -915,22 +928,12 @@
 
 static release_t ftl_close(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
-    struct super_block *sb = get_super(inode->i_rdev);
-#endif
     int minor = MINOR(inode->i_rdev);
     partition_t *part = myparts[minor >> 4];
     int i;
     
     DEBUG(0, "ftl_cs: ftl_close(%d)\n", minor);
 
-    /* Flush all writes */
-    fsync_dev(inode->i_rdev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
-    if (sb) invalidate_inodes(sb);
-#endif
-    invalidate_buffers(inode->i_rdev);
-
     /* Wait for any pending erase operations to complete */
     if (part->mtd->sync)
 	    part->mtd->sync(part->mtd);
@@ -943,7 +946,7 @@
     atomic_dec(&part->open);
 
     put_mtd_device(part->mtd);
-    MOD_DEC_USE_COUNT;
+    BLK_DEC_USE_COUNT;
     release_return(0);
 } /* ftl_close */
 
@@ -1178,11 +1181,13 @@
 	put_user(ftl_hd[minor].start_sect, (u_long *)&geo->start);
 	break;
     case BLKGETSIZE:
-	ret = verify_area(VERIFY_WRITE, (long *)arg, sizeof(long));
-	if (ret) return ret;
-	put_user(ftl_hd[minor].nr_sects, 
-		 (long *)arg);
+	ret = put_user(ftl_hd[minor].nr_sects, (unsigned long *)arg);
+	break;
+#ifdef BLKGETSIZE64
+    case BLKGETSIZE64:
+	ret = put_user((u64)ftl_hd[minor].nr_sects << 9, (u64 *)arg);
 	break;
+#endif
     case BLKRRPART:
 	ret = ftl_reread_partitions(minor);
 	break;
@@ -1226,11 +1231,12 @@
     }
     whole = minor & ~(MAX_PART-1);
 
-    for (i = 0; i < MAX_PART; i++) {
+    i = MAX_PART - 1;
+    while (i-- > 0) {
 	if (ftl_hd[whole+i].nr_sects > 0) {
 	    kdev_t rdev = MKDEV(FTL_MAJOR, whole+i);
-	    sync_dev(rdev);
-	    invalidate_buffers(rdev);
+
+	    invalidate_device(rdev, 1);
 	}
 	ftl_hd[whole+i].start_sect = 0;
 	ftl_hd[whole+i].nr_sects = 0;
@@ -1369,7 +1375,8 @@
 		printk(KERN_INFO "ftl_cs: opening %d kb FTL partition\n",
 		       le32_to_cpu(partition->header.FormattedSize) >> 10);
 #endif
-	}
+	} else
+		kfree(partition);
 }
 
 static void ftl_notify_remove(struct mtd_info *mtd)
@@ -1402,20 +1409,14 @@
 		}
 }
 
-
-#if LINUX_VERSION_CODE < 0x20300
-#ifdef MODULE
-#define init_ftl init_module
-#define cleanup_ftl cleanup_module
-#endif
-#endif
-
-mod_init_t init_ftl(void)
+int init_ftl(void)
 {
     int i;
 
     memset(myparts, 0, sizeof(myparts));
     
+    DEBUG(0, "$Id: ftl.c,v 1.42 2001/11/20 11:42:33 dwmw2 Exp $\n");
+    
     if (register_blkdev(FTL_MAJOR, "ftl", &ftl_blk_fops)) {
 	printk(KERN_NOTICE "ftl_cs: unable to grab major "
 	       "device number!\n");
@@ -1431,32 +1432,28 @@
     blksize_size[FTL_MAJOR] = ftl_blocksizes;
     ftl_gendisk.major = FTL_MAJOR;
     blk_init_queue(BLK_DEFAULT_QUEUE(FTL_MAJOR), &do_ftl_request);
-    ftl_gendisk.next = gendisk_head;
-    gendisk_head = &ftl_gendisk;
+    add_gendisk(&ftl_gendisk);
     
     register_mtd_user(&ftl_notifier);
     
     return 0;
 }
 
-mod_exit_t cleanup_ftl(void)
+static void __exit cleanup_ftl(void)
 {
-    struct gendisk *gd, **gdp;
-
     unregister_mtd_user(&ftl_notifier);
 
     unregister_blkdev(FTL_MAJOR, "ftl");
     blk_cleanup_queue(BLK_DEFAULT_QUEUE(FTL_MAJOR));
     blksize_size[FTL_MAJOR] = NULL;
 
-    for (gdp = &gendisk_head; *gdp; gdp = &((*gdp)->next))
-	if (*gdp == &ftl_gendisk) {
-	    gd = *gdp; *gdp = gd->next;
-	    break;
-	}
+    del_gendisk(&ftl_gendisk);
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_ftl);
 module_exit(cleanup_ftl);
-#endif
+
+
+MODULE_LICENSE("Dual MPL/GPL");
+MODULE_AUTHOR("David Hinds <dhinds@sonic.net>");
+MODULE_DESCRIPTION("Support code for Flash Translation Layer, used on PCMCIA devices and M-Systems DiskOnChip 1000");
diff -Naur linux-2.4.2.orig/drivers/mtd/initcalls.c linux-2.4.2/drivers/mtd/initcalls.c
--- linux-2.4.2.orig/drivers/mtd/initcalls.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/initcalls.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,123 @@
+/*
+ * $Id: initcalls.c,v 1.3 2001/03/26 20:08:19 kd Exp $
+ *
+ * Init calls for MTD drivers in kernels < 2.2.18
+ * Split off into a separate file so they don't pollute
+ * the 2.4 and 2.2.18+ versions.
+ */
+#include <linux/config.h>
+
+extern int init_doc1000(void);
+extern int init_doc2000(void);
+extern int init_doc2001(void);
+extern int init_doc(void);
+extern int cfi_probe_init(void);
+extern int cfi_intelext_init(void);
+extern int cfi_amdstd_init(void);
+extern int map_rom_init(void);
+extern int map_rom_init(void);
+extern int init_physmap(void);
+extern int init_rpxlite(void);
+extern int init_octagon5066(void);
+extern int init_pnc2000(void);
+extern int init_vmax301(void);
+extern int init_mixmem(void);
+extern int init_pmc551(void);
+extern int init_nora(void);
+extern int init_sbc_mediagx(void);
+extern int init_elan_104nc(void);
+extern int spia_init(void);
+extern int init_mtdram(void);
+extern int init_ftl(void);
+extern int init_nftl(void);
+extern int init_mtdblock(void);
+extern int init_mtdchar(void);
+extern int init_flagadm(void);
+
+void init_mtd_devices(void)
+{
+	/* Shedloads of calls to init functions of all the
+	 * other drivers and users of MTD, which we can
+	 * ditch in 2.2.18 because of the sexy new way of
+	 * finding init routines.
+	 */
+#ifdef CONFIG_MTD_DOC1000
+	init_doc1000();
+#endif
+#ifdef CONFIG_MTD_DOC2000
+	init_doc2000();
+#endif
+#ifdef CONFIG_MTD_DOC2001
+	init_doc2001();
+#endif
+#ifdef CONFIG_MTD_DOCPROBE
+	init_doc();
+#endif
+#ifdef CONFIG_MTD_CFI
+	cfi_probe_init();
+#endif
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	cfi_intelext_init();
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	cfi_amdstd_init();
+#endif
+#ifdef CONFIG_MTD_RAM
+	map_rom_init();
+#endif
+#ifdef CONFIG_MTD_ROM
+	map_rom_init();
+#endif
+#ifdef CONFIG_MTD_PHYSMAP
+	init_physmap();
+#endif
+#ifdef CONFIG_MTD_RPXLITE
+	init_rpxlite();
+#endif
+#ifdef CONFIG_MTD_OCTAGON
+	init_octagon5066();
+#endif
+#ifdef CONFIG_MTD_PNC2000
+	init_pnc2000();
+#endif
+#ifdef CONFIG_MTD_VMAX
+	init_vmax301();
+#endif
+#ifdef CONFIGF_MTD_MIXMEM
+	init_mixmem();
+#endif
+#ifdef CONFIG_MTD_PMC551
+	init_pmc551();
+#endif
+#ifdef CONFIG_MTD_NORA
+	init_nora();
+#endif
+#ifdef CONFIG_MTD_SBC_MEDIAGX
+	init_sbc_mediagx();
+#endif
+#ifdef CONFIG_MTD_ELAN_104NC
+	init_elan_104nc();
+#endif
+#ifdef CONFIG_MTD_NAND_SPIA
+	spia_init();
+#endif
+#ifdef CONFIG_MTD_MTDRAM
+	init_mtdram();
+#endif
+#ifdef CONFIG_FTL
+	init_ftl();
+#endif
+#ifdef CONFIG_NFTL
+	init_nftl();
+#endif
+#if defined(CONFIG_MTD_BLOCK) || defined(CONFIG_MTD_BLOCK_RO)
+	init_mtdblock();
+#endif
+#ifdef CONFIG_MTD_CHAR
+	init_mtdchar();
+#endif
+#ifdef CONFIG_MTD_FLAGADM
+	init_flagadm();
+#endif
+}
+
diff -Naur linux-2.4.2.orig/drivers/mtd/iq80310.c linux-2.4.2/drivers/mtd/iq80310.c
--- linux-2.4.2.orig/drivers/mtd/iq80310.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/iq80310.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,134 @@
+/*
+ * $Id: iq80310.c,v 1.2 2001/03/26 18:08:44 nico Exp $
+ *
+ * Mapping for the Intel XScale IQ80310 evaluation board
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 	0
+#define WINDOW_SIZE 	8*1024*1024
+#define BUSWIDTH 	1
+
+static struct mtd_info *mymtd;
+
+static __u8 iq80310_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 iq80310_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 iq80310_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void iq80310_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void iq80310_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info iq80310_map = {
+	name: "IQ80310 flash",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8:		iq80310_read8,
+	read16:		iq80310_read16,
+	read32:		iq80310_read32,
+	copy_from:	iq80310_copy_from,
+	write8:		iq80310_write8,
+	write16:	iq80310_write16,
+	write32:	iq80310_write32,
+	copy_to:	iq80310_copy_to
+};
+
+static struct mtd_partition iq80310_partitions[3] = {
+	{
+		name:		"firmware",
+		size:		0x00080000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE  /* force read-only */
+	},{
+		name:		"kernel",
+		size:		0x00080000,
+		offset:		0x00080000,
+	},{
+		name:		"filesystem",
+		size:		0x00700000,
+		offset:		0x00100000
+	}
+};
+
+static int __init init_iq80310(void)
+{
+	iq80310_map.map_priv_1 = (unsigned long)__ioremap(WINDOW_ADDR, WINDOW_SIZE, 0);
+
+	if (!iq80310_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_cfi_probe(&iq80310_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, iq80310_partitions, 3);
+		return 0;
+	}
+
+	iounmap((void *)iq80310_map.map_priv_1);
+	return -ENXIO;
+}
+
+static int __exit cleanup_iq80310(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (iq80310_map.map_priv_1) {
+		iounmap((void *)iq80310_map.map_priv_1);
+		iq80310_map.map_priv_1 = 0;
+	}
+	return 0;
+}
+
+module_init(init_iq80310);
+module_exit(cleanup_iq80310);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/jedec.c linux-2.4.2/drivers/mtd/jedec.c
--- linux-2.4.2.orig/drivers/mtd/jedec.c	Tue Jul  4 19:10:05 2000
+++ linux-2.4.2/drivers/mtd/jedec.c	Fri Feb 15 14:41:15 2002
@@ -11,7 +11,7 @@
  * not going to guess how to send commands to them, plus I expect they will
  * all speak CFI..
  *
- * $Id: jedec.c,v 1.1 2000/07/04 07:21:57 jgg Exp $
+ * $Id: jedec.c,v 1.5 2001/03/01 15:05:14 cwryu Exp $
  */
 
 #include <linux/mtd/jedec.h>
@@ -28,15 +28,20 @@
 static int flash_erase(struct mtd_info *mtd, struct erase_info *instr);
 static int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
 		       size_t *retlen, const u_char *buf);
+
+static const char im_name[] = "jedec_probe";
    
-EXPORT_SYMBOL(jedec_probe);
+static unsigned long my_bank_size;
 
 /* Listing of parts and sizes. We need this table to learn the sector
    size of the chip and the total length */
 static const struct JEDECTable JEDEC_table[] = 
-  {{0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+  {{0x013D,"AMD Am29F017D",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {0x01A4,"AMD Am29F040",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x20E3,"AMD Am29W040B",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0xC2AD,"Macronix MX29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {}};
 
 static void jedec_sync(struct mtd_info *mtd) {};
@@ -46,8 +51,8 @@
 			     size_t *retlen, u_char *buf);
 
 /* Probe entry point */
-   struct jedec_private priv;
-   struct mtd_info __MTD;
+struct jedec_private priv;
+struct mtd_info __MTD;
 struct mtd_info *jedec_probe(struct map_info *map)
 {
    struct mtd_info *MTD = &__MTD;
@@ -58,26 +63,29 @@
    char Part[200];
    memset(&priv,0,sizeof(priv));
    
-   if (map->bank_size == 0)
-      map->bank_size = map->size;
+   my_bank_size = map->size;
 
-   if (map->size/map->bank_size > MAX_JEDEC_CHIPS)
+   if (map->size/my_bank_size > MAX_JEDEC_CHIPS)
    {
       printk("mtd: Increase MAX_JEDEC_CHIPS, too many banks.\n");
       return 0;
    }
    
-   for (Base = 0; Base < map->size; Base += map->bank_size)
+   for (Base = 0; Base < map->size; Base += my_bank_size)
    {
       // Perhaps zero could designate all tests?
-      if (map->bus_width == 0)
-	 map->bus_width = 8;
+      if (map->buswidth == 0)
+	 map->buswidth = 1;
       
-      if (map->bus_width == 8)
-	 jedec_probe8(map,Base,&priv);
-      if (map->bus_width == 16)
+      if (map->buswidth == 1){
+	 if (jedec_probe8(map,Base,&priv) == 0) {
+		 printk("did recognize jedec chip\n");
+	         return 0;
+	 }
+      }
+      if (map->buswidth == 2)
 	 jedec_probe16(map,Base,&priv);
-      if (map->bus_width == 32)
+      if (map->buswidth == 4)
 	 jedec_probe32(map,Base,&priv);
    }
    
@@ -85,6 +93,8 @@
    SectorSize = 0;
    for (I = 0; priv.chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
    {
+	   printk("priv.chips[%d].jedec is %x\n",I,priv.chips[I].jedec);
+	   printk("priv.chips[%d].sectorsize is %lx\n",I,priv.chips[I].sectorsize);
       if (priv.chips[I].sectorsize > SectorSize)
 	 SectorSize = priv.chips[I].sectorsize;
    }
@@ -141,34 +151,50 @@
       are empty banks. Note, the last bank does not count here, only the
       first banks are important. Holes on non-bank boundaries can not exist
       due to the way the detection algorithm works. */
-   if (priv.size < map->bank_size)
-      map->bank_size = priv.size;
+   if (priv.size < my_bank_size)
+      my_bank_size = priv.size;
    priv.is_banked = 0;
-   for (I = 0; I != priv.size/map->bank_size - 1; I++)
-   {
-      if (priv.bank_fill[I] != map->bank_size)
-	 priv.is_banked = 1;
-      
-      /* This even could be eliminated, but new de-optimized read/write
-         functions have to be written */
-      if (priv.bank_fill[I] != priv.bank_fill[0])
-      {
-	 printk("mtd: Failed. Cannot handle unsymetric banking\n");
-	 return 0;
-      }      
+   //printk("priv.size is %x, my_bank_size is %x\n",priv.size,my_bank_size);
+   //printk("priv.bank_fill[0] is %x\n",priv.bank_fill[0]);
+   if (!priv.size) {
+	   printk("priv.size is zero\n");
+	   return 0;
+   }
+   if (priv.size/my_bank_size) {
+	   if (priv.size/my_bank_size == 1) {
+		   priv.size = my_bank_size;
+	   }
+	   else {
+		   for (I = 0; I != priv.size/my_bank_size - 1; I++)
+		   {
+		      if (priv.bank_fill[I] != my_bank_size)
+			 priv.is_banked = 1;
+		      
+		      /* This even could be eliminated, but new de-optimized read/write
+			 functions have to be written */
+		      printk("priv.bank_fill[%d] is %lx, priv.bank_fill[0] is %lx\n",I,priv.bank_fill[I],priv.bank_fill[0]);
+		      if (priv.bank_fill[I] != priv.bank_fill[0])
+		      {
+			 printk("mtd: Failed. Cannot handle unsymetric banking\n");
+			 return 0;
+		      }      
+		   }
+	   }
    }
    if (priv.is_banked == 1)
       strcat(Part,", banked");
 
-   xprintf("Part: '%s'\n",Part);
+   printk("Part: '%s'\n",Part);
    
    memset(MTD,0,sizeof(*MTD));
-   strncpy(MTD->name,Part,sizeof(MTD->name));
-   MTD->name[sizeof(MTD->name)-1] = 0;
+  // strncpy(MTD->name,Part,sizeof(MTD->name));
+  // MTD->name[sizeof(MTD->name)-1] = 0;
    MTD->type = MTD_NORFLASH;
    MTD->flags = MTD_CAP_NORFLASH;
-   MTD->erasesize = SectorSize*(map->bus_width/8);
+   MTD->erasesize = SectorSize*(map->buswidth);
+   printk("MTD->erasesize is %x\n",(unsigned int)MTD->erasesize);
    MTD->size = priv.size;
+   printk("MTD->size is %x\n",(unsigned int)MTD->size);
    //MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
    MTD->erase = flash_erase;
    if (priv.is_banked == 1)
@@ -274,10 +300,10 @@
       for (Bank = Count; Bank != 1; Bank >>= 1, priv->chips[I].addrshift++);
       
       // Determine how filled this bank is.
-      Bank = base & (~(map->bank_size-1));
-      if (priv->bank_fill[Bank/map->bank_size] < base + 
+      Bank = base & (~(my_bank_size-1));
+      if (priv->bank_fill[Bank/my_bank_size] < base + 
 	  (JEDEC->size << priv->chips[I].addrshift) - Bank)
-	 priv->bank_fill[Bank/map->bank_size] =  base + (JEDEC->size << priv->chips[I].addrshift) - Bank;
+	 priv->bank_fill[Bank/my_bank_size] =  base + (JEDEC->size << priv->chips[I].addrshift) - Bank;
       I++;
    }
 
@@ -301,7 +327,53 @@
 int jedec_probe8(struct map_info *map,unsigned long base,
 		  struct jedec_private *priv)
 { 
-   return 0;
+   #define flread(x) map->read8(map,base+x)
+   #define flwrite(v,x) map->write8(map,v,base+x)
+
+   const unsigned long AutoSel1 = 0xAA;
+   const unsigned long AutoSel2 = 0x55;
+   const unsigned long AutoSel3 = 0x90;
+   const unsigned long Reset = 0xF0;
+   __u32 OldVal;
+   __u8 Mfg[1];
+   __u8 Id[1];
+   unsigned I;
+   unsigned long Size;
+
+   // Wait for any write/erase operation to settle
+   OldVal = flread(base);
+   for (I = 0; OldVal != flread(base) && I < 10000; I++)
+      OldVal = flread(base);
+   
+   // Reset the chip
+   flwrite(Reset,0x555); 
+   
+   // Send the sequence
+   flwrite(AutoSel1,0x555);
+   flwrite(AutoSel2,0x2AA);
+   flwrite(AutoSel3,0x555);
+   
+   //  Get the JEDEC numbers
+   Mfg[0] = flread(0);
+   Id[0] = flread(1);
+   printk("Mfg is %x, Id is %x\n",Mfg[0],Id[0]);
+      
+   Size = handle_jedecs(map,Mfg,Id,1,base,priv);
+   printk("handle_jedecs Size is %x\n",(unsigned int)Size);
+   if (Size == 0)
+   {
+      flwrite(Reset,0x555);
+      return 0;
+   }
+   
+
+   // Reset.
+   flwrite(Reset,0x555);
+   
+   return 1;
+   
+   #undef flread
+   #undef flwrite
 }
 
 // Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
@@ -321,7 +393,7 @@
    const unsigned long AutoSel1 = 0xAAAAAAAA;
    const unsigned long AutoSel2 = 0x55555555;
    const unsigned long AutoSel3 = 0x90909090;
-   const unsigned long Reset = 0x90909090;
+   const unsigned long Reset = 0xF0F0F0F0;
    __u32 OldVal;
    __u8 Mfg[4];
    __u8 Id[4];
@@ -370,7 +442,7 @@
       more flashes have a truncated address space the probe test will still
       work */
    if (base + Size+0x555 < map->size &&
-       base + Size+0x555 < (base & (~(map->bank_size-1))) + map->bank_size)
+       base + Size+0x555 < (base & (~(my_bank_size-1))) + my_bank_size)
    {
       if (flread(base+Size) != flread(base+Size + 0x100) ||
 	  flread(base+Size + 1) != flread(base+Size + 0x101))
@@ -418,7 +490,7 @@
 	 get = priv->bank_fill[0] - offset;
 
       bank /= priv->bank_fill[0];      
-      map->copy_from(map,buf + *retlen,bank*map->bank_size + offset,get);
+      map->copy_from(map,buf + *retlen,bank*my_bank_size + offset,get);
       
       len -= get;
       *retlen += get;
@@ -477,16 +549,9 @@
       if (chip->length == 0)
 	 continue;
       
-      // Send the erase setup code
-      xprintf("Erase: ");
-      puth(chip->start); putc(' ');
-      puth(chip->base); putc(' ');
-      puth(chip->length); putc(' ');
-      puth(chip->sectorsize); putc('\n');
-      
       if (chip->start + chip->length > chip->size)
       {
-	 xprintf("DIE\n");
+	 printk("DIE\n");
 	 return -EIO;
       }     
       
@@ -497,20 +562,10 @@
       flwrite(0xAA,chip->start + 0x555);
       flwrite(0x55,chip->start + 0x2AA);
 
-      // Use chip erase if possible
-      if (chip->start == 0 && chip->length == chip->size)
-      {
-	 flwrite(0x10,0x555);
-	 continue;
-      }
-            
       /* Once we start selecting the erase sectors the delay between each 
          command must not exceed 50us or it will immediately start erasing 
          and ignore the other sectors */
-/*    how do you portably turn off interrupts?
-      save_flags(flags);
-      cli();*/
-      for (off = 0; off < chip->length; off += chip->sectorsize)
+      for (off = 0; off < len; off += chip->sectorsize)
       {
 	 // Check to make sure we didn't timeout
 	 flwrite(0x30,chip->start + off);
@@ -522,7 +577,6 @@
 	    return -EIO;
 	 }       	 
       }
-//      restore_flags(flags);
    }   
 
    /* We could split this into a timer routine and return early, performing
@@ -560,7 +614,7 @@
 	 }	 
       }
 
-      xprintf("todo: %x %x %x %x\n",(short)todo[0],(short)todo[1],
+      printk("todo: %x %x %x %x\n",(short)todo[0],(short)todo[1],
 	      (short)todo[2],(short)todo[3]);
       
       while (1)
@@ -571,9 +625,23 @@
 	 /* During erase bit 7 is held low and bit 6 toggles, we watch this,
 	    should it stop toggling or go high then the erase is completed,
   	    or this is not really flash ;> */
-	 Last[0] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
-	 Last[1] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
-	 Last[2] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	 switch (map->buswidth) {
+	 case 1:
+	    Last[0] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 2:
+	    Last[0] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 3:
+	    Last[0] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 }
 	 Count = 3;
 	 while (todo_left != 0)
 	 {
@@ -604,12 +672,20 @@
 /*	    if (NoTime == 0)
 	       Time += HZ/10 - schedule_timeout(HZ/10);*/
 	    NoTime = 0;
-	    
-	    Last[Count % 4] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+
+	    switch (map->buswidth) {
+	    case 1:
+	       Last[Count % 4] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 2:
+	       Last[Count % 4] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 4:
+	       Last[Count % 4] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    }
 	    Count++;
 	    
-	    putc('.');
-	    
 /*	    // Count time, max of 15s per sector (according to AMD)
 	    if (Time > 15*len/mtd->erasesize*HZ)
 	    {
@@ -618,8 +694,6 @@
 	    }	    */
 	 }
 	 	 
-	 puts("out\n");
-	    
 	 // Skip to the next chip if we used chip erase
 	 if (chip->length == chip->size)
 	    off = chip->size;
@@ -639,7 +713,9 @@
       }      
    }
        	    
-   puts("done\n");
+   //printk("done\n");
+   if (instr->callback)
+	instr->callback(instr);
    return 0;
    
    #undef flread
@@ -663,12 +739,14 @@
    struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
    unsigned long base;
    unsigned long off;
+   size_t save_len = len;
    
    if (start + len > mtd->size)
       return -EIO;
    
-   puts("Here");
+   //printk("Here");
    
+   //printk("flash_write: start is %x, len is %x\n",start,(unsigned long)len);
    while (len != 0)
    {
       struct jedec_flash_chip *chip = priv->chips;
@@ -676,16 +754,17 @@
       unsigned long boffset;
 	 
       // Compute the base of the flash.
-      off = start % (chip->size << chip->addrshift);
+      off = ((unsigned long)start) % (chip->size << chip->addrshift);
       base = start - off;
 
       // Perform banked addressing translation.
       bank = base & (~(priv->bank_fill[0]-1));
       boffset = base & (priv->bank_fill[0]-1);
-      bank = (bank/priv->bank_fill[0])*map->bank_size;
+      bank = (bank/priv->bank_fill[0])*my_bank_size;
       base = bank + boffset;
       
-      xprintf("Flasing %X %X %X\n",base,chip->size,len);
+    //  printk("Flasing %X %X %X\n",base,chip->size,len);
+     // printk("off is %x, compare with %x\n",off,chip->size << chip->addrshift);
       
       // Loop over this page
       for (; off != (chip->size << chip->addrshift) && len != 0; start++, len--, off++,buf++)
@@ -694,10 +773,10 @@
 	 unsigned char Last[4];
 	 unsigned long Count = 0;
 
-//	 putc('.');
-	 
-	 if (oldbyte == *buf)
+	 if (oldbyte == *buf) {
+	//	 printk("oldbyte and *buf is %x,len is %x\n",oldbyte,len);
 	    continue;
+	 }
 	 if (((~oldbyte) & *buf) != 0)
 	    printk("mtd: warn: Trying to set a 0 to a 1\n");
 	     
@@ -724,7 +803,7 @@
 	 }	 
       }
    }
-   *retlen = len;
+   *retlen = save_len;
    return 0;
 }
 
@@ -771,3 +850,21 @@
    }
 }
 									/*}}}*/
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define jedec_probe_init init_module
+#define jedec_probe_exit cleanup_module
+#endif
+
+int __init jedec_probe_init(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &jedec_probe);
+	return 0;
+}
+
+static void __exit jedec_probe_exit(void)
+{
+	inter_module_unregister(im_name);
+}
+
+module_init(jedec_probe_init);
+module_exit(jedec_probe_exit);
diff -Naur linux-2.4.2.orig/drivers/mtd/map_ram.c linux-2.4.2/drivers/mtd/map_ram.c
--- linux-2.4.2.orig/drivers/mtd/map_ram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/map_ram.c	Fri Feb 15 14:41:15 2002
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple RAM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_ram.c,v 1.7 2000/12/10 01:39:13 dwmw2 Exp $
+ * $Id: map_ram.c,v 1.8 2000/12/18 00:03:26 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -10,7 +10,7 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 
@@ -60,7 +60,6 @@
 
 	memset(mtd, 0, sizeof(*mtd));
 
-	map->im_name = im_name;
 	map->fldrv_destroy = mapram_nop;
 	mtd->priv = map;
 	mtd->name = map->name;
diff -Naur linux-2.4.2.orig/drivers/mtd/map_rom.c linux-2.4.2/drivers/mtd/map_rom.c
--- linux-2.4.2.orig/drivers/mtd/map_rom.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/map_rom.c	Fri Feb 15 14:41:15 2002
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple ROM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_rom.c,v 1.10 2000/12/10 01:39:13 dwmw2 Exp $
+ * $Id: map_rom.c,v 1.12 2000/12/18 16:14:51 eauth Exp $
  */
 
 #include <linux/module.h>
@@ -10,7 +10,7 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 
@@ -38,7 +38,6 @@
 
 	memset(mtd, 0, sizeof(*mtd));
 
-	map->im_name = im_name;
 	map->fldrv_destroy = maprom_nop;
 	mtd->priv = map;
 	mtd->name = map->name;
@@ -79,13 +78,13 @@
 #define map_rom_exit cleanup_module
 #endif
 
-static int __init map_rom_init(void)
+mod_init_t map_rom_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &map_rom_probe);
 	return 0;
 }
 
-static void __exit map_rom_exit(void)
+mod_exit_t map_rom_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/mapped.c linux-2.4.2/drivers/mtd/mapped.c
--- linux-2.4.2.orig/drivers/mtd/mapped.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/mapped.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,672 @@
+// Description                                                          /*{{{*/
+// $Id: mapped.c,v 1.10 2000/11/21 08:43:04 dwmw2 Exp $
+/* ######################################################################
+
+   Flash MTD Routines
+
+   These routine support IDing and manipulating flash. Currently the 
+   older JEDEC ID mechanism and a table is used for determining the
+   flash characterisitics, but it is trivial to add support for the
+   CFI specification:
+     http://www.pentium.com/design/flash/ in the technote section.
+   
+   ##################################################################### */
+									/*}}}*/
+#include <linux/mtd/mapped.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+struct JEDECTable mtd_JEDEC_table[] = 
+  {{0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {}};
+
+// flash_setup - Setup the mapped_mtd_info structure for normal flash	/*{{{*/
+// ---------------------------------------------------------------------
+/* There is a set of commands that flash manufactures follow for getting the
+   JEDEC id, erasing and writing. So long as your flash device supports 
+   getting the JEDEC ID in this (standard?) way it will be supported as flash,
+   otherwise it is converted to ROM. Upon completion the structure is 
+   registered with the MTD layer */
+int mtd_mapped_setup(struct mapped_mtd_info *map)
+{
+   DEBUG(MTD_DEBUG_LEVEL1, "\n");
+   // Must define a page function to use the defaults!
+   if (map->page == 0)
+      return -1;
+   
+   if (map->jedec_sense == 0)
+      map->jedec_sense = flash_jedec;
+
+   if (map->jedec_sense(map) != 0)
+      return -1;
+
+   if (map->mtd.erase == 0 && map->mtd.type == MTD_NORFLASH)
+      map->mtd.erase = flash_erase;
+   if (map->mtd.write == 0)
+   {
+      if (map->mtd.type == MTD_NORFLASH)
+	 map->mtd.write = flash_write;
+      if (map->mtd.type == MTD_RAM)
+	 map->mtd.write = ram_write;      
+   }   
+   if (map->mtd.read == 0)
+      map->mtd.read = rom_read;   
+   
+   return add_mtd_device(&map->mtd);
+}
+									/*}}}*/
+// flash_remove - Remove the flash device from the MTD layer		/*{{{*/
+// ---------------------------------------------------------------------
+/* Free any memory allocated for the device here */
+int mtd_mapped_remove(struct mapped_mtd_info *map)
+{
+   return del_mtd_device(&map->mtd);
+}
+									/*}}}*/
+
+// checkparity - Checks a number for odd parity				/*{{{*/
+// ---------------------------------------------------------------------
+/* Helper for the JEDEC function, JEDEC numbers all have odd parity */
+static int checkparity(u_char C)
+{
+   u_char parity = 0;
+   while (C != 0)
+   {
+      parity ^= C & 1;
+      C >>= 1;
+   }
+   
+   return parity == 1;
+}
+									/*}}}*/
+// SetJedec - Set the jedec information for a chip			/*{{{*/
+// ---------------------------------------------------------------------
+/* We track the configuration of each chip separately in the chip list, 
+   each chip can have a different type and configuration to allow for 
+   maximum flexability. */
+void set_jedec(struct mapped_mtd_info *map,unsigned chip,unsigned char mfr,
+	      unsigned char id)
+{
+   unsigned long longID = (mfr << 8) + id;
+   unsigned int I;
+   
+   map->mtd.type = MTD_NORFLASH;
+   map->mfr = mfr;
+   map->id = id;
+
+   // Locate the chip in the jedec table
+   for (I = 0; mtd_JEDEC_table[I].jedec != 0; I++)
+   {      
+      if (mtd_JEDEC_table[I].jedec == longID)
+	 break;
+   }
+
+   if (mtd_JEDEC_table[I].jedec != longID || longID == 0)
+   {
+      printk("Unknown JEDEC number %x-%x, treating as ROM\n",map->mfr,
+	     map->id);
+      map->mtd.type = MTD_ROM;
+      return;
+   }
+      
+   // Setup the MTD from the JEDEC information
+//   map->mtd.size = mtd_JEDEC_table[I].size;
+//   map->mtd.erasesize = mtd_JEDEC_table[I].sectorsize;
+//   map->mtd.capabilities = mtd_JEDEC_table[I].capabilities;
+//   strncpy(map->mtd.part,mtd_JEDEC_table[I].name,sizeof(map->mtd.part)-1);
+   
+   map->chips[chip].jedec = longID;
+   map->chips[chip].size = mtd_JEDEC_table[I].size;
+   map->chips[chip].sectorsize = mtd_JEDEC_table[I].sectorsize;
+   map->chips[chip].capabilities = mtd_JEDEC_table[I].capabilities;
+   map->chips[chip].base = 0; 
+}
+									/*}}}*/
+// isjedec - Check if reading from the memory location gives jedec #s	/*{{{*/
+// ---------------------------------------------------------------------
+/* This is ment to be called on the flash window once it is in jedec mode */
+int isjedec(unsigned long base)
+{
+   // Test #1, JEDEC numbers are readable from 0x??00/0x??01
+   if (readb(base + 0) != readb(base + 0x100) || 
+       readb(base + 1) != readb(base + 0x101))
+      return 0;
+   
+   // Test #2 JEDEC numbers exhibit odd parity
+   if (checkparity(readb(base + 0)) == 0 || checkparity(readb(base + 1)) == 0)
+      return 0;
+   return 1;
+}
+									/*}}}*/
+// flash_jedec - JEDEC ID sensor					/*{{{*/
+// ---------------------------------------------------------------------
+/* The mysterious jedec flash probe sequence writes a specific pattern of
+   bytes to the flash. This should be general enough to work with any MTD
+   structure that may contain a flash chip, but note that it will corrupt
+   address 0x5555 on SRAM cards if the machine dies between the two 
+   critical operations. */
+int flash_jedec(struct mapped_mtd_info *map)
+{
+   unsigned I;
+   u_char OldVal;
+   unsigned long base;
+   unsigned long baseaddr = 0;
+   unsigned chip = 0;
+   unsigned count;
+   
+   // Who has a page size this small? :>
+   if (map->pagesize < 0x555)
+      return 1;
+   
+   base = map->page(map,0);
+   
+   // Wait for any write/erase operation to settle
+   OldVal = readb(base);
+   for (I = 0; OldVal != readb(base) && I < 10000; I++)
+      OldVal = readb(base);
+   
+   /* Check for sram by writing to it, the write also happens to be part 
+      of the flash reset sequence.. */
+   OldVal = readb(base + 0x555);
+   writeb(OldVal,base + 0x555);
+   writeb(0xF0,base + 0x555);
+   if (OldVal != readb(base + 0x555))
+   {
+      udelay(100);
+      
+      // Set it back and make sure..
+      writeb(OldVal,base + 0x555);
+      if (OldVal == readb(base + 0x555))
+      {
+	 map->mtd.type = MTD_RAM;
+	 return 0;
+      }
+      
+      writeb(0xF0,base + 0x555);
+   }
+   
+   // Probe for chips
+   while (chip < sizeof(map->chips)/sizeof(map->chips[0]))
+   {
+      // Already in jedec mode, we might be doing some address wrap around
+      if (chip != 0 && isjedec(base) != 0)
+      {
+	 /* Try to reset this page and check if that resets the first page
+	    to confirm */
+	 writeb(0xF0,base + 0x555);
+	 if (isjedec(base) != 0)
+	    break;
+	 base = map->page(map,0);
+	 if (isjedec(base) == 0)
+	    break;
+	 base = map->page(map,baseaddr/map->pagesize);
+      }
+      
+      // Send the sequence
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+      writeb(0x90,base + 0x555);
+
+      // Check the jedec number
+      if (isjedec(base) == 0)
+      {
+	 /* If this is the first chip it must be rom, otherwise it is the
+	    end of the flash region */
+	 if (chip == 0)
+	 {
+	    map->mtd.type = MTD_ROM;
+	    return 0;
+	 }
+	 break;
+      }      
+      
+      // Store the jdec info
+      set_jedec(map,chip,readb(base + 0),readb(base + 1));
+      map->chips[chip].base = baseaddr;
+      
+      // Jump to the next chip
+      baseaddr += map->chips[chip].size;
+      if (baseaddr/map->pagesize > map->maxsize)
+	 break;
+      base = map->page(map,baseaddr/map->pagesize);
+      if (base == 0)
+	 return -EIO;
+      
+      chip++;
+   }
+
+   // Reset all of the chips
+   map->mtd.size = 0;
+   baseaddr = 0;
+   map->mtd.flags = 0xFFFF;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      // Fill in the various MTD structures
+      map->mtd.size += map->chips[I].size;
+      if (map->mtd.erasesize < map->chips[I].sectorsize)
+	 map->mtd.erasesize = map->chips[I].sectorsize;
+      map->mtd.flags &= map->chips[I].capabilities;
+      
+      base = map->page(map,baseaddr/map->pagesize);
+      baseaddr += map->chips[chip].size;
+      writeb(0xF0,base + 0);  // Reset      
+   }   
+   
+   /* Generate a part name that includes the number of different chips and
+      other configuration information */
+   count = 1;
+   map->part[0] = 0;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      unsigned J;
+      if (map->chips[I+1].jedec == map->chips[I].jedec)
+      {
+	 count++;
+	 continue;
+      }
+      
+      // Locate the chip in the jedec table
+      for (J = 0; mtd_JEDEC_table[J].jedec != 0; J++)
+      {      
+	 if (mtd_JEDEC_table[J].jedec == map->chips[I].jedec)
+	    break;
+      }
+      
+      if (map->part[0] != 0)
+	 strcat(map->part,",");
+      
+      if (count != 1)
+	 sprintf(map->part+strlen(map->part),"%u*[%s]",count,
+		 mtd_JEDEC_table[J].name);
+      else
+	 sprintf(map->part+strlen(map->part),"%s",
+		 mtd_JEDEC_table[J].name);
+      count = 1;
+   }   
+   return 0;
+}
+									/*}}}*/
+
+// flash_failed - Print a console message about why the failure		/*{{{*/
+// ---------------------------------------------------------------------
+/* Pass the flags value that the flash return before it re-entered read 
+   mode. */
+static void flash_failed(unsigned char code)
+{
+   /* Bit 5 being high indicates that there was an internal device
+      failure, erasure time limits exceeded or something */
+   if ((code & (1 << 5)) != 0)
+   {
+      printk("mtd: Internal Flash failure\n");
+      return;
+   }
+   printk("mtd: Programming didn't take\n");
+}
+									/*}}}*/
+// flash_erase - Generic erase function					/*{{{*/
+// ---------------------------------------------------------------------
+/* This uses the erasure function described in the AMD Flash Handbook, 
+   it will work for flashes with a fixed sector size only. Flashes with
+   a selection of sector sizes (ie the AMD Am29F800B) will need a different
+   routine. This routine tries to parallize erasing multiple chips/sectors 
+   where possible */
+int flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+   unsigned long Time = 0;
+   unsigned long NoTime = 0;
+   unsigned long start = instr->addr, len = instr->len;
+   unsigned int I;
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+
+   // Verify the arguments..
+   if (start + len > map->mtd.size ||
+       (start % map->mtd.erasesize) != 0 ||
+       (len % map->mtd.erasesize) != 0 ||
+       (len/map->mtd.erasesize) == 0)
+      return -EINVAL;
+   
+   flash_chip_scan(map,start,len);
+
+   // Start the erase sequence on each chip
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      unsigned long off;
+      struct flash_chip *chip = map->chips + I;
+      unsigned long base;
+      unsigned long flags;
+      
+      if (chip->length == 0)
+	 continue;
+      
+      if (page_jump(map,chip->base + chip->start,0x555,&base,0) != 0)
+	 return -EIO;
+      
+      // Send the erase setup code
+      writeb(0xF0,base + 0x555);
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+      writeb(0x80,base + 0x555);
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+
+      // Use chip erase if possible
+      if (chip->start == 0 && chip->length == chip->size)
+      {
+	 writeb(0x10,base+0x555);
+	 continue;
+      }
+            
+      /* Once we start selecting the erase sectors the delay between each 
+         command must not exceed 50us or it will immediately start erasing 
+         and ignore the other sectors */
+      save_flags(flags);
+      cli();
+      for (off = 0; off < chip->length; off += chip->sectorsize)
+      {
+	 if (page_jump(map,chip->base + chip->start + off,1,&base,0) != 0)
+	    return -EIO;
+	 
+	 // Check to make sure we didn't timeout
+	 writeb(0x30,base);
+	 if ((readb(base) & (1 << 3)) != 0)
+	 {
+	    printk("mtd: Ack! We timed out the erase timer!\n");
+	    return -EIO;
+	 }       	 
+      }
+      restore_flags(flags);
+   }   
+
+   /* We could split this into a timer routine and return early, performing
+      background erasure.. Maybe later if the need warrents */
+   
+   /* Poll the flash for erasure completion, specs say this can take as long
+      as 480 seconds to do all the sectors (for a 2 meg flash). 
+      Erasure time is dependant on chip age, temp and wear.. */
+   Time = 0;
+   NoTime = 0;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      struct flash_chip *chip = map->chips + I;
+      unsigned long base;
+      unsigned long off = 0;
+      if (chip->length == 0)
+	 continue;
+      
+      if (page_jump(map,chip->base + chip->start,1,&base,0) != 0)
+	 return -EIO;
+      
+      while (1)
+      {
+	 unsigned char Last[4];
+	 unsigned long Count = 0;
+	 
+	 /* During erase bit 7 is held low and bit 6 toggles, we watch this,
+	    should it stop toggling or go high then the erase is completed,
+  	    or this is not really flash ;> */
+	 Last[0] = readb(base);
+	 Last[1] = readb(base);
+	 Last[2] = readb(base);
+	 for (Count = 3; (Last[(Count - 1) % 4] & (1 << 7)) == 0 && 
+	      Last[(Count - 1) % 4] != Last[(Count - 2) % 4]; Count++)
+	 {
+	    if (NoTime == 0)
+	       Time += HZ/10 - schedule_timeout(HZ/10);
+	    NoTime = 0;
+	    
+	    Last[Count % 4] = readb(base);
+	 
+	    // Count time, max of 15s per sector (according to AMD)
+	    if (Time > 15*len/mtd->erasesize*HZ)
+	    {
+	       printk("mtd: Flash Erase Timed out\n");
+	       return -EIO;
+	    }	    
+	 }
+	 
+	 if (Last[(Count - 1) % 4] == Last[(Count - 2) % 4])
+	 {
+	    flash_failed(Last[(Count - 3) % 4]);
+	    return -EIO;
+	 }
+	 
+	 // Skip to the next chip if we used chip erase
+	 if (chip->length == chip->size)
+	    off = chip->size;
+	 else
+	    off += chip->sectorsize;
+	 
+	 if (off >= chip->length)
+	    break;
+	 if (page_jump(map,chip->base + chip->start + off,1,&base,0) != 0)
+	    return -EIO;	 
+	 NoTime = 1;
+      }      
+   }
+       	 
+   // Paranoid verify of erasure
+   {
+      unsigned long base;
+      unsigned long buflen;
+      while (len > 0)
+      {
+	 unsigned long step;
+	 
+	 if (page_jump(map,start,len,&base,&buflen) != 0)
+	    return -EIO;
+	 start += buflen;
+	 len -= buflen;
+	 step = buflen/128;
+	 for (;buflen != 0; buflen -= step)
+	 {
+	    if (readb(base+buflen-1) != 0xFF)
+	    {
+	       printk("mtd: Flash Erase didn't take %lu %lu %lu\n",buflen,len,start);
+	       return -EIO;
+	    }
+	 }	 
+      }      
+   }   
+   
+   return 0;
+}
+#if 1
+									/*}}}*/
+// flash_write - Generic writing function				/*{{{*/
+// ---------------------------------------------------------------------
+/* This could do parallel writes on multiple chips but doesnt, memory 
+   constraints make that infeasable. This should work with any sort of 
+   linear flash that is not interleved */
+extern int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   unsigned long base;
+   unsigned long off;
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Compute the page offset and reposition
+      base = map->page(map,(u_long)start/map->pagesize);
+      off = (u_long)start %  map->pagesize;
+
+      // Loop over this page
+      for (; off != map->pagesize && len != 0; start++, len--, off++,buf++)
+      {
+	 unsigned char oldbyte = readb(base+off);
+	 unsigned char Last[4];
+	 unsigned long Count = 0;
+
+	 if (oldbyte == *buf)
+	    continue;
+	 if (((~oldbyte) & *buf) != 0)
+	    printk("mtd: warn: Trying to set a 0 to a 1\n");
+	     
+	 // Write
+	 writeb(0xAA,base + 0x555);
+	 writeb(0x55,base + 0x2AA);
+	 writeb(0xA0,base + 0x555);
+	 writeb(*buf,base + off);
+	 Last[0] = readb(base + off);
+	 Last[1] = readb(base + off);
+	 Last[2] = readb(base + off);
+	 
+	 /* Wait for the flash to finish the operation. We store the last 4
+	    status bytes that have been retrieved so we can determine why
+	    it failed. The toggle bits keep toggling when there is a 
+	    failure */
+	 for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] &&
+	      Count < 10000; Count++)
+	    Last[Count % 4] = readb(base + off);
+	 if (Last[(Count - 1) % 4] != *buf)
+	 {
+	    flash_failed(Last[(Count - 3) % 4]);
+	    return -EIO;
+	 }	 
+      }
+   }
+   *retlen = len;
+   return 0;
+}
+#endif
+
+// ram_write - Generic writing function	for ram				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+extern int ram_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   unsigned long base;
+   size_t origlen = len;
+   unsigned long buflen;
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Reposition..
+      if (page_jump(map,start,len,&base,&buflen) != 0)
+	 return -EIO;
+      
+      // Copy
+      memcpy_toio(base,buf,buflen);
+      len -= buflen;
+      start += buflen;
+   }
+   *retlen = origlen;
+   return 0;
+}
+
+// rom_read - Read handler for any sort of device			/*{{{*/
+// ---------------------------------------------------------------------
+/* This is a generic read function that should work with any device in the
+   mapped region. */
+extern int rom_read(struct mtd_info *mtd, loff_t start, size_t len,
+		    size_t *retlen, u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   size_t origlen = len;
+   unsigned long base;
+   unsigned long buflen;
+
+   printk("Rom_Read\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Reposition..
+      if (page_jump(map,start,len,&base,&buflen) != 0)
+	 return -EIO;
+      
+      // Copy
+      memcpy_fromio(buf,base,buflen);
+      len -= buflen;
+      start += buflen;
+   }
+   *retlen = origlen;
+   return 0;
+}
+
+// page_jump - Move the window and return the buffer			/*{{{*/
+// ---------------------------------------------------------------------
+/* Unlike the page function this returns a buffer and length adjusted for
+   the page dimensions and the reading offset into the page, simplifies
+   many of the other routines */
+int page_jump(struct mapped_mtd_info *map,unsigned long start,
+	      unsigned long len,unsigned long *base,
+	      unsigned long *retlen)
+{
+   DEBUG(MTD_DEBUG_LEVEL1,"Page Jump\n");
+   if (start > map->mtd.size || start + len > map->mtd.size)
+      return -EINVAL;
+      
+   *base = map->page(map,start/map->pagesize);
+   if (*base == 0)
+      return -EIO;
+
+   *base += start % map->pagesize;
+
+   // If retlen is 0 that mean the caller requires len bytes, no quibbling.
+   if (retlen == 0)
+   {
+      if (len > map->pagesize  - (start % map->pagesize))
+	 return -EIO;
+      return 0;
+   }
+   
+   // Compute the buffer paramaters and return
+   if (len > map->pagesize - (start % map->pagesize))
+      *retlen = map->pagesize - (start % map->pagesize);
+   else
+      *retlen = len;
+   return 0;
+}
+									/*}}}*/
+// flash_chip_scan - Intersect a region with the flash chip structure	/*{{{*/
+// ---------------------------------------------------------------------
+/* This is used to enhance the speed of the erase routine,
+   when things are being done to multiple chips it is possible to
+   parallize the operations, particularly full memory erases of multi
+   chip memories benifit */
+
+void flash_chip_scan(struct mapped_mtd_info *map,unsigned long start,
+		     unsigned long len)
+{
+   unsigned int I = 0;
+
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   // Zero the records
+   for (I = 0; map->chips[I].jedec != 0; I++)
+      map->chips[I].start = map->chips[I].length = 0;
+   
+   // Intesect our region with the chip structures
+   for (I = 0; map->chips[I].jedec != 0 && len != 0; I++)
+   {
+      // Havent found the start yet
+      if (start >= map->chips[I].base + map->chips[I].size)
+	 continue;
+
+      // Store the portion of this chip that is being effected
+      map->chips[I].start = start - map->chips[I].base;
+      if (len <= map->chips[I].size - map->chips[I].start)
+	 map->chips[I].length = len;
+      else
+	 map->chips[I].length = map->chips[I].size - map->chips[I].start;
+      len -= map->chips[I].length;
+      start = map->chips[I].base + map->chips[I].size;
+   }
+}
+									/*}}}*/
+
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/Config.in linux-2.4.2/drivers/mtd/maps/Config.in
--- linux-2.4.2.orig/drivers/mtd/maps/Config.in	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/Config.in	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,78 @@
+# drivers/mtd/maps/Config.in
+
+# $Id: Config.in,v 1.25 2002/01/21 18:09:02 rkaiser Exp $
+
+mainmenu_option next_comment
+
+comment 'Mapping drivers for chip access'
+
+dep_tristate '  CFI Flash device in physical memory map' CONFIG_MTD_PHYSMAP $CONFIG_MTD_GEN_PROBE
+if [ "$CONFIG_MTD_PHYSMAP" = "y" -o "$CONFIG_MTD_PHYSMAP" = "m" ]; then
+   hex '    Physical start address of flash mapping' CONFIG_MTD_PHYSMAP_START 0x8000000
+   hex '    Physical length of flash mapping' CONFIG_MTD_PHYSMAP_LEN 0x4000000
+   int '    Bus width in octets' CONFIG_MTD_PHYSMAP_BUSWIDTH 2
+fi
+
+if [ "$CONFIG_SPARC" = "y" -o "$CONFIG_SPARC64" = "y" ]; then
+   dep_tristate '  Sun Microsystems userflash support' CONFIG_MTD_SUN_UFLASH $CONFIG_MTD_CFI
+fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   dep_tristate '  CFI Flash device mapped on Photron PNC-2000' CONFIG_MTD_PNC2000 $CONFIG_MTD_CFI $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on AMD SC520 CDP' CONFIG_MTD_SC520CDP $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on AMD NetSc520'  CONFIG_MTD_NETSC520 $CONFIG_MTD_CFI $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on Arcom SBC-GXx boards' CONFIG_MTD_SBC_GXX $CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on Arcom ELAN-104NC' CONFIG_MTD_ELAN_104NC $CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on DIL/Net PC' CONFIG_MTD_DILNETPC $CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_PARTITIONS
+   dep_tristate '  JEDEC Flash device mapped on Mixcom piggyback card' CONFIG_MTD_MIXMEM $CONFIG_MTD_JEDEC
+   dep_tristate '  JEDEC Flash device mapped on Octagon 5066 SBC' CONFIG_MTD_OCTAGON $CONFIG_MTD_JEDEC
+   dep_tristate '  JEDEC Flash device mapped on Tempustech VMAX SBC301' CONFIG_MTD_VMAX $CONFIG_MTD_JEDEC
+   dep_tristate '  BIOS flash chip on Intel L440GX boards' CONFIG_MTD_L440GX $CONFIG_MTD_JEDECPROBE
+   dep_tristate ' ROM connected to AMD766 southbridge' CONFIG_MTD_AMD766ROM $CONFIG_MTD_GEN_PROBE   
+   dep_tristate ' ROM connected to Intel Hub Controller 2' CONFIG_MTD_ICH2ROM $CONFIG_MTD_JEDECPROBE
+fi
+
+if [ "$CONFIG_PPC" = "y" ]; then
+   dep_tristate '  CFI Flash device mapped on TQM8XXL' CONFIG_MTD_TQM8XXL $CONFIG_MTD_CFI $CONFIG_TQM8xxL
+   dep_tristate '  CFI Flash device mapped on RPX Lite or CLLF' CONFIG_MTD_RPXLITE $CONFIG_MTD_CFI
+   dep_tristate '  System flash on MBX860 board' CONFIG_MTD_MBX860 $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on D-Box2' CONFIG_MTD_DBOX2 $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapping on FlagaDM' CONFIG_MTD_CFI_FLAGADM $CONFIG_MTD_CFI
+fi
+
+if [ "$CONFIG_MIPS" = "y" ]; then
+   dep_tristate '  Alchemy Pb1000 boot flash device' CONFIG_MTD_PB1000 $CONFIG_MIPS_PB1000
+   dep_tristate '  Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board' CONFIG_MTD_CSTM_MIPS_IXX $CONFIG_MTD_CFI $CONFIG_MTD_JEDEC $CONFIG_MTD_PARTITIONS 
+   if [ "$CONFIG_MTD_CSTM_MIPS_IXX" = "y" -o "$CONFIG_MTD_CSTM_MIPS_IXX" = "m" ]; then
+      hex '    Physical start address of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_START 0x8000000
+      hex '    Physical length of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_LEN 0x4000000
+      int '    Bus width in octets' CONFIG_MTD_CSTM_MIPS_IXX_BUSWIDTH 2
+   fi
+   dep_tristate '  Momenco Ocelot boot flash device' CONFIG_MTD_OCELOT $CONFIG_MOMENCO_OCELOT
+fi
+
+if [ "$CONFIG_SUPERH" = "y" ]; then
+   dep_tristate '  CFI Flash device mapped on Hitachi SolutionEngine' \
+      CONFIG_MTD_SOLUTIONENGINE $CONFIG_MTD_PARTITIONS $CONFIG_MTD_CFI
+   if [ "$CONFIG_MTD_SOLUTIONENGINE" != "n" ]; then
+      hex '  Default reserved Flash size'  CONFIG_MTD_SUPERH_RESERVE 0x00010000
+   fi
+fi
+
+if [ "$CONFIG_ARM" = "y" ]; then
+   dep_tristate '  CFI Flash device mapped on Nora' CONFIG_MTD_NORA $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on ARM Integrator/P720T' CONFIG_MTD_ARM_INTEGRATOR $CONFIG_MTD_CFI
+   dep_tristate '  Cirrus CDB89712 evaluation board mappings' CONFIG_MTD_CDB89712 $CONFIG_MTD_CFI $CONFIG_ARCH_CDB89712
+   dep_tristate '  CFI Flash device mapped on StrongARM SA11x0' CONFIG_MTD_SA1100 $CONFIG_MTD_CFI $CONFIG_ARCH_SA1100 $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on DC21285 Footbridge' CONFIG_MTD_DC21285 $CONFIG_MTD_CFI $CONFIG_ARCH_FOOTBRIDGE $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on the XScale IQ80310 board' CONFIG_MTD_IQ80310 $CONFIG_MTD_CFI $CONFIG_ARCH_IQ80310
+   dep_tristate '  CFI Flash device mapped on Epxa10db' CONFIG_MTD_EPXA10DB $CONFIG_MTD_CFI  $CONFIG_MTD_PARTITIONS $CONFIG_ARCH_CAMELOT
+fi
+if [ "$CONFIG_ALPHA" = "y" ]; then
+   dep_tristate '  Flash chip mapping on TSUNAMI' CONFIG_MTD_TSUNAMI $CONFIG_MTD_GENPROBE
+fi
+
+# This needs CFI or JEDEC, depending on the cards found.
+dep_tristate '  PCI MTD driver' CONFIG_MTD_PCI $CONFIG_MTD $CONFIG_PCI
+
+endmenu
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/GNUmakefile linux-2.4.2/drivers/mtd/maps/GNUmakefile
--- linux-2.4.2.orig/drivers/mtd/maps/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/GNUmakefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,43 @@
+# $Id: GNUmakefile,v 1.8 2001/06/23 19:32:20 dwmw2 Exp $
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+
+# CONFIG_MTD_ARM := m
+CONFIG_MTD_CFI_FLAGADM := m
+# CONFIG_MTD_CSTM_MIPS_IXX := m
+# CONFIG_MTD_DC21285 := m
+CONFIG_MTD_ELAN_104NC := m
+CONFIG_MTD_IQ80310 := m
+CONFIG_MTD_L440GX := m
+CONFIG_MTD_NORA := m
+CONFIG_MTD_OCTAGON := m
+CONFIG_MTD_PHYSMAP := m
+CONFIG_MTD_PNC2000 := m
+CONFIG_MTD_RPXLITE := m
+# CONFIG_MTD_SA1100 := m
+CONFIG_MTD_SBC_GXX := m
+CONFIG_MTD_SC520CDP := m
+CONFIG_MTD_NETSC520 := m
+# CONFIG_MTD_SUN_UFLASH := m
+CONFIG_MTD_VMAX := m
+CONFIG_MTD_DBOX2 := m
+
+CFLAGS_physmap.o := -DCONFIG_MTD_PHYSMAP_START=0x8000000 -DCONFIG_MTD_PHYSMAP_LEN=0x4000000 -DCONFIG_MTD_PHYSMAP_BUSWIDTH=2
+CFLAGS_cstmmap.o := -DCONFIG_MTD_CSTM_MIPS_IXX_START=0x8000000 -DCONFIG_MTD_CSTM_MIPS_IXX_LEN=0x4000000 -DCONFIG_MTD_CSTM_MIPS_IXX_BUSWIDTH=2
+endif
+
+# Normal case - build in-kernel
+
+ifeq ($(VERSION),2)
+ ifneq ($(PATCHLEVEL),4)
+  ifneq ($(PATCHLEVEL),5)
+   OLDTOPDIR := $(TOPDIR)
+   TOPDIR := $(shell pwd)/..
+  endif
+ endif
+endif
+
+include Makefile
+
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/Makefile linux-2.4.2/drivers/mtd/maps/Makefile
--- linux-2.4.2.orig/drivers/mtd/maps/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/Makefile	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,41 @@
+#
+# linux/drivers/maps/Makefile
+#
+# $Id: Makefile,v 1.19 2002/01/21 18:09:02 rkaiser Exp $
+
+O_TARGET	:= mapslink.o
+
+# Chip mappings
+obj-$(CONFIG_MTD_CDB89712)      += cdb89712.o
+obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
+obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
+obj-$(CONFIG_MTD_CSTM_MIPS_IXX) += cstm_mips_ixx.o
+obj-$(CONFIG_MTD_DC21285)       += dc21285.o
+obj-$(CONFIG_MTD_DILNETPC)      += dilnetpc.o
+obj-$(CONFIG_MTD_ELAN_104NC)    += elan-104nc.o
+obj-$(CONFIG_MTD_EPXA10DB)      += epxa10db-flash.o
+obj-$(CONFIG_MTD_IQ80310)	+= iq80310.o
+obj-$(CONFIG_MTD_L440GX)	+= l440gx.o
+obj-$(CONFIG_MTD_AMD766ROM)	+= amd766rom.o
+obj-$(CONFIG_MTD_ICH2ROM)	+= ich2rom.o
+obj-$(CONFIG_MTD_TSUNAMI)	+= tsunami_flash.o
+obj-$(CONFIG_MTD_MBX860)	+= mbx860.o
+obj-$(CONFIG_MTD_NORA)		+= nora.o
+obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
+obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o 
+obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o
+obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
+obj-$(CONFIG_MTD_TQM8XXL)	+= tqm8xxl.o
+obj-$(CONFIG_MTD_SA1100)        += sa1100-flash.o
+obj-$(CONFIG_MTD_SBC_GXX)	+= sbc_gxx.o
+obj-$(CONFIG_MTD_SC520CDP)	+= sc520cdp.o
+obj-$(CONFIG_MTD_NETSC520)	+= netsc520.o
+obj-$(CONFIG_MTD_SUN_UFLASH)    += sun_uflash.o
+obj-$(CONFIG_MTD_VMAX)		+= vmax301.o
+obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
+obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
+obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
+obj-$(CONFIG_MTD_PCI)		+= pci.o
+obj-$(CONFIG_MTD_PB1000)        += pb1xxx-flash.o
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/amd766rom.c linux-2.4.2/drivers/mtd/maps/amd766rom.c
--- linux-2.4.2.orig/drivers/mtd/maps/amd766rom.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/amd766rom.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,245 @@
+/*
+ * amd766rom.c
+ *
+ * Normal mappings of chips in physical memory
+ * $Id: amd766rom.c,v 1.1 2002/01/10 22:59:13 eric Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+
+
+struct amd766rom_map_info {
+	struct map_info map;
+	struct mtd_info *mtd;
+	unsigned long window_addr;
+	u32 window_start, window_size;
+	struct pci_dev *pdev;
+};
+
+static __u8 amd766rom_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+static __u16 amd766rom_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+static __u32 amd766rom_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+static void amd766rom_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+static void amd766rom_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void amd766rom_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void amd766rom_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void amd766rom_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct amd766rom_map_info amd766rom_map = {
+	map: {
+		name: "AMD766 rom",
+		size: 0,
+		buswidth: 1,
+		read8: amd766rom_read8,
+		read16: amd766rom_read16,
+		read32: amd766rom_read32,
+		copy_from: amd766rom_copy_from,
+		write8: amd766rom_write8,
+		write16: amd766rom_write16,
+		write32: amd766rom_write32,
+		copy_to: amd766rom_copy_to,
+		/* The standard rom socket is for single power supply chips
+		 * that don't have an extra vpp.
+		 */
+	},
+	mtd: 0,
+	window_addr: 0,
+};
+
+static int __devinit amd766rom_init_one (struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	struct rom_window {
+		u32 start;
+		u32 size;
+		u8 segen_bits;
+	};
+	static struct rom_window rom_window[] = {
+		{ 0xffb00000, 5*1024*1024, (1<<7) | (1<<6), },
+		{ 0xffc00000, 4*1024*1024, (1<<7), },
+		{ 0xffff0000, 64*1024,     0 },
+		{ 0         , 0,           0 },
+	};
+	static const u32 rom_probe_sizes[] = { 
+		5*1024*1024, 4*1024*1024, 2*1024*1024, 1024*1024, 512*1024, 
+		256*1024, 128*1024, 64*1024, 0};
+	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", 0 };
+	u8 byte;
+	struct amd766rom_map_info *info = &amd766rom_map;
+	struct rom_window *window;
+	int i;
+	u32 rom_size;
+
+	window = &rom_window[0];
+	while(window->size) {
+		if (request_mem_region(window->start, window->size, "amd766rom")) {
+			break;
+		}
+		window++;
+	}
+	if (!window->size) {
+		printk(KERN_ERR "amd766rom: cannot reserve rom window");
+		goto err_out_none;
+	}
+
+	/* Enable the selected rom window */
+	pci_read_config_byte(pdev, 0x43, &byte);
+	pci_write_config_byte(pdev, 0x43, byte | window->segen_bits);
+
+	/* Enable writes through the rom window */
+	pci_read_config_byte(pdev, 0x40, &byte);
+	pci_write_config_byte(pdev, 0x40, byte | 1);
+
+	/* FIXME handle registers 0x80 - 0x8C the bios region locks */
+
+	printk(KERN_NOTICE "amd766rom window : %x at %x\n", 
+		window->size, window->start);
+	/* For write accesses caches are useless */
+	info->window_addr = (unsigned long)ioremap_nocache(window->start, window->size);
+
+	if (!info->window_addr) {
+		printk(KERN_ERR "Failed to ioremap\n");
+		goto err_out_free_mmio_region;
+	}
+	info->mtd = 0;
+	for(i = 0; (rom_size = rom_probe_sizes[i]); i++) {
+		char **chip_type;
+		if (rom_size > window->size) {
+			continue;
+		}
+		info->map.map_priv_1 = 
+			info->window_addr + window->size - rom_size;
+		info->map.size = rom_size;
+		chip_type = rom_probe_types;
+		for(; !info->mtd && *chip_type; chip_type++) {
+			info->mtd = do_map_probe(*chip_type, &amd766rom_map.map);
+		}
+		if (info->mtd) {
+			break;
+		}
+	}
+	if (!info->mtd) {
+		goto err_out_iounmap;
+	}
+	printk(KERN_NOTICE "amd766rom chip at offset: %x\n",
+		window->size - rom_size);
+		
+	info->mtd->module = THIS_MODULE;
+	add_mtd_device(info->mtd);
+	info->window_start = window->start;
+	info->window_size = window->size;
+	return 0;
+
+err_out_iounmap:
+	iounmap((void *)(info->window_addr));
+err_out_free_mmio_region:
+	release_mem_region(window->start, window->size);
+err_out_none:
+	return -ENODEV;
+}
+
+
+static void __devexit amd766rom_remove_one (struct pci_dev *pdev)
+{
+	struct amd766rom_map_info *info = &amd766rom_map;
+	u8 byte;
+
+	del_mtd_device(info->mtd);
+	map_destroy(info->mtd);
+	info->mtd = 0;
+	info->map.map_priv_1 = 0;
+
+	iounmap((void *)(info->window_addr));
+	info->window_addr = 0;
+
+	/* Disable writes through the rom window */
+	pci_read_config_byte(pdev, 0x40, &byte);
+	pci_write_config_byte(pdev, 0x40, byte & ~1);
+	
+	release_mem_region(info->window_start, info->window_size);
+}
+
+static struct pci_device_id amd766rom_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_7410, 
+	  PCI_ANY_ID, PCI_ANY_ID, },
+};
+
+MODULE_DEVICE_TABLE(pci, amd766rom_pci_tbl);
+
+#if 0
+static struct pci_driver amd766rom_driver = {
+	name:	  "amd766rom",
+	id_table: amd766rom_pci_tbl,
+	probe:    amd766rom_init_one,
+	remove:   amd766rom_remove_one,
+};
+#endif
+
+int __init init_amd766rom(void)
+{
+	struct pci_dev *pdev;
+	pdev = pci_find_device(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_7410, 0);
+	if (pdev) {
+		amd766rom_map.pdev = pdev;
+		return amd766rom_init_one(pdev, &amd766rom_pci_tbl[0]);
+	}
+	return -ENXIO;
+#if 0
+	return pci_module_init(&amd766rom_driver);
+#endif
+}
+
+static void __exit cleanup_amd766rom(void)
+{
+	amd766rom_remove_one(amd766rom_map.pdev);
+}
+
+module_init(init_amd766rom);
+module_exit(cleanup_amd766rom);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Eric Biederman <ebiederman@lnxi.com>");
+MODULE_DESCRIPTION("MTD map driver for BIOS chips on the AMD766 southbridge");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/cdb89712.c linux-2.4.2/drivers/mtd/maps/cdb89712.c
--- linux-2.4.2.orig/drivers/mtd/maps/cdb89712.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/cdb89712.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,333 @@
+/*
+ * Flash on Cirrus CDB89712
+ *
+ * $Id: cdb89712.c,v 1.3 2001/10/02 15:14:43 rmk Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+
+__u8 cdb89712_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 cdb89712_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 cdb89712_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void cdb89712_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cdb89712_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cdb89712_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cdb89712_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	// printk ("cdb89712_copy_from: 0x%x@0x%x -> 0x%x\n", len, from, to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cdb89712_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	while(len) {
+		__raw_writeb(*(unsigned char *) from, map->map_priv_1 + to);
+		from++;
+		to++;
+		len--;
+	}
+}
+
+
+static struct mtd_info *flash_mtd;
+
+struct map_info cdb89712_flash_map = {
+	name: "flash",
+	size: FLASH_SIZE,
+	buswidth: FLASH_WIDTH,
+	read8: cdb89712_read8,
+	read16: cdb89712_read16,
+	read32: cdb89712_read32,
+	copy_from: cdb89712_copy_from,
+	write8: cdb89712_write8,
+	write16: cdb89712_write16,
+	write32: cdb89712_write32,
+	copy_to: cdb89712_copy_to
+};
+
+struct resource cdb89712_flash_resource = {
+	name:   "Flash",
+	start:  FLASH_START,
+	end:    FLASH_START + FLASH_SIZE - 1,
+	flags:  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_flash (void)
+{
+	int err;
+	
+	if (request_resource (&ioport_resource, &cdb89712_flash_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 FLASH space\n");
+		err = -EBUSY;
+		goto out;
+	}
+	
+	cdb89712_flash_map.map_priv_1 = (unsigned long)ioremap(FLASH_START, FLASH_SIZE);
+	if (!cdb89712_flash_map.map_priv_1) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 FLASH space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+
+	flash_mtd = do_map_probe("cfi_probe", &cdb89712_flash_map);
+	if (!flash_mtd) {
+		flash_mtd = do_map_probe("map_rom", &cdb89712_flash_map);
+		if (flash_mtd)
+			flash_mtd->erasesize = 0x10000;
+	}
+	if (!flash_mtd) {
+		printk("FLASH probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	flash_mtd->module = THIS_MODULE;
+	
+	if (add_mtd_device(flash_mtd)) {
+		printk("FLASH device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+		
+	return 0;
+
+out_probe:
+	map_destroy(flash_mtd);
+	flash_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_flash_map.map_priv_1);
+out_resource:
+	release_resource (&cdb89712_flash_resource);
+out:
+	return err;
+}
+
+
+
+
+
+static struct mtd_info *sram_mtd;
+
+struct map_info cdb89712_sram_map = {
+	name: "SRAM",
+	size: SRAM_SIZE,
+	buswidth: SRAM_WIDTH,
+	read8: cdb89712_read8,
+	read16: cdb89712_read16,
+	read32: cdb89712_read32,
+	copy_from: cdb89712_copy_from,
+	write8: cdb89712_write8,
+	write16: cdb89712_write16,
+	write32: cdb89712_write32,
+	copy_to: cdb89712_copy_to
+};
+
+struct resource cdb89712_sram_resource = {
+	name:   "SRAM",
+	start:  SRAM_START,
+	end:    SRAM_START + SRAM_SIZE - 1,
+	flags:  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_sram (void)
+{
+	int err;
+	
+	if (request_resource (&ioport_resource, &cdb89712_sram_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 SRAM space\n");
+		err = -EBUSY;
+		goto out;
+	}
+	
+	cdb89712_sram_map.map_priv_1 = (unsigned long)ioremap(SRAM_START, SRAM_SIZE);
+	if (!cdb89712_sram_map.map_priv_1) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 SRAM space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+
+	sram_mtd = do_map_probe("map_ram", &cdb89712_sram_map);
+	if (!sram_mtd) {
+		printk("SRAM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	sram_mtd->module = THIS_MODULE;
+	sram_mtd->erasesize = 16;
+	
+	if (add_mtd_device(sram_mtd)) {
+		printk("SRAM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+		
+	return 0;
+
+out_probe:
+	map_destroy(sram_mtd);
+	sram_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_sram_map.map_priv_1);
+out_resource:
+	release_resource (&cdb89712_sram_resource);
+out:
+	return err;
+}
+
+
+
+
+
+
+
+static struct mtd_info *bootrom_mtd;
+
+struct map_info cdb89712_bootrom_map = {
+	name: "BootROM",
+	size: BOOTROM_SIZE,
+	buswidth: BOOTROM_WIDTH,
+	read8: cdb89712_read8,
+	read16: cdb89712_read16,
+	read32: cdb89712_read32,
+	copy_from: cdb89712_copy_from,
+};
+
+struct resource cdb89712_bootrom_resource = {
+	name:   "BootROM",
+	start:  BOOTROM_START,
+	end:    BOOTROM_START + BOOTROM_SIZE - 1,
+	flags:  IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_cdb89712_bootrom (void)
+{
+	int err;
+	
+	if (request_resource (&ioport_resource, &cdb89712_bootrom_resource)) {
+		printk(KERN_NOTICE "Failed to reserve Cdb89712 BOOTROM space\n");
+		err = -EBUSY;
+		goto out;
+	}
+	
+	cdb89712_bootrom_map.map_priv_1 = (unsigned long)ioremap(BOOTROM_START, BOOTROM_SIZE);
+	if (!cdb89712_bootrom_map.map_priv_1) {
+		printk(KERN_NOTICE "Failed to ioremap Cdb89712 BootROM space\n");
+		err = -EIO;
+		goto out_resource;
+	}
+
+	bootrom_mtd = do_map_probe("map_rom", &cdb89712_bootrom_map);
+	if (!bootrom_mtd) {
+		printk("BootROM probe failed\n");
+		err = -ENXIO;
+		goto out_ioremap;
+	}
+
+	bootrom_mtd->module = THIS_MODULE;
+	bootrom_mtd->erasesize = 0x10000;
+	
+	if (add_mtd_device(bootrom_mtd)) {
+		printk("BootROM device addition failed\n");
+		err = -ENOMEM;
+		goto out_probe;
+	}
+		
+	return 0;
+
+out_probe:
+	map_destroy(bootrom_mtd);
+	bootrom_mtd = 0;
+out_ioremap:
+	iounmap((void *)cdb89712_bootrom_map.map_priv_1);
+out_resource:
+	release_resource (&cdb89712_bootrom_resource);
+out:
+	return err;
+}
+
+
+
+
+
+static int __init init_cdb89712_maps(void)
+{
+
+       	printk(KERN_INFO "Cirrus CDB89712 MTD mappings:\n  Flash 0x%x at 0x%x\n  SRAM 0x%x at 0x%x\n  BootROM 0x%x at 0x%x\n", 
+	       FLASH_SIZE, FLASH_START, SRAM_SIZE, SRAM_START, BOOTROM_SIZE, BOOTROM_START);
+
+	init_cdb89712_flash();
+	init_cdb89712_sram();
+	init_cdb89712_bootrom();
+	
+	return 0;
+}
+	
+
+static void __exit cleanup_cdb89712_maps(void)
+{
+	if (sram_mtd) {
+		del_mtd_device(sram_mtd);
+		map_destroy(sram_mtd);
+		iounmap((void *)cdb89712_sram_map.map_priv_1);
+		release_resource (&cdb89712_sram_resource);
+	}
+	
+	if (flash_mtd) {
+		del_mtd_device(flash_mtd);
+		map_destroy(flash_mtd);
+		iounmap((void *)cdb89712_flash_map.map_priv_1);
+		release_resource (&cdb89712_flash_resource);
+	}
+
+	if (bootrom_mtd) {
+		del_mtd_device(bootrom_mtd);
+		map_destroy(bootrom_mtd);
+		iounmap((void *)cdb89712_bootrom_map.map_priv_1);
+		release_resource (&cdb89712_bootrom_resource);
+	}
+}
+
+module_init(init_cdb89712_maps);
+module_exit(cleanup_cdb89712_maps);
+
+MODULE_AUTHOR("Ray L");
+MODULE_DESCRIPTION("ARM CDB89712 map driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/cfi_flagadm.c linux-2.4.2/drivers/mtd/maps/cfi_flagadm.c
--- linux-2.4.2.orig/drivers/mtd/maps/cfi_flagadm.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/cfi_flagadm.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,184 @@
+/*
+ *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
+ *
+ *  $Id: cfi_flagadm.c,v 1.7 2001/10/02 15:05:13 dwmw2 Exp $
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+/* We split the flash chip up into four parts.
+ * 1: bootloader firts 128k			(0x00000000 - 0x0001FFFF) size 0x020000
+ * 2: kernel 640k					(0x00020000 - 0x000BFFFF) size 0x0A0000
+ * 3: compressed 1536k root ramdisk	(0x000C0000 - 0x0023FFFF) size 0x180000
+ * 4: writeable diskpartition (jffs)(0x00240000 - 0x003FFFFF) size 0x1C0000
+ */
+
+#define FLASH_PHYS_ADDR 0x40000000
+#define FLASH_SIZE 0x400000  
+
+#define FLASH_PARTITION0_ADDR 0x00000000
+#define FLASH_PARTITION0_SIZE 0x00020000
+
+#define FLASH_PARTITION1_ADDR 0x00020000
+#define FLASH_PARTITION1_SIZE 0x000A0000
+
+#define FLASH_PARTITION2_ADDR 0x000C0000
+#define FLASH_PARTITION2_SIZE 0x00180000
+
+#define FLASH_PARTITION3_ADDR 0x00240000
+#define FLASH_PARTITION3_SIZE 0x001C0000
+
+__u8 flagadm_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 flagadm_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 flagadm_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void flagadm_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void flagadm_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info flagadm_map = {
+		name: "FlagaDM flash device",
+		size: FLASH_SIZE,
+		buswidth: 2,
+		read8: flagadm_read8,
+		read16: flagadm_read16,
+		read32: flagadm_read32,
+		copy_from: flagadm_copy_from,
+		write8: flagadm_write8,
+		write16: flagadm_write16,
+		write32: flagadm_write32,
+		copy_to: flagadm_copy_to
+};
+
+struct mtd_partition flagadm_parts[] = {
+	{
+		name	: "Bootloader",
+		offset	: FLASH_PARTITION0_ADDR,
+		size	: FLASH_PARTITION0_SIZE
+	},
+	{
+		name	: "Kernel image",
+		offset	: FLASH_PARTITION1_ADDR,
+		size	: FLASH_PARTITION1_SIZE
+	},
+	{
+		name	: "Initial ramdisk image",
+		offset	: FLASH_PARTITION2_ADDR,
+		size	: FLASH_PARTITION2_SIZE
+	},
+	{	
+		name	: "Persistant storage",
+		offset	: FLASH_PARTITION3_ADDR,
+		size	: FLASH_PARTITION3_SIZE
+	}
+};
+
+#define PARTITION_COUNT (sizeof(flagadm_parts)/sizeof(struct mtd_partition))
+
+static struct mtd_info *mymtd;
+
+int __init init_flagadm(void)
+{	
+	printk(KERN_NOTICE "FlagaDM flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	flagadm_map.map_priv_1 = (unsigned long)ioremap(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!flagadm_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &flagadm_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, flagadm_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "FlagaDM flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)flagadm_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_flagadm(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (flagadm_map.map_priv_1) {
+		iounmap((void *)flagadm_map.map_priv_1);
+		flagadm_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_flagadm);
+module_exit(cleanup_flagadm);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kri Davsson <kd@flaga.is>");
+MODULE_DESCRIPTION("MTD map driver for Flaga digital module");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/cstm_mips_ixx.c linux-2.4.2/drivers/mtd/maps/cstm_mips_ixx.c
--- linux-2.4.2.orig/drivers/mtd/maps/cstm_mips_ixx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/cstm_mips_ixx.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,314 @@
+/*
+ * $Id: cstm_mips_ixx.c,v 1.5 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * Mapping of a custom board with both AMD CFI and JEDEC flash in partitions.
+ * Config with both CFI and JEDEC device support.
+ *
+ * Basically physmap.c with the addition of partitions and 
+ * an array of mapping info to accomodate more than one flash type per board.
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#include <linux/delay.h>
+#endif
+
+__u8 cstm_mips_ixx_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+__u16 cstm_mips_ixx_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+__u32 cstm_mips_ixx_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+void cstm_mips_ixx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cstm_mips_ixx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_mips_ixx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_mips_ixx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_mips_ixx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define CC_GCR             0xB4013818
+#define CC_GPBCR           0xB401380A
+#define CC_GPBDR           0xB4013808
+#define CC_M68K_DEVICE     1
+#define CC_M68K_FUNCTION   6
+#define CC_CONFADDR        0xB8004000
+#define CC_CONFDATA        0xB8004004
+#define CC_FC_FCR          0xB8002004
+#define CC_FC_DCR          0xB8002008
+#define CC_GPACR           0xB4013802
+#define CC_GPAICR          0xB4013804
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+void cstm_mips_ixx_set_vpp(struct map_info *map,int vpp)
+{
+  if (vpp) {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+        __u8	data1;
+	static u8 first = 1;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff0f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) | 0x08;
+	if (first) {
+		first = 0;
+		/* need to have this delay for first
+		   enabling vpp after powerup */
+		udelay(40);
+	}
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+  else {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff3f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) & 0xf7;
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+}
+
+const struct map_info basic_cstm_mips_ixx_map = {
+	NULL,
+	0,
+	0,
+	cstm_mips_ixx_read8,
+	cstm_mips_ixx_read16,
+	cstm_mips_ixx_read32,
+	cstm_mips_ixx_copy_from,
+	cstm_mips_ixx_write8,
+	cstm_mips_ixx_write16,
+	cstm_mips_ixx_write32,
+	cstm_mips_ixx_copy_to,
+        cstm_mips_ixx_set_vpp,
+	0,
+	0
+};
+
+/* board and partition description */
+
+#define MAX_PHYSMAP_PARTITIONS    8
+struct cstm_mips_ixx_info {
+	char *name;
+	unsigned long window_addr;
+	unsigned long window_size;
+	int buswidth;
+	int num_partitions;
+};
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define PHYSMAP_NUMBER  1  // number of board desc structs needed, one per contiguous flash type 
+const struct cstm_mips_ixx_info cstm_mips_ixx_board_desc[PHYSMAP_NUMBER] = 
+{
+    {   // 28F128J3A in 2x16 configuration
+        "big flash",     // name
+	0x08000000,      // window_addr
+	0x02000000,      // window_size
+        4,               // buswidth
+	1,               // num_partitions
+    }
+
+};
+static struct mtd_partition cstm_mips_ixx_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{   // 28F128J3A in 2x16 configuration
+	{
+		name: "main partition ",
+		size: 0x02000000, // 128 x 2 x 128k byte sectors
+		offset: 0,
+	},
+},
+};
+#else /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+#define PHYSMAP_NUMBER  1  // number of board desc structs needed, one per contiguous flash type 
+const struct cstm_mips_ixx_info cstm_mips_ixx_board_desc[PHYSMAP_NUMBER] = 
+{
+    {  
+        "MTD flash",                   // name
+	CONFIG_MTD_CSTM_MIPS_IXX_START,      // window_addr
+	CONFIG_MTD_CSTM_MIPS_IXX_LEN,        // window_size
+        CONFIG_MTD_CSTM_MIPS_IXX_BUSWIDTH,   // buswidth
+	1,                             // num_partitions
+    },
+
+};
+static struct mtd_partition cstm_mips_ixx_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{ 
+	{
+		name: "main partition",
+		size:  CONFIG_MTD_CSTM_MIPS_IXX_LEN,
+		offset: 0,
+	},
+},
+};
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+struct map_info cstm_mips_ixx_map[PHYSMAP_NUMBER];
+
+int __init init_cstm_mips_ixx(void)
+{
+	int i;
+	int jedec;
+        struct mtd_info *mymtd;
+        struct mtd_partition *parts;
+
+	/* Initialize mapping */
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+		printk(KERN_NOTICE "cstm_mips_ixx flash device: %lx at %lx\n", cstm_mips_ixx_board_desc[i].window_size, cstm_mips_ixx_board_desc[i].window_addr);
+                memcpy((char *)&cstm_mips_ixx_map[i],(char *)&basic_cstm_mips_ixx_map,sizeof(struct map_info));
+		cstm_mips_ixx_map[i].map_priv_1 = (unsigned long)ioremap(cstm_mips_ixx_board_desc[i].window_addr, cstm_mips_ixx_board_desc[i].window_size);
+		if (!cstm_mips_ixx_map[i].map_priv_1) {
+			printk(KERN_WARNING "Failed to ioremap\n");
+			return -EIO;
+	        }
+		cstm_mips_ixx_map[i].name = cstm_mips_ixx_board_desc[i].name;
+		cstm_mips_ixx_map[i].size = cstm_mips_ixx_board_desc[i].window_size;
+		cstm_mips_ixx_map[i].buswidth = cstm_mips_ixx_board_desc[i].buswidth;
+		//printk(KERN_NOTICE "cstm_mips_ixx: ioremap is %x\n",(unsigned int)(cstm_mips_ixx_map[i].map_priv_1));
+	}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        setup_ITE_IVR_flash();
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+                parts = &cstm_mips_ixx_partitions[i][0];
+		jedec = 0;
+		mymtd = (struct mtd_info *)do_map_probe("cfi_probe", &cstm_mips_ixx_map[i]);
+		//printk(KERN_NOTICE "phymap %d cfi_probe: mymtd is %x\n",i,(unsigned int)mymtd);
+		if (!mymtd) {
+			jedec = 1;
+			mymtd = (struct mtd_info *)do_map_probe("jedec", &cstm_mips_ixx_map[i]);
+		        printk(KERN_NOTICE "cstm_mips_ixx %d jedec: mymtd is %x\n",i,(unsigned int)mymtd);
+		}
+		if (mymtd) {
+			mymtd->module = THIS_MODULE;
+
+	                cstm_mips_ixx_map[i].map_priv_2 = (unsigned long)mymtd;
+		        add_mtd_partitions(mymtd, parts, cstm_mips_ixx_board_desc[i].num_partitions);
+		}
+		else
+	           return -ENXIO;
+	}
+	return 0;
+}
+
+static void __exit cleanup_cstm_mips_ixx(void)
+{
+	int i;
+        struct mtd_info *mymtd;
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+	        mymtd = (struct mtd_info *)cstm_mips_ixx_map[i].map_priv_2;
+		if (mymtd) {
+			del_mtd_partitions(mymtd);
+			map_destroy(mymtd);
+		}
+		if (cstm_mips_ixx_map[i].map_priv_1) {
+			iounmap((void *)cstm_mips_ixx_map[i].map_priv_1);
+			cstm_mips_ixx_map[i].map_priv_1 = 0;
+		}
+	}
+}
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+void PCISetULongByOffset(__u32 DevNumber, __u32 FuncNumber, __u32 Offset, __u32 data)
+{
+	__u32	offset;
+
+	offset = ( unsigned long )( 0x80000000 | ( DevNumber << 11 ) + ( FuncNumber << 8 ) + Offset) ;
+
+	*(__u32 *)CC_CONFADDR = offset;	
+	*(__u32 *)CC_CONFDATA = data;
+}
+void setup_ITE_IVR_flash()
+{
+		__u32	size, base;
+
+		size = 0x0e000000;		// 32MiB
+		base = (0x08000000) >> 8 >>1; // Bug: we must shift one more bit
+
+		/* need to set ITE flash to 32 bits instead of default 8 */
+#ifdef CONFIG_MIPS_IVR
+		*(__u32 *)CC_FC_FCR = 0x55;
+		*(__u32 *)CC_GPACR = 0xfffc;
+#else
+		*(__u32 *)CC_FC_FCR = 0x77;
+#endif
+		/* turn bursting off */
+		*(__u32 *)CC_FC_DCR = 0x0;
+
+		/* setup for one chip 4 byte PCI access */
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x60, size | base);
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x64, 0x02);
+}
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+module_init(init_cstm_mips_ixx);
+module_exit(cleanup_cstm_mips_ixx);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Alice Hennessy <ahennessy@mvista.com>");
+MODULE_DESCRIPTION("MTD map driver for ITE 8172G and Globespan IVR boards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/dbox2-flash.c linux-2.4.2/drivers/mtd/maps/dbox2-flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/dbox2-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/dbox2-flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,163 @@
+/*
+ * $Id: dbox2-flash.c,v 1.4 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * Nokia / Sagem D-Box 2 flash driver
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+
+static struct mtd_partition partition_info[]= {{name: "BR Bootloader",          // raw
+                                                      size: 128 * 1024,
+                                                      offset: 0,
+                                                      mask_flags: MTD_WRITEABLE},
+                                                     {name: "idxfs",
+                                                      size: 640 * 1024,
+                                                      offset: MTDPART_OFS_APPEND,
+                                                      mask_flags: 0},
+                                                     {name: "var ( JFFS2 )",
+                                                      size: 640 * 1024,
+                                                      offset: MTDPART_OFS_APPEND,
+                                                      mask_flags: 0},
+                                                     {name: "root ( CramFS )",
+                                                      size: 6144 * 1024,
+                                                      offset: MTDPART_OFS_APPEND,
+                                                      mask_flags: 0},
+                                                     {name: "ppcboot",
+                                                      size: 640 * 1024,
+                                                      offset: MTDPART_OFS_APPEND,
+                                                      mask_flags: 0},
+                                                     {name: "GesamtesFlashohneBL",
+                                                      size: MTDPART_SIZ_FULL,
+                                                      offset: 128 * 1024,
+                                                      mask_flags: 0}};
+
+
+
+
+
+#define NUM_PARTITIONS (sizeof(partition_info) / sizeof(partition_info[0]))
+
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x800000
+
+static struct mtd_info *mymtd;
+
+__u8 dbox2_flash_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 dbox2_flash_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 dbox2_flash_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void dbox2_flash_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void dbox2_flash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info dbox2_flash_map = {
+	name: "D-Box 2 flash memory",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: dbox2_flash_read8,
+	read16: dbox2_flash_read16,
+	read32: dbox2_flash_read32,
+	copy_from: dbox2_flash_copy_from,
+	write8: dbox2_flash_write8,
+	write16: dbox2_flash_write16,
+	write32: dbox2_flash_write32,
+	copy_to: dbox2_flash_copy_to
+};
+
+int __init init_dbox2_flash(void)
+{
+       	printk(KERN_NOTICE "D-Box 2 flash driver (size->0x%X mem->0x%X)\n", WINDOW_SIZE, WINDOW_ADDR);
+	dbox2_flash_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dbox2_flash_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	// Probe for dual Intel 28F320 or dual AMD
+	mymtd = do_map_probe("cfi_probe", &dbox2_flash_map);
+	if (!mymtd) {
+	    // Probe for single Intel 28F640
+	    dbox2_flash_map.buswidth = 2;
+	
+	    mymtd = do_map_probe("cfi_probe", &dbox2_flash_map);
+	}
+	    
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+                /* Create MTD devices for each partition. */
+	        add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
+		
+		return 0;
+	}
+
+	iounmap((void *)dbox2_flash_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dbox2_flash(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dbox2_flash_map.map_priv_1) {
+		iounmap((void *)dbox2_flash_map.map_priv_1);
+		dbox2_flash_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dbox2_flash);
+module_exit(cleanup_dbox2_flash);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kri Davsson <kd@flaga.is>");
+MODULE_DESCRIPTION("MTD map driver for Nokia/Sagem D-Box 2 board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/dc21285.c linux-2.4.2/drivers/mtd/maps/dc21285.c
--- linux-2.4.2.orig/drivers/mtd/maps/dc21285.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/dc21285.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,198 @@
+/*
+ * MTD map driver for flash on the DC21285 (the StrongARM-110 companion chip)
+ *
+ * (C) 2000  Nicolas Pitre <nico@cam.org>
+ *
+ * This code is GPL
+ * 
+ * $Id: dc21285.c,v 1.7 2001/10/11 16:17:51 nico Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/hardware/dec21285.h>
+
+
+static struct mtd_info *mymtd;
+
+__u8 dc21285_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8*)(map->map_priv_1 + ofs);
+}
+
+__u16 dc21285_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16*)(map->map_priv_1 + ofs);
+}
+
+__u32 dc21285_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32*)(map->map_priv_1 + ofs);
+}
+
+void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void*)(map->map_priv_1 + from), len);
+}
+
+void dc21285_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr & 3;
+	adr &= ~3;
+	*(__u8*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr & 3;
+	adr &= ~3;
+	*(__u16*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	switch (map->buswidth) {
+		case 4:
+			while (len > 0) {
+				__u32 d = *((__u32*)from)++;
+				dc21285_write32(map, d, to);
+				to += 4;
+				len -= 4;
+			}
+			break;
+		case 2:
+			while (len > 0) {
+				__u16 d = *((__u16*)from)++;
+				dc21285_write16(map, d, to);
+				to += 2;
+				len -= 2;
+			}
+			break;
+		case 1:
+			while (len > 0) {
+				__u8 d = *((__u8*)from)++;
+				dc21285_write8(map, d, to);
+				to++;
+				len--;
+			}
+			break;
+	}
+}
+
+struct map_info dc21285_map = {
+	name: "DC21285 flash",
+	size: 16*1024*1024,
+	read8: dc21285_read8,
+	read16: dc21285_read16,
+	read32: dc21285_read32,
+	copy_from: dc21285_copy_from,
+	write8: dc21285_write8,
+	write16: dc21285_write16,
+	write32: dc21285_write32,
+	copy_to: dc21285_copy_to
+};
+
+
+/* Partition stuff */
+static struct mtd_partition *dc21285_parts;
+		      
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+
+int __init init_dc21285(void)
+{
+	/* Determine buswidth */
+	switch (*CSR_SA110_CNTL & (3<<14)) {
+		case SA110_CNTL_ROMWIDTH_8: 
+			dc21285_map.buswidth = 1;
+			break;
+		case SA110_CNTL_ROMWIDTH_16: 
+			dc21285_map.buswidth = 2; 
+			break;
+		case SA110_CNTL_ROMWIDTH_32: 
+			dc21285_map.buswidth = 4; 
+			break;
+		default:
+			printk (KERN_ERR "DC21285 flash: undefined buswidth\n");
+			return -ENXIO;
+	}
+	printk (KERN_NOTICE "DC21285 flash support (%d-bit buswidth)\n",
+		dc21285_map.buswidth*8);
+
+	/* Let's map the flash area */
+	dc21285_map.map_priv_1 = (unsigned long)__ioremap(DC21285_FLASH, 16*1024*1024, 0);
+	if (!dc21285_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	mymtd = do_map_probe("cfi_probe", &dc21285_map);
+	if (mymtd) {
+		int nrparts;
+
+		mymtd->module = THIS_MODULE;
+			
+		/* partition fixup */
+
+		nrparts = parse_redboot_partitions(mymtd, &dc21285_parts);
+		if (nrparts <=0) {
+			printk(KERN_NOTICE "RedBoot partition table failed\n");
+			iounmap((void *)dc21285_map.map_priv_1);
+			return -ENXIO;
+		}
+
+		add_mtd_partitions(mymtd, dc21285_parts, nrparts);
+
+		/* 
+		 * Flash timing is determined with bits 19-16 of the
+		 * CSR_SA110_CNTL.  The value is the number of wait cycles, or
+		 * 0 for 16 cycles (the default).  Cycles are 20 ns.
+		 * Here we use 7 for 140 ns flash chips.
+		 */
+		/* access time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x000f0000) | (7 << 16));
+		/* burst time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x00f00000) | (7 << 20));
+		/* tristate time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x0f000000) | (7 << 24));
+
+		return 0;
+	}
+
+	iounmap((void *)dc21285_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dc21285(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+		mymtd = NULL;
+	}
+	if (dc21285_map.map_priv_1) {
+		iounmap((void *)dc21285_map.map_priv_1);
+		dc21285_map.map_priv_1 = 0;
+	}
+	if(dc21285_parts)
+		kfree(dc21285_parts);
+}
+
+module_init(init_dc21285);
+module_exit(cleanup_dc21285);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Pitre <nico@cam.org>");
+MODULE_DESCRIPTION("MTD map driver for DC21285 boards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/dilnetpc.c linux-2.4.2/drivers/mtd/maps/dilnetpc.c
--- linux-2.4.2.orig/drivers/mtd/maps/dilnetpc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/dilnetpc.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,437 @@
+/* dilnetpc.c -- MTD map driver for SSV DIL/Net PC Boards "DNP" and "ADNP"
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * $Id: dilnetpc.c,v 1.3 2002/01/21 18:37:50 rkaiser Exp $
+ *
+ * The DIL/Net PC is a tiny embedded PC board made by SSV Embedded Systems
+ * featuring the AMD Elan SC410 processor. There are two variants of this
+ * this board: DNP/1486 and ADNP/1486. The DNP version has 2 megs of flash
+ * ROM (Intel 28F016S3) and 8 megs of DRAM, the ADNP version has 4 megs
+ * flash and 16 megs of RAM.
+ * For details, see http://www.ssv-embedded.de/ssv/pc104/p169.htm
+ * and http://www.ssv-embedded.de/ssv/pc104/p170.htm
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+/*
+** The DIL/NetPC keeps it's BIOS in two distinct flash blocks.
+** Destroying any of these blocks transforms the DNPC into
+** a paperweight (albeit not a very useful one, considering
+** it only weighs a few grams).
+**
+** Therefore, the BIOS blocks must never be erased or written to
+** except by people who know exactly what they are doing (e.g.
+** to install a BIOS update). These partitions are marked read-only
+** by default, but can be made read/write by undefining
+** DNPC_BIOS_BLOCKS_WRITEABLE:
+*/
+#define DNPC_BIOS_BLOCKS_WRITEABLE
+
+/*
+** The ID string (in ROM) is checked to determine whether we
+** are running on a DNP/1486 or ADNP/1486
+*/
+#define BIOSID_BASE	0x000fe100
+
+#define ID_DNPC	"DNP1486"
+#define ID_ADNP	"ADNP1486"
+
+/*
+** Address where the flash should appear in CPU space
+*/
+#define FLASH_BASE	0x2000000
+
+/*
+** Chip Setup and Control (CSC) indexed register space
+*/
+#define CSC_INDEX	0x22
+#define CSC_DATA	0x23
+
+#define CSC_MMSWAR	0x30	/* MMS window C-F attributes register */
+#define CSC_MMSWDSR	0x31	/* MMS window C-F device select register */
+
+#define CSC_RBWR	0xa7	/* GPIO Read-Back/Write Register B */
+
+#define CSC_CR		0xd0	/* internal I/O device disable/Echo */
+				/* Z-bus/configuration register */
+
+#define CSC_PCCMDCR	0xf1	/* PC card mode and DMA control register */
+
+
+/*
+** PC Card indexed register space:
+*/
+
+#define PCC_INDEX	0x3e0
+#define PCC_DATA	0x3e1
+
+#define PCC_AWER_B		0x46	/* Socket B Address Window enable register */
+#define PCC_MWSAR_1_Lo	0x58	/* memory window 1 start address low register */
+#define PCC_MWSAR_1_Hi	0x59	/* memory window 1 start address high register */
+#define PCC_MWEAR_1_Lo	0x5A	/* memory window 1 stop address low register */
+#define PCC_MWEAR_1_Hi	0x5B	/* memory window 1 stop address high register */
+#define PCC_MWAOR_1_Lo	0x5C	/* memory window 1 address offset low register */
+#define PCC_MWAOR_1_Hi	0x5D	/* memory window 1 address offset high register */
+
+
+/*
+** Access to SC4x0's Chip Setup and Control (CSC)
+** and PC Card (PCC) indexed registers:
+*/
+static inline void setcsc(int reg, unsigned char data)
+{
+	outb(reg, CSC_INDEX);
+	outb(data, CSC_DATA);
+}
+
+static inline unsigned char getcsc(int reg)
+{
+	outb(reg, CSC_INDEX);
+	return(inb(CSC_DATA));
+}
+
+static inline void setpcc(int reg, unsigned char data)
+{
+	outb(reg, PCC_INDEX);
+	outb(data, PCC_DATA);
+}
+
+static inline unsigned char getpcc(int reg)
+{
+	outb(reg, PCC_INDEX);
+	return(inb(PCC_DATA));
+}
+
+
+/*
+************************************************************
+** Enable access to DIL/NetPC's flash by mapping it into
+** the SC4x0's MMS Window C.
+************************************************************
+*/
+static void dnpc_map_flash(unsigned long flash_base, unsigned long flash_size)
+{
+	unsigned long flash_end = flash_base + flash_size - 1;
+
+	/*
+	** enable setup of MMS windows C-F:
+	*/
+	/* - enable PC Card indexed register space */
+	setcsc(CSC_CR, getcsc(CSC_CR) | 0x2);
+	/* - set PC Card controller to operate in standard mode */
+	setcsc(CSC_PCCMDCR, getcsc(CSC_PCCMDCR) & ~1);
+
+	/*
+	** Program base address and end address of window
+	** where the flash ROM should appear in CPU address space
+	*/
+	setpcc(PCC_MWSAR_1_Lo, (flash_base >> 12) & 0xff);
+	setpcc(PCC_MWSAR_1_Hi, (flash_base >> 20) & 0x3f);
+	setpcc(PCC_MWEAR_1_Lo, (flash_end >> 12) & 0xff);
+	setpcc(PCC_MWEAR_1_Hi, (flash_end >> 20) & 0x3f);
+
+	/* program offset of first flash location to appear in this window (0) */
+	setpcc(PCC_MWAOR_1_Lo, ((0 - flash_base) >> 12) & 0xff);
+	setpcc(PCC_MWAOR_1_Hi, ((0 - flash_base)>> 20) & 0x3f);
+
+	/* set attributes for MMS window C: non-cacheable, write-enabled */
+	setcsc(CSC_MMSWAR, getcsc(CSC_MMSWAR) & ~0x11);
+
+	/* select physical device ROMCS0 (i.e. flash) for MMS Window C */
+	setcsc(CSC_MMSWDSR, getcsc(CSC_MMSWDSR) & ~0x03);
+
+	/* enable memory window 1 */
+	setpcc(PCC_AWER_B, getpcc(PCC_AWER_B) | 0x02);
+
+	/* now disable PC Card indexed register space again */
+	setcsc(CSC_CR, getcsc(CSC_CR) & ~0x2);
+}
+
+
+/*
+************************************************************
+** Disable access to DIL/NetPC's flash by mapping it into
+** the SC4x0's MMS Window C.
+************************************************************
+*/
+static void dnpc_unmap_flash(void)
+{
+	/* - enable PC Card indexed register space */
+	setcsc(CSC_CR, getcsc(CSC_CR) | 0x2);
+
+	/* disable memory window 1 */
+	setpcc(PCC_AWER_B, getpcc(PCC_AWER_B) & ~0x02);
+
+	/* now disable PC Card indexed register space again */
+	setcsc(CSC_CR, getcsc(CSC_CR) & ~0x2);
+}
+
+
+static __u8 dnpc_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 dnpc_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 dnpc_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void dnpc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void dnpc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void dnpc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void dnpc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void dnpc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+/*
+************************************************************
+** Enable/Disable VPP to write to flash
+************************************************************
+*/
+
+static spinlock_t dnpc_spin = SPIN_LOCK_UNLOCKED;
+
+/*
+** This is what has to be done for the DNP board ..
+*/
+static void dnp_set_vpp(struct map_info *not_used, int on)
+{
+	spin_lock_irq(&dnpc_spin);
+
+	if (on)
+		setcsc(CSC_RBWR, getcsc(CSC_RBWR) & ~0x4);
+	else
+		setcsc(CSC_RBWR, getcsc(CSC_RBWR) | 0x4);
+
+	spin_unlock_irq(&dnpc_spin);
+}
+
+/*
+** .. and this the ADNP version:
+*/
+static void adnp_set_vpp(struct map_info *not_used, int on)
+{
+	spin_lock_irq(&dnpc_spin);
+
+	if (on)
+		setcsc(CSC_RBWR, getcsc(CSC_RBWR) & ~0x8);
+	else
+		setcsc(CSC_RBWR, getcsc(CSC_RBWR) | 0x8);
+
+	spin_unlock_irq(&dnpc_spin);
+}
+
+
+
+#define DNP_WINDOW_SIZE		0x00200000	/*  DNP flash size is 2MiB  */
+#define ADNP_WINDOW_SIZE	0x00400000	/* ADNP flash size is 4MiB */
+#define WINDOW_ADDR			FLASH_BASE
+
+static struct map_info dnpc_map = {
+	name: "ADNP Flash Bank",
+	size: ADNP_WINDOW_SIZE,
+	buswidth: 1,
+	read8: dnpc_read8,
+	read16: dnpc_read16,
+	read32: dnpc_read32,
+	copy_from: dnpc_copy_from,
+	write8: dnpc_write8,
+	write16: dnpc_write16,
+	write32: dnpc_write32,
+	copy_to: dnpc_copy_to,
+	set_vpp: adnp_set_vpp,
+	map_priv_2: WINDOW_ADDR
+};
+
+/*
+** The layout of the flash is somewhat "strange":
+**
+** 1.  960 KiB (15 blocks) : Space for ROM Bootloader and user data
+** 2.   64 KiB (1 block)   : System BIOS
+** 3.  960 KiB (15 blocks) : User Data (DNP model) or
+** 3. 3008 KiB (47 blocks) : User Data (ADNP model)
+** 4.   64 KiB (1 block)   : System BIOS Entry
+*/
+
+static struct mtd_partition partition_info[]=
+{
+	{ 
+		name:		"ADNP boot", 
+		offset:		0, 
+		size:		0xf0000,
+	},
+	{ 
+		name:		"ADNP system BIOS", 
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		0x10000,
+#ifdef DNPC_BIOS_BLOCKS_WRITEABLE
+		mask_flags:	MTD_WRITEABLE,
+#endif
+	},
+	{
+		name:		"ADNP file system",
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		0x2f0000,
+	},
+	{
+		name:		"ADNP system BIOS entry", 
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		0x10000,
+#ifdef DNPC_BIOS_BLOCKS_WRITEABLE
+		mask_flags:	MTD_WRITEABLE,
+#endif
+	},
+};
+
+#define NUM_PARTITIONS (sizeof(partition_info)/sizeof(partition_info[0]))
+
+static struct mtd_info *mymtd;
+
+static int dnp_adnp_probe(void)
+{
+	char *biosid, rc = -1;
+
+	biosid = (char*)ioremap(BIOSID_BASE, 16);
+	if(biosid)
+	{
+		if(!strcmp(biosid, ID_DNPC))
+			rc = 1;		/* this is a DNPC  */
+		else if(!strcmp(biosid, ID_ADNP))
+			rc = 0;		/* this is a ADNPC */
+	}
+	iounmap((void *)biosid);
+	return(rc);
+}
+
+
+static int __init init_dnpc(void)
+{
+	int is_dnp;
+
+	/*
+	** determine hardware (DNP/ADNP/invalid)
+	*/	
+	if((is_dnp = dnp_adnp_probe()) < 0)
+		return -ENXIO;
+
+	/*
+	** Things are set up for ADNP by default
+	** -> modify all that needs to be different for DNP
+	*/
+	if(is_dnp)
+	{	/*
+		** Adjust window size, select correct set_vpp function.
+		** The partitioning scheme is identical on both DNP
+		** and ADNP except for the size of the third partition.
+		*/
+		int i;
+		dnpc_map.size          = DNP_WINDOW_SIZE;
+		dnpc_map.set_vpp       = dnp_set_vpp;
+		partition_info[2].size = 0xf0000;
+
+		/*
+		** increment all string pointers so the leading 'A' gets skipped,
+		** thus turning all occurrences of "ADNP ..." into "DNP ..."
+		*/
+		++dnpc_map.name;
+		for(i = 0; i < NUM_PARTITIONS; i++)
+			++partition_info[i].name;
+	}
+
+	printk(KERN_NOTICE "DIL/Net %s flash: 0x%lx at 0x%lx\n", 
+		is_dnp ? "DNPC" : "ADNP", dnpc_map.size, dnpc_map.map_priv_2);
+
+	dnpc_map.map_priv_1 = (unsigned long)ioremap_nocache(dnpc_map.map_priv_2, dnpc_map.size);
+
+	dnpc_map_flash(dnpc_map.map_priv_2, dnpc_map.size);
+
+	if (!dnpc_map.map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	printk("FLASH virtual address: 0x%lx\n", dnpc_map.map_priv_1);
+
+	mymtd = do_map_probe("cfi_probe", &dnpc_map);
+
+	if (!mymtd)
+		mymtd = do_map_probe("jedec_probe", &dnpc_map);
+
+	if (!mymtd)
+		mymtd = do_map_probe("map_rom", &dnpc_map);
+
+	if (!mymtd) {
+		iounmap((void *)dnpc_map.map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
+
+	return 0;
+}
+
+static void __exit cleanup_dnpc(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dnpc_map.map_priv_1) {
+		iounmap((void *)dnpc_map.map_priv_1);
+		dnpc_unmap_flash();
+		dnpc_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dnpc);
+module_exit(cleanup_dnpc);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sysgo Real-Time Solutions GmbH");
+MODULE_DESCRIPTION("MTD map driver for SSV DIL/NetPC DNP & ADNP");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/elan-104nc.c linux-2.4.2/drivers/mtd/maps/elan-104nc.c
--- linux-2.4.2.orig/drivers/mtd/maps/elan-104nc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/elan-104nc.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,277 @@
+/* elan-104nc.c -- MTD map driver for Arcom Control Systems ELAN-104NC
+ 
+   Copyright (C) 2000 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: elan-104nc.c,v 1.12 2001/10/02 15:05:14 dwmw2 Exp $
+
+The ELAN-104NC has up to 8 Mibyte of Intel StrataFlash (28F320/28F640) in x16
+mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   32 kbyte memory window at 0xb0000-0xb7fff
+   
+   16 bit I/O port (0x22) for some sort of paging.
+
+The single flash device is divided into 3 partition which appear as seperate
+MTD devices.
+
+Linux thinks that the I/O port is used by the PIC and hence check_region() will
+always fail.  So we don't do it.  I just hope it doesn't break anything.
+*/
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_START 0xb0000
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 15
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x22
+#define PAGE_IO_SIZE 2
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t elan_104nc_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "ELAN-104NC flash boot partition", 
+      offset: 0, 
+      size: 640*1024 },
+    { name: "ELAN-104NC flash partition 1", 
+      offset: 640*1024, 
+      size: 896*1024 },
+    { name: "ELAN-104NC flash partition 2", 
+      offset: (640+896)*1024 }
+};
+#define NUM_PARTITIONS (sizeof(partition_info)/sizeof(partition_info[0]))
+
+/*
+ * If no idea what is going on here.  This is taken from the FlashFX stuff.
+ */
+#define ROMCS 1
+
+static inline void elan_104nc_setup(void)
+{
+    u16 t;
+
+    outw( 0x0023 + ROMCS*2, PAGE_IO );
+    t=inb( PAGE_IO+1 );
+
+    t=(t & 0xf9) | 0x04;
+
+    outw( ((0x0023 + ROMCS*2) | (t << 8)), PAGE_IO );
+}
+
+static inline void elan_104nc_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+       
+	if( page!=page_in_window ) {
+		int cmd1;
+		int cmd2;
+
+		cmd1=(page & 0x700) + 0x0833 + ROMCS*0x4000;
+		cmd2=((page & 0xff) << 8) + 0x0032;
+
+		outw( cmd1, PAGE_IO );
+		outw( cmd2, PAGE_IO );
+
+		page_in_window = page;
+	}
+}
+
+
+static __u8 elan_104nc_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u16 elan_104nc_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u32 elan_104nc_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static void elan_104nc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&elan_104nc_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void elan_104nc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&elan_104nc_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info elan_104nc_map = {
+	name: "ELAN-104NC flash",
+	size: 8*1024*1024, /* this must be set to a maximum possible amount
+			of flash so the cfi probe routines find all
+			the chips */
+	buswidth: 2,
+	read8: elan_104nc_read8,
+	read16: elan_104nc_read16,
+	read32: elan_104nc_read32,
+	copy_from: elan_104nc_copy_from,
+	write8: elan_104nc_write8,
+	write16: elan_104nc_write16,
+	write32: elan_104nc_write32,
+	copy_to: elan_104nc_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+static void __exit cleanup_elan_104nc(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+int __init init_elan_104nc(void)
+{
+	/* Urg! We use I/O port 0x22 without request_region()ing it */
+	/*
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			elan_104nc_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+	*/
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			elan_104nc_map.name );
+		return -EIO;
+	}
+
+	/*
+	request_region( PAGE_IO, PAGE_IO_SIZE, "ELAN-104NC flash" );
+	*/
+
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		elan_104nc_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	elan_104nc_setup();
+
+	/* Probe for chip. */
+	all_mtd = do_map_probe("cfi_probe",  &elan_104nc_map );
+	if( !all_mtd ) {
+		cleanup_elan_104nc();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions( all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_elan_104nc);
+module_exit(cleanup_elan_104nc);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Arcom Control Systems Ltd.");
+MODULE_DESCRIPTION("MTD map driver for Arcom Control Systems ELAN-104NC");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/epxa10db-flash.c linux-2.4.2/drivers/mtd/maps/epxa10db-flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/epxa10db-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/epxa10db-flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,219 @@
+/*
+ * Flash memory access on EPXA based devices
+ *
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ *  Copyright (C) 2001 Altera Corporation
+ *  Copyright (C) 2001 Red Hat, Inc.
+ *
+ * $Id: epxa10db-flash.c,v 1.2 2001/12/19 13:00:19 jskov Exp $ 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+
+static int nr_parts = 0;
+static struct mtd_partition *parts;
+
+static struct mtd_info *mymtd;
+
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+static int epxa10db_default_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+static __u8 epxa10db_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+static __u16 epxa10db_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+static __u32 epxa10db_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+static void epxa10db_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void epxa10db_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void epxa10db_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void epxa10db_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+static void epxa10db_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+
+
+static struct map_info epxa10db_map = {
+	name:		"EPXA10DB flash",
+	size:		FLASH_SIZE,
+	buswidth:	2,
+	read8:		epxa10db_read8,
+	read16:		epxa10db_read16,
+	read32:		epxa10db_read32,
+	copy_from:	epxa10db_copy_from,
+	write8:		epxa10db_write8,
+	write16:	epxa10db_write16,
+	write32:	epxa10db_write32,
+	copy_to:	epxa10db_copy_to
+};
+
+
+static int __init epxa10db_mtd_init(void)
+{
+	int i;
+	printk(KERN_NOTICE "Epxa10db flash device: %x at %x\n", FLASH_SIZE, FLASH_START);
+	epxa10db_map.map_priv_1 = (unsigned long)ioremap(FLASH_START, FLASH_SIZE);
+	if (!epxa10db_map.map_priv_1) {
+		printk("Failed to ioremap Epxa10db flash\n");
+		return -EIO;
+	}
+
+	mymtd = do_map_probe("cfi_probe", &epxa10db_map);
+	if (!mymtd) {
+		iounmap((void *)epxa10db_map.map_priv_1);
+		return -ENXIO;
+	}
+
+	mymtd->module = THIS_MODULE;
+
+	/* Unlock the flash device. */
+	for (i=0; i<mymtd->numeraseregions;i++){
+		int j;
+		for(j=0;j<mymtd->eraseregions[i].numblocks;j++){
+			mymtd->unlock(mymtd,mymtd->eraseregions[i].offset + j * mymtd->eraseregions[i].erasesize,4);
+		}
+	}
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	nr_parts = parse_redboot_partitions(mymtd, &parts);
+
+	if (nr_parts > 0) {
+		add_mtd_partitions(mymtd, parts, nr_parts);
+		return 0;
+	}
+#endif
+#ifdef CONFIG_MTD_AFS_PARTS
+	nr_parts = parse_afs_partitions(mymtd, &parts);
+
+	if (nr_parts > 0) {
+		add_mtd_partitions(mymtd, parts, nr_parts);
+		return 0;
+	}
+#endif
+
+	/* No recognised partitioning schemes found - use defaults */
+	nr_parts = epxa10db_default_partitions(mymtd, &parts);
+	if (nr_parts > 0) {
+		add_mtd_partitions(mymtd, parts, nr_parts);
+		return 0;
+	}
+
+	/* If all else fails... */
+	add_mtd_device(mymtd);
+	return 0;
+}
+
+static void __exit epxa10db_mtd_cleanup(void)
+{
+	if (mymtd) {
+		if (nr_parts)
+			del_mtd_partitions(mymtd);
+		else
+			del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (epxa10db_map.map_priv_1) {
+		iounmap((void *)epxa10db_map.map_priv_1);
+		epxa10db_map.map_priv_1 = 0;
+	}
+}
+
+
+/* 
+ * This will do for now, once we decide which bootldr we're finally 
+ * going to use then we'll remove this function and do it properly
+ *
+ * Partions are currently (as offsets from base of flash):
+ * 0x00000000 - 0x003FFFFF - bootloader (!)
+ * 0x00400000 - 0x00FFFFFF - Flashdisk
+ */
+
+static int __init epxa10db_default_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+{
+	struct mtd_partition *parts;
+	int ret, i;
+	int npartitions = 0;
+	char *names; 
+	const char *name = "jffs";
+
+	printk("Using default partitions for epxa10db\n");
+	npartitions=1;
+	parts = kmalloc(npartitions*sizeof(*parts)+strlen(name), GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	i=0;
+	names = (char *)&parts[npartitions];	
+	parts[i].name = names;
+	names += strlen(name) + 1;
+	strcpy(parts[i].name, name);
+
+	parts[i].size = FLASH_SIZE-0x00400000;
+	parts[i].offset = 0x00400000;
+	parts[i].mask_flags = 0;
+
+ out:
+	*pparts = parts;
+	return npartitions;
+}
+
+module_init(epxa10db_mtd_init);
+module_exit(epxa10db_mtd_cleanup);
+
+MODULE_AUTHOR("Clive Davies");
+MODULE_DESCRIPTION("Altera epxa10db mtd flash map");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/ich2rom.c linux-2.4.2/drivers/mtd/maps/ich2rom.c
--- linux-2.4.2.orig/drivers/mtd/maps/ich2rom.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/ich2rom.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,302 @@
+/*
+ * ich2rom.c
+ *
+ * Normal mappings of chips in physical memory
+ * $Id: ich2rom.c,v 1.1 2002/01/10 22:59:13 eric Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+
+#define RESERVE_MEM_REGION 0
+
+#define ICH2_FWH_REGION_START	0xFF000000UL
+#define ICH2_FWH_REGION_SIZE	0x01000000UL
+#define BIOS_CNTL	0x4e
+#define FWH_DEC_EN1	0xE3
+#define FWH_DEC_EN2	0xF0
+#define FWH_SEL1	0xE8
+#define FWH_SEL2	0xEE
+
+struct ich2rom_map_info {
+	struct map_info map;
+	struct mtd_info *mtd;
+	unsigned long window_addr;
+};
+
+static inline unsigned long addr(struct map_info *map, unsigned long ofs)
+{
+	unsigned long offset;
+	offset = ((8*1024*1024) - map->size) + ofs;
+	if (offset >= (4*1024*1024)) {
+		offset += 0x400000;
+	}
+	return map->map_priv_1 + 0x400000 + offset;
+}
+
+static inline unsigned long dbg_addr(struct map_info *map, unsigned long addr)
+{
+	return addr - map->map_priv_1 + ICH2_FWH_REGION_START;
+}
+	
+static __u8 ich2rom_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(addr(map, ofs));
+}
+
+static __u16 ich2rom_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(addr(map, ofs));
+}
+
+static __u32 ich2rom_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(addr(map, ofs));
+}
+
+static void ich2rom_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, addr(map, from), len);
+}
+
+static void ich2rom_write8(struct map_info *map, __u8 d, unsigned long ofs)
+{
+	__raw_writeb(d, addr(map,ofs));
+	mb();
+}
+
+static void ich2rom_write16(struct map_info *map, __u16 d, unsigned long ofs)
+{
+	__raw_writew(d, addr(map, ofs));
+	mb();
+}
+
+static void ich2rom_write32(struct map_info *map, __u32 d, unsigned long ofs)
+{
+	__raw_writel(d, addr(map, ofs));
+	mb();
+}
+
+static void ich2rom_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(addr(map, to), from, len);
+}
+
+static struct ich2rom_map_info ich2rom_map = {
+	map: {
+		name: "ICH2 rom",
+		size: 0,
+		buswidth: 1,
+		read8: ich2rom_read8,
+		read16: ich2rom_read16,
+		read32: ich2rom_read32,
+		copy_from: ich2rom_copy_from,
+		write8: ich2rom_write8,
+		write16: ich2rom_write16,
+		write32: ich2rom_write32,
+		copy_to: ich2rom_copy_to,
+		/* Firmware hubs only use vpp when being programmed
+		 * in a factory setting.  So in place programming
+		 * needs to use a different method.
+		 */
+	},
+	mtd: 0,
+	window_addr: 0,
+};
+
+enum fwh_lock_state {
+	FWH_DENY_WRITE = 1,
+	FWH_IMMUTABLE  = 2,
+	FWH_DENY_READ  = 4,
+};
+
+static int ich2rom_set_lock_state(struct mtd_info *mtd, loff_t ofs, size_t len,
+	enum fwh_lock_state state)
+{
+	struct map_info *map = mtd->priv;
+	unsigned long start = ofs;
+	unsigned long end = start + len -1;
+
+	/* FIXME do I need to guard against concurrency here? */
+	/* round down to 64K boundaries */
+	start = start & ~0xFFFF;
+	end = end & ~0xFFFF;
+	while (start <= end) {
+		unsigned long ctrl_addr;
+		ctrl_addr = addr(map, start) - 0x400000 + 2;
+		writeb(state, ctrl_addr);
+		start = start + 0x10000;
+	}
+	return 0;
+}
+
+static int ich2rom_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	return ich2rom_set_lock_state(mtd, ofs, len, FWH_DENY_WRITE);
+}
+
+static int ich2rom_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	return ich2rom_set_lock_state(mtd, ofs, len, 0);
+}
+
+static int __devinit ich2rom_init_one (struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	u16 word;
+	struct ich2rom_map_info *info = &ich2rom_map;
+	unsigned long map_size;
+
+	/* For now I just handle the ich2 and I assume there
+	 * are not a lot of resources up at the top of the address
+	 * space.  It is possible to handle other devices in the
+	 * top 16MB but it is very painful.  Also since
+	 * you can only really attach a FWH to an ICH2 there
+	 * a number of simplifications you can make.
+	 *
+	 * Also you can page firmware hubs if an 8MB window isn't enough 
+	 * but don't currently handle that case either.
+	 */
+
+#if RESERVE_MEM_REGION
+	/* Some boards have this reserved and I haven't found a good work
+	 * around to say I know what I'm doing!
+	 */
+	if (!request_mem_region(ICH2_FWH_REGION_START, ICH2_FWH_REGION_SIZE, "ich2rom")) {
+		printk(KERN_ERR "ich2rom: cannot reserve rom window\n");
+		goto err_out_none;
+	}
+#endif /* RESERVE_MEM_REGION */
+	
+	/* Enable writes through the rom window */
+	pci_read_config_word(pdev, BIOS_CNTL, &word);
+	if (!(word & 1)  && (word & (1<<1))) {
+		/* The BIOS will generate an error if I enable
+		 * this device, so don't even try.
+		 */
+		printk(KERN_ERR "ich2rom: firmware access control, I can't enable writes\n");
+		goto err_out_none;
+	}
+	pci_write_config_word(pdev, BIOS_CNTL, word | 1);
+
+
+	/* Map the firmware hub into my address space. */
+	/* Does this use to much virtual address space? */
+	info->window_addr = (unsigned long)ioremap(
+		ICH2_FWH_REGION_START, ICH2_FWH_REGION_SIZE);
+	if (!info->window_addr) {
+		printk(KERN_ERR "Failed to ioremap\n");
+		goto err_out_free_mmio_region;
+	}
+
+	/* For now assume the firmware has setup all relavent firmware
+	 * windows.  We don't have enough information to handle this case
+	 * intelligently.
+	 */
+
+	/* FIXME select the firmware hub and enable a window to it. */
+
+	info->mtd = 0;
+	info->map.map_priv_1 = 	info->window_addr;
+
+	map_size = ICH2_FWH_REGION_SIZE;
+	while(!info->mtd && (map_size > 0)) {
+		info->map.size = map_size;
+		info->mtd = do_map_probe("jedec_probe", &ich2rom_map.map);
+		map_size -= 512*1024;
+	}
+	if (!info->mtd) {
+		goto err_out_iounmap;
+	}
+	/* I know I can only be a firmware hub here so put
+	 * in the special lock and unlock routines.
+	 */
+	info->mtd->lock = ich2rom_lock;
+	info->mtd->unlock = ich2rom_unlock;
+		
+	info->mtd->module = THIS_MODULE;
+	add_mtd_device(info->mtd);
+	return 0;
+
+err_out_iounmap:
+	iounmap((void *)(info->window_addr));
+err_out_free_mmio_region:
+#if RESERVE_MEM_REGION
+	release_mem_region(ICH2_FWH_REGION_START, ICH2_FWH_REGION_SIZE);
+#endif
+err_out_none:
+	return -ENODEV;
+}
+
+
+static void __devexit ich2rom_remove_one (struct pci_dev *pdev)
+{
+	struct ich2rom_map_info *info = &ich2rom_map;
+	u16 word;
+
+	del_mtd_device(info->mtd);
+	map_destroy(info->mtd);
+	info->mtd = 0;
+	info->map.map_priv_1 = 0;
+
+	iounmap((void *)(info->window_addr));
+	info->window_addr = 0;
+
+	/* Disable writes through the rom window */
+	pci_read_config_word(pdev, BIOS_CNTL, &word);
+	pci_write_config_word(pdev, BIOS_CNTL, word & ~1);
+
+#if RESERVE_MEM_REGION	
+	release_mem_region(ICH2_FWH_REGION_START, ICH2_FWH_REGION_SIZE);
+#endif
+}
+
+static struct pci_device_id ich2rom_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0, 
+	  PCI_ANY_ID, PCI_ANY_ID, },
+};
+
+MODULE_DEVICE_TABLE(pci, ich2rom_pci_tbl);
+
+#if 0
+static struct pci_driver ich2rom_driver = {
+	name:	  "ich2rom",
+	id_table: ich2rom_pci_tbl,
+	probe:    ich2rom_init_one,
+	remove:   ich2rom_remove_one,
+};
+#endif
+
+static struct pci_dev *mydev;
+int __init init_ich2rom(void)
+{
+	struct pci_dev *pdev;
+	pdev = pci_find_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0, 0);
+	if (pdev) {
+		mydev = pdev;
+		return ich2rom_init_one(pdev, &ich2rom_pci_tbl[0]);
+	}
+	return -ENXIO;
+#if 0
+	return pci_module_init(&ich2rom_driver);
+#endif
+}
+
+static void __exit cleanup_ich2rom(void)
+{
+	ich2rom_remove_one(mydev);
+}
+
+module_init(init_ich2rom);
+module_exit(cleanup_ich2rom);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Eric Biederman <ebiederman@lnxi.com>");
+MODULE_DESCRIPTION("MTD map driver for BIOS chips on the ICH2 southbridge");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/integrator-flash.c linux-2.4.2/drivers/mtd/maps/integrator-flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/integrator-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/integrator-flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,303 @@
+/*======================================================================
+
+    drivers/mtd/maps/armflash.c: ARM Flash Layout/Partitioning
+  
+    Copyright (C) 2000 ARM Limited
+  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+  
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+  
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  
+   This is access code for flashes using ARM's flash partitioning 
+   standards.
+
+   $Id: integrator-flash.c,v 1.7 2001/11/01 20:55:47 rmk Exp $
+
+======================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+extern int parse_afs_partitions(struct mtd_info *, struct mtd_partition **);
+
+// board specific stuff - sorry, it should be in arch/arm/mach-*.
+#ifdef CONFIG_ARCH_INTEGRATOR
+
+#define FLASH_BASE	INTEGRATOR_FLASH_BASE
+#define FLASH_SIZE	INTEGRATOR_FLASH_SIZE
+
+#define FLASH_PART_SIZE 0x400000
+
+#define SC_CTRLC	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLC_OFFSET)
+#define SC_CTRLS	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLS_OFFSET)
+#define EBI_CSR1	(IO_ADDRESS(INTEGRATOR_EBI_BASE) + INTEGRATOR_EBI_CSR1_OFFSET)
+#define EBI_LOCK	(IO_ADDRESS(INTEGRATOR_EBI_BASE) + INTEGRATOR_EBI_LOCK_OFFSET)
+
+/*
+ * Initialise the flash access systems:
+ *  - Disable VPP
+ *  - Assert WP
+ *  - Set write enable bit in EBI reg
+ */
+static void armflash_flash_init(void)
+{
+	unsigned int tmp;
+
+	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP, SC_CTRLC);
+
+	tmp = __raw_readl(EBI_CSR1) | INTEGRATOR_EBI_WRITE_ENABLE;
+	__raw_writel(tmp, EBI_CSR1);
+
+	if (!(__raw_readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE)) {
+		__raw_writel(0xa05f, EBI_LOCK);
+		__raw_writel(tmp, EBI_CSR1);
+		__raw_writel(0, EBI_LOCK);
+	}
+}
+
+/*
+ * Shutdown the flash access systems:
+ *  - Disable VPP
+ *  - Assert WP
+ *  - Clear write enable bit in EBI reg
+ */
+static void armflash_flash_exit(void)
+{
+	unsigned int tmp;
+
+	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP, SC_CTRLC);
+
+	/*
+	 * Clear the write enable bit in system controller EBI register.
+	 */
+	tmp = __raw_readl(EBI_CSR1) & ~INTEGRATOR_EBI_WRITE_ENABLE;
+	__raw_writel(tmp, EBI_CSR1);
+
+	if (__raw_readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE) {
+		__raw_writel(0xa05f, EBI_LOCK);
+		__raw_writel(tmp, EBI_CSR1);
+		__raw_writel(0, EBI_LOCK);
+	}
+}
+
+static void armflash_flash_wp(int on)
+{
+	unsigned int reg;
+
+	if (on)
+		reg = SC_CTRLC;
+	else
+		reg = SC_CTRLS;
+
+	__raw_writel(INTEGRATOR_SC_CTRL_nFLWP, reg);
+}
+
+static void armflash_set_vpp(struct map_info *map, int on)
+{
+	unsigned int reg;
+
+	if (on)
+		reg = SC_CTRLS;
+	else
+		reg = SC_CTRLC;
+
+	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN, reg);
+}
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+
+#define FLASH_BASE		(0x04000000)
+#define FLASH_SIZE		(64*1024*1024)
+
+#define FLASH_PART_SIZE 	(4*1024*1024)
+#define FLASH_BLOCK_SIZE	(128*1024)
+
+static void armflash_flash_init(void)
+{
+}
+
+static void armflash_flash_exit(void)
+{
+}
+
+static void armflash_flash_wp(int on)
+{
+}
+
+static void armflash_set_vpp(struct map_info *map, int on)
+{
+}
+#endif
+
+static __u8 armflash_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(ofs + map->map_priv_2);
+}
+
+static __u16 armflash_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(ofs + map->map_priv_2);
+}
+
+static __u32 armflash_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(ofs + map->map_priv_2);
+}
+
+static void armflash_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *) (from + map->map_priv_2), len);
+}
+
+static void armflash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, adr + map->map_priv_2);
+}
+
+static void armflash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, adr + map->map_priv_2);
+}
+
+static void armflash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, adr + map->map_priv_2);
+}
+
+static void armflash_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *) (to + map->map_priv_2), from, len);
+}
+
+static struct map_info armflash_map =
+{
+	name:		"AFS",
+	read8:		armflash_read8,
+	read16:		armflash_read16,
+	read32:		armflash_read32,
+	copy_from:	armflash_copy_from,
+	write8:		armflash_write8,
+	write16:	armflash_write16,
+	write32:	armflash_write32,
+	copy_to:	armflash_copy_to,
+	set_vpp:	armflash_set_vpp,
+};
+
+static struct mtd_info *mtd;
+static struct mtd_partition *parts;
+
+static int __init armflash_cfi_init(void *base, u_int size)
+{
+	int ret;
+
+	armflash_flash_init();
+	armflash_flash_wp(1);
+
+	/*
+	 * look for CFI based flash parts fitted to this board
+	 */
+	armflash_map.size       = size;
+	armflash_map.buswidth   = 4;
+	armflash_map.map_priv_2 = (unsigned long) base;
+
+	/*
+	 * Also, the CFI layer automatically works out what size
+	 * of chips we have, and does the necessary identification
+	 * for us automatically.
+	 */
+	mtd = do_map_probe("cfi_probe", &armflash_map);
+	if (!mtd)
+		return -ENXIO;
+
+	mtd->module = THIS_MODULE;
+
+	ret = parse_afs_partitions(mtd, &parts);
+	if (ret > 0) {
+		ret = add_mtd_partitions(mtd, parts, ret);
+		if (ret)
+			printk(KERN_ERR "mtd partition registration "
+				"failed: %d\n", ret);
+	}
+
+	/*
+	 * If we got an error, free all resources.
+	 */
+	if (ret < 0) {
+		del_mtd_partitions(mtd);
+		map_destroy(mtd);
+	}
+
+	return ret;
+}
+
+static void armflash_cfi_exit(void)
+{
+	if (mtd) {
+		del_mtd_partitions(mtd);
+		map_destroy(mtd);
+	}
+	if (parts)
+		kfree(parts);
+}
+
+static int __init armflash_init(void)
+{
+	int err = -EBUSY;
+	void *base;
+
+	if (request_mem_region(FLASH_BASE, FLASH_SIZE, "flash") == NULL)
+		goto out;
+
+	base = ioremap(FLASH_BASE, FLASH_SIZE);
+	err = -ENOMEM;
+	if (base == NULL)
+		goto release;
+
+	err = armflash_cfi_init(base, FLASH_SIZE);
+	if (err) {
+		iounmap(base);
+release:
+		release_mem_region(FLASH_BASE, FLASH_SIZE);
+	}
+out:
+	return err;
+}
+
+static void __exit armflash_exit(void)
+{
+	armflash_cfi_exit();
+	iounmap((void *)armflash_map.map_priv_2);
+	release_mem_region(FLASH_BASE, FLASH_SIZE);
+	armflash_flash_exit();
+}
+
+module_init(armflash_init);
+module_exit(armflash_exit);
+
+MODULE_AUTHOR("ARM Ltd");
+MODULE_DESCRIPTION("ARM Integrator CFI map driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/iq80310.c linux-2.4.2/drivers/mtd/maps/iq80310.c
--- linux-2.4.2.orig/drivers/mtd/maps/iq80310.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/iq80310.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,172 @@
+/*
+ * $Id: iq80310.c,v 1.9 2002/01/01 22:45:02 rmk Exp $
+ *
+ * Mapping for the Intel XScale IQ80310 evaluation board
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 	0
+#define WINDOW_SIZE 	8*1024*1024
+#define BUSWIDTH 	1
+
+static struct mtd_info *mymtd;
+
+static __u8 iq80310_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 iq80310_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 iq80310_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void iq80310_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void iq80310_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info iq80310_map = {
+	name: "IQ80310 flash",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8:		iq80310_read8,
+	read16:		iq80310_read16,
+	read32:		iq80310_read32,
+	copy_from:	iq80310_copy_from,
+	write8:		iq80310_write8,
+	write16:	iq80310_write16,
+	write32:	iq80310_write32,
+	copy_to:	iq80310_copy_to
+};
+
+static struct mtd_partition iq80310_partitions[4] = {
+	{
+		name:		"Firmware",
+		size:		0x00080000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE  /* force read-only */
+	},{
+		name:		"Kernel",
+		size:		0x000a0000,
+		offset:		0x00080000,
+	},{
+		name:		"Filesystem",
+		size:		0x00600000,
+		offset:		0x00120000
+	},{
+		name:		"RedBoot",
+		size:		0x000e0000,
+		offset:		0x00720000,
+		mask_flags:	MTD_WRITEABLE
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+static struct mtd_partition *parsed_parts;
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+static int __init init_iq80310(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	char *part_type = "static";
+
+	iq80310_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	if (!iq80310_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &iq80310_map);
+	if (!mymtd) {
+		iounmap((void *)iq80310_map.map_priv_1);
+		return -ENXIO;
+	}
+	mymtd->module = THIS_MODULE;
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	if (parsed_nr_parts == 0) {
+		int ret = parse_redboot_partitions(mymtd, &parsed_parts);
+
+		if (ret > 0) {
+			part_type = "RedBoot";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	} else {
+		parts = iq80310_partitions;
+		nb_parts = NB_OF(iq80310_partitions);
+	}
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit cleanup_iq80310(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (iq80310_map.map_priv_1)
+		iounmap((void *)iq80310_map.map_priv_1);
+}
+
+module_init(init_iq80310);
+module_exit(cleanup_iq80310);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Pitre <nico@cam.org>");
+MODULE_DESCRIPTION("MTD map driver for Intel XScale IQ80310 evaluation board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/l440gx.c linux-2.4.2/drivers/mtd/maps/l440gx.c
--- linux-2.4.2.orig/drivers/mtd/maps/l440gx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/l440gx.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,207 @@
+/*
+ * $Id: l440gx.c,v 1.8 2002/01/10 20:27:40 eric Exp $
+ *
+ * BIOS Flash chip on Intel 440GX board.
+ *
+ * Bugs this currently does not work under linuxBIOS.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+
+#define PIIXE_IOBASE_RESOURCE	11
+
+#define WINDOW_ADDR 0xfff00000
+#define WINDOW_SIZE 0x00100000
+#define BUSWIDTH 1
+
+static u32 iobase;
+#define IOBASE iobase
+#define TRIBUF_PORT (IOBASE+0x37)
+#define VPP_PORT (IOBASE+0x28)
+
+static struct mtd_info *mymtd;
+
+__u8 l440gx_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 l440gx_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 l440gx_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void l440gx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void l440gx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void l440gx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void l440gx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void l440gx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+/* Is this really the vpp port? */
+void l440gx_set_vpp(struct map_info *map, int vpp)
+{
+	unsigned long l;
+
+	l = inl(VPP_PORT);
+	if (vpp) {
+		l |= 1;
+	} else {
+		l &= ~1;
+	}
+	outl(l, VPP_PORT);
+}
+
+struct map_info l440gx_map = {
+	name: "L440GX BIOS",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: l440gx_read8,
+	read16: l440gx_read16,
+	read32: l440gx_read32,
+	copy_from: l440gx_copy_from,
+	write8: l440gx_write8,
+	write16: l440gx_write16,
+	write32: l440gx_write32,
+	copy_to: l440gx_copy_to,
+#if 0
+	/* FIXME verify that this is the 
+	 * appripriate code for vpp enable/disable
+	 */
+	set_vpp: l440gx_set_vpp
+#endif
+};
+
+static int __init init_l440gx(void)
+{
+	struct pci_dev *dev, *pm_dev;
+	struct resource *pm_iobase;
+	__u16 word;
+
+	dev = pci_find_device(PCI_VENDOR_ID_INTEL, 
+		PCI_DEVICE_ID_INTEL_82371AB_0, NULL);
+
+
+	pm_dev = pci_find_device(PCI_VENDOR_ID_INTEL, 
+		PCI_DEVICE_ID_INTEL_82371AB_3, NULL);
+
+	if (!dev || !pm_dev) {
+		printk(KERN_NOTICE "L440GX flash mapping: failed to find PIIX4 ISA bridge, cannot continue\n");
+		return -ENODEV;
+	}
+
+
+	l440gx_map.map_priv_1 = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!l440gx_map.map_priv_1) {
+		printk(KERN_WARNING "Failed to ioremap L440GX flash region\n");
+		return -ENOMEM;
+	}
+
+	printk(KERN_NOTICE "window_addr = 0x%08lx\n", (unsigned long)l440gx_map.map_priv_1);
+
+	/* Setup the pm iobase resource 
+	 * This code should move into some kind of generic bridge
+	 * driver but for the moment I'm content with getting the
+	 * allocation correct. 
+	 */
+	pm_iobase = &pm_dev->resource[PIIXE_IOBASE_RESOURCE];
+	if (!(pm_iobase->flags & IORESOURCE_IO)) {
+		pm_iobase->name = "pm iobase";
+		pm_iobase->start = 0;
+		pm_iobase->end = 63;
+		pm_iobase->flags = IORESOURCE_IO;
+
+		/* Put the current value in the resource */
+		pci_read_config_dword(pm_dev, 0x40, &iobase);
+		iobase &= ~1;
+		pm_iobase->start += iobase & ~1;
+		pm_iobase->end += iobase & ~1;
+
+		/* Allocate the resource region */
+		if (pci_assign_resource(pm_dev, PIIXE_IOBASE_RESOURCE) != 0) {
+			printk(KERN_WARNING "Could not allocate pm iobase resource\n");
+			iounmap((void *)l440gx_map.map_priv_1);
+			return -ENXIO;
+		}
+	}
+	/* Set the iobase */
+	iobase = pm_iobase->start;
+	pci_write_config_dword(pm_dev, 0x40, iobase | 1);
+	
+
+	/* Set XBCS# */
+	pci_read_config_word(dev, 0x4e, &word);
+	word |= 0x4;
+        pci_write_config_word(dev, 0x4e, word);
+
+	/* Supply write voltage to the chip */
+	l440gx_set_vpp(&l440gx_map, 1);
+
+	/* Enable the gate on the WE line */
+	outb(inb(TRIBUF_PORT) & ~1, TRIBUF_PORT);
+	
+       	printk(KERN_NOTICE "Enabled WE line to L440GX BIOS flash chip.\n");
+
+	mymtd = do_map_probe("jedec_probe", &l440gx_map);
+	if (!mymtd) {
+		printk(KERN_NOTICE "JEDEC probe on BIOS chip failed. Using ROM\n");
+		mymtd = do_map_probe("map_rom", &l440gx_map);
+	}
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		add_mtd_device(mymtd);
+		return 0;
+	}
+
+	iounmap((void *)l440gx_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_l440gx(void)
+{
+	del_mtd_device(mymtd);
+	map_destroy(mymtd);
+	
+	iounmap((void *)l440gx_map.map_priv_1);
+}
+
+module_init(init_l440gx);
+module_exit(cleanup_l440gx);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD map driver for BIOS chips on Intel L440GX motherboards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/mbx860.c linux-2.4.2/drivers/mtd/maps/mbx860.c
--- linux-2.4.2.orig/drivers/mtd/maps/mbx860.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/mbx860.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,144 @@
+/*
+ * $Id: mbx860.c,v 1.1 2001/11/18 19:43:09 dwmw2 Exp $
+ *
+ * Handle mapping of the flash on MBX860 boards
+ *
+ * Author:	Anton Todorov
+ * Copyright:	(C) 2001 Emness Technology
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 0xfe000000
+#define WINDOW_SIZE 0x00200000
+
+/* Flash / Partition sizing */
+#define MAX_SIZE_KiB              8192
+#define BOOT_PARTITION_SIZE_KiB    512
+#define KERNEL_PARTITION_SIZE_KiB 5632
+#define APP_PARTITION_SIZE_KiB    2048
+
+#define NUM_PARTITIONS 3
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+	{ name: "MBX flash BOOT partition",
+	offset: 0,
+	size:   BOOT_PARTITION_SIZE_KiB*1024 },
+	{ name: "MBX flash DATA partition",
+	offset: BOOT_PARTITION_SIZE_KiB*1024,
+	size: (KERNEL_PARTITION_SIZE_KiB)*1024 },
+	{ name: "MBX flash APPLICATION partition",
+	offset: (BOOT_PARTITION_SIZE_KiB+KERNEL_PARTITION_SIZE_KiB)*1024 }
+};
+				   
+
+static struct mtd_info *mymtd;
+
+__u8 mbx_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+__u16 mbx_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+__u32 mbx_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+void mbx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+void mbx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+void mbx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+void mbx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+void mbx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+struct map_info mbx_map = {
+	name: "MBX flash",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: mbx_read8,
+	read16: mbx_read16,
+	read32: mbx_read32,
+	copy_from: mbx_copy_from,
+	write8: mbx_write8,
+	write16: mbx_write16,
+	write32: mbx_write32,
+	copy_to: mbx_copy_to
+};
+
+int __init init_mbx(void)
+{
+	printk(KERN_NOTICE "Motorola MBX flash device: %x at %x\n", WINDOW_SIZE*4, WINDOW_ADDR);
+	mbx_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+
+	if (!mbx_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("jedec_probe", &mbx_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_device(mymtd);
+                add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
+		return 0;
+	}
+
+	iounmap((void *)mbx_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_mbx(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (mbx_map.map_priv_1) {
+		iounmap((void *)mbx_map.map_priv_1);
+		mbx_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_mbx);
+module_exit(cleanup_mbx);
+
+MODULE_AUTHOR("Anton Todorov <a.todorov@emness.com>");
+MODULE_DESCRIPTION("MTD map driver for Motorola MBX860 board");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/netsc520.c linux-2.4.2/drivers/mtd/maps/netsc520.c
--- linux-2.4.2.orig/drivers/mtd/maps/netsc520.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/netsc520.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,190 @@
+/* netsc520.c -- MTD map driver for AMD NetSc520 Demonstration Board
+ *
+ * Copyright (C) 2001 Mark Langsdorf (mark.langsdorf@amd.com)
+ *	based on sc520cdp.c by Sysgo Real-Time Solutions GmbH
+ *
+ * $Id: netsc520.c,v 1.5 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * The NetSc520 is a demonstration board for the Elan Sc520 processor available
+ * from AMD.  It has a single back of 16 megs of 32-bit Flash ROM and another
+ * 16 megs of SDRAM.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+/*
+** The single, 16 megabyte flash bank is divided into four virtual
+** partitions.  The first partition is 768 KiB and is intended to
+** store the kernel image loaded by the bootstrap loader.  The second
+** partition is 256 KiB and holds the BIOS image.  The third 
+** partition is 14.5 MiB and is intended for the flash file system
+** image.  The last partition is 512 KiB and contains another copy
+** of the BIOS image and the reset vector.
+**
+** Only the third partition should be mounted.  The first partition
+** should not be mounted, but it can erased and written to using the
+** MTD character routines.  The second and fourth partitions should
+** not be touched - it is possible to corrupt the BIOS image by
+** mounting these partitions, and potentially the board will not be
+** recoverable afterwards.
+*/
+
+static __u8 netsc520_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 netsc520_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 netsc520_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void netsc520_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void netsc520_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void netsc520_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void netsc520_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void netsc520_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { 
+	    name: "NetSc520 boot kernel", 
+	    offset: 0, 
+	    size: 	0xc0000
+    },
+    { 
+	    name: "NetSc520 Low BIOS", 
+	    offset: 0xc0000, 
+	    size: 	0x40000
+    },
+    { 
+	    name: "NetSc520 file system", 
+	    offset: 0x100000, 
+	    size: 	0xe80000
+    },
+    { 
+	    name: "NetSc520 High BIOS", 
+	    offset: 0xf80000, 
+	    size: 0x80000
+    },
+};
+#define NUM_PARTITIONS (sizeof(partition_info)/sizeof(partition_info[0]))
+
+/*
+ * If no idea what is going on here.  This is taken from the FlashFX stuff.
+ */
+#define ROMCS 1
+
+
+#define WINDOW_SIZE	0x00100000
+#define WINDOW_ADDR	0x00200000
+
+static struct map_info netsc520_map = {
+	name: "netsc520 Flash Bank",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: netsc520_read8,
+	read16: netsc520_read16,
+	read32: netsc520_read32,
+	copy_from: netsc520_copy_from,
+	write8: netsc520_write8,
+	write16: netsc520_write16,
+	write32: netsc520_write32,
+	copy_to: netsc520_copy_to,
+	map_priv_2: WINDOW_ADDR
+};
+
+#define NUM_FLASH_BANKS	(sizeof(netsc520_map)/sizeof(struct map_info))
+
+static struct mtd_info *mymtd;
+
+static int __init init_netsc520(void)
+{
+	printk(KERN_NOTICE "NetSc520 flash device: %lx at %lx\n", netsc520_map.size, netsc520_map.map_priv_2);
+	netsc520_map.map_priv_1 = (unsigned long)ioremap_nocache(netsc520_map.map_priv_2, netsc520_map.size);
+
+	if (!netsc520_map.map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &netsc520_map);
+	if(!mymtd)
+		mymtd = do_map_probe("map_ram", &netsc520_map);
+	if(!mymtd)
+		mymtd = do_map_probe("map_rom", &netsc520_map);
+
+	if (!mymtd) {
+		iounmap((void *)netsc520_map.map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module = THIS_MODULE;
+	add_mtd_partitions( mymtd, partition_info, NUM_PARTITIONS );
+	return 0;
+}
+
+static void __exit cleanup_netsc520(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (netsc520_map.map_priv_1) {
+		iounmap((void *)netsc520_map.map_priv_1);
+		netsc520_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_netsc520);
+module_exit(cleanup_netsc520);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark Langsdorf <mark.langsdorf@amd.com>");
+MODULE_DESCRIPTION("MTD map driver for AMD NetSc520 Demonstration Board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/nora.c linux-2.4.2/drivers/mtd/maps/nora.c
--- linux-2.4.2.orig/drivers/mtd/maps/nora.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/nora.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,204 @@
+/*
+ * $Id: nora.c,v 1.21 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * This is so simple I love it.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_ADDR 0xd0000000
+#define WINDOW_SIZE 0x04000000
+
+static struct mtd_info *mymtd;
+
+__u8 nora_read8(struct map_info *map, unsigned long ofs)
+{
+  return *(__u8 *)(WINDOW_ADDR + ofs);
+}
+
+__u16 nora_read16(struct map_info *map, unsigned long ofs)
+{
+  return *(__u16 *)(WINDOW_ADDR + ofs);
+}
+
+__u32 nora_read32(struct map_info *map, unsigned long ofs)
+{
+  return *(__u32 *)(WINDOW_ADDR + ofs);
+}
+
+void nora_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+  memcpy(to, (void *)(WINDOW_ADDR + from), len);
+}
+
+void nora_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+  *(__u8 *)(WINDOW_ADDR + adr) = d;
+}
+
+void nora_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+  *(__u16 *)(WINDOW_ADDR + adr) = d;
+}
+
+void nora_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+  *(__u32 *)(WINDOW_ADDR + adr) = d;
+}
+
+void nora_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+  memcpy((void *)(WINDOW_ADDR + to), from, len);
+}
+
+struct map_info nora_map = {
+	name: "NORA",
+	size: WINDOW_SIZE,
+	buswidth: 2,
+	read8: nora_read8,
+	read16: nora_read16,
+	read32: nora_read32,
+	copy_from: nora_copy_from,
+	write8: nora_write8,
+	write16: nora_write16,
+	write32: nora_write32,
+	copy_to: nora_copy_to
+};
+
+
+static int nora_mtd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	return mymtd->read(mymtd, from + (unsigned long)mtd->priv, len, retlen, buf);
+}
+
+static int nora_mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	return mymtd->write(mymtd, to + (unsigned long)mtd->priv, len, retlen, buf);
+}
+
+static int nora_mtd_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	instr->addr += (unsigned long)mtd->priv;
+	return mymtd->erase(mymtd, instr);
+}
+
+static void nora_mtd_sync (struct mtd_info *mtd)
+{
+	mymtd->sync(mymtd);
+}
+
+static int nora_mtd_suspend (struct mtd_info *mtd)
+{
+	return mymtd->suspend(mymtd);
+}
+
+static void nora_mtd_resume (struct mtd_info *mtd)
+{
+	mymtd->resume(mymtd);
+}
+
+
+static struct mtd_info nora_mtds[4] = {  /* boot, kernel, ramdisk, fs */
+	{
+		type: MTD_NORFLASH,
+		flags: MTD_CAP_NORFLASH,
+		size: 0x60000,
+		erasesize: 0x20000,
+		name: "NORA boot firmware",
+		module: THIS_MODULE,
+		erase: nora_mtd_erase,
+		read: nora_mtd_read,
+		write: nora_mtd_write,
+		suspend: nora_mtd_suspend,
+		resume: nora_mtd_resume,
+		sync: nora_mtd_sync,
+		priv: (void *)0
+	},
+	{
+		type: MTD_NORFLASH,
+		flags: MTD_CAP_NORFLASH,
+		size: 0x0a0000,
+		erasesize: 0x20000,
+		name: "NORA kernel",
+		module: THIS_MODULE,
+		erase: nora_mtd_erase,
+		read: nora_mtd_read,
+		write: nora_mtd_write,
+		suspend: nora_mtd_suspend,
+		resume: nora_mtd_resume,
+		sync: nora_mtd_sync,
+		priv: (void *)0x60000
+	},
+	{
+		type: MTD_NORFLASH,
+		flags: MTD_CAP_NORFLASH,
+		size: 0x900000,
+		erasesize: 0x20000,
+		name: "NORA root filesystem",
+		module: THIS_MODULE,
+		erase: nora_mtd_erase,
+		read: nora_mtd_read,
+		write: nora_mtd_write,
+		suspend: nora_mtd_suspend,
+		resume: nora_mtd_resume,
+		sync: nora_mtd_sync,
+		priv: (void *)0x100000
+	},
+	{
+		type: MTD_NORFLASH,
+		flags: MTD_CAP_NORFLASH,
+		size: 0x1600000,
+		erasesize: 0x20000,
+		name: "NORA second filesystem",
+		module: THIS_MODULE,
+		erase: nora_mtd_erase,
+		read: nora_mtd_read,
+		write: nora_mtd_write,
+		suspend: nora_mtd_suspend,
+		resume: nora_mtd_resume,
+		sync: nora_mtd_sync,
+		priv: (void *)0xa00000
+	}
+};
+
+int __init init_nora(void)
+{
+       	printk(KERN_NOTICE "nora flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+
+	mymtd = do_map_probe("cfi_probe", &nora_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		
+		add_mtd_device(&nora_mtds[2]);
+		add_mtd_device(&nora_mtds[0]);
+		add_mtd_device(&nora_mtds[1]);
+		add_mtd_device(&nora_mtds[3]);
+		return 0;
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_nora(void)
+{
+	if (mymtd) {
+		del_mtd_device(&nora_mtds[3]);
+		del_mtd_device(&nora_mtds[1]);
+		del_mtd_device(&nora_mtds[0]);
+		del_mtd_device(&nora_mtds[2]);
+		map_destroy(mymtd);
+	}
+}
+
+module_init(init_nora);
+module_exit(cleanup_nora);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>");
+MODULE_DESCRIPTION("MTD map driver for Nora board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/ocelot.c linux-2.4.2/drivers/mtd/maps/ocelot.c
--- linux-2.4.2.orig/drivers/mtd/maps/ocelot.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/ocelot.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,202 @@
+/*
+ * $Id: ocelot.c,v 1.6 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * Flash on Momenco Ocelot
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define OCELOT_PLD 0x2c000000
+#define FLASH_WINDOW_ADDR 0x2fc00000
+#define FLASH_WINDOW_SIZE 0x00080000
+#define FLASH_BUSWIDTH 1
+#define NVRAM_WINDOW_ADDR 0x2c800000
+#define NVRAM_WINDOW_SIZE 0x00007FF0
+#define NVRAM_BUSWIDTH 1
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+static unsigned int cacheflush = 0;
+
+static struct mtd_info *flash_mtd;
+static struct mtd_info *nvram_mtd;
+
+__u8 ocelot_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+void ocelot_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	cacheflush = 1;
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void ocelot_copy_from_cache(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	if (cacheflush) {
+		dma_cache_inv(map->map_priv_2, map->size);
+		cacheflush = 0;
+	}
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void ocelot_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void ocelot_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	/* If we use memcpy, it does word-wide writes. Even though we told the 
+	   GT64120A that it's an 8-bit wide region, word-wide writes don't work.
+	   We end up just writing the first byte of the four to all four bytes.
+	   So we have this loop instead */
+	while(len) {
+		__raw_writeb(*(unsigned char *) from, map->map_priv_1 + to);
+		from++;
+		to++;
+		len--;
+	}
+}
+
+static struct mtd_partition *parsed_parts;
+
+struct map_info ocelot_flash_map = {
+	name: "Ocelot boot flash",
+	size: FLASH_WINDOW_SIZE,
+	buswidth: FLASH_BUSWIDTH,
+	read8: ocelot_read8,
+	copy_from: ocelot_copy_from_cache,
+	write8: ocelot_write8,
+};
+
+struct map_info ocelot_nvram_map = {
+	name: "Ocelot NVRAM",
+	size: NVRAM_WINDOW_SIZE,
+	buswidth: NVRAM_BUSWIDTH,
+	read8: ocelot_read8,
+	copy_from: ocelot_copy_from,
+	write8: ocelot_write8,
+	copy_to: ocelot_copy_to
+};
+
+static int __init init_ocelot_maps(void)
+{
+	void *pld;
+	int nr_parts;
+	unsigned char brd_status;
+
+       	printk(KERN_INFO "Momenco Ocelot MTD mappings: Flash 0x%x at 0x%x, NVRAM 0x%x at 0x%x\n", 
+	       FLASH_WINDOW_SIZE, FLASH_WINDOW_ADDR, NVRAM_WINDOW_SIZE, NVRAM_WINDOW_ADDR);
+
+	/* First check whether the flash jumper is present */
+	pld = ioremap(OCELOT_PLD, 0x10);
+	if (!pld) {
+		printk(KERN_NOTICE "Failed to ioremap Ocelot PLD\n");
+		return -EIO;
+	}
+	brd_status = readb(pld+4);
+	iounmap(pld);
+
+	/* Now ioremap the NVRAM space */
+	ocelot_nvram_map.map_priv_1 = (unsigned long)ioremap_nocache(NVRAM_WINDOW_ADDR, NVRAM_WINDOW_SIZE);
+	if (!ocelot_nvram_map.map_priv_1) {
+		printk(KERN_NOTICE "Failed to ioremap Ocelot NVRAM space\n");
+		return -EIO;
+	}
+	//	ocelot_nvram_map.map_priv_2 = ocelot_nvram_map.map_priv_1;
+
+	/* And do the RAM probe on it to get an MTD device */
+	nvram_mtd = do_map_probe("map_ram", &ocelot_nvram_map);
+	if (!nvram_mtd) {
+		printk("NVRAM probe failed\n");
+		goto fail_1;
+	}
+	nvram_mtd->module = THIS_MODULE;
+	nvram_mtd->erasesize = 16;
+
+	/* Now map the flash space */
+	ocelot_flash_map.map_priv_1 = (unsigned long)ioremap_nocache(FLASH_WINDOW_ADDR, FLASH_WINDOW_SIZE);
+	if (!ocelot_flash_map.map_priv_1) {
+		printk(KERN_NOTICE "Failed to ioremap Ocelot flash space\n");
+		goto fail_2;
+	}
+	/* Now the cached version */
+	ocelot_flash_map.map_priv_2 = (unsigned long)__ioremap(FLASH_WINDOW_ADDR, FLASH_WINDOW_SIZE, 0);
+
+	if (!ocelot_flash_map.map_priv_2) {
+		/* Doesn't matter if it failed. Just use the uncached version */
+		ocelot_flash_map.map_priv_2 = ocelot_flash_map.map_priv_1;
+	}
+
+	/* Only probe for flash if the write jumper is present */
+	if (brd_status & 0x40) {
+		flash_mtd = do_map_probe("jedec", &ocelot_flash_map);
+	} else {
+		printk(KERN_NOTICE "Ocelot flash write jumper not present. Treating as ROM\n");
+	}
+	/* If that failed or the jumper's absent, pretend it's ROM */
+	if (!flash_mtd) {
+		flash_mtd = do_map_probe("map_rom", &ocelot_flash_map);
+		/* If we're treating it as ROM, set the erase size */
+		if (flash_mtd)
+			flash_mtd->erasesize = 0x10000;
+	}
+	if (!flash_mtd)
+		goto fail3;
+
+	add_mtd_device(nvram_mtd);
+
+	flash_mtd->module = THIS_MODULE;
+	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts);
+
+	if (nr_parts)
+		add_mtd_partitions(flash_mtd, parsed_parts, nr_parts);
+	else
+		add_mtd_device(flash_mtd);
+
+	return 0;
+	
+ fail3:	
+	iounmap((void *)ocelot_flash_map.map_priv_1);
+	if (ocelot_flash_map.map_priv_2 &&
+	    ocelot_flash_map.map_priv_2 != ocelot_flash_map.map_priv_1)
+			iounmap((void *)ocelot_flash_map.map_priv_2);
+ fail_2:
+	map_destroy(nvram_mtd);
+ fail_1:
+	iounmap((void *)ocelot_nvram_map.map_priv_1);
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_ocelot_maps(void)
+{
+	del_mtd_device(nvram_mtd);
+	map_destroy(nvram_mtd);
+	iounmap((void *)ocelot_nvram_map.map_priv_1);
+
+	if (parsed_parts)
+		del_mtd_partitions(flash_mtd);
+	else
+		del_mtd_device(flash_mtd);
+	map_destroy(flash_mtd);
+	iounmap((void *)ocelot_flash_map.map_priv_1);
+	if (ocelot_flash_map.map_priv_2 != ocelot_flash_map.map_priv_1)
+		iounmap((void *)ocelot_flash_map.map_priv_2);
+}
+
+module_init(init_ocelot_maps);
+module_exit(cleanup_ocelot_maps);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>");
+MODULE_DESCRIPTION("MTD map driver for Momenco Ocelot board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/octagon-5066.c linux-2.4.2/drivers/mtd/maps/octagon-5066.c
--- linux-2.4.2.orig/drivers/mtd/maps/octagon-5066.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/octagon-5066.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,284 @@
+// $Id: octagon-5066.c,v 1.19 2001/10/02 15:05:14 dwmw2 Exp $
+/* ######################################################################
+
+   Octagon 5066 MTD Driver. 
+  
+   The Octagon 5066 is a SBC based on AMD's 586-WB running at 133 MHZ. It
+   comes with a builtin AMD 29F016 flash chip and a socketed EEPROM that
+   is replacable by flash. Both units are mapped through a multiplexer
+   into a 32k memory window at 0xe8000. The control register for the 
+   multiplexing unit is located at IO 0x208 with a bit map of
+     0-5 Page Selection in 32k increments
+     6-7 Device selection:
+        00 SSD off
+        01 SSD 0 (Socket)
+        10 SSD 1 (Flash chip)
+        11 undefined
+  
+   On each SSD, the first 128k is reserved for use by the bios
+   (actually it IS the bios..) This only matters if you are booting off the 
+   flash, you must not put a file system starting there.
+   
+   The driver tries to do a detection algorithm to guess what sort of devices
+   are plugged into the sockets.
+   
+   ##################################################################### */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+
+#define WINDOW_START 0xe8000
+#define WINDOW_LENGTH 0x8000
+#define WINDOW_SHIFT 27
+#define WINDOW_MASK 0x7FFF
+#define PAGE_IO 0x208
+
+static volatile char page_n_dev = 0;
+static unsigned long iomapadr;
+static spinlock_t oct5066_spin = SPIN_LOCK_UNLOCKED;
+
+/*
+ * We use map_priv_1 to identify which device we are.
+ */
+
+static void __oct5066_page(struct map_info *map, __u8 byte)
+{
+	outb(byte,PAGE_IO);
+	page_n_dev = byte;
+}
+
+static inline void oct5066_page(struct map_info *map, unsigned long ofs)
+{
+	__u8 byte = map->map_priv_1 | (ofs >> WINDOW_SHIFT);
+	
+	if (page_n_dev != byte)
+		__oct5066_page(map, byte);
+}
+
+
+static __u8 oct5066_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+	return ret;
+}
+
+static __u16 oct5066_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+	return ret;
+}
+
+static __u32 oct5066_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+	return ret;
+}
+
+static void oct5066_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&oct5066_spin);
+		oct5066_page(map, from);
+		memcpy_fromio(to, iomapadr + from, thislen);
+		spin_unlock(&oct5066_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void oct5066_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+}
+
+static void oct5066_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+}
+
+static void oct5066_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&oct5066_spin);
+	oct5066_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&oct5066_spin);
+}
+
+static void oct5066_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&oct5066_spin);
+		oct5066_page(map, to);
+		memcpy_toio(iomapadr + to, from, thislen);
+		spin_unlock(&oct5066_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info oct5066_map[2] = {
+	{
+		name: "Octagon 5066 Socket",
+		size: 512 * 1024,
+		buswidth: 1,
+		read8: oct5066_read8,
+		read16: oct5066_read16,
+		read32: oct5066_read32,
+		copy_from: oct5066_copy_from,
+		write8: oct5066_write8,
+		write16: oct5066_write16,
+		write32: oct5066_write32,
+		copy_to: oct5066_copy_to,
+		map_priv_1: 1<<6
+	},
+	{
+		name: "Octagon 5066 Internal Flash",
+		size: 2 * 1024 * 1024,
+		buswidth: 1,
+		read8: oct5066_read8,
+		read16: oct5066_read16,
+		read32: oct5066_read32,
+		copy_from: oct5066_copy_from,
+		write8: oct5066_write8,
+		write16: oct5066_write16,
+		write32: oct5066_write32,
+		copy_to: oct5066_copy_to,
+		map_priv_1: 2<<6
+	}
+};
+
+static struct mtd_info *oct5066_mtd[2] = {NULL, NULL};
+
+// OctProbe - Sense if this is an octagon card
+// ---------------------------------------------------------------------
+/* Perform a simple validity test, we map the window select SSD0 and
+   change pages while monitoring the window. A change in the window, 
+   controlled by the PAGE_IO port is a functioning 5066 board. This will
+   fail if the thing in the socket is set to a uniform value. */
+static int __init OctProbe(void)
+{
+   unsigned int Base = (1 << 6);
+   unsigned long I;
+   unsigned long Values[10];
+   for (I = 0; I != 20; I++)
+   {
+      outb(Base + (I%10),PAGE_IO);
+      if (I < 10)
+      {
+	 // Record the value and check for uniqueness
+	 Values[I%10] = readl(iomapadr);
+	 if (I > 0 && Values[I%10] == Values[0])
+	    return -EAGAIN;
+      }      
+      else
+      {
+	 // Make sure we get the same values on the second pass
+	 if (Values[I%10] != readl(iomapadr))
+	    return -EAGAIN;
+      }      
+   }
+   return 0;
+}
+
+void cleanup_oct5066(void)
+{
+	int i;
+	for (i=0; i<2; i++) {
+		if (oct5066_mtd[i]) {
+			del_mtd_device(oct5066_mtd[i]);
+			map_destroy(oct5066_mtd[i]);
+		}
+	}
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,1);
+}
+
+int __init init_oct5066(void)
+{
+	int i;
+	
+	// Do an autoprobe sequence
+	if (check_region(PAGE_IO,1) != 0)
+		{
+			printk("5066: Page Register in Use\n");
+			return -EAGAIN;
+		}
+	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk("Failed to ioremap memory region\n");
+		return -EIO;
+	}
+	if (OctProbe() != 0)
+		{
+			printk("5066: Octagon Probe Failed, is this an Octagon 5066 SBC?\n");
+			iounmap((void *)iomapadr);
+			return -EAGAIN;
+		}
+	
+	request_region(PAGE_IO,1,"Octagon SSD");
+	
+	// Print out our little header..
+	printk("Octagon 5066 SSD IO:0x%x MEM:0x%x-0x%x\n",PAGE_IO,WINDOW_START,
+	       WINDOW_START+WINDOW_LENGTH);
+	
+	for (i=0; i<2; i++) {
+		oct5066_mtd[i] = do_map_probe("cfi_probe", &oct5066_map[i]);
+		if (!oct5066_mtd[i])
+			oct5066_mtd[i] = do_map_probe("jedec", &oct5066_map[i]);
+		if (!oct5066_mtd[i])
+			oct5066_mtd[i] = do_map_probe("map_ram", &oct5066_map[i]);
+		if (!oct5066_mtd[i])
+			oct5066_mtd[i] = do_map_probe("map_rom", &oct5066_map[i]);
+		if (oct5066_mtd[i]) {
+			oct5066_mtd[i]->module = THIS_MODULE;
+			add_mtd_device(oct5066_mtd[i]);
+		}
+	}
+	
+	if (!oct5066_mtd[0] && !oct5066_mtd[1]) {
+		cleanup_oct5066();
+		return -ENXIO;
+	}	  
+	
+	return 0;
+}
+
+module_init(init_oct5066);
+module_exit(cleanup_oct5066);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jason Gunthorpe <jgg@deltatee.com>, David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD map driver for Octagon 5066 Single Board Computer");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/pb1xxx-flash.c linux-2.4.2/drivers/mtd/maps/pb1xxx-flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/pb1xxx-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/pb1xxx-flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,169 @@
+/*
+ * Flash memory access on Alchemy Pb1xxx boards
+ * 
+ * (C) 2001 Pete Popov <ppopov@mvista.com>
+ * 
+ * $Id: pb1xxx-flash.c,v 1.1 2001/11/29 18:43:29 ppopov Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define WINDOW_ADDR 0x1F800000
+#define WINDOW_SIZE 0x800000
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info pb1xxx_map = {
+	name:		"Pb1xxx flash",
+	size: 0x800000,
+	buswidth: 4,
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+#ifdef CONFIG_MIPS_PB1000
+
+static unsigned long pb1000_max_flash_size = 0x00800000;
+static struct mtd_partition pb1000_partitions[] = {
+        {
+                name: "yamon env",
+                size: 0x00020000,
+                offset: 0,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "jffs/2",
+                size: 0x003e0000,
+                offset: 0x20000,
+        },{
+                name: "boot code",
+                size: 0x100000,
+                offset: 0x400000,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw/kernel",
+                size: 0x300000,
+                offset: 0x500000
+        }
+};
+#else
+#error Unsupported board
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init pb1xxx_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	pb1xxx_map.buswidth = 4;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+#ifdef CONFIG_MIPS_PB1000
+	parts = pb1000_partitions;
+	nb_parts = NB_OF(pb1000_partitions);
+#endif
+	pb1xxx_map.size = 4;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Pb1xxx flash: probing %d-bit flash bus\n", 
+			pb1xxx_map.buswidth*8);
+	pb1xxx_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &pb1xxx_map);
+	if (!mymtd)
+		return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit pb1xxx_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(pb1xxx_mtd_init);
+module_exit(pb1xxx_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("Pb1xxx CFI map driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/pci.c linux-2.4.2/drivers/mtd/maps/pci.c
--- linux-2.4.2.orig/drivers/mtd/maps/pci.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/pci.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,385 @@
+/*
+ *  linux/drivers/mtd/maps/pci.c
+ *
+ *  Copyright (C) 2001 Russell King, All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  $Id: pci.c,v 1.1 2001/09/27 20:28:45 rmk Exp $
+ * 
+ * Generic PCI memory map driver.  We support the following boards:
+ *  - Intel IQ80310 ATU.
+ *  - Intel EBSA285 (blank rom programming mode). Tested working 27/09/2001
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+struct map_pci_info;
+
+struct mtd_pci_info {
+	int  (*init)(struct pci_dev *dev, struct map_pci_info *map);
+	void (*exit)(struct pci_dev *dev, struct map_pci_info *map);
+	unsigned long (*translate)(struct map_pci_info *map, unsigned long ofs);
+	const char *map_name;
+};
+
+struct map_pci_info {
+	struct map_info map;
+	void *base;
+	void (*exit)(struct pci_dev *dev, struct map_pci_info *map);
+	unsigned long (*translate)(struct map_pci_info *map, unsigned long ofs);
+	struct pci_dev *dev;
+};	
+
+/*
+ * Intel IOP80310 Flash driver
+ */
+
+static int
+intel_iq80310_init(struct pci_dev *dev, struct map_pci_info *map)
+{
+	u32 win_base;
+
+	map->map.buswidth = 1;
+	map->map.size     = 0x00800000;
+	map->base         = ioremap_nocache(pci_resource_start(dev, 0),
+					    pci_resource_len(dev, 0));
+
+	if (!map->base)
+		return -ENOMEM;
+
+	/*
+	 * We want to base the memory window at Xscale
+	 * bus address 0, not 0x1000.
+	 */
+	pci_read_config_dword(dev, 0x44, &win_base);
+	pci_write_config_dword(dev, 0x44, 0);
+
+	map->map.map_priv_2 = win_base;
+
+	return 0;
+}
+
+static void
+intel_iq80310_exit(struct pci_dev *dev, struct map_pci_info *map)
+{
+	if (map->base)
+		iounmap((void *)map->base);
+	pci_write_config_dword(dev, 0x44, map->map.map_priv_2);
+}
+
+static unsigned long
+intel_iq80310_translate(struct map_pci_info *map, unsigned long ofs)
+{
+	unsigned long page_addr = ofs & 0x00400000;
+
+	/*
+	 * This mundges the flash location so we avoid
+	 * the first 80 bytes (they appear to read nonsense).
+	 */
+	if (page_addr) {
+		writel(0x00000008, map->base + 0x1558);
+		writel(0x00000000, map->base + 0x1550);
+	} else {
+		writel(0x00000007, map->base + 0x1558);
+		writel(0x00800000, map->base + 0x1550);
+		ofs += 0x00800000;
+	}
+
+	return ofs;
+}
+
+static struct mtd_pci_info intel_iq80310_info = {
+	init:		intel_iq80310_init,
+	exit:		intel_iq80310_exit,
+	translate:	intel_iq80310_translate,
+	map_name:	"cfi_probe",
+};
+
+/*
+ * Intel DC21285 driver
+ */
+
+static int
+intel_dc21285_init(struct pci_dev *dev, struct map_pci_info *map)
+{
+	unsigned long base, len;
+
+	base = pci_resource_start(dev, PCI_ROM_RESOURCE);
+	len  = pci_resource_len(dev, PCI_ROM_RESOURCE);
+
+	if (!len || !base) {
+		/*
+		 * No ROM resource
+		 */
+		base = pci_resource_start(dev, 2);
+		len  = pci_resource_len(dev, 2);
+
+		/*
+		 * We need to re-allocate PCI BAR2 address range to the
+		 * PCI ROM BAR, and disable PCI BAR2.
+		 */
+	} else {
+		/*
+		 * Hmm, if an address was allocated to the ROM resource, but
+		 * not enabled, should we be allocating a new resource for it
+		 * or simply enabling it?
+		 */
+		if (!(pci_resource_flags(dev, PCI_ROM_RESOURCE) &
+		     PCI_ROM_ADDRESS_ENABLE)) {
+		     	u32 val;
+			pci_resource_flags(dev, PCI_ROM_RESOURCE) |= PCI_ROM_ADDRESS_ENABLE;
+			pci_read_config_dword(dev, PCI_ROM_ADDRESS, &val);
+			val |= PCI_ROM_ADDRESS_ENABLE;
+			pci_write_config_dword(dev, PCI_ROM_ADDRESS, val);
+			printk("%s: enabling expansion ROM\n", dev->slot_name);
+		}
+	}
+
+	if (!len || !base)
+		return -ENXIO;
+
+	map->map.buswidth = 4;
+	map->map.size     = len;
+	map->base         = ioremap_nocache(base, len);
+
+	if (!map->base)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void
+intel_dc21285_exit(struct pci_dev *dev, struct map_pci_info *map)
+{
+	u32 val;
+
+	if (map->base)
+		iounmap((void *)map->base);
+
+	/*
+	 * We need to undo the PCI BAR2/PCI ROM BAR address alteration.
+	 */
+	pci_resource_flags(dev, PCI_ROM_RESOURCE) &= ~PCI_ROM_ADDRESS_ENABLE;
+	pci_read_config_dword(dev, PCI_ROM_ADDRESS, &val);
+	val &= ~PCI_ROM_ADDRESS_ENABLE;
+	pci_write_config_dword(dev, PCI_ROM_ADDRESS, val);
+}
+
+static unsigned long
+intel_dc21285_translate(struct map_pci_info *map, unsigned long ofs)
+{
+	return ofs & 0x00ffffc0 ? ofs : (ofs ^ (1 << 5));
+}
+
+static struct mtd_pci_info intel_dc21285_info = {
+	init:		intel_dc21285_init,
+	exit:		intel_dc21285_exit,
+	translate:	intel_dc21285_translate,
+	map_name:	"jedec_probe",
+};
+
+/*
+ * PCI device ID table
+ */
+
+static struct pci_device_id mtd_pci_ids[] __devinitdata = {
+	{
+		vendor:		PCI_VENDOR_ID_INTEL,
+		device:		0x530d,
+		subvendor:	PCI_ANY_ID,
+		subdevice:	PCI_ANY_ID,
+		class:		PCI_CLASS_MEMORY_OTHER << 8,
+		class_mask:	0xffff00,
+		driver_data:	(unsigned long)&intel_iq80310_info,
+	},
+	{
+		vendor:		PCI_VENDOR_ID_DEC,
+		device:		PCI_DEVICE_ID_DEC_21285,
+		subvendor:	0,	/* DC21285 defaults to 0 on reset */
+		subdevice:	0,	/* DC21285 defaults to 0 on reset */
+		class:		0,
+		class_mask:	0,
+		driver_data:	(unsigned long)&intel_dc21285_info,
+	},
+	{ 0, }
+};
+
+/*
+ * Generic code follows.
+ */
+
+static u8 mtd_pci_read8(struct map_info *_map, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	u8 val = readb(map->base + map->translate(map, ofs));
+//	printk("read8 : %08lx => %02x\n", ofs, val);
+	return val;
+}
+
+static u16 mtd_pci_read16(struct map_info *_map, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	u16 val = readw(map->base + map->translate(map, ofs));
+//	printk("read16: %08lx => %04x\n", ofs, val);
+	return val;
+}
+
+static u32 mtd_pci_read32(struct map_info *_map, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	u32 val = readl(map->base + map->translate(map, ofs));
+//	printk("read32: %08lx => %08x\n", ofs, val);
+	return val;
+}
+
+static void mtd_pci_copyfrom(struct map_info *_map, void *to, unsigned long from, ssize_t len)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	memcpy_fromio(to, map->base + map->translate(map, from), len);
+}
+
+static void mtd_pci_write8(struct map_info *_map, u8 val, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write8 : %08lx <= %02x\n", ofs, val);
+	writeb(val, map->base + map->translate(map, ofs));
+}
+
+static void mtd_pci_write16(struct map_info *_map, u16 val, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write16: %08lx <= %04x\n", ofs, val);
+	writew(val, map->base + map->translate(map, ofs));
+}
+
+static void mtd_pci_write32(struct map_info *_map, u32 val, unsigned long ofs)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+//	printk("write32: %08lx <= %08x\n", ofs, val);
+	writel(val, map->base + map->translate(map, ofs));
+}
+
+static void mtd_pci_copyto(struct map_info *_map, unsigned long to, const void *from, ssize_t len)
+{
+	struct map_pci_info *map = (struct map_pci_info *)_map;
+	memcpy_toio(map->base + map->translate(map, to), from, len);
+}
+
+static struct map_info mtd_pci_map = {
+	read8:		mtd_pci_read8,
+	read16:		mtd_pci_read16,
+	read32:		mtd_pci_read32,
+	copy_from:	mtd_pci_copyfrom,
+	write8:		mtd_pci_write8,
+	write16:	mtd_pci_write16,
+	write32:	mtd_pci_write32,
+	copy_to:	mtd_pci_copyto,
+};
+
+static int __devinit
+mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	struct mtd_pci_info *info = (struct mtd_pci_info *)id->driver_data;
+	struct map_pci_info *map = NULL;
+	struct mtd_info *mtd = NULL;
+	int err;
+
+	err = pci_enable_device(dev);
+	if (err)
+		goto out;
+
+	err = pci_request_regions(dev, "pci mtd");
+	if (err)
+		goto out;
+
+	map = kmalloc(sizeof(*map), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!map)
+		goto release;
+
+	map->map       = mtd_pci_map;
+	map->map.name  = dev->slot_name;
+	map->dev       = dev;
+	map->exit      = info->exit;
+	map->translate = info->translate;
+
+	err = info->init(dev, map);
+	if (err)
+		goto release;
+
+	/* tsk - do_map_probe should take const char * */
+	mtd = do_map_probe((char *)info->map_name, &map->map);
+	err = -ENODEV;
+	if (!mtd)
+		goto release;
+
+	mtd->module = THIS_MODULE;
+	add_mtd_device(mtd);
+
+	pci_set_drvdata(dev, mtd);
+
+	return 0;
+
+release:
+	if (mtd)
+		map_destroy(mtd);
+
+	if (map) {
+		map->exit(dev, map);
+		kfree(map);
+	}
+
+	pci_release_regions(dev);
+out:
+	return err;
+}
+
+static void __devexit
+mtd_pci_remove(struct pci_dev *dev)
+{
+	struct mtd_info *mtd = pci_get_drvdata(dev);
+	struct map_pci_info *map = mtd->priv;
+
+	del_mtd_device(mtd);
+	map_destroy(mtd);
+	map->exit(dev, map);
+	kfree(map);
+
+	pci_set_drvdata(dev, NULL);
+	pci_release_regions(dev);
+}
+
+static struct pci_driver mtd_pci_driver = {
+	name:		"MTD PCI",
+	probe:		mtd_pci_probe,
+	remove:		mtd_pci_remove,
+	id_table:	mtd_pci_ids,
+};
+
+static int __init mtd_pci_maps_init(void)
+{
+	return pci_module_init(&mtd_pci_driver);
+}
+
+static void __exit mtd_pci_maps_exit(void)
+{
+	pci_unregister_driver(&mtd_pci_driver);
+}
+
+module_init(mtd_pci_maps_init);
+module_exit(mtd_pci_maps_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");
+MODULE_DESCRIPTION("Generic PCI map driver");
+MODULE_DEVICE_TABLE(pci, mtd_pci_ids);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/physmap.c linux-2.4.2/drivers/mtd/maps/physmap.c
--- linux-2.4.2.orig/drivers/mtd/maps/physmap.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/physmap.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,126 @@
+/*
+ * $Id: physmap.c,v 1.16 2002/01/10 20:27:41 eric Exp $
+ *
+ * Normal mappings of chips in physical memory
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR CONFIG_MTD_PHYSMAP_START
+#define WINDOW_SIZE CONFIG_MTD_PHYSMAP_LEN
+#define BUSWIDTH CONFIG_MTD_PHYSMAP_BUSWIDTH
+
+static struct mtd_info *mymtd;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info physmap_map = {
+	name: "Physically mapped flash",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to
+};
+
+int __init init_physmap(void)
+{
+	static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", 0 };
+	char **type;
+
+       	printk(KERN_NOTICE "physmap flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	physmap_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!physmap_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	
+	mymtd = 0;
+	type = rom_probe_types;
+	for(; !mymtd && *type; type++) {
+		mymtd = do_map_probe(*type, &physmap_map);
+	}
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		add_mtd_device(mymtd);
+		return 0;
+	}
+
+	iounmap((void *)physmap_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_physmap(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (physmap_map.map_priv_1) {
+		iounmap((void *)physmap_map.map_priv_1);
+		physmap_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_physmap);
+module_exit(cleanup_physmap);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Generic configurable MTD map driver");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/pnc2000.c linux-2.4.2/drivers/mtd/maps/pnc2000.c
--- linux-2.4.2.orig/drivers/mtd/maps/pnc2000.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/pnc2000.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,135 @@
+/*
+ *	pnc2000.c - mapper for Photron PNC-2000 board.
+ *
+ * Copyright (C) 2000 Crossnet Co. <info@crossnet.co.jp>
+ *
+ * This code is GPL
+ *
+ * $Id: pnc2000.c,v 1.10 2001/10/02 15:05:14 dwmw2 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 0xbf000000
+#define WINDOW_SIZE 0x00400000
+
+/* 
+ * MAP DRIVER STUFF
+ */
+
+__u8 pnc_read8(struct map_info *map, unsigned long ofs)
+{
+  return *(__u8 *)(WINDOW_ADDR + ofs);
+}
+
+__u16 pnc_read16(struct map_info *map, unsigned long ofs)
+{
+  return *(__u16 *)(WINDOW_ADDR + ofs);
+}
+
+__u32 pnc_read32(struct map_info *map, unsigned long ofs)
+{
+  return *(volatile unsigned int *)(WINDOW_ADDR + ofs);
+}
+
+void pnc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+  memcpy(to, (void *)(WINDOW_ADDR + from), len);
+}
+
+void pnc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+  *(__u8 *)(WINDOW_ADDR + adr) = d;
+}
+
+void pnc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+  *(__u16 *)(WINDOW_ADDR + adr) = d;
+}
+
+void pnc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+  *(__u32 *)(WINDOW_ADDR + adr) = d;
+}
+
+void pnc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+  memcpy((void *)(WINDOW_ADDR + to), from, len);
+}
+
+struct map_info pnc_map = {
+	name: "PNC-2000",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: pnc_read8,
+	read16: pnc_read16,
+	read32: pnc_read32,
+	copy_from: pnc_copy_from,
+	write8: pnc_write8,
+	write16: pnc_write16,
+	write32: pnc_write32,
+	copy_to: pnc_copy_to
+};
+
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ */
+static struct mtd_partition pnc_partitions[3] = {
+	{
+		name: "PNC-2000 boot firmware",
+		size: 0x20000,
+		offset: 0
+	},
+	{
+		name: "PNC-2000 kernel",
+		size: 0x1a0000,
+		offset: 0x20000
+	},
+	{
+		name: "PNC-2000 filesystem",
+		size: 0x240000,
+		offset: 0x1c0000
+	}
+};
+
+/* 
+ * This is the master MTD device for which all the others are just
+ * auto-relocating aliases.
+ */
+static struct mtd_info *mymtd;
+
+int __init init_pnc2000(void)
+{
+	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+
+	mymtd = do_map_probe("cfi_probe", &pnc_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		return add_mtd_partitions(mymtd, pnc_partitions, 3);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_pnc2000(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+}
+
+module_init(init_pnc2000);
+module_exit(cleanup_pnc2000);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Crossnet Co. <info@crossnet.co.jp>");
+MODULE_DESCRIPTION("MTD map driver for Photron PNC-2000 board");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/rpxlite.c linux-2.4.2/drivers/mtd/maps/rpxlite.c
--- linux-2.4.2.orig/drivers/mtd/maps/rpxlite.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/rpxlite.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,114 @@
+/*
+ * $Id: rpxlite.c,v 1.15 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * Handle mapping of the flash on the RPX Lite and CLLF boards
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_ADDR 0xfe000000
+#define WINDOW_SIZE 0x800000
+
+static struct mtd_info *mymtd;
+
+__u8 rpxlite_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 rpxlite_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 rpxlite_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void rpxlite_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+void rpxlite_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void rpxlite_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void rpxlite_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void rpxlite_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+struct map_info rpxlite_map = {
+	name: "RPX",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: rpxlite_read8,
+	read16: rpxlite_read16,
+	read32: rpxlite_read32,
+	copy_from: rpxlite_copy_from,
+	write8: rpxlite_write8,
+	write16: rpxlite_write16,
+	write32: rpxlite_write32,
+	copy_to: rpxlite_copy_to
+};
+
+int __init init_rpxlite(void)
+{
+	printk(KERN_NOTICE "RPX Lite or CLLF flash device: %x at %x\n", WINDOW_SIZE*4, WINDOW_ADDR);
+	rpxlite_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+
+	if (!rpxlite_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &rpxlite_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_device(mymtd);
+		return 0;
+	}
+
+	iounmap((void *)rpxlite_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_rpxlite(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (rpxlite_map.map_priv_1) {
+		iounmap((void *)rpxlite_map.map_priv_1);
+		rpxlite_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_rpxlite);
+module_exit(cleanup_rpxlite);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Arnold Christensen <AKC@pel.dk>");
+MODULE_DESCRIPTION("MTD map driver for RPX Lite and CLLF boards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/sa1100-flash.c linux-2.4.2/drivers/mtd/maps/sa1100-flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/sa1100-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/sa1100-flash.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,921 @@
+/*
+ * Flash memory access on SA11x0 based devices
+ * 
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ * 
+ * $Id: sa1100-flash.c,v 1.23 2002/01/01 23:26:07 rmk Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+#ifndef CONFIG_ARCH_SA1100
+#error This is for SA1100 architecture only
+#endif
+
+
+#define WINDOW_ADDR 0xe8000000
+
+static __u8 sa1100_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 sa1100_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 sa1100_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void sa1100_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void sa1100_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sa1100_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sa1100_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sa1100_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info sa1100_map = {
+	name:		"SA1100 flash",
+	read8:		sa1100_read8,
+	read16:		sa1100_read16,
+	read32:		sa1100_read32,
+	copy_from:	sa1100_copy_from,
+	write8:		sa1100_write8,
+	write16:	sa1100_write16,
+	write32:	sa1100_write32,
+	copy_to:	sa1100_copy_to,
+
+	map_priv_1:	WINDOW_ADDR,
+	map_priv_2:	-1,
+};
+
+
+/*
+ * Here are partition information for all known SA1100-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ *
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must be no more than
+ * the value specified in the "struct map_desc *_io_desc" mapping
+ * definition for the corresponding machine.
+ *
+ * Please keep these in alphabetical order, and formatted as per existing
+ * entries.  Thanks.
+ */
+
+#ifdef CONFIG_SA1100_ADSBITSY
+#define ADSBITSY_FLASH_SIZE		0x02000000
+static struct mtd_partition adsbitsy_partitions[] = {
+	{
+		name:		"bootROM",
+		size:		0x80000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"zImage",
+		size:		0x100000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"ramdisk.gz",
+		size:		0x300000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"User FS",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+/* Phase 4 Assabet has two 28F160B3 flash parts in bank 0: */
+#define ASSABET4_FLASH_SIZE		0x00400000
+static struct mtd_partition assabet4_partitions[] = {
+	{
+		name:		"bootloader",
+		size:		0x00020000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"bootloader params",
+		size:		0x00020000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"jffs",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+
+/* Phase 5 Assabet has two 28F128J3A flash parts in bank 0: */
+#define ASSABET5_FLASH_SIZE		0x02000000
+static struct mtd_partition assabet5_partitions[] = {
+	{
+		name:		"bootloader",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"bootloader params",
+		size:		0x00040000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"jffs",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+
+#define ASSABET_FLASH_SIZE	ASSABET5_FLASH_SIZE
+#define assabet_partitions	assabet5_partitions
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+#ifdef CONFIG_SA1100_CERF_FLASH_32MB
+#define CERF_FLASH_SIZE			0x02000000
+static struct mtd_partition cerf_partitions[] = {
+	{
+		name:		"firmware",
+		size:		0x00040000,
+		offset:		0,
+	}, {
+		name:		"params",
+		size:		0x00040000,
+		offset:		0x00040000,
+	}, {
+		name:		"kernel",
+		size:		0x00100000,
+		offset:		0x00080000,
+	}, {
+		name:		"rootdisk",
+		size:		0x01E80000,
+		offset:		0x00180000,
+	}
+};
+#elif defined CONFIG_SA1100_CERF_FLASH_16MB
+#define CERF_FLASH_SIZE			0x01000000
+static struct mtd_partition cerf_partitions[] = {
+	{
+		name:		"firmware",
+		size:		0x00020000,
+		offset:		0,
+	}, {
+		name:		"params",
+		size:		0x00020000,
+		offset:		0x00020000,
+	}, {
+		name:		"kernel",
+		size:		0x00100000,
+		offset:		0x00040000,
+	}, {
+		name:		"rootdisk",
+		size:		0x00EC0000,
+		offset:		0x00140000,
+	}
+};
+#elif defined CONFIG_SA1100_CERF_FLASH_8MB
+#   error "Unwritten type definition"
+#else
+#   error "Undefined memory orientation for CERF in sa1100-flash.c"
+#endif
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+/* Flexanet has two 28F128J3A flash parts in bank 0: */
+#define FLEXANET_FLASH_SIZE		0x02000000
+static struct mtd_partition flexanet_partitions[] = {
+	{
+		name:		"bootloader",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"bootloader params",
+		size:		0x00040000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"kernel",
+		size:		0x000C0000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"altkernel",
+		size:		0x000C0000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"root",
+		size:		0x00400000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"free1",
+		size:		0x00300000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"free2",
+		size:		0x00300000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}, {
+		name:		"free3",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_FREEBIRD
+#define FREEBIRD_FLASH_SIZE		0x02000000
+static struct mtd_partition freebird_partitions[] = {
+#if CONFIG_SA1100_FREEBIRD_NEW
+	{
+		name:		"firmware",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"kernel",
+		size:		0x00080000,
+		offset:		0x00040000,
+	}, {
+		name:		"params",
+		size:		0x00040000,
+		offset:		0x000C0000,
+	}, {
+		name:		"initrd",
+		size:		0x00100000,
+		offset:		0x00100000,
+	}, {
+		name:		"root cramfs",
+		size:		0x00300000,
+		offset:		0x00200000,
+	}, {
+		name:		"usr cramfs",
+		size:		0x00C00000,
+		offset:		0x00500000,
+	}, {
+		name:		"local",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x01100000,
+	}
+#else
+	{
+		size:		0x00040000,
+		offset:		0,
+	}, {
+		size:		0x000c0000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		size:		0x00400000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+#endif
+};
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+#define GRAPHICSCLIENT_FLASH_SIZE	0x02000000
+static struct mtd_partition graphicsclient_partitions[] = {
+	{
+		name:		"zImage",
+		size:		0x100000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"ramdisk.gz",
+		size:		0x300000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"User FS",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+#define GRAPHICSMASTER_FLASH_SIZE	0x01000000
+static struct mtd_partition graphicsmaster_partitions[] = {
+	{
+		name:		"zImage",
+		size:		0x100000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		name:		"ramdisk.gz",
+		size:		0x300000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		name:		"User FS",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+#define H3600_FLASH_SIZE		0x02000000
+static struct mtd_partition h3600_partitions[] = {
+	{
+		name:		"H3600 boot firmware",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"H3600 kernel",
+		size:		0x00080000,
+		offset:		0x00040000,
+	}, {
+		name:		"H3600 params",
+		size:		0x00040000,
+		offset:		0x000C0000,
+	}, {
+#ifdef CONFIG_JFFS2_FS
+		name:		"H3600 root jffs2",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00100000,
+#else
+		name:		"H3600 initrd",
+		size:		0x00100000,
+		offset:		0x00100000,
+	}, {
+		name:		"H3600 root cramfs",
+		size:		0x00300000,
+		offset:		0x00200000,
+	}, {
+		name:		"H3600 usr cramfs",
+		size:		0x00800000,
+		offset:		0x00500000,
+	}, {
+		name:		"H3600 usr local",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00d00000,
+#endif
+	}
+};
+
+static void h3600_set_vpp(struct map_info *map, int vpp)
+{
+	assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, vpp);
+}
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+#define HUW_WEBPANEL_FLASH_SIZE		0x01000000
+static struct mtd_partition huw_webpanel_partitions[] = {
+	{
+		name:		"Loader",
+		size:		0x00040000,
+		offset:		0,
+	}, {
+		name:		"Sector 1",
+		size:		0x00040000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+#define JORNADA720_FLASH_SIZE		0x02000000
+static struct mtd_partition jornada720_partitions[] = {
+	{
+		name:		"JORNADA720 boot firmware",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"JORNADA720 kernel",
+		size:		0x000c0000,
+		offset:		0x00040000,
+	}, {
+		name:		"JORNADA720 params",
+		size:		0x00040000,
+		offset:		0x00100000,
+	}, {
+		name:		"JORNADA720 initrd",
+		size:		0x00100000,
+		offset:		0x00140000,
+	}, {
+		name:		"JORNADA720 root cramfs",
+		size:		0x00300000,
+		offset:		0x00240000,
+	}, {
+		name:		"JORNADA720 usr cramfs",
+		size:		0x00800000,
+		offset:		0x00540000,
+	}, {
+		name:		"JORNADA720 usr local",
+		size:		0  /* will expand to the end of the flash */
+		offset:		0x00d00000,
+	}
+};
+
+static void jornada720_set_vpp(int vpp)
+{
+	if (vpp)
+		PPSR |= 0x80;
+	else
+		PPSR &= ~0x80;
+	PPDR |= 0x80;
+}
+
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+#define PANGOLIN_FLASH_SIZE		0x04000000
+static struct mtd_partition pangolin_partitions[] = {
+	{
+		name:		"boot firmware",
+		size:		0x00080000,
+		offset:		0x00000000,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"kernel",
+		size:		0x00100000,
+		offset:		0x00080000,
+	}, {
+		name:		"initrd",
+		size:		0x00280000,
+		offset:		0x00180000,
+	}, {
+		name:		"initrd-test",
+		size:		0x03C00000,
+		offset:		0x00400000,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+/* erase size is 0x40000 == 256k partitions have to have this boundary */
+#define SYSTEM3_FLASH_SIZE		0x01000000
+static struct mtd_partition system3_partitions[] = {
+	{
+		name:		"BLOB",
+		size:		0x00040000,
+		offset:		0x00000000,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"config",
+		size:		0x00040000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		name:		"kernel",
+		size:		0x00100000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		name:		"root",
+		size:		MTDPART_SIZ_FULL,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+#define SHANNON_FLASH_SIZE		0x00400000
+static struct mtd_partition shannon_partitions[] = {
+	{
+		name: "BLOB boot loader",
+		offset: 0,
+		size: 0x20000
+	},
+	{
+		name: "kernel",
+		offset: MTDPART_OFS_APPEND,
+		size: 0xe0000
+	},
+	{ 
+		name: "initrd",
+		offset: MTDPART_OFS_APPEND,	
+		size: MTDPART_SIZ_FULL
+	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+#define SHERMAN_FLASH_SIZE		0x02000000
+static struct mtd_partition sherman_partitions[] = {
+	{
+		size:		0x50000,
+		offset:		0,
+	}, {
+		size:		0x70000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		size:		0x600000,
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		size:		0xA0000,
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+#define SIMPAD_FLASH_SIZE		0x02000000
+static struct mtd_partition simpad_partitions[] = {
+	{
+		name:		"SIMpad boot firmware",
+		size:		0x00080000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"SIMpad kernel",
+		size:		0x00100000,
+		offset:		0x00080000,
+	}, {
+#ifdef CONFIG_JFFS2_FS
+		name:		"SIMpad root jffs2",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00180000,
+#else
+		name:		"SIMpad initrd",
+		size:		0x00300000,
+		offset:		0x00180000,
+	}, {
+		name:		"SIMpad root cramfs",
+		size:		0x00300000,
+		offset:		0x00480000,
+	}, {
+		name:		"SIMpad usr cramfs",
+		size:		0x005c0000,
+		offset:		0x00780000,
+	}, {
+		name:		"SIMpad usr local",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00d40000,
+#endif
+	}
+};
+#endif /* CONFIG_SA1100_SIMPAD */
+
+#ifdef CONFIG_SA1100_STORK
+#define STORK_FLASH_SIZE		0x02000000
+static struct mtd_partition stork_partitions[] = {
+	{
+		name:		"STORK boot firmware",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"STORK params",
+		size:		0x00040000,
+		offset:		0x00040000,
+	}, {
+		name:		"STORK kernel",
+		size:		0x00100000,
+		offset:		0x00080000,
+	}, {
+#ifdef CONFIG_JFFS2_FS
+		name:		"STORK root jffs2",
+		offset:		0x00180000,
+		size:		MTDPART_SIZ_FULL,
+#else
+		name:		"STORK initrd",
+		size:		0x00100000,
+		offset:		0x00180000,
+	}, {
+		name:		"STORK root cramfs",
+		size:		0x00300000,
+		offset:		0x00280000,
+	}, {
+		name:		"STORK usr cramfs",
+		size:		0x00800000,
+		offset:		0x00580000,
+	}, {
+		name:		"STORK usr local",
+		offset:		0x00d80000,
+		size:		MTDPART_SIZ_FULL,
+#endif
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+#define YOPY_FLASH_SIZE			0x08000000
+static struct mtd_partition yopy_partitions[] = {
+	{
+		name:		"boot firmware",
+		size:		0x00040000,
+		offset:		0x00000000,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"kernel",
+		size:		0x00080000,
+		offset:		0x00080000,
+	}, {
+		name:		"initrd",
+		size:		0x00300000,
+		offset:		0x00100000,
+	}, {
+		name:		"root",
+		size:		0x01000000,
+		offset:		0x00400000,
+	}
+};
+#endif
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init sa1100_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0, ret;
+	int parsed_nr_parts = 0;
+	const char *part_type;
+	unsigned long base = -1UL;
+
+	/* Default flash buswidth */
+	sa1100_map.buswidth = (MSC0 & MSC_RBW) ? 2 : 4;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+
+#ifdef CONFIG_SA1100_ADSBITSY
+	if (machine_is_adsbitsy()) {
+		parts = adsbitsy_partitions;
+		nb_parts = ARRAY_SIZE(adsbitsy_partitions);
+		sa1100_map.size = ADSBITSY_FLASH_SIZE;
+		sa1100_map.buswidth = (MSC1 & MSC_RBW) ? 2 : 4;
+		base = 0x08000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_ASSABET
+	if (machine_is_assabet()) {
+		parts = assabet_partitions;
+		nb_parts = ARRAY_SIZE(assabet_partitions);
+		sa1100_map.size = ASSABET_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_CERF
+	if (machine_is_cerf()) {
+		parts = cerf_partitions;
+		nb_parts = ARRAY_SIZE(cerf_partitions);
+		sa1100_map.size = CERF_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_FLEXANET
+	if (machine_is_flexanet()) {
+		parts = flexanet_partitions;
+		nb_parts = ARRAY_SIZE(flexanet_partitions);
+		sa1100_map.size = FLEXANET_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_FREEBIRD
+	if (machine_is_freebird()) {
+		parts = freebird_partitions;
+		nb_parts = ARRAY_SIZE(freebird_partitions);
+		sa1100_map.size = FREEBIRD_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+	if (machine_is_graphicsclient()) {
+		parts = graphicsclient_partitions;
+		nb_parts = ARRAY_SIZE(graphicsclient_partitions);
+		sa1100_map.size = GRAPHICSCLIENT_FLASH_SIZE;
+		sa1100_map.buswidth = (MSC1 & MSC_RBW) ? 2:4;
+		base = 0x08000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+	if (machine_is_graphicsmaster()) {
+		parts = graphicsmaster_partitions;
+		nb_parts = ARRAY_SIZE(graphicsmaster_partitions);
+		sa1100_map.size = GRAPHICSMASTER_FLASH_SIZE;
+		sa1100_map.buswidth = (MSC1 & MSC_RBW) ? 2:4;
+		base = 0x08000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_H3600
+	if (machine_is_h3600()) {
+		parts = h3600_partitions;
+		nb_parts = ARRAY_SIZE(h3600_partitions);
+		sa1100_map.size = H3600_FLASH_SIZE;
+		sa1100_map.set_vpp = h3600_set_vpp;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+	if (machine_is_huw_webpanel()) {
+		parts = huw_webpanel_partitions;
+		nb_parts = ARRAY_SIZE(huw_webpanel_partitions);
+		sa1100_map.size = HUW_WEBPANEL_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_JORNADA720
+	if (machine_is_jornada720()) {
+		parts = jornada720_partitions;
+		nb_parts = ARRAY_SIZE(jornada720_partitions);
+		sa1100_map.size = JORNADA720_FLASH_SIZE;
+		sa1100_map.set_vpp = jornada720_set_vpp;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_PANGOLIN
+	if (machine_is_pangolin()) {
+		parts = pangolin_partitions;
+		nb_parts = ARRAY_SIZE(pangolin_partitions);
+		sa1100_map.size = PANGOLIN_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+	if (machine_is_pt_system3()) {
+		parts = system3_partitions;
+		nb_parts = ARRAY_SIZE(system3_partitions);
+		sa1100_map.size = SYSTEM3_FLASH_SIZE;
+	}
+#endif
+#ifdef CONFIG_SA1100_SHANNON
+	if (machine_is_shannon()) {
+		parts = shannon_partitions;
+		nb_parts = ARRAY_SIZE(shannon_partitions);
+		sa1100_map.size = SHANNON_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_SHERMAN
+	if (machine_is_sherman()) {
+		parts = sherman_partitions;
+		nb_parts = ARRAY_SIZE(sherman_partitions);
+		sa1100_map.size = SHERMAN_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_SIMPAD
+	if (machine_is_simpad()) {
+		parts = simpad_partitions;
+		nb_parts = ARRAY_SIZE(simpad_partitions);
+		sa1100_map.size = SIMPAD_FLASH_SIZE;
+		base = 0x00000000;
+	}
+#endif
+#ifdef CONFIG_SA1100_STORK
+	if (machine_is_stork()) {
+		parts = stork_partitions;
+		nb_parts = ARRAY_SIZE(stork_partitions);
+		sa1100_map.size = STORK_FLASH_SIZE;
+	}
+#endif
+#ifdef CONFIG_SA1100_YOPY
+	if (machine_is_yopy()) {
+		parts = yopy_partitions;
+		nb_parts = ARRAY_SIZE(yopy_partitions);
+		sa1100_map.size = YOPY_FLASH_SIZE;
+		/* uses static mapping */
+	}
+#endif
+
+	/*
+	 * For simple flash devices, use ioremap to map the flash.
+	 */
+	if (base != (unsigned long)-1) {
+		if (!request_mem_region(base, sa1100_map.size, "flash"))
+			return -EBUSY;
+		sa1100_map.map_priv_2 = base;
+		sa1100_map.map_priv_1 = (unsigned long)
+				ioremap(base, sa1100_map.size);
+		ret = -ENOMEM;
+		if (!sa1100_map.map_priv_1)
+			goto out_err;
+	}
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "SA1100 flash: probing %d-bit flash bus\n", sa1100_map.buswidth*8);
+	mymtd = do_map_probe("cfi_probe", &sa1100_map);
+	ret = -ENXIO;
+	if (!mymtd)
+		goto out_err;
+	mymtd->module = THIS_MODULE;
+
+	/*
+	 * Dynamic partition selection stuff (might override the static ones)
+	 */
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	if (parsed_nr_parts == 0) {
+		int ret = parse_redboot_partitions(mymtd, &parsed_parts);
+
+		if (ret > 0) {
+			part_type = "RedBoot";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+#ifdef CONFIG_MTD_BOOTLDR_PARTS
+	if (parsed_nr_parts == 0) {
+		int ret = parse_bootldr_partitions(mymtd, &parsed_parts);
+		if (ret > 0) {
+			part_type = "Compaq bootldr";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	}
+
+	if (nb_parts == 0) {
+		printk(KERN_NOTICE "SA1100 flash: no partition info available, registering whole flash at once\n");
+		add_mtd_device(mymtd);
+	} else {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	}
+	return 0;
+
+ out_err:
+	if (sa1100_map.map_priv_2 != -1) {
+		iounmap((void *)sa1100_map.map_priv_1);
+		release_mem_region(sa1100_map.map_priv_2, sa1100_map.size);
+	}
+	return ret;
+}
+
+static void __exit sa1100_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (sa1100_map.map_priv_2 != -1) {
+		iounmap((void *)sa1100_map.map_priv_1);
+		release_mem_region(sa1100_map.map_priv_2, sa1100_map.size);
+	}
+}
+
+module_init(sa1100_mtd_init);
+module_exit(sa1100_mtd_cleanup);
+
+MODULE_AUTHOR("Nicolas Pitre");
+MODULE_DESCRIPTION("SA1100 CFI map driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/sbc_gxx.c linux-2.4.2/drivers/mtd/maps/sbc_gxx.c
--- linux-2.4.2.orig/drivers/mtd/maps/sbc_gxx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/sbc_gxx.c	Fri Feb 15 14:41:15 2002
@@ -0,0 +1,277 @@
+/* sbc_gxx.c -- MTD map driver for Arcom Control Systems SBC-MediaGX,
+                SBC-GXm and SBC-GX1 series boards.
+ 
+   Copyright (C) 2001 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: sbc_gxx.c,v 1.19 2001/10/02 15:05:14 dwmw2 Exp $
+
+The SBC-MediaGX / SBC-GXx has up to 16 MiB of 
+Intel StrataFlash (28F320/28F640) in x8 mode.  
+
+This driver uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   16 kbyte memory window at 0xdc000-0xdffff
+   
+   Two IO address locations for paging
+   
+   0x258
+       bit 0-7: address bit 14-21
+   0x259
+       bit 0-1: address bit 22-23
+       bit 7:   0 - reset/powered down
+                1 - device enabled
+
+The single flash device is divided into 3 partition which appear as 
+separate MTD devices.
+
+25/04/2001 AJL (Arcom)  Modified signon strings and partition sizes
+                        (to support bzImages up to 638KiB-ish)
+*/
+
+// Includes
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+// Defines
+
+// - Hardware specific
+
+#define WINDOW_START 0xdc000
+
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 14
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x258
+#define PAGE_IO_SIZE 2
+
+/* bit 7 of 0x259 must be 1 to enable device. */
+#define DEVICE_ENABLE 0x8000
+
+// - Flash / Partition sizing
+
+#define MAX_SIZE_KiB             16384
+#define BOOT_PARTITION_SIZE_KiB  768
+#define DATA_PARTITION_SIZE_KiB  1280
+#define APP_PARTITION_SIZE_KiB   6144
+
+// Globals
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t sbc_gxx_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "SBC-GXx flash boot partition", 
+      offset: 0, 
+      size:   BOOT_PARTITION_SIZE_KiB*1024 },
+    { name: "SBC-GXx flash data partition", 
+      offset: BOOT_PARTITION_SIZE_KiB*1024, 
+      size: (DATA_PARTITION_SIZE_KiB)*1024 },
+    { name: "SBC-GXx flash application partition", 
+      offset: (BOOT_PARTITION_SIZE_KiB+DATA_PARTITION_SIZE_KiB)*1024 }
+};
+
+#define NUM_PARTITIONS 3
+
+static inline void sbc_gxx_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+
+	if( page!=page_in_window ) {
+		outw( page | DEVICE_ENABLE, PAGE_IO );
+		page_in_window = page;
+	}
+}
+
+
+static __u8 sbc_gxx_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+	return ret;
+}
+
+static __u16 sbc_gxx_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+	return ret;
+}
+
+static __u32 sbc_gxx_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+	return ret;
+}
+
+static void sbc_gxx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&sbc_gxx_spin);
+		sbc_gxx_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&sbc_gxx_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void sbc_gxx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+}
+
+static void sbc_gxx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+}
+
+static void sbc_gxx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&sbc_gxx_spin);
+	sbc_gxx_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_gxx_spin);
+}
+
+static void sbc_gxx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&sbc_gxx_spin);
+		sbc_gxx_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&sbc_gxx_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info sbc_gxx_map = {
+	name: "SBC-GXx flash",
+	size: MAX_SIZE_KiB*1024, /* this must be set to a maximum possible amount
+			 of flash so the cfi probe routines find all
+			 the chips */
+	buswidth: 1,
+	read8: sbc_gxx_read8,
+	read16: sbc_gxx_read16,
+	read32: sbc_gxx_read32,
+	copy_from: sbc_gxx_copy_from,
+	write8: sbc_gxx_write8,
+	write16: sbc_gxx_write16,
+	write32: sbc_gxx_write32,
+	copy_to: sbc_gxx_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+static void __exit cleanup_sbc_gxx(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+int __init init_sbc_gxx(void)
+{
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			sbc_gxx_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			sbc_gxx_map.name );
+		return -EIO;
+	}
+	
+	request_region( PAGE_IO, PAGE_IO_SIZE, "SBC-GXx flash" );
+	
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		sbc_gxx_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	/* Probe for chip. */
+	all_mtd = do_map_probe( "cfi_probe", &sbc_gxx_map );
+	if( !all_mtd ) {
+		cleanup_sbc_gxx();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions(all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_sbc_gxx);
+module_exit(cleanup_sbc_gxx);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Arcom Control Systems Ltd.");
+MODULE_DESCRIPTION("MTD map driver for SBC-GXm and SBC-GX1 series boards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/sc520cdp.c linux-2.4.2/drivers/mtd/maps/sc520cdp.c
--- linux-2.4.2.orig/drivers/mtd/maps/sc520cdp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/sc520cdp.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,347 @@
+/* sc520cdp.c -- MTD map driver for AMD SC520 Customer Development Platform
+ *
+ * Copyright (C) 2001 Sysgo Real-Time Solutions GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * $Id: sc520cdp.c,v 1.9 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ *
+ * The SC520CDP is an evaluation board for the Elan SC520 processor available
+ * from AMD. It has two banks of 32-bit Flash ROM, each 8 Megabytes in size,
+ * and up to 512 KiB of 8-bit DIL Flash ROM.
+ * For details see http://www.amd.com/products/epd/desiging/evalboards/18.elansc520/520_cdp_brief/index.html
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+/*
+** The Embedded Systems BIOS decodes the first FLASH starting at
+** 0x8400000. This is a *terrible* place for it because accessing
+** the flash at this location causes the A22 address line to be high
+** (that's what 0x8400000 binary's ought to be). But this is the highest
+** order address line on the raw flash devices themselves!!
+** This causes the top HALF of the flash to be accessed first. Beyond
+** the physical limits of the flash, the flash chip aliases over (to
+** 0x880000 which causes the bottom half to be accessed. This splits the
+** flash into two and inverts it! If you then try to access this from another
+** program that does NOT do this insanity, then you *will* access the
+** first half of the flash, but not find what you expect there. That
+** stuff is in the *second* half! Similarly, the address used by the
+** BIOS for the second FLASH bank is also quite a bad choice.
+** If REPROGRAM_PAR is defined below (the default), then this driver will
+** choose more useful addresses for the FLASH banks by reprogramming the
+** responsible PARxx registers in the SC520's MMCR region. This will
+** cause the settings to be incompatible with the BIOS's settings, which
+** shouldn't be a problem since you are running Linux, (i.e. the BIOS is
+** not much use anyway). However, if you need to be compatible with
+** the BIOS for some reason, just undefine REPROGRAM_PAR.
+*/
+#define REPROGRAM_PAR
+
+
+
+#ifdef REPROGRAM_PAR
+
+/* These are the addresses we want.. */
+#define WINDOW_ADDR_0	0x08800000
+#define WINDOW_ADDR_1	0x09000000
+#define WINDOW_ADDR_2	0x09800000
+
+/* .. and these are the addresses the BIOS gives us */
+#define WINDOW_ADDR_0_BIOS	0x08400000
+#define WINDOW_ADDR_1_BIOS	0x08c00000
+#define WINDOW_ADDR_2_BIOS	0x09400000
+
+#else
+
+#define WINDOW_ADDR_0	0x08400000
+#define WINDOW_ADDR_1	0x08C00000
+#define WINDOW_ADDR_2	0x09400000
+
+#endif
+
+#define WINDOW_SIZE_0	0x00800000
+#define WINDOW_SIZE_1	0x00800000
+#define WINDOW_SIZE_2	0x00080000
+
+static __u8 sc520cdp_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 sc520cdp_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 sc520cdp_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void sc520cdp_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void sc520cdp_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info sc520cdp_map[] = {
+	{
+		name: "SC520CDP Flash Bank #0",
+		size: WINDOW_SIZE_0,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_0
+	},
+	{
+		name: "SC520CDP Flash Bank #1",
+		size: WINDOW_SIZE_1,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_1
+	},
+	{
+		name: "SC520CDP DIL Flash",
+		size: WINDOW_SIZE_2,
+		buswidth: 1,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_2
+	},
+};
+
+#define NUM_FLASH_BANKS	(sizeof(sc520cdp_map)/sizeof(struct map_info))
+
+static struct mtd_info *mymtd[NUM_FLASH_BANKS];
+
+#ifdef REPROGRAM_PAR
+
+/*
+** The SC520 MMCR (memory mapped control register) region resides
+** at 0xFFFEF000. The 16 Programmable Address Region (PAR) registers
+** are at offset 0x88 in the MMCR:
+*/
+#define SC520_MMCR_BASE		0xFFFEF000
+#define SC520_MMCR_EXTENT	0x1000
+#define SC520_PAR(x)		((0x88/sizeof(unsigned long)) + (x))
+#define NUM_SC520_PAR		16	/* total number of PAR registers */
+
+/*
+** The highest three bits in a PAR register determine what target
+** device is controlled by this PAR. Here, only ROMCS? and BOOTCS
+** devices are of interest.
+*/
+#define SC520_PAR_BOOTCS	(0x4<<29)
+#define SC520_PAR_ROMCS0	(0x5<<29)
+#define SC520_PAR_ROMCS1	(0x6<<29)
+#define SC520_PAR_TRGDEV	(0x7<<29)
+
+/*
+** Bits 28 thru 26 determine some attributes for the
+** region controlled by the PAR. (We only use non-cacheable)
+*/
+#define SC520_PAR_WRPROT	(1<<26)	/* write protected       */
+#define SC520_PAR_NOCACHE	(1<<27)	/* non-cacheable         */
+#define SC520_PAR_NOEXEC	(1<<28)	/* code execution denied */
+
+
+/*
+** Bit 25 determines the granularity: 4K or 64K
+*/
+#define SC520_PAR_PG_SIZ4	(0<<25)
+#define SC520_PAR_PG_SIZ64	(1<<25)
+
+/*
+** Build a value to be written into a PAR register.
+** We only need ROM entries, 64K page size:
+*/
+#define SC520_PAR_ENTRY(trgdev, address, size) \
+	((trgdev) | SC520_PAR_NOCACHE | SC520_PAR_PG_SIZ64 | \
+	(address) >> 16 | (((size) >> 16) - 1) << 14)
+
+struct sc520_par_table
+{
+	unsigned long trgdev;
+	unsigned long new_par;
+	unsigned long default_address;
+};
+
+static struct sc520_par_table par_table[NUM_FLASH_BANKS] =
+{
+	{	/* Flash Bank #0: selected by ROMCS0 */
+		SC520_PAR_ROMCS0,
+		SC520_PAR_ENTRY(SC520_PAR_ROMCS0, WINDOW_ADDR_0, WINDOW_SIZE_0),
+		WINDOW_ADDR_0_BIOS
+	},
+	{	/* Flash Bank #1: selected by ROMCS1 */
+		SC520_PAR_ROMCS1,
+		SC520_PAR_ENTRY(SC520_PAR_ROMCS1, WINDOW_ADDR_1, WINDOW_SIZE_1),
+		WINDOW_ADDR_1_BIOS
+	},
+	{	/* DIL (BIOS) Flash: selected by BOOTCS */
+		SC520_PAR_BOOTCS,
+		SC520_PAR_ENTRY(SC520_PAR_BOOTCS, WINDOW_ADDR_2, WINDOW_SIZE_2),
+		WINDOW_ADDR_2_BIOS
+	}
+};
+
+
+static void sc520cdp_setup_par(void)
+{
+	volatile unsigned long *mmcr;
+	unsigned long mmcr_val;
+	int i, j;
+
+	/* map in SC520's MMCR area */
+	mmcr = (unsigned long *)ioremap_nocache(SC520_MMCR_BASE, SC520_MMCR_EXTENT);
+	if(!mmcr) { /* ioremap_nocache failed: skip the PAR reprogramming */
+		/* force map_priv_2 fields to BIOS defaults: */
+		for(i = 0; i < NUM_FLASH_BANKS; i++)
+			sc520cdp_map[i].map_priv_2 = par_table[i].default_address;
+		return;
+	}
+
+	/*
+	** Find the PARxx registers that are reponsible for activating
+	** ROMCS0, ROMCS1 and BOOTCS. Reprogram each of these with a
+	** new value from the table.
+	*/
+	for(i = 0; i < NUM_FLASH_BANKS; i++) {		/* for each par_table entry  */
+		for(j = 0; j < NUM_SC520_PAR; j++) {	/* for each PAR register     */
+			mmcr_val = mmcr[SC520_PAR(j)];
+			/* if target device field matches, reprogram the PAR */
+			if((mmcr_val & SC520_PAR_TRGDEV) == par_table[i].trgdev)
+			{
+				mmcr[SC520_PAR(j)] = par_table[i].new_par;
+				break;
+			}
+		}
+		if(j == NUM_SC520_PAR)
+		{	/* no matching PAR found: try default BIOS address */
+			printk(KERN_NOTICE "Could not find PAR responsible for %s\n",
+				sc520cdp_map[i].name);
+			printk(KERN_NOTICE "Trying default address 0x%lx\n",
+				par_table[i].default_address);
+			sc520cdp_map[i].map_priv_2 = par_table[i].default_address;
+		}
+	}
+	iounmap((void *)mmcr);
+}
+#endif
+
+
+static int __init init_sc520cdp(void)
+{
+	int i, devices_found = 0;
+	
+#ifdef REPROGRAM_PAR
+	/* reprogram PAR registers so flash appears at the desired addresses */
+	sc520cdp_setup_par();
+#endif
+
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		printk(KERN_NOTICE "SC520 CDP flash device: %lx at %lx\n", sc520cdp_map[i].size, sc520cdp_map[i].map_priv_2);
+		sc520cdp_map[i].map_priv_1 = (unsigned long)ioremap_nocache(sc520cdp_map[i].map_priv_2, sc520cdp_map[i].size);
+
+		if (!sc520cdp_map[i].map_priv_1) {
+			printk("Failed to ioremap_nocache\n");
+			return -EIO;
+		}
+		mymtd[i] = do_map_probe("cfi_probe", &sc520cdp_map[i]);
+		if(!mymtd[i])
+			mymtd[i] = do_map_probe("jedec", &sc520cdp_map[i]);
+		if(!mymtd[i])
+			mymtd[i] = do_map_probe("map_rom", &sc520cdp_map[i]);
+
+		if (mymtd[i]) {
+			mymtd[i]->module = THIS_MODULE;
+			add_mtd_device(mymtd[i]);
+			++devices_found;
+		}
+		else {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+		}
+	}
+	return(devices_found ? 0 : -ENXIO);
+}
+
+static void __exit cleanup_sc520cdp(void)
+{
+	int i;
+	
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		if (mymtd[i]) {
+			del_mtd_device(mymtd[i]);
+			map_destroy(mymtd[i]);
+		}
+		if (sc520cdp_map[i].map_priv_1) {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+			sc520cdp_map[i].map_priv_1 = 0;
+		}
+	}
+}
+
+module_init(init_sc520cdp);
+module_exit(cleanup_sc520cdp);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sysgo Real-Time Solutions GmbH");
+MODULE_DESCRIPTION("MTD map driver for AMD SC520 Customer Development Platform");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/solutionengine.c linux-2.4.2/drivers/mtd/maps/solutionengine.c
--- linux-2.4.2.orig/drivers/mtd/maps/solutionengine.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/solutionengine.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,156 @@
+/*
+ * $Id: solutionengine.c,v 1.4 2001/11/07 01:20:59 jsiegel Exp $
+ *
+ * Flash and EPROM on Hitachi Solution Engine and similar boards.
+ *
+ * (C) 2001 Red Hat, Inc.
+ *
+ * GPL'd
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+__u32 soleng_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void soleng_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void soleng_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+
+static struct mtd_info *flash_mtd;
+static struct mtd_info *eprom_mtd;
+
+static struct mtd_partition *parsed_parts;
+
+struct map_info soleng_eprom_map = {
+	name: "Solution Engine EPROM",
+	size: 0x400000,
+	buswidth: 4,
+	copy_from: soleng_copy_from,
+};
+
+struct map_info soleng_flash_map = {
+	name: "Solution Engine FLASH",
+	size: 0x400000,
+	buswidth: 4,
+	read32: soleng_read32,
+	copy_from: soleng_copy_from,
+	write32: soleng_write32,
+};
+
+#ifdef CONFIG_MTD_SUPERH_RESERVE
+static struct mtd_partition superh_se_partitions[] = {
+	/* Reserved for boot code, read-only */
+	{
+		name: "flash_boot",
+		offset: 0x00000000,
+		size: CONFIG_MTD_SUPERH_RESERVE,
+		mask_flags: MTD_WRITEABLE,
+	},
+	/* All else is writable (e.g. JFFS) */
+	{
+		name: "Flash FS",
+		offset: MTDPART_OFS_NXTBLK,
+		size: MTDPART_SIZ_FULL,
+	}
+};
+#endif /* CONFIG_MTD_SUPERH_RESERVE */
+
+static int __init init_soleng_maps(void)
+{
+	int nr_parts = 0;
+
+	/* First probe at offset 0 */
+	soleng_flash_map.map_priv_1 = P2SEGADDR(0);
+	soleng_eprom_map.map_priv_1 = P1SEGADDR(0x01000000);
+
+	printk(KERN_NOTICE "Probing for flash chips at 0x00000000:\n");
+	flash_mtd = do_map_probe("cfi_probe", &soleng_flash_map);
+	if (!flash_mtd) {
+		/* Not there. Try swapping */
+		printk(KERN_NOTICE "Probing for flash chips at 0x01000000:\n");
+		soleng_flash_map.map_priv_1 = P2SEGADDR(0x01000000);
+		soleng_eprom_map.map_priv_1 = P1SEGADDR(0);
+		flash_mtd = do_map_probe("cfi_probe", &soleng_flash_map);
+		if (!flash_mtd) {
+			/* Eep. */
+			printk(KERN_NOTICE "Flash chips not detected at either possible location.\n");
+			return -ENXIO;
+		}
+	}
+	printk(KERN_NOTICE "Solution Engine: Flash at 0x%08lx, EPROM at 0x%08lx\n",
+	       soleng_flash_map.map_priv_1 & 0x1fffffff,
+	       soleng_eprom_map.map_priv_1 & 0x1fffffff);
+	flash_mtd->module = THIS_MODULE;
+
+	eprom_mtd = do_map_probe("map_rom", &soleng_eprom_map);
+	if (eprom_mtd) {
+		eprom_mtd->module = THIS_MODULE;
+		add_mtd_device(eprom_mtd);
+	}
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts);
+	if (nr_parts > 0)
+		printk(KERN_NOTICE "Found RedBoot partition table.\n");
+	else if (nr_parts < 0)
+		printk(KERN_NOTICE "Error looking for RedBoot partitions.\n");
+#endif /* CONFIG_MTD_REDBOOT_PARTS */
+#if CONFIG_MTD_SUPERH_RESERVE
+	if (nr_parts == 0) {
+		printk(KERN_NOTICE "Using configured partition at 0x%08x.\n",
+		       CONFIG_MTD_SUPERH_RESERVE);
+		parsed_parts = superh_se_partitions;
+		nr_parts = sizeof(superh_se_partitions)/sizeof(*parsed_parts);
+	}
+#endif /* CONFIG_MTD_SUPERH_RESERVE */
+
+	if (nr_parts > 0)
+		add_mtd_partitions(flash_mtd, parsed_parts, nr_parts);
+	else
+		add_mtd_device(flash_mtd);
+
+	return 0;
+}
+
+static void __exit cleanup_soleng_maps(void)
+{
+	if (eprom_mtd) {
+		del_mtd_device(eprom_mtd);
+		map_destroy(eprom_mtd);
+	}
+
+	if (parsed_parts)
+		del_mtd_partitions(flash_mtd);
+	else
+		del_mtd_device(flash_mtd);
+	map_destroy(flash_mtd);
+}
+
+module_init(init_soleng_maps);
+module_exit(cleanup_soleng_maps);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD map driver for Hitachi SolutionEngine (and similar) boards");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/sun_uflash.c linux-2.4.2/drivers/mtd/maps/sun_uflash.c
--- linux-2.4.2.orig/drivers/mtd/maps/sun_uflash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/sun_uflash.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,226 @@
+/* $Id: sun_uflash.c,v 1.4 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * sun_uflash - Driver implementation for user-programmable flash
+ * present on many Sun Microsystems SME boardsets.
+ *
+ * This driver does NOT provide access to the OBP-flash for
+ * safety reasons-- use <linux>/drivers/sbus/char/flash.c instead.
+ *
+ * Copyright (c) 2001 Eric Brower (ebrower@usa.net)
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/ebus.h>
+#include <asm/oplib.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+#define UFLASH_OBPNAME	"flashprom"
+#define UFLASH_DEVNAME 	"userflash"
+
+#define UFLASH_WINDOW_SIZE	0x200000
+#define UFLASH_BUSWIDTH		1			/* EBus is 8-bit */
+
+MODULE_AUTHOR
+	("Eric Brower <ebrower@usa.net>");
+MODULE_DESCRIPTION
+	("User-programmable flash device on Sun Microsystems boardsets");
+MODULE_SUPPORTED_DEVICE
+	("userflash");
+MODULE_LICENSE
+	("GPL");
+
+static LIST_HEAD(device_list);
+struct uflash_dev {
+	char *			name;	/* device name */
+	struct map_info 	map;	/* mtd map info */
+	struct mtd_info *	mtd;	/* mtd info */
+	struct list_head	list;
+};
+
+__u8 uflash_read8(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readb(map->map_priv_1 + ofs));
+}
+
+__u16 uflash_read16(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readw(map->map_priv_1 + ofs));
+}
+
+__u32 uflash_read32(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readl(map->map_priv_1 + ofs));
+}
+
+void uflash_copy_from(struct map_info *map, void *to, unsigned long from, 
+		      ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void uflash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+}
+
+void uflash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+}
+
+void uflash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+}
+
+void uflash_copy_to(struct map_info *map, unsigned long to, const void *from,
+		    ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info uflash_map_templ = {
+		name:		"SUNW,???-????",
+		size:		UFLASH_WINDOW_SIZE,
+		buswidth:	UFLASH_BUSWIDTH,
+		read8:		uflash_read8,
+		read16:		uflash_read16,
+		read32:		uflash_read32,
+		copy_from:	uflash_copy_from,
+		write8:		uflash_write8,
+		write16:	uflash_write16,
+		write32:	uflash_write32,
+		copy_to:	uflash_copy_to
+};
+
+int uflash_devinit(struct linux_ebus_device* edev)
+{
+	int iTmp, nregs;
+	struct linux_prom_registers regs[2];
+	struct uflash_dev *pdev;
+
+	iTmp = prom_getproperty(
+		edev->prom_node, "reg", (void *)regs, sizeof(regs));
+	if ((iTmp % sizeof(regs[0])) != 0) {
+		printk("%s: Strange reg property size %d\n", 
+			UFLASH_DEVNAME, iTmp);
+		return -ENODEV;
+	}
+
+	nregs = iTmp / sizeof(regs[0]);
+
+	if (nregs != 1) {
+		/* Non-CFI userflash device-- once I find one we
+		 * can work on supporting it.
+		 */
+		printk("%s: unsupported device at 0x%lx (%d regs): " \
+			"email ebrower@usa.net\n", 
+			UFLASH_DEVNAME, edev->resource[0].start, nregs);
+		return -ENODEV;
+	}
+
+	if(0 == (pdev = kmalloc(sizeof(struct uflash_dev), GFP_KERNEL))) {
+		printk("%s: unable to kmalloc new device\n", UFLASH_DEVNAME);
+		return(-ENOMEM);
+	}
+	
+	/* copy defaults and tweak parameters */
+	memcpy(&pdev->map, &uflash_map_templ, sizeof(uflash_map_templ));
+	pdev->map.size = regs[0].reg_size;
+
+	iTmp = prom_getproplen(edev->prom_node, "model");
+	pdev->name = kmalloc(iTmp, GFP_KERNEL);
+	prom_getstring(edev->prom_node, "model", pdev->name, iTmp);
+	if(0 != pdev->name && 0 < strlen(pdev->name)) {
+		pdev->map.name = pdev->name;
+	}
+
+	pdev->map.map_priv_1 = 
+		(unsigned long)ioremap_nocache(edev->resource[0].start, pdev->map.size);
+	if(0 == pdev->map.map_priv_1) {
+		printk("%s: failed to map device\n", __FUNCTION__);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-1);
+	}
+
+	/* MTD registration */
+	pdev->mtd = do_map_probe("cfi_probe", &pdev->map);
+	if(0 == pdev->mtd) {
+		iounmap((void *)pdev->map.map_priv_1);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-ENXIO);
+	}
+
+	list_add(&pdev->list, &device_list);
+
+	pdev->mtd->module = THIS_MODULE;
+
+	add_mtd_device(pdev->mtd);
+	return(0);
+}
+
+static int __init uflash_init(void)
+{
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, UFLASH_OBPNAME)) {
+				if(0 > prom_getproplen(edev->prom_node, "user")) {
+					DEBUG(2, "%s: ignoring device at 0x%lx\n",
+							UFLASH_DEVNAME, edev->resource[0].start);
+				} else {
+					uflash_devinit(edev);
+				}
+			}
+		}
+	}
+
+	if(list_empty(&device_list)) {
+		printk("%s: unable to locate device\n", UFLASH_DEVNAME);
+		return -ENODEV;
+	}
+	return(0);
+}
+
+static void __exit uflash_cleanup(void)
+{
+	struct list_head *udevlist;
+	struct uflash_dev *udev;
+
+	list_for_each(udevlist, &device_list) {
+		udev = list_entry(udevlist, struct uflash_dev, list);
+		DEBUG(2, "%s: removing device %s\n", 
+			UFLASH_DEVNAME, udev->name);
+
+		if(0 != udev->mtd) {
+			del_mtd_device(udev->mtd);
+			map_destroy(udev->mtd);
+		}
+		if(0 != udev->map.map_priv_1) {
+			iounmap((void*)udev->map.map_priv_1);
+			udev->map.map_priv_1 = 0;
+		}
+		if(0 != udev->name) {
+			kfree(udev->name);
+		}
+		kfree(udev);
+	}	
+}
+
+module_init(uflash_init);
+module_exit(uflash_cleanup);
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/tqm8xxl.c linux-2.4.2/drivers/mtd/maps/tqm8xxl.c
--- linux-2.4.2.orig/drivers/mtd/maps/tqm8xxl.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/tqm8xxl.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,315 @@
+/*
+ * Handle mapping of the flash memory access routines 
+ * on TQM8xxL based devices.
+ *
+ * $Id: tqm8xxl.c,v 1.3 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * based on rpxlite.c
+ *
+ * Copyright(C) 2001 Kirk Lee <kirk@hpc.ee.ntu.edu.tw>
+ *
+ * This code is GPLed
+ * 
+ */
+
+/*
+ * According to TQM8xxL hardware manual, TQM8xxL series have
+ * following flash memory organisations:
+ *	| capacity |	| chip type |	| bank0 |	| bank1 |
+ *	    2MiB	   512Kx16	  2MiB		   0
+ *	    4MiB	   1Mx16	  4MiB		   0
+ *	    8MiB	   1Mx16	  4MiB		   4MiB
+ * Thus, we choose CONFIG_MTD_CFI_I2 & CONFIG_MTD_CFI_B4 at 
+ * kernel configuration.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_ADDR 0x40000000
+#define FLASH_SIZE 0x00800000
+#define FLASH_BANK_MAX 4
+
+// trivial struct to describe partition information
+struct mtd_part_def
+{
+	int nums;
+	unsigned char *type;
+	struct mtd_partition* mtd_part;
+};
+
+//static struct mtd_info *mymtd;
+static struct mtd_info* mtd_banks[FLASH_BANK_MAX];
+static struct map_info* map_banks[FLASH_BANK_MAX];
+static struct mtd_part_def part_banks[FLASH_BANK_MAX];
+static unsigned long num_banks;
+static unsigned long start_scan_addr;
+
+__u8 tqm8xxl_read8(struct map_info *map, unsigned long ofs)
+{
+	return *((__u8 *)(map->map_priv_1 + ofs));
+}
+
+__u16 tqm8xxl_read16(struct map_info *map, unsigned long ofs)
+{
+	return *((__u16 *)(map->map_priv_1 + ofs));
+}
+
+__u32 tqm8xxl_read32(struct map_info *map, unsigned long ofs)
+{
+	return *((__u32 *)(map->map_priv_1 + ofs));
+}
+
+void tqm8xxl_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+void tqm8xxl_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*((__u8 *)(map->map_priv_1 + adr)) = d;
+}
+
+void tqm8xxl_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*((__u16 *)( map->map_priv_1 + adr)) = d;
+}
+
+void tqm8xxl_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*((__u32 *)(map->map_priv_1 + adr)) = d;
+}
+
+void tqm8xxl_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+struct map_info tqm8xxl_map = {
+	name: "TQM8xxL",
+	//size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: tqm8xxl_read8,
+	read16: tqm8xxl_read16,
+	read32: tqm8xxl_read32,
+	copy_from: tqm8xxl_copy_from,
+	write8: tqm8xxl_write8,
+	write16: tqm8xxl_write16,
+	write32: tqm8xxl_write32,
+	copy_to: tqm8xxl_copy_to
+};
+
+/*
+ * Here are partition information for all known TQM8xxL series devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ * 
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the 
+ * value specified in the mapping definition defined by the
+ * "struct map_desc *_io_desc" for the corresponding machine.
+ */
+
+#ifdef CONFIG_MTD_PARTITIONS
+/* Currently, TQM8xxL has upto 8MiB flash */
+static unsigned long tqm8xxl_max_flash_size = 0x00800000;
+
+/* partition definition for first flash bank
+ * also ref. to "drivers\char\flash_config.c" 
+ */
+static struct mtd_partition tqm8xxl_partitions[] = {
+	{
+	  name: "ppcboot",
+	  offset: 0x00000000,
+	  size: 0x00020000,           /* 128KB           */
+	  mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  name: "kernel",             /* default kernel image */
+	  offset: 0x00020000,
+	  size: 0x000e0000,
+	  mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  name: "user",
+	  offset: 0x00100000,
+	  size: 0x00100000,
+	},
+	{
+	  name: "initrd",
+	  offset: 0x00200000,
+	  size: 0x00200000,
+	}
+};
+/* partition definition for second flahs bank */
+static struct mtd_partition tqm8xxl_fs_partitions[] = {
+	{
+	  name: "cramfs",
+	  offset: 0x00000000,
+	  size: 0x00200000,
+	},
+	{
+	  name: "jffs",
+	  offset: 0x00200000,
+	  size: 0x00200000,
+	  //size: MTDPART_SIZ_FULL,
+	}
+};
+#endif
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+int __init init_tqm_mtd(void)
+{
+	int idx = 0, ret = 0;
+	unsigned long flash_addr, flash_size, mtd_size = 0;
+	/* pointer to TQM8xxL board info data */
+	bd_t *bd = (bd_t *)__res;
+
+	flash_addr = bd->bi_flashstart;
+	flash_size = bd->bi_flashsize;
+	//request maximum flash size address spzce
+	start_scan_addr = (unsigned long)ioremap(flash_addr, flash_size);
+	if (!start_scan_addr) {
+		//printk("%s:Failed to ioremap address:0x%x\n", __FUNCTION__, FLASH_ADDR);
+		printk("%s:Failed to ioremap address:0x%x\n", __FUNCTION__, flash_addr);
+		return -EIO;
+	}
+	for(idx = 0 ; idx < FLASH_BANK_MAX ; idx++)
+	{
+		if(mtd_size >= flash_size)
+			break;
+		
+		printk("%s: chip probing count %d\n", __FUNCTION__, idx);
+		
+		map_banks[idx] = (struct map_info *)kmalloc(sizeof(struct map_info), GFP_KERNEL);
+		if(map_banks[idx] == NULL)
+		{
+			//return -ENOMEM;
+			ret = -ENOMEM;
+			goto error_mem;
+		}
+		memset((void *)map_banks[idx], 0, sizeof(struct map_info));
+		map_banks[idx]->name = (char *)kmalloc(16, GFP_KERNEL);
+		if(map_banks[idx]->name == NULL)
+		{
+			//return -ENOMEM;
+			ret = -ENOMEM;
+			goto error_mem;
+		}
+		memset((void *)map_banks[idx]->name, 0, 16);
+		
+		sprintf(map_banks[idx]->name, "TQM8xxL%d", idx);
+		map_banks[idx]->buswidth = 4;
+		map_banks[idx]->read8 = tqm8xxl_read8;
+		map_banks[idx]->read16 = tqm8xxl_read16;
+		map_banks[idx]->read32 = tqm8xxl_read32;
+		map_banks[idx]->copy_from = tqm8xxl_copy_from;
+		map_banks[idx]->write8 = tqm8xxl_write8;
+		map_banks[idx]->write16 = tqm8xxl_write16;
+		map_banks[idx]->write32 = tqm8xxl_write32;
+		map_banks[idx]->copy_to = tqm8xxl_copy_to;
+		map_banks[idx]->map_priv_1 = 
+		start_scan_addr + ((idx > 0) ? 
+		(mtd_banks[idx-1] ? mtd_banks[idx-1]->size : 0) : 0);
+		//start to probe flash chips
+		mtd_banks[idx] = do_map_probe("cfi_probe", map_banks[idx]);
+		if(mtd_banks[idx])
+		{
+			mtd_banks[idx]->module = THIS_MODULE;
+			mtd_size += mtd_banks[idx]->size;
+			num_banks++;
+			printk("%s: bank%d, name:%s, size:%dbytes \n", __FUNCTION__, num_banks, 
+			mtd_banks[idx]->name, mtd_banks[idx]->size);
+		}
+	}
+
+	/* no supported flash chips found */
+	if(!num_banks)
+	{
+		printk("TQM8xxL: No support flash chips found!\n");
+		ret = -ENXIO;
+		goto error_mem;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/*
+	 * Select Static partition definitions
+	 */
+	part_banks[0].mtd_part = tqm8xxl_partitions;
+	part_banks[0].type = "Static image";
+	part_banks[0].nums = NB_OF(tqm8xxl_partitions);
+	part_banks[1].mtd_part = tqm8xxl_fs_partitions;
+	part_banks[1].type = "Static file system";
+	part_banks[1].nums = NB_OF(tqm8xxl_fs_partitions);
+	for(idx = 0; idx < num_banks ; idx++)
+	{
+		if (part_banks[idx].nums == 0) {
+			printk(KERN_NOTICE "TQM flash%d: no partition info available, registering whole flash at once\n", idx);
+			add_mtd_device(mtd_banks[idx]);
+		} else {
+			printk(KERN_NOTICE "TQM flash%d: Using %s partition definition\n",
+					idx, part_banks[idx].type);
+			add_mtd_partitions(mtd_banks[idx], part_banks[idx].mtd_part, 
+								part_banks[idx].nums);
+		}
+	}
+#else
+	printk(KERN_NOTICE "TQM flash: registering %d whole flash banks at once\n", num_banks);
+	for(idx = 0 ; idx < num_banks ; idx++)
+		add_mtd_device(mtd_banks[idx]);
+#endif
+	return 0;
+error_mem:
+	for(idx = 0 ; idx < FLASH_BANK_MAX ; idx++)
+	{
+		if(map_banks[idx] != NULL)
+		{
+			if(map_banks[idx]->name != NULL)
+			{
+				kfree(map_banks[idx]->name);
+				map_banks[idx]->name = NULL;
+			}
+			kfree(map_banks[idx]);
+			map_banks[idx] = NULL;
+		}
+	}
+	//return -ENOMEM;
+error:
+	iounmap((void *)start_scan_addr);
+	//return -ENXIO;
+	return ret;
+}
+
+static void __exit cleanup_tqm_mtd(void)
+{
+	unsigned int idx = 0;
+	for(idx = 0 ; idx < num_banks ; idx++)
+	{
+		/* destroy mtd_info previously allocated */
+		if (mtd_banks[idx]) {
+			del_mtd_partitions(mtd_banks[idx]);
+			map_destroy(mtd_banks[idx]);
+		}
+		/* release map_info not used anymore */
+		kfree(map_banks[idx]->name);
+		kfree(map_banks[idx]);
+	}
+	if (start_scan_addr) {
+		iounmap((void *)start_scan_addr);
+		start_scan_addr = 0;
+	}
+}
+
+module_init(init_tqm_mtd);
+module_exit(cleanup_tqm_mtd);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kirk Lee <kirk@hpc.ee.ntu.edu.tw>");
+MODULE_DESCRIPTION("MTD map driver for TQM8xxL boards");
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/tsunami_flash.c linux-2.4.2/drivers/mtd/maps/tsunami_flash.c
--- linux-2.4.2.orig/drivers/mtd/maps/tsunami_flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/tsunami_flash.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,110 @@
+/*
+ * tsunami_flash.c
+ *
+ * flash chip on alpha ds10...
+ * $Id: tsunami_flash.c,v 1.1 2002/01/10 22:59:13 eric Exp $
+ */
+#include <asm/io.h>
+#include <asm/core_tsunami.h>
+#include <linux/mtd/map.h>
+
+#define FLASH_ENABLE_PORT 0x00C00001
+#define FLASH_ENABLE_BYTE 0x01
+#define FLASH_DISABLE_BYTE 0x00
+
+#define MAX_TIG_FLASH_SIZE (12*1024*1024)
+static inline  __u8 tsunami_flash_read8(struct map_info *map, unsigned long offset)
+{
+	return tsunami_tig_readb(offset);
+}
+
+static void tsunami_flash_write8(struct map_info *map, __u8 value, unsigned long offset)
+{
+	tsunami_tig_writeb(value, offset);
+}
+
+static void tsunami_flash_copy_from(
+	struct map_info *map, void *addr, unsigned long offset, ssize_t len)
+{
+	unsigned char *dest;
+	dest = addr;
+	while(len && (offset < MAX_TIG_FLASH_SIZE)) {
+		*dest = tsunami_tig_readb(offset);
+		offset++;
+		dest++;
+		len--;
+	}
+}
+
+static void tsunami_flash_copy_to(
+	struct map_info *map, unsigned long offset, 
+	const void *addr, ssize_t len)
+{
+	const unsigned char *src;
+	src = addr;
+	while(len && (offset < MAX_TIG_FLASH_SIZE)) {
+		tsunami_tig_writeb(*src, offset);
+		offset++;
+		src++;
+		len--;
+	}
+}
+
+/*
+ * Deliberately don't provide operations wider than 8 bits.  I don't
+ * have then and it scares me to think how you could mess up if
+ * you tried to use them.   Buswidth is correctly so I'm safe.
+ */
+static struct map_info tsunami_flash_map = {
+	.name = "flash chip on the Tsunami TIG bus",
+	.size = MAX_TIG_FLASH_SIZE,
+	.buswidth = 1,
+	.read8 = tsunami_flash_read8,
+	.read16 = 0,
+	.read32 = 0, 
+	.copy_from = tsunami_flash_copy_from,
+	.write8 = tsunami_flash_write8,
+	.write16 = 0,
+	.write32 = 0,
+	.copy_to = tsunami_flash_copy_to,
+	.set_vpp = 0,
+	.map_priv_1 = 0,
+
+};
+
+static struct mtd_info *tsunami_flash_mtd;
+
+static void __exit  cleanup_tsunami_flash(void)
+{
+	struct mtd_info *mtd;
+	mtd = tsunami_flash_mtd;
+	if (mtd) {
+		del_mtd_device(mtd);
+		map_destroy(mtd);
+	}
+	tsunami_flash_mtd = 0;
+}
+
+
+static int __init init_tsunami_flash(void)
+{
+	static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", 0 };
+	char **type;
+
+	tsunami_tig_writeb(FLASH_ENABLE_BYTE, FLASH_ENABLE_PORT);
+	
+	tsunami_flash_mtd = 0;
+	type = rom_probe_types;
+	for(; !tsunami_flash_mtd && *type; type++) {
+		tsunami_flash_mtd = do_map_probe(*type, &tsunami_flash_map);
+	}
+	if (tsunami_flash_mtd) {
+		tsunami_flash_mtd->module = THIS_MODULE;
+		add_mtd_device(tsunami_flash_mtd);
+		return 0;
+	}
+	return -ENXIO;
+}
+
+module_init(init_tsunami_flash);
+module_exit(cleanup_tsunami_flash);
diff -Naur linux-2.4.2.orig/drivers/mtd/maps/vmax301.c linux-2.4.2/drivers/mtd/maps/vmax301.c
--- linux-2.4.2.orig/drivers/mtd/maps/vmax301.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/maps/vmax301.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,239 @@
+// $Id: vmax301.c,v 1.24 2001/10/02 15:05:14 dwmw2 Exp $
+/* ######################################################################
+
+   Tempustech VMAX SBC301 MTD Driver.
+  
+   The VMAx 301 is a SBC based on . It
+   comes with three builtin AMD 29F016B flash chips and a socket for SRAM or
+   more flash. Each unit has it's own 8k mapping into a settable region 
+   (0xD8000). There are two 8k mappings for each MTD, the first is always set
+   to the lower 8k of the device the second is paged. Writing a 16 bit page
+   value to anywhere in the first 8k will cause the second 8k to page around.
+
+   To boot the device a bios extension must be installed into the first 8k 
+   of flash that is smart enough to copy itself down, page in the rest of 
+   itself and begin executing.
+   
+   ##################################################################### */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_START 0xd8000
+#define WINDOW_LENGTH 0x2000
+#define WINDOW_SHIFT 25
+#define WINDOW_MASK 0x1FFF
+
+/* Actually we could use two spinlocks, but we'd have to have
+   more private space in the struct map_info. We lose a little
+   performance like this, but we'd probably lose more by having
+   the extra indirection from having one of the map->map_priv 
+   fields pointing to yet another private struct.
+*/
+static spinlock_t vmax301_spin = SPIN_LOCK_UNLOCKED;
+
+static void __vmax301_page(struct map_info *map, unsigned long page)
+{
+	writew(page, map->map_priv_2 - WINDOW_LENGTH);
+	map->map_priv_1 = page;
+}
+
+static inline void vmax301_page(struct map_info *map,
+				  unsigned long ofs)
+{
+	unsigned long page = (ofs >> WINDOW_SHIFT);
+	if (map->map_priv_1 != page)
+		__vmax301_page(map, page);
+}
+
+static __u8 vmax301_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, ofs);
+	ret = readb(map->map_priv_2 + (ofs & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+	return ret;
+}
+
+static __u16 vmax301_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, ofs);
+	ret = readw(map->map_priv_2 + (ofs & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+	return ret;
+}
+
+static __u32 vmax301_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, ofs);
+	ret =  readl(map->map_priv_2 + (ofs & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+	return ret;
+}
+
+static void vmax301_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		spin_lock(&vmax301_spin);
+		vmax301_page(map, from);
+		memcpy_fromio(to, map->map_priv_2 + from, thislen);
+		spin_unlock(&vmax301_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void vmax301_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, adr);
+	writeb(d, map->map_priv_2 + (adr & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+}
+
+static void vmax301_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, adr);
+	writew(d, map->map_priv_2 + (adr & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+}
+
+static void vmax301_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&vmax301_spin);
+	vmax301_page(map, adr);
+	writel(d, map->map_priv_2 + (adr & WINDOW_MASK));
+	spin_unlock(&vmax301_spin);
+}
+
+static void vmax301_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+
+		spin_lock(&vmax301_spin);
+		vmax301_page(map, to);
+		memcpy_toio(map->map_priv_2 + to, from, thislen);
+		spin_unlock(&vmax301_spin);		
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info vmax_map[2] = {
+	{
+		name: "VMAX301 Internal Flash",
+		size: 3*2*1024*1024,
+		buswidth: 1,
+		read8: vmax301_read8,
+		read16: vmax301_read16,
+		read32: vmax301_read32,
+		copy_from: vmax301_copy_from,
+		write8: vmax301_write8,
+		write16: vmax301_write16,
+		write32: vmax301_write32,
+		copy_to: vmax301_copy_to,
+		map_priv_1: WINDOW_START + WINDOW_LENGTH,
+		map_priv_2: 0xFFFFFFFF
+	},
+	{
+		name: "VMAX301 Socket",
+		size: 0,
+		buswidth: 1,
+		read8: vmax301_read8,
+		read16: vmax301_read16,
+		read32: vmax301_read32,
+		copy_from: vmax301_copy_from,
+		write8: vmax301_write8,
+		write16: vmax301_write16,
+		write32: vmax301_write32,
+		copy_to: vmax301_copy_to,
+		map_priv_1: WINDOW_START + (3*WINDOW_LENGTH),
+		map_priv_2: 0xFFFFFFFF
+	}
+};
+
+static struct mtd_info *vmax_mtd[2] = {NULL, NULL};
+
+static void __exit cleanup_vmax301(void)
+{
+	int i;
+	
+	for (i=0; i<2; i++) {
+		if (vmax_mtd[i]) {
+			del_mtd_device(vmax_mtd[i]);
+			map_destroy(vmax_mtd[i]);
+		}
+	}
+	iounmap((void *)vmax_map[0].map_priv_1 - WINDOW_START);
+}
+
+int __init init_vmax301(void)
+{
+	int i;
+	unsigned long iomapadr;
+	// Print out our little header..
+	printk("Tempustech VMAX 301 MEM:0x%x-0x%x\n",WINDOW_START,
+	       WINDOW_START+4*WINDOW_LENGTH);
+
+	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH*4);
+	if (!iomapadr) {
+		printk("Failed to ioremap memory region\n");
+		return -EIO;
+	}
+	/* Put the address in the map's private data area.
+	   We store the actual MTD IO address rather than the 
+	   address of the first half, because it's used more
+	   often. 
+	*/
+	vmax_map[0].map_priv_1 = iomapadr + WINDOW_START;
+	vmax_map[1].map_priv_1 = iomapadr + (3*WINDOW_START);
+	
+	for (i=0; i<2; i++) {
+		vmax_mtd[i] = do_map_probe("cfi_probe", &vmax_map[i]);
+		if (!vmax_mtd[i])
+			vmax_mtd[i] = do_map_probe("jedec", &vmax_map[i]);
+		if (!vmax_mtd[i])
+			vmax_mtd[i] = do_map_probe("map_ram", &vmax_map[i]);
+		if (!vmax_mtd[i])
+			vmax_mtd[i] = do_map_probe("map_rom", &vmax_map[i]);
+		if (vmax_mtd[i]) {
+			vmax_mtd[i]->module = THIS_MODULE;
+			add_mtd_device(vmax_mtd[i]);
+		}
+	}
+
+	if (!vmax_mtd[1] && !vmax_mtd[2]) {
+		iounmap((void *)iomapadr);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+module_init(init_vmax301);
+module_exit(cleanup_vmax301);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("MTD map driver for Tempustech VMAX SBC301 board");
diff -Naur linux-2.4.2.orig/drivers/mtd/mixmem.c linux-2.4.2/drivers/mtd/mixmem.c
--- linux-2.4.2.orig/drivers/mtd/mixmem.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mixmem.c	Fri Feb 15 14:41:16 2002
@@ -4,6 +4,8 @@
  *
  * Author: Gergely Madarasz <gorgo@itc.hu> 
  *
+ * $Id: mixmem.c,v 1.8 2000/11/14 10:58:02 dwmw2 Exp $
+ *
  * Copyright (c) 1999 ITConsult-Pro Co. <info@itc.hu>
  *
  * This code is GPL
@@ -11,7 +13,7 @@
  */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <linux/init.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdblock.c linux-2.4.2/drivers/mtd/mtdblock.c
--- linux-2.4.2.orig/drivers/mtd/mtdblock.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdblock.c	Fri Feb 15 14:41:16 2002
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id: mtdblock.c,v 1.38 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: mtdblock.c,v 1.51 2001/11/20 11:42:33 dwmw2 Exp $
  *
  * 02-nov-2000	Nicolas Pitre		Added read-modify-write with cache
  */
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/compatmac.h>
 
 #define MAJOR_NR MTD_BLOCK_MAJOR
 #define DEVICE_NAME "mtdblock"
@@ -59,6 +60,13 @@
 static int mtd_sizes[MAX_MTD_DEVICES];
 static int mtd_blksizes[MAX_MTD_DEVICES];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,14)
+#define BLK_INC_USE_COUNT MOD_INC_USE_COUNT
+#define BLK_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define BLK_INC_USE_COUNT do {} while(0)
+#define BLK_DEC_USE_COUNT do {} while(0)
+#endif
 
 /*
  * Cache stuff...
@@ -158,13 +166,16 @@
 			    int len, const char *buf)
 {
 	struct mtd_info *mtd = mtdblk->mtd;
-	unsigned int sect_size = mtd->erasesize;
+	unsigned int sect_size = mtdblk->cache_size;
 	size_t retlen;
 	int ret;
 
 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%lx, size 0x%x\n",
 		mtd->name, pos, len);
 	
+	if (!sect_size)
+		return MTD_WRITE (mtd, pos, len, &retlen, buf);
+
 	while (len > 0) {
 		unsigned long sect_start = (pos/sect_size)*sect_size;
 		unsigned int offset = pos - sect_start;
@@ -224,13 +235,16 @@
 			   int len, char *buf)
 {
 	struct mtd_info *mtd = mtdblk->mtd;
-	unsigned int sect_size = mtd->erasesize;
+	unsigned int sect_size = mtdblk->cache_size;
 	size_t retlen;
 	int ret;
 
 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: read on \"%s\" at 0x%lx, size 0x%x\n", 
 			mtd->name, pos, len);
 	
+	if (!sect_size)
+		return MTD_READ (mtd, pos, len, &retlen, buf);
+
 	while (len > 0) {
 		unsigned long sect_start = (pos/sect_size)*sect_size;
 		unsigned int offset = pos - sect_start;
@@ -268,6 +282,7 @@
 static int mtdblock_open(struct inode *inode, struct file *file)
 {
 	struct mtdblk_dev *mtdblk;
+	struct mtd_info *mtd;
 	int dev;
 
 	DEBUG(MTD_DEBUG_LEVEL1,"mtdblock_open\n");
@@ -278,9 +293,18 @@
 	dev = MINOR(inode->i_rdev);
 	if (dev >= MAX_MTD_DEVICES)
 		return -EINVAL;
-	
-	MOD_INC_USE_COUNT;
 
+	BLK_INC_USE_COUNT;
+
+	mtd = get_mtd_device(NULL, dev);
+	if (!mtd)
+		return -ENODEV;
+	if (MTD_ABSENT == mtd->type) {
+		put_mtd_device(mtd);
+		BLK_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+	
 	spin_lock(&mtdblks_lock);
 
 	/* If it's already open, no need to piss about. */
@@ -299,28 +323,26 @@
 
 	mtdblk = kmalloc(sizeof(struct mtdblk_dev), GFP_KERNEL);
 	if (!mtdblk) {
-		MOD_DEC_USE_COUNT;
+		put_mtd_device(mtd);
+		BLK_DEC_USE_COUNT;
 		return -ENOMEM;
 	}
 	memset(mtdblk, 0, sizeof(*mtdblk));
 	mtdblk->count = 1;
-	mtdblk->mtd = get_mtd_device(NULL, dev);
-
-	if (!mtdblk->mtd) {
-		kfree(mtdblk);
-		MOD_DEC_USE_COUNT;
-		return -ENODEV;
-	}
+	mtdblk->mtd = mtd;
 
 	init_MUTEX (&mtdblk->cache_sem);
 	mtdblk->cache_state = STATE_EMPTY;
-	mtdblk->cache_size = mtdblk->mtd->erasesize;
-	mtdblk->cache_data = vmalloc(mtdblk->mtd->erasesize);
-	if (!mtdblk->cache_data) {
-		put_mtd_device(mtdblk->mtd);
-		kfree(mtdblk);
-		MOD_DEC_USE_COUNT;
-		return -ENOMEM;
+	if ((mtdblk->mtd->flags & MTD_CAP_RAM) != MTD_CAP_RAM &&
+	    mtdblk->mtd->erasesize) {
+		mtdblk->cache_size = mtdblk->mtd->erasesize;
+		mtdblk->cache_data = vmalloc(mtdblk->mtd->erasesize);
+		if (!mtdblk->cache_data) {
+			put_mtd_device(mtdblk->mtd);
+			kfree(mtdblk);
+			BLK_DEC_USE_COUNT;
+			return -ENOMEM;
+		}
 	}
 
 	/* OK, we've created a new one. Add it to the list. */
@@ -339,7 +361,8 @@
 
 	mtdblks[dev] = mtdblk;
 	mtd_sizes[dev] = mtdblk->mtd->size/1024;
-	mtd_blksizes[dev] = mtdblk->mtd->erasesize;
+	if (mtdblk->mtd->erasesize)
+		mtd_blksizes[dev] = mtdblk->mtd->erasesize;
 	if (mtd_blksizes[dev] > PAGE_SIZE)
 		mtd_blksizes[dev] = PAGE_SIZE;
 	set_device_ro (inode->i_rdev, !(mtdblk->mtd->flags & MTD_WRITEABLE));
@@ -355,19 +378,10 @@
 {
 	int dev;
 	struct mtdblk_dev *mtdblk;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
-	struct super_block * sb = get_super(inode->i_rdev);
-#endif
    	DEBUG(MTD_DEBUG_LEVEL1, "mtdblock_release\n");
 
 	if (inode == NULL)
 		release_return(-ENODEV);
-   
-	fsync_dev(inode->i_rdev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
-	if (sb) invalidate_inodes(sb);
-#endif
-	invalidate_buffers(inode->i_rdev);
 
 	dev = MINOR(inode->i_rdev);
 	mtdblk = mtdblks[dev];
@@ -392,7 +406,7 @@
 
 	DEBUG(MTD_DEBUG_LEVEL1, "ok\n");
 
-	MOD_DEC_USE_COUNT;
+	BLK_DEC_USE_COUNT;
 	release_return(0);
 }  
 
@@ -461,13 +475,8 @@
 }
 
 static volatile int leaving = 0;
-#if LINUX_VERSION_CODE > 0x020300
 static DECLARE_MUTEX_LOCKED(thread_sem);
 static DECLARE_WAIT_QUEUE_HEAD(thr_wq);
-#else
-static struct semaphore thread_sem = MUTEX_LOCKED;
-DECLARE_WAIT_QUEUE_HEAD(thr_wq);
-#endif
 
 int mtdblock_thread(void *dummy)
 {
@@ -536,10 +545,12 @@
 
 	switch (cmd) {
 	case BLKGETSIZE:   /* Return device size */
-		if (!arg)
-			return -EFAULT;
-		return put_user((mtdblk->mtd->size >> 9),
-                                (long *) arg)?-EFAULT:0;
+		return put_user((mtdblk->mtd->size >> 9), (unsigned long *) arg);
+
+#ifdef BLKGETSIZE64
+	case BLKGETSIZE64:
+		return put_user((u64)mtdblk->mtd->size, (u64 *)arg);
+#endif
 		
 	case BLKFLSBUF:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
@@ -572,6 +583,9 @@
 #else
 static struct block_device_operations mtd_fops = 
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,14)
+	owner: THIS_MODULE,
+#endif
 	open: mtdblock_open,
 	release: mtdblock_release,
 	ioctl: mtdblock_ioctl
@@ -586,7 +600,7 @@
 {
         char name[8];
 
-        if (!mtd)
+        if (!mtd || mtd->type == MTD_ABSENT)
                 return;
 
         sprintf(name, "%d", mtd->index);
@@ -598,18 +612,13 @@
 
 static void mtd_notify_remove(struct mtd_info* mtd)
 {
-        if (!mtd)
+        if (!mtd || mtd->type == MTD_ABSENT)
                 return;
 
         devfs_unregister(devfs_rw_handle[mtd->index]);
 }
 #endif
 
-#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
-#define init_mtdblock init_module
-#define cleanup_mtdblock cleanup_module
-#endif
-
 int __init init_mtdblock(void)
 {
 	int i;
@@ -643,11 +652,7 @@
 	blksize_size[MAJOR_NR] = mtd_blksizes;
 	blk_size[MAJOR_NR] = mtd_sizes;
 	
-#if LINUX_VERSION_CODE < 0x20320
-	blk_dev[MAJOR_NR].request_fn = mtdblock_request;
-#else
 	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), &mtdblock_request);
-#endif
 	kernel_thread (mtdblock_thread, NULL, CLONE_FS|CLONE_FILES|CLONE_SIGHAND);
 	return 0;
 }
@@ -664,14 +669,15 @@
 #else
 	unregister_blkdev(MAJOR_NR,DEVICE_NAME);
 #endif
-#if LINUX_VERSION_CODE < 0x20320
-	blk_dev[MAJOR_NR].request_fn = NULL;
-#else
 	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
-#endif
 	blksize_size[MAJOR_NR] = NULL;
 	blk_size[MAJOR_NR] = NULL;
 }
 
 module_init(init_mtdblock);
 module_exit(cleanup_mtdblock);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Pitre <nico@cam.org> et al.");
+MODULE_DESCRIPTION("Caching read/erase/writeback block device emulation access to MTD devices");
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdblock_ro.c linux-2.4.2/drivers/mtd/mtdblock_ro.c
--- linux-2.4.2.orig/drivers/mtd/mtdblock_ro.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/mtdblock_ro.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,300 @@
+/*
+ * $Id: mtdblock_ro.c,v 1.12 2001/11/20 11:42:33 dwmw2 Exp $
+ *
+ * Read-only version of the mtdblock device, without the 
+ * read/erase/modify/writeback stuff
+ */
+
+#ifdef MTDBLOCK_DEBUG
+#define DEBUGLVL debug
+#endif							       
+
+
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/compatmac.h>
+
+#define MAJOR_NR MTD_BLOCK_MAJOR
+#define DEVICE_NAME "mtdblock"
+#define DEVICE_REQUEST mtdblock_request
+#define DEVICE_NR(device) (device)
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+#define DEVICE_NO_RANDOM
+#include <linux/blk.h>
+
+#if LINUX_VERSION_CODE < 0x20300
+#define RQFUNC_ARG void
+#define blkdev_dequeue_request(req) do {CURRENT = req->next;} while (0)
+#else
+#define RQFUNC_ARG request_queue_t *q
+#endif
+
+#ifdef MTDBLOCK_DEBUG
+static int debug = MTDBLOCK_DEBUG;
+MODULE_PARM(debug, "i");
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,14)
+#define BLK_INC_USE_COUNT MOD_INC_USE_COUNT
+#define BLK_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define BLK_INC_USE_COUNT do {} while(0)
+#define BLK_DEC_USE_COUNT do {} while(0)
+#endif
+
+static int mtd_sizes[MAX_MTD_DEVICES];
+
+
+static int mtdblock_open(struct inode *inode, struct file *file)
+{
+	struct mtd_info *mtd = NULL;
+
+	int dev;
+
+	DEBUG(1,"mtdblock_open\n");
+	
+	if (inode == 0)
+		return -EINVAL;
+	
+	dev = MINOR(inode->i_rdev);
+	
+	mtd = get_mtd_device(NULL, dev);
+	if (!mtd)
+		return -EINVAL;
+	if (MTD_ABSENT == mtd->type) {
+		put_mtd_device(mtd);
+		return -EINVAL;
+	}
+
+	BLK_INC_USE_COUNT;
+
+	mtd_sizes[dev] = mtd->size>>9;
+
+	DEBUG(1, "ok\n");
+
+	return 0;
+}
+
+static release_t mtdblock_release(struct inode *inode, struct file *file)
+{
+	int dev;
+	struct mtd_info *mtd;
+
+   	DEBUG(1, "mtdblock_release\n");
+
+	if (inode == NULL)
+		release_return(-ENODEV);
+   
+	dev = MINOR(inode->i_rdev);
+	mtd = __get_mtd_device(NULL, dev);
+
+	if (!mtd) {
+		printk(KERN_WARNING "MTD device is absent on mtd_release!\n");
+		BLK_DEC_USE_COUNT;
+		release_return(-ENODEV);
+	}
+	
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+
+	DEBUG(1, "ok\n");
+
+	BLK_DEC_USE_COUNT;
+	release_return(0);
+}  
+
+
+static void mtdblock_request(RQFUNC_ARG)
+{
+   struct request *current_request;
+   unsigned int res = 0;
+   struct mtd_info *mtd;
+
+   while (1)
+   {
+      /* Grab the Request and unlink it from the request list, INIT_REQUEST
+       	 will execute a return if we are done. */
+      INIT_REQUEST;
+      current_request = CURRENT;
+   
+      if (MINOR(current_request->rq_dev) >= MAX_MTD_DEVICES)
+      {
+	 printk("mtd: Unsupported device!\n");
+	 end_request(0);
+	 continue;
+      }
+      
+      // Grab our MTD structure
+
+      mtd = __get_mtd_device(NULL, MINOR(current_request->rq_dev));
+      if (!mtd) {
+	      printk("MTD device %d doesn't appear to exist any more\n", CURRENT_DEV);
+	      end_request(0);
+      }
+
+      if (current_request->sector << 9 > mtd->size ||
+	  (current_request->sector + current_request->nr_sectors) << 9 > mtd->size)
+      {
+	 printk("mtd: Attempt to read past end of device!\n");
+	 printk("size: %x, sector: %lx, nr_sectors %lx\n", mtd->size, current_request->sector, current_request->nr_sectors);
+	 end_request(0);
+	 continue;
+      }
+      
+      /* Remove the request we are handling from the request list so nobody messes
+         with it */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+      /* Now drop the lock that the ll_rw_blk functions grabbed for us
+         and process the request. This is necessary due to the extreme time
+         we spend processing it. */
+      spin_unlock_irq(&io_request_lock);
+#endif
+
+      // Handle the request
+      switch (current_request->cmd)
+      {
+         size_t retlen;
+
+	 case READ:
+	 if (MTD_READ(mtd,current_request->sector<<9, 
+		      current_request->nr_sectors << 9, 
+		      &retlen, current_request->buffer) == 0)
+	    res = 1;
+	 else
+	    res = 0;
+	 break;
+	 
+	 case WRITE:
+
+	 /* printk("mtdblock_request WRITE sector=%d(%d)\n",current_request->sector,
+		current_request->nr_sectors);
+	 */
+
+	 // Read only device
+	 if ((mtd->flags & MTD_CAP_RAM) == 0)
+	 {
+	    res = 0;
+	    break;
+	 }
+
+	 // Do the write
+	 if (MTD_WRITE(mtd,current_request->sector<<9, 
+		       current_request->nr_sectors << 9, 
+		       &retlen, current_request->buffer) == 0)
+	    res = 1;
+	 else
+	    res = 0;
+	 break;
+	 
+	 // Shouldn't happen
+	 default:
+	 printk("mtd: unknown request\n");
+	 break;
+      }
+
+      // Grab the lock and re-thread the item onto the linked list
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	spin_lock_irq(&io_request_lock);
+#endif
+	end_request(res);
+   }
+}
+
+
+
+static int mtdblock_ioctl(struct inode * inode, struct file * file,
+		      unsigned int cmd, unsigned long arg)
+{
+	struct mtd_info *mtd;
+
+	mtd = __get_mtd_device(NULL, MINOR(inode->i_rdev));
+
+	if (!mtd) return -EINVAL;
+
+	switch (cmd) {
+	case BLKGETSIZE:   /* Return device size */
+		return put_user((mtd->size >> 9), (unsigned long *) arg);
+
+#ifdef BLKGETSIZE64
+	case BLKGETSIZE64:
+		return put_user((u64)mtd->size, (u64 *)arg);
+#endif
+
+	case BLKFLSBUF:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+		if(!capable(CAP_SYS_ADMIN))  return -EACCES;
+#endif
+		fsync_dev(inode->i_rdev);
+		invalidate_buffers(inode->i_rdev);
+		if (mtd->sync)
+			mtd->sync(mtd);
+		return 0;
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+#if LINUX_VERSION_CODE < 0x20326
+static struct file_operations mtd_fops =
+{
+	open: mtdblock_open,
+	ioctl: mtdblock_ioctl,
+	release: mtdblock_release,
+	read: block_read,
+	write: block_write
+};
+#else
+static struct block_device_operations mtd_fops = 
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,14)
+	owner: THIS_MODULE,
+#endif
+	open: mtdblock_open,
+	release: mtdblock_release,
+	ioctl: mtdblock_ioctl
+};
+#endif
+
+int __init init_mtdblock(void)
+{
+	int i;
+
+	if (register_blkdev(MAJOR_NR,DEVICE_NAME,&mtd_fops)) {
+		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
+		       MTD_BLOCK_MAJOR);
+		return EAGAIN;
+	}
+	
+	/* We fill it in at open() time. */
+	for (i=0; i< MAX_MTD_DEVICES; i++) {
+		mtd_sizes[i] = 0;
+	}
+	
+	/* Allow the block size to default to BLOCK_SIZE. */
+	blksize_size[MAJOR_NR] = NULL;
+	blk_size[MAJOR_NR] = mtd_sizes;
+	
+	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), &mtdblock_request);
+	return 0;
+}
+
+static void __exit cleanup_mtdblock(void)
+{
+	unregister_blkdev(MAJOR_NR,DEVICE_NAME);
+	blksize_size[MAJOR_NR] = NULL;
+	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+}
+
+module_init(init_mtdblock);
+module_exit(cleanup_mtdblock);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Erwin Authried <eauth@softsys.co.at> et al.");
+MODULE_DESCRIPTION("Simple read-only block device emulation access to MTD devices");
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdchar-compat.c linux-2.4.2/drivers/mtd/mtdchar-compat.c
--- linux-2.4.2.orig/drivers/mtd/mtdchar-compat.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/mtdchar-compat.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,587 @@
+/*
+ * $Id: mtdchar-compat.c,v 1.2 2001/10/02 15:05:11 dwmw2 Exp $
+ *
+ * Character-device access to raw MTD devices.
+ *
+ */
+
+
+#include <linux/mtd/compatmac.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+static void mtd_notify_add(struct mtd_info* mtd);
+static void mtd_notify_remove(struct mtd_info* mtd);
+
+static struct mtd_notifier notifier = {
+	add:	mtd_notify_add,
+	remove:	mtd_notify_remove,
+};
+
+static devfs_handle_t devfs_dir_handle;
+static devfs_handle_t devfs_rw_handle[MAX_MTD_DEVICES];
+static devfs_handle_t devfs_ro_handle[MAX_MTD_DEVICES];
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
+#else
+static int mtd_lseek (struct inode *inode, struct file *file, off_t offset, int orig)
+#endif
+{
+	struct mtd_info *mtd=(struct mtd_info *)file->private_data;
+
+	switch (orig) {
+	case 0:
+		/* SEEK_SET */
+		file->f_pos = offset;
+		break;
+	case 1:
+		/* SEEK_CUR */
+		file->f_pos += offset;
+		break;
+	case 2:
+		/* SEEK_END */
+		file->f_pos =mtd->size + offset;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (file->f_pos < 0)
+		file->f_pos = 0;
+	else if (file->f_pos >= mtd->size)
+		file->f_pos = mtd->size - 1;
+
+	return file->f_pos;
+}
+
+
+
+static int mtd_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	int devnum = minor >> 1;
+	struct mtd_info *mtd;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
+
+	if (devnum >= MAX_MTD_DEVICES)
+		return -ENODEV;
+
+	/* You can't open the RO devices RW */
+	if ((file->f_mode & 2) && (minor & 1))
+		return -EACCES;
+
+	mtd = get_mtd_device(NULL, devnum);
+	if (!mtd)
+		return -ENODEV;
+	if (MTD_ABSENT == mtd->type) {
+		put_mtd_device(mtd);
+		return -ENODEV;
+	}
+
+	MOD_INC_USE_COUNT;
+
+	file->private_data = mtd;
+		
+	/* You can't open it RW if it's not a writeable device */
+	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
+		put_mtd_device(mtd);
+		MOD_DEC_USE_COUNT;
+		return -EACCES;
+	}
+		
+	return 0;
+} /* mtd_open */
+
+/*====================================================================*/
+
+static release_t mtd_close(struct inode *inode,
+				 struct file *file)
+{
+	struct mtd_info *mtd;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
+
+	mtd = (struct mtd_info *)file->private_data;
+	
+	if (mtd->sync)
+		mtd->sync(mtd);
+	
+	put_mtd_device(mtd);
+
+	MOD_DEC_USE_COUNT;
+	release_return(0);
+} /* mtd_close */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+#define FILE_POS *ppos
+#else
+#define FILE_POS file->f_pos
+#endif
+
+/* FIXME: This _really_ needs to die. In 2.5, we should lock the
+   userspace buffer down and use it directly with readv/writev.
+*/
+#define MAX_KMALLOC_SIZE 0x20000
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static ssize_t mtd_read(struct file *file, char *buf, size_t count,loff_t *ppos)
+#else
+static int mtd_read(struct inode *inode,struct file *file, char *buf, int count)
+#endif
+{
+	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	size_t retlen=0;
+	size_t total_retlen=0;
+	int ret=0;
+#ifndef NO_MM
+	int len;
+	char *kbuf;
+#endif	
+	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
+
+	if (FILE_POS + count > mtd->size)
+		count = mtd->size - FILE_POS;
+
+	if (!count)
+		return 0;
+	
+	/* FIXME: Use kiovec in 2.3 or 2.2+rawio, or at
+	 * least split the IO into smaller chunks.
+	 */
+#ifdef NO_MM	
+	ret = MTD_READ(mtd, FILE_POS, count, &retlen, buf);
+	if (!ret) {
+		FILE_POS += retlen;
+		ret = retlen;
+	}
+	total_retlen = ret;
+#else
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
+
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+		
+		ret = MTD_READ(mtd, FILE_POS, len, &retlen, kbuf);
+		if (!ret) {
+			FILE_POS += retlen;
+			if (copy_to_user(buf, kbuf, retlen)) {
+			        kfree(kbuf);
+				return -EFAULT;
+			}
+			else
+				total_retlen += retlen;
+
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
+	}
+	
+#endif	
+	return total_retlen;
+} /* mtd_read */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+static ssize_t mtd_write(struct file *file, const char *buf, size_t count,loff_t *ppos)
+#else
+static read_write_t mtd_write(struct inode *inode,struct file *file, const char *buf, count_t count)
+#endif
+{
+	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	size_t retlen;
+	size_t total_retlen=0;
+	int ret=0;
+#ifndef NO_MM
+	int len;
+	char *kbuf;
+#endif
+
+	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
+	
+	if (FILE_POS == mtd->size)
+		return -ENOSPC;
+	
+	if (FILE_POS + count > mtd->size)
+		count = mtd->size - FILE_POS;
+
+	if (!count)
+		return 0;
+
+#ifdef NO_MM	
+	ret = MTD_WRITE(mtd, FILE_POS, count, &retlen, buf);
+	if (!ret) {
+		FILE_POS += retlen;
+		ret = retlen;
+	}
+	total_retlen = ret;
+#else
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
+
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf) {
+			printk("kmalloc is null\n");
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(kbuf, buf, len)) {
+			kfree(kbuf);
+			return -EFAULT;
+		}
+		
+	        ret = (*(mtd->write))(mtd, FILE_POS, len, &retlen, kbuf);
+		if (!ret) {
+			FILE_POS += retlen;
+			total_retlen += retlen;
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
+	}
+#endif		
+	return total_retlen;
+} /* mtd_write */
+
+/*======================================================================
+
+    IOCTL calls for getting device parameters.
+
+======================================================================*/
+static void mtd_erase_callback (struct erase_info *instr)
+{
+	wake_up((wait_queue_head_t *)instr->priv);
+}
+
+static int mtd_ioctl(struct inode *inode, struct file *file,
+		     u_int cmd, u_long arg)
+{
+	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	int ret = 0;
+	u_long size;
+	
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_ioctl\n");
+
+	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
+	if (cmd & IOC_IN) {
+		ret = verify_area(VERIFY_READ, (char *)arg, size);
+		if (ret) return ret;
+	}
+	if (cmd & IOC_OUT) {
+		ret = verify_area(VERIFY_WRITE, (char *)arg, size);
+		if (ret) return ret;
+	}
+	
+	switch (cmd) {
+	case MEMGETREGIONCOUNT:
+		if (copy_to_user((int *) arg, &(mtd->numeraseregions), sizeof(int)))
+			return -EFAULT;
+		break;
+
+	case MEMGETREGIONINFO:
+	{
+		struct region_info_user ur;
+
+		if (copy_from_user(	&ur, 
+					(struct region_info_user *)arg, 
+					sizeof(struct region_info_user))) {
+			return -EFAULT;
+		}
+
+		if (ur.regionindex >= mtd->numeraseregions)
+			return -EINVAL;
+		if (copy_to_user((struct mtd_erase_region_info *) arg, 
+				&(mtd->eraseregions[ur.regionindex]),
+				sizeof(struct mtd_erase_region_info)))
+			return -EFAULT;
+		break;
+	}
+
+	case MEMGETINFO:
+		if (copy_to_user((struct mtd_info *)arg, mtd,
+				 sizeof(struct mtd_info_user)))
+			return -EFAULT;
+		break;
+
+	case MEMERASE:
+	{
+		struct erase_info *erase=kmalloc(sizeof(struct erase_info),GFP_KERNEL);
+		if (!erase)
+			ret = -ENOMEM;
+		else {
+			wait_queue_head_t waitq;
+			DECLARE_WAITQUEUE(wait, current);
+
+			init_waitqueue_head(&waitq);
+
+			memset (erase,0,sizeof(struct erase_info));
+			if (copy_from_user(&erase->addr, (u_long *)arg,
+					   2 * sizeof(u_long))) {
+				kfree(erase);
+				return -EFAULT;
+			}
+			erase->mtd = mtd;
+			erase->callback = mtd_erase_callback;
+			erase->priv = (unsigned long)&waitq;
+
+			/*
+			  FIXME: Allow INTERRUPTIBLE. Which means
+			  not having the wait_queue head on the stack.
+			  
+			  If the wq_head is on the stack, and we
+			  leave because we got interrupted, then the
+			  wq_head is no longer there when the
+			  callback routine tries to wake us up.
+			*/
+			ret = mtd->erase(mtd, erase);
+			if (!ret) {
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				add_wait_queue(&waitq, &wait);
+				if (erase->state != MTD_ERASE_DONE &&
+				    erase->state != MTD_ERASE_FAILED)
+					schedule();
+				remove_wait_queue(&waitq, &wait);
+				set_current_state(TASK_RUNNING);
+
+				ret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;
+			}
+			kfree(erase);
+		}
+		break;
+	}
+
+	case MEMWRITEOOB:
+	{
+		struct mtd_oob_buf buf;
+		void *databuf;
+		ssize_t retlen;
+		
+		if (copy_from_user(&buf, (struct mtd_oob_buf *)arg, sizeof(struct mtd_oob_buf)))
+			return -EFAULT;
+		
+		if (buf.length > 0x4096)
+			return -EINVAL;
+
+		if (!mtd->write_oob)
+			ret = -EOPNOTSUPP;
+		else
+			ret = verify_area(VERIFY_READ, (char *)buf.ptr, buf.length);
+
+		if (ret)
+			return ret;
+
+		databuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!databuf)
+			return -ENOMEM;
+		
+		if (copy_from_user(databuf, buf.ptr, buf.length)) {
+			kfree(databuf);
+			return -EFAULT;
+		}
+
+		ret = (mtd->write_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+
+		if (copy_to_user((void *)arg + sizeof(u_int32_t), &retlen, sizeof(u_int32_t)))
+			ret = -EFAULT;
+
+		kfree(databuf);
+		break;
+
+	}
+
+	case MEMREADOOB:
+	{
+		struct mtd_oob_buf buf;
+		void *databuf;
+		ssize_t retlen;
+
+		if (copy_from_user(&buf, (struct mtd_oob_buf *)arg, sizeof(struct mtd_oob_buf)))
+			return -EFAULT;
+		
+		if (buf.length > 0x4096)
+			return -EINVAL;
+
+		if (!mtd->read_oob)
+			ret = -EOPNOTSUPP;
+		else
+			ret = verify_area(VERIFY_WRITE, (char *)buf.ptr, buf.length);
+
+		if (ret)
+			return ret;
+
+		databuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!databuf)
+			return -ENOMEM;
+		
+		ret = (mtd->read_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+
+		if (copy_to_user((void *)arg + sizeof(u_int32_t), &retlen, sizeof(u_int32_t)))
+			ret = -EFAULT;
+		else if (retlen && copy_to_user(buf.ptr, databuf, retlen))
+			ret = -EFAULT;
+		
+		kfree(databuf);
+		break;
+	}
+
+	case MEMLOCK:
+	{
+		unsigned long adrs[2];
+
+		if (copy_from_user(adrs ,(void *)arg, 2* sizeof(unsigned long)))
+			return -EFAULT;
+
+		if (!mtd->lock)
+			ret = -EOPNOTSUPP;
+		else
+			ret = mtd->lock(mtd, adrs[0], adrs[1]);
+		break;
+	}
+
+	case MEMUNLOCK:
+	{
+		unsigned long adrs[2];
+
+		if (copy_from_user(adrs, (void *)arg, 2* sizeof(unsigned long)))
+			return -EFAULT;
+
+		if (!mtd->unlock)
+			ret = -EOPNOTSUPP;
+		else
+			ret = mtd->unlock(mtd, adrs[0], adrs[1]);
+		break;
+	}
+
+		
+	default:
+		DEBUG(MTD_DEBUG_LEVEL0, "Invalid ioctl %x (MEMGETINFO = %x)\n", cmd, MEMGETINFO);
+		ret = -ENOTTY;
+	}
+
+	return ret;
+} /* memory_ioctl */
+
+static struct file_operations mtd_fops = {
+#if LINUX_VERSION_CODE >= 0x20300	/* Someone knows when these made their debut? */
+	owner:		THIS_MODULE,
+#endif
+#if LINUX_VERSION_CODE >=0x20200
+	llseek:		mtd_lseek,     	/* lseek */
+#else
+	lseek:		mtd_lseek,     	/* lseek */
+#endif
+	read:		mtd_read,	/* read */
+	write: 		mtd_write, 	/* write */
+	ioctl:		mtd_ioctl,	/* ioctl */
+	open:		mtd_open,	/* open */
+	release:	mtd_close,	/* release */
+};
+
+
+#ifdef CONFIG_DEVFS_FS
+/* Notification that a new device has been added. Create the devfs entry for
+ * it. */
+
+static void mtd_notify_add(struct mtd_info* mtd)
+{
+	char name[8];
+
+	if (!mtd)
+		return;
+
+	sprintf(name, "%d", mtd->index);
+	devfs_rw_handle[mtd->index] = devfs_register(devfs_dir_handle, name,
+			DEVFS_FL_DEFAULT, MTD_CHAR_MAJOR, mtd->index*2,
+			S_IFCHR | S_IRUGO | S_IWUGO,
+			&mtd_fops, NULL);
+
+	sprintf(name, "%dro", mtd->index);
+	devfs_ro_handle[mtd->index] = devfs_register(devfs_dir_handle, name,
+			DEVFS_FL_DEFAULT, MTD_CHAR_MAJOR, mtd->index*2+1,
+			S_IFCHR | S_IRUGO | S_IWUGO,
+			&mtd_fops, NULL);
+}
+
+static void mtd_notify_remove(struct mtd_info* mtd)
+{
+	if (!mtd)
+		return;
+
+	devfs_unregister(devfs_rw_handle[mtd->index]);
+	devfs_unregister(devfs_ro_handle[mtd->index]);
+}
+#endif
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_mtdchar init_module
+#define cleanup_mtdchar cleanup_module
+#endif
+
+mod_init_t init_mtdchar(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	if (devfs_register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops))
+	{
+		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
+		       MTD_CHAR_MAJOR);
+		return -EAGAIN;
+	}
+
+	devfs_dir_handle = devfs_mk_dir(NULL, "mtd", NULL);
+
+	register_mtd_user(&notifier);
+#else
+	if (register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops))
+	{
+		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
+		       MTD_CHAR_MAJOR);
+		return -EAGAIN;
+	}
+#endif
+
+	return 0;
+}
+
+mod_exit_t cleanup_mtdchar(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	unregister_mtd_user(&notifier);
+	devfs_unregister(devfs_dir_handle);
+	devfs_unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
+#else
+	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
+#endif
+}
+
+module_init(init_mtdchar);
+module_exit(cleanup_mtdchar);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Direct character-device access to MTD devices");
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdchar.c linux-2.4.2/drivers/mtd/mtdchar.c
--- linux-2.4.2.orig/drivers/mtd/mtdchar.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdchar.c	Fri Feb 15 14:41:16 2002
@@ -1,13 +1,11 @@
 /*
- * $Id: mtdchar.c,v 1.21.2.3 2001/01/09 00:18:31 dwmw2 Exp $
+ * $Id: mtdchar.c,v 1.44 2001/10/02 15:05:11 dwmw2 Exp $
  *
  * Character-device access to raw MTD devices.
+ * Pure 2.4 version - compatibility cruft removed to mtdchar-compat.c
  *
  */
 
-
-#include <linux/mtd/compatmac.h>
-
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -18,21 +16,18 @@
 #include <linux/devfs_fs_kernel.h>
 static void mtd_notify_add(struct mtd_info* mtd);
 static void mtd_notify_remove(struct mtd_info* mtd);
+
 static struct mtd_notifier notifier = {
-	mtd_notify_add,
-	mtd_notify_remove,
-	NULL
+	add:	mtd_notify_add,
+	remove:	mtd_notify_remove,
 };
-static devfs_handle_t devfs_dir_handle = NULL;
+
+static devfs_handle_t devfs_dir_handle;
 static devfs_handle_t devfs_rw_handle[MAX_MTD_DEVICES];
 static devfs_handle_t devfs_ro_handle[MAX_MTD_DEVICES];
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
-#else
-static int mtd_lseek (struct inode *inode, struct file *file, off_t offset, int orig)
-#endif
 {
 	struct mtd_info *mtd=(struct mtd_info *)file->private_data;
 
@@ -79,10 +74,15 @@
 		return -EACCES;
 
 	mtd = get_mtd_device(NULL, devnum);
-		
+	
 	if (!mtd)
 		return -ENODEV;
 	
+	if (MTD_ABSENT == mtd->type) {
+		put_mtd_device(mtd);
+		return -ENODEV;
+	}
+
 	file->private_data = mtd;
 		
 	/* You can't open it RW if it's not a writeable device */
@@ -96,8 +96,7 @@
 
 /*====================================================================*/
 
-static release_t mtd_close(struct inode *inode,
-				 struct file *file)
+static int mtd_close(struct inode *inode, struct file *file)
 {
 	struct mtd_info *mtd;
 
@@ -110,100 +109,120 @@
 	
 	put_mtd_device(mtd);
 
-	release_return(0);
+	return 0;
 } /* mtd_close */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
-#define FILE_POS *ppos
-#else
-#define FILE_POS file->f_pos
-#endif
+/* FIXME: This _really_ needs to die. In 2.5, we should lock the
+   userspace buffer down and use it directly with readv/writev.
+*/
+#define MAX_KMALLOC_SIZE 0x20000
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
 static ssize_t mtd_read(struct file *file, char *buf, size_t count,loff_t *ppos)
-#else
-static int mtd_read(struct inode *inode,struct file *file, char *buf, int count)
-#endif
 {
 	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
 	size_t retlen=0;
+	size_t total_retlen=0;
 	int ret=0;
+	int len;
 	char *kbuf;
 	
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
-	if (FILE_POS + count > mtd->size)
-		count = mtd->size - FILE_POS;
+	if (*ppos + count > mtd->size)
+		count = mtd->size - *ppos;
 
 	if (!count)
 		return 0;
 	
-	/* FIXME: Use kiovec in 2.3 or 2.2+rawio, or at
-	 * least split the IO into smaller chunks.
-	 */
-	
-	kbuf = vmalloc(count);
-	if (!kbuf)
-		return -ENOMEM;
-	
-	ret = MTD_READ(mtd, FILE_POS, count, &retlen, kbuf);
-	if (!ret) {
-		FILE_POS += retlen;
-		if (copy_to_user(buf, kbuf, retlen))
-			ret = -EFAULT;
+	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
+	   and pass them directly to the MTD functions */
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
 		else
-			ret = retlen;
+			len = count;
 
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+		
+		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+		if (!ret) {
+			*ppos += retlen;
+			if (copy_to_user(buf, kbuf, retlen)) {
+			        kfree(kbuf);
+				return -EFAULT;
+			}
+			else
+				total_retlen += retlen;
+
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
 	}
 	
-	vfree(kbuf);
-	
-	return ret;
+	return total_retlen;
 } /* mtd_read */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
 static ssize_t mtd_write(struct file *file, const char *buf, size_t count,loff_t *ppos)
-#else
-static read_write_t mtd_write(struct inode *inode,struct file *file, const char *buf, count_t count)
-#endif
 {
 	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
 	char *kbuf;
 	size_t retlen;
+	size_t total_retlen=0;
 	int ret=0;
+	int len;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
 	
-	if (FILE_POS == mtd->size)
+	if (*ppos == mtd->size)
 		return -ENOSPC;
 	
-	if (FILE_POS + count > mtd->size)
-		count = mtd->size - FILE_POS;
+	if (*ppos + count > mtd->size)
+		count = mtd->size - *ppos;
 
 	if (!count)
 		return 0;
 
-	kbuf=vmalloc(count);
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
 
-	if (!kbuf)
-		return -ENOMEM;
-	
-	if (copy_from_user(kbuf, buf, count)) {
-		vfree(kbuf);
-		return -EFAULT;
-	}
-		
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf) {
+			printk("kmalloc is null\n");
+			return -ENOMEM;
+		}
 
-	ret = (*(mtd->write))(mtd, FILE_POS, count, &retlen, buf);
+		if (copy_from_user(kbuf, buf, len)) {
+			kfree(kbuf);
+			return -EFAULT;
+		}
+		
+	        ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+		if (!ret) {
+			*ppos += retlen;
+			total_retlen += retlen;
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
 		
-	if (!ret) {
-		FILE_POS += retlen;
-		ret = retlen;
+		kfree(kbuf);
 	}
 
-	vfree(kbuf);
-
-	return ret;
+	return total_retlen;
 } /* mtd_write */
 
 /*======================================================================
@@ -236,6 +255,30 @@
 	}
 	
 	switch (cmd) {
+	case MEMGETREGIONCOUNT:
+		if (copy_to_user((int *) arg, &(mtd->numeraseregions), sizeof(int)))
+			return -EFAULT;
+		break;
+
+	case MEMGETREGIONINFO:
+	{
+		struct region_info_user ur;
+
+		if (copy_from_user(	&ur, 
+					(struct region_info_user *)arg, 
+					sizeof(struct region_info_user))) {
+			return -EFAULT;
+		}
+
+		if (ur.regionindex >= mtd->numeraseregions)
+			return -EINVAL;
+		if (copy_to_user((struct mtd_erase_region_info *) arg, 
+				&(mtd->eraseregions[ur.regionindex]),
+				sizeof(struct mtd_erase_region_info)))
+			return -EFAULT;
+		break;
+	}
+
 	case MEMGETINFO:
 		if (copy_to_user((struct mtd_info *)arg, mtd,
 				 sizeof(struct mtd_info_user)))
@@ -272,15 +315,18 @@
 			  wq_head is no longer there when the
 			  callback routine tries to wake us up.
 			*/
-			current->state = TASK_UNINTERRUPTIBLE;
-			add_wait_queue(&waitq, &wait);
 			ret = mtd->erase(mtd, erase);
-			if (!ret)
-				schedule();
-			remove_wait_queue(&waitq, &wait);
-			current->state = TASK_RUNNING;
-			if (!ret)
-				ret = (erase->state == MTD_ERASE_FAILED);
+			if (!ret) {
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				add_wait_queue(&waitq, &wait);
+				if (erase->state != MTD_ERASE_DONE &&
+				    erase->state != MTD_ERASE_FAILED)
+					schedule();
+				remove_wait_queue(&waitq, &wait);
+				set_current_state(TASK_RUNNING);
+
+				ret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;
+			}
 			kfree(erase);
 		}
 		break;
@@ -310,12 +356,14 @@
 		if (!databuf)
 			return -ENOMEM;
 		
-		if (copy_from_user(databuf, buf.ptr, buf.length))
+		if (copy_from_user(databuf, buf.ptr, buf.length)) {
+			kfree(databuf);
 			return -EFAULT;
+		}
 
 		ret = (mtd->write_oob)(mtd, buf.start, buf.length, &retlen, databuf);
 
-		if (copy_to_user((void *)arg + sizeof(loff_t), &retlen, sizeof(ssize_t)))
+		if (copy_to_user((void *)arg + sizeof(u_int32_t), &retlen, sizeof(u_int32_t)))
 			ret = -EFAULT;
 
 		kfree(databuf);
@@ -349,7 +397,7 @@
 		
 		ret = (mtd->read_oob)(mtd, buf.start, buf.length, &retlen, databuf);
 
-		if (copy_to_user((void *)arg + sizeof(loff_t), &retlen, sizeof(ssize_t)))
+		if (copy_to_user((void *)arg + sizeof(u_int32_t), &retlen, sizeof(u_int32_t)))
 			ret = -EFAULT;
 		else if (retlen && copy_to_user(buf.ptr, databuf, retlen))
 			ret = -EFAULT;
@@ -369,6 +417,7 @@
 			ret = -EOPNOTSUPP;
 		else
 			ret = mtd->lock(mtd, adrs[0], adrs[1]);
+		break;
 	}
 
 	case MEMUNLOCK:
@@ -382,14 +431,15 @@
 			ret = -EOPNOTSUPP;
 		else
 			ret = mtd->unlock(mtd, adrs[0], adrs[1]);
+		break;
 	}
 
 		
 	default:
-	  printk("Invalid ioctl %x (MEMGETINFO = %x)\n",cmd, MEMGETINFO);
-		ret = -EINVAL;
+		DEBUG(MTD_DEBUG_LEVEL0, "Invalid ioctl %x (MEMGETINFO = %x)\n", cmd, MEMGETINFO);
+		ret = -ENOTTY;
 	}
-	
+
 	return ret;
 } /* memory_ioctl */
 
@@ -438,12 +488,7 @@
 }
 #endif
 
-#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
-#define init_mtdchar init_module
-#define cleanup_mtdchar cleanup_module
-#endif
-
-mod_init_t init_mtdchar(void)
+static int __init init_mtdchar(void)
 {
 #ifdef CONFIG_DEVFS_FS
 	if (devfs_register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops))
@@ -468,7 +513,7 @@
 	return 0;
 }
 
-mod_exit_t cleanup_mtdchar(void)
+static void __exit cleanup_mtdchar(void)
 {
 #ifdef CONFIG_DEVFS_FS
 	unregister_mtd_user(&notifier);
@@ -481,3 +526,8 @@
 
 module_init(init_mtdchar);
 module_exit(cleanup_mtdchar);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Direct character-device access to MTD devices");
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdcore.c linux-2.4.2/drivers/mtd/mtdcore.c
--- linux-2.4.2.orig/drivers/mtd/mtdcore.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdcore.c	Fri Feb 15 14:41:16 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.27 2000/12/10 01:10:09 dwmw2 Exp $
+ * $Id: mtdcore.c,v 1.31 2001/10/02 15:05:11 dwmw2 Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -258,8 +258,8 @@
 	if (!this)
 		return 0;
 
-	return sprintf(buf, "mtd%d: %8.8lx \"%s\"\n", i, this->size,
-		       this->name);
+	return sprintf(buf, "mtd%d: %8.8x %8.8x \"%s\"\n", i, this->size,
+		       this->erasesize, this->name);
 }
 
 static int mtd_read_proc ( char *page, char **start, off_t off,int count
@@ -270,11 +270,12 @@
 #endif
 			)
 {
-	int len = 0, l, i;
+	int len, l, i;
         off_t   begin = 0;
 
 	down(&mtd_table_mutex);
 
+	len = sprintf(page, "dev:    size   erasesize  name\n");
         for (i=0; i< MAX_MTD_DEVICES; i++) {
 
                 l = mtd_proc_info(page + len, i);
@@ -316,12 +317,7 @@
 /*====================================================================*/
 /* Init code */
 
-#if  LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
-#define init_mtd init_module
-#define cleanup_mtd cleanup_module
-#endif
-
-mod_init_t init_mtd(void)
+int __init init_mtd(void)
 {
 #ifdef CONFIG_PROC_FS
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
@@ -342,7 +338,7 @@
 	return 0;
 }
 
-mod_exit_t cleanup_mtd(void)
+static void __exit cleanup_mtd(void)
 {
 #ifdef CONFIG_PM
 	if (mtd_pm_dev) {
@@ -365,3 +361,6 @@
 module_exit(cleanup_mtd);
 
 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Core MTD registration and access routines");
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdpart.c linux-2.4.2/drivers/mtd/mtdpart.c
--- linux-2.4.2.orig/drivers/mtd/mtdpart.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdpart.c	Fri Feb 15 14:41:16 2002
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.7 2000/12/09 23:29:47 dwmw2 Exp $
+ * $Id: mtdpart.c,v 1.25 2001/11/27 14:55:11 cdavies Exp $
  */
 
 #include <linux/module.h>
@@ -25,7 +25,7 @@
 struct mtd_part {
 	struct mtd_info mtd;
 	struct mtd_info *master;
-	loff_t offset;
+	u_int32_t offset;
 	int index;
 	struct list_head list;
 };
@@ -100,15 +100,36 @@
 static int part_lock (struct mtd_info *mtd, loff_t ofs, size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	if ((len + ofs) > mtd->size) 
+		return -EINVAL;
 	return part->master->lock(part->master, ofs + part->offset, len);
 }
 
 static int part_unlock (struct mtd_info *mtd, loff_t ofs, size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	if ((len + ofs) > mtd->size) 
+		return -EINVAL;
 	return part->master->unlock(part->master, ofs + part->offset, len);
 }
 
+static void part_sync(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	part->master->sync(part->master);
+}
+
+static int part_suspend(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	return part->master->suspend(part->master);
+}
+
+static void part_resume(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	part->master->resume(part->master);
+}
 
 /* 
  * This function unregisters and destroy all slave MTD objects which are 
@@ -130,14 +151,12 @@
 			del_mtd_device(&slave->mtd);
 			kfree(slave);
 			node = prev;
-			MOD_DEC_USE_COUNT;
 		}
 	}
 
 	return 0;
 }
 
-
 /*
  * This function, given a master MTD object and a partition table, creates
  * and registers slave MTD objects which are bound to the master according to
@@ -150,10 +169,13 @@
 		       int nbparts)
 {
 	struct mtd_part *slave;
-	u_long cur_offset = 0;
+	u_int32_t cur_offset = 0;
 	int i;
 
+	printk (KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
+
 	for (i = 0; i < nbparts; i++) {
+
 		/* allocate the partition structure */
 		slave = kmalloc (sizeof(*slave), GFP_KERNEL);
 		if (!slave) {
@@ -162,63 +184,115 @@
 			del_mtd_partitions(master);
 			return -ENOMEM;
 		}
+		memset(slave, 0, sizeof(*slave));
 		list_add(&slave->list, &mtd_partitions);
 
 		/* set up the MTD object for this partition */
-		slave->mtd = *master;
-		slave->mtd.name = parts[i].name;
+		slave->mtd.type = master->type;
+		slave->mtd.flags = master->flags & ~parts[i].mask_flags;
 		slave->mtd.size = parts[i].size;
-		slave->mtd.flags &= ~parts[i].mask_flags;
+		slave->mtd.oobblock = master->oobblock;
+		slave->mtd.oobsize = master->oobsize;
+		slave->mtd.ecctype = master->ecctype;
+		slave->mtd.eccsize = master->eccsize;
+		slave->mtd.read_user_prot_reg = master->read_user_prot_reg;
+		slave->mtd.read_fact_prot_reg = master->read_fact_prot_reg;
+		slave->mtd.write_user_prot_reg = master->write_user_prot_reg;
+
+		slave->mtd.name = parts[i].name;
+		slave->mtd.bank_size = master->bank_size;
+
+		slave->mtd.module = master->module;
+
 		slave->mtd.read = part_read;
 		slave->mtd.write = part_write;
-		if (slave->mtd.writev)
+		if (master->sync)
+			slave->mtd.sync = part_sync;
+		if (!i && master->suspend && master->resume) {
+				slave->mtd.suspend = part_suspend;
+				slave->mtd.resume = part_resume;
+		}
+
+		if (master->writev)
 			slave->mtd.writev = part_writev;
-		if (slave->mtd.readv)
+		if (master->readv)
 			slave->mtd.readv = part_readv;
-		if (slave->mtd.lock)
+		if (master->lock)
 			slave->mtd.lock = part_lock;
-		if (slave->mtd.unlock)
+		if (master->unlock)
 			slave->mtd.unlock = part_unlock;
 		slave->mtd.erase = part_erase;
 		slave->master = master;
 		slave->offset = parts[i].offset;
 		slave->index = i;
 
-		if (slave->offset == 0)
+		if (slave->offset == MTDPART_OFS_APPEND)
 			slave->offset = cur_offset;
-		if (slave->mtd.size == 0)
+		if (slave->offset == MTDPART_OFS_NXTBLK) {
+			u_int32_t emask = master->erasesize-1;
+			slave->offset = (cur_offset + emask) & ~emask;
+			if (slave->offset != cur_offset) {
+				printk(KERN_NOTICE "Moving partition %d: "
+				       "0x%08x -> 0x%08x\n", i,
+				       cur_offset, slave->offset);
+			}
+		}
+		if (slave->mtd.size == MTDPART_SIZ_FULL)
 			slave->mtd.size = master->size - slave->offset;
 		cur_offset = slave->offset + slave->mtd.size;
+	
+		printk (KERN_NOTICE "0x%08x-0x%08x : \"%s\"\n", slave->offset, 
+			slave->offset + slave->mtd.size, slave->mtd.name);
 
 		/* let's do some sanity checks */
+		if (slave->offset >= master->size) {
+				/* let's register it anyway to preserve ordering */
+			slave->offset = 0;
+			slave->mtd.size = 0;
+			printk ("mtd: partition \"%s\" is out of reach -- disabled\n",
+				parts[i].name);
+		}
+		if (slave->offset + slave->mtd.size > master->size) {
+			slave->mtd.size = master->size - slave->offset;
+			printk ("mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#x\n",
+				parts[i].name, master->name, slave->mtd.size);
+		}
+		if (master->numeraseregions>1) {
+			/* Deal with variable erase size stuff */
+			int i;
+			struct mtd_erase_region_info *regions = master->eraseregions;
+			
+			/* Find the first erase regions which is part of this partition. */
+			for (i=0; i < master->numeraseregions && slave->offset >= regions[i].offset; i++)
+				;
+
+			for (i--; i < master->numeraseregions && slave->offset + slave->mtd.size > regions[i].offset; i++) {
+				if (slave->mtd.erasesize < regions[i].erasesize) {
+					slave->mtd.erasesize = regions[i].erasesize;
+				}
+			}
+		} else {
+			/* Single erase size */
+			slave->mtd.erasesize = master->erasesize;
+		}
+
 		if ((slave->mtd.flags & MTD_WRITEABLE) && 
-		    (parts[i].offset % master->erasesize)) {
+		    (slave->offset % slave->mtd.erasesize)) {
+			/* Doesn't start on a boundary of major erase size */
+			/* FIXME: Let it be writable if it is on a boundary of _minor_ erase size though */
 			slave->mtd.flags &= ~MTD_WRITEABLE;
 			printk ("mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
-					parts[i].name);
+				parts[i].name);
 		}
 		if ((slave->mtd.flags & MTD_WRITEABLE) && 
-		    (parts[i].size % master->erasesize)) {
+		    (slave->mtd.size % slave->mtd.erasesize)) {
 			slave->mtd.flags &= ~MTD_WRITEABLE;
 			printk ("mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
-					parts[i].name);
-		}
-		if (parts[i].offset >= master->size) {
-			/* let's register it anyway to preserve ordering */
-			slave->offset = 0;
-			slave->mtd.size = 0;
-			printk ("mtd: partition \"%s\" is out of reach -- disabled\n",
-					parts[i].name);
-		}
-		if (parts[i].offset + parts[i].size > master->size) {
-			slave->mtd.size = master->size - parts[i].offset;
-			printk ("mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#lx\n",
-					parts[i].name, master->name, slave->mtd.size);
+				parts[i].name);
 		}
 
 		/* register our partition */
 		add_mtd_device(&slave->mtd);
-		MOD_INC_USE_COUNT;
 	}
 
 	return 0;
@@ -226,3 +300,9 @@
 
 EXPORT_SYMBOL(add_mtd_partitions);
 EXPORT_SYMBOL(del_mtd_partitions);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Pitre <nico@cam.org>");
+MODULE_DESCRIPTION("Generic support for partitioning of MTD devices");
+
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdram.c linux-2.4.2/drivers/mtd/mtdram.c
--- linux-2.4.2.orig/drivers/mtd/mtdram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdram.c	Fri Feb 15 14:41:16 2002
@@ -1,7 +1,7 @@
-/* 
+/*
  * mtdram - a test mtd device
- * $Id: mtdram.c,v 1.15 2000/07/13 12:40:46 scote1 Exp $
- * Author: Alexander Larsson <alex@cendio.se> 
+ * $Id: mtdram.c,v 1.21 2001/03/17 19:08:45 dwmw2 Exp $
+ * Author: Alexander Larsson <alex@cendio.se>
  *
  * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
  *
@@ -9,17 +9,32 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
-
-#include <linux/slab.h>
+#include <linux/config.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/mtd.h>
 
+#ifndef CONFIG_MTDRAM_ABS_POS
+  #define CONFIG_MTDRAM_ABS_POS 0
+#endif
+
+#if CONFIG_MTDRAM_ABS_POS > 0
+  #include <asm/io.h>
+#endif
 
+#ifdef MODULE
+static unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;
+static unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;
+MODULE_PARM(total_size,"l");
+MODULE_PARM(erase_size,"l");
+#define MTDRAM_TOTAL_SIZE (total_size * 1024)
+#define MTDRAM_ERASE_SIZE (erase_size * 1024)
+#else
 #define MTDRAM_TOTAL_SIZE (CONFIG_MTDRAM_TOTAL_SIZE * 1024)
 #define MTDRAM_ERASE_SIZE (CONFIG_MTDRAM_ERASE_SIZE * 1024)
+#endif
 
 
 // We could store these in the mtd structure, but we only support 1 device..
@@ -29,11 +44,14 @@
 static int
 ram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-  if (instr->addr + instr->len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_erase(pos:%ld, len:%ld)\n", (long)instr->addr, (long)instr->len);
+  if (instr->addr + instr->len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_erase() out of bounds (%ld > %ld)\n", (long)(instr->addr + instr->len), (long)mtd->size);
     return -EINVAL;
+  }
 	
   memset((char *)mtd->priv + instr->addr, 0xff, instr->len);
-  
+
   instr->state = MTD_ERASE_DONE;
 
   if (instr->callback)
@@ -45,7 +63,7 @@
 {
   if (from + len > mtd->size)
     return -EINVAL;
-  
+
   *mtdbuf = mtd->priv + from;
   *retlen = len;
   return 0;
@@ -53,13 +71,17 @@
 
 static void ram_unpoint (struct mtd_info *mtd, u_char *addr)
 {
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_unpoint\n");
 }
 
 static int ram_read(struct mtd_info *mtd, loff_t from, size_t len,
 	     size_t *retlen, u_char *buf)
 {
-  if (from + len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_read(pos:%ld, len:%ld)\n", (long)from, (long)len);
+  if (from + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_read() out of bounds (%ld > %ld)\n", (long)(from + len), (long)mtd->size);
     return -EINVAL;
+  }
 
   memcpy(buf, mtd->priv + from, len);
 
@@ -70,21 +92,22 @@
 static int ram_write(struct mtd_info *mtd, loff_t to, size_t len,
 	      size_t *retlen, const u_char *buf)
 {
-  if (to + len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_write(pos:%ld, len:%ld)\n", (long)to, (long)len);
+  if (to + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_write() out of bounds (%ld > %ld)\n", (long)(to + len), (long)mtd->size);
     return -EINVAL;
-  
+  }
+
   memcpy ((char *)mtd->priv + to, buf, len);
 
   *retlen=len;
   return 0;
 }
 
-#if LINUX_VERSION_CODE < 0x20300
-#ifdef MODULE
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_mtdram init_module
 #define cleanup_mtdram cleanup_module
 #endif
-#endif
 
 //static void __exit cleanup_mtdram(void)
 mod_exit_t cleanup_mtdram(void)
@@ -92,20 +115,22 @@
   if (mtd_info) {
     del_mtd_device(mtd_info);
     if (mtd_info->priv)
+#if CONFIG_MTDRAM_ABS_POS > 0
+      iounmap(mtd_info->priv);
+#else
       vfree(mtd_info->priv);
+#endif	
     kfree(mtd_info);
   }
 }
 
-extern struct module __this_module;
-
 mod_init_t init_mtdram(void)
 {
    // Allocate some memory
    mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
    if (mtd_info == 0)
       return 0;
-   
+
    memset(mtd_info, 0, sizeof(*mtd_info));
 
    // Setup the MTD structure
@@ -114,14 +139,19 @@
    mtd_info->flags = MTD_CAP_RAM;
    mtd_info->size = MTDRAM_TOTAL_SIZE;
    mtd_info->erasesize = MTDRAM_ERASE_SIZE;
+#if CONFIG_MTDRAM_ABS_POS > 0
+   mtd_info->priv = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
+#else
    mtd_info->priv = vmalloc(MTDRAM_TOTAL_SIZE);
    memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+#endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
    mtd_info->module = THIS_MODULE;			
 #endif
 
    if (!mtd_info->priv) {
+     DEBUG(MTD_DEBUG_LEVEL1, "Failed to vmalloc(/ioremap) memory region of size %ld (ABS_POS:%ld)\n", (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
      kfree(mtd_info);
      mtd_info = NULL;
      return -ENOMEM;
@@ -133,16 +163,18 @@
    mtd_info->write = ram_write;
 
    if (add_mtd_device(mtd_info)) {
+#if CONFIG_MTDRAM_ABS_POS > 0
+     iounmap(mtd_info->priv);
+#else
      vfree(mtd_info->priv);
+#endif	
      kfree(mtd_info);
      mtd_info = NULL;
      return -EIO;
    }
-   
+
    return 0;
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_mtdram);
 module_exit(cleanup_mtdram);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/Config.in linux-2.4.2/drivers/mtd/nand/Config.in
--- linux-2.4.2.orig/drivers/mtd/nand/Config.in	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/Config.in	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,18 @@
+# drivers/mtd/nand/Config.in
+
+# $Id: Config.in,v 1.4 2001/09/19 09:35:23 dwmw2 Exp $
+
+mainmenu_option next_comment
+
+comment 'NAND Flash Device Drivers'
+
+dep_tristate '  NAND Device Support' CONFIG_MTD_NAND $CONFIG_MTD
+if [ "$CONFIG_MTD_NAND" = "y" -o "$CONFIG_MTD_NAND" = "m" ]; then
+   bool '    Enable ECC correction algorithm'  CONFIG_MTD_NAND_ECC
+   bool '    Verify NAND page writes' CONFIG_MTD_NAND_VERIFY_WRITE
+fi
+if [ "$CONFIG_ARM" = "y" -a "$CONFIG_ARCH_P720T" = "y" ]; then
+   dep_tristate '  NAND Flash device on SPIA board' CONFIG_MTD_NAND_SPIA $CONFIG_MTD_NAND
+fi
+
+endmenu
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/GNUmakefile linux-2.4.2/drivers/mtd/nand/GNUmakefile
--- linux-2.4.2.orig/drivers/mtd/nand/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/GNUmakefile	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,26 @@
+# $Id: GNUmakefile,v 1.1 2001/04/19 23:57:02 dwmw2 Exp $
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+
+CONFIG_MTD_NAND := m
+CONFIG_MTD_NAND_ECC := m
+# CONFIG_MTD_NAND_SPIA := m
+
+endif
+
+# Normal case - build in-kernel
+
+ifeq ($(VERSION),2)
+ ifneq ($(PATCHLEVEL),4)
+  ifneq ($(PATCHLEVEL),5)
+   OLDTOPDIR := $(TOPDIR)
+   TOPDIR := $(shell pwd)/..
+  endif
+ endif
+endif
+
+include Makefile
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/Makefile linux-2.4.2/drivers/mtd/nand/Makefile
--- linux-2.4.2.orig/drivers/mtd/nand/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/Makefile	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,16 @@
+#
+# linux/drivers/nand/Makefile
+#
+# $Id: Makefile,v 1.5 2001/09/19 22:39:59 dwmw2 Exp $
+
+O_TARGET	:= nandlink.o
+
+export-objs	:= nand.o nand_ecc.o
+
+nandobjs-y			:= nand.o
+nandobjs-$(CONFIG_MTD_NAND_ECC) += nand_ecc.o
+
+obj-$(CONFIG_MTD_NAND)		+= $(nandobjs-y)
+obj-$(CONFIG_MTD_NAND_SPIA)	+= spia.o
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/nand.c linux-2.4.2/drivers/mtd/nand/nand.c
--- linux-2.4.2.orig/drivers/mtd/nand/nand.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/nand.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,1377 @@
+/*
+ *  drivers/mtd/nand.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: nand.c,v 1.13 2002/01/22 17:09:47 eclarke Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is the generic MTD driver for NAND flash devices. It should be
+ *   capable of working with almost all NAND chips currently available.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ids.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_MTD_NAND_ECC
+#include <linux/mtd/nand_ecc.h>
+#endif
+
+/*
+ * Macros for low-level register control
+ */
+#define NAND_CTRL (*(volatile unsigned char *) \
+			((struct nand_chip *) mtd->priv)->CTRL_ADDR)
+#define nand_select()	NAND_CTRL &= ~this->NCE; \
+			nand_command(mtd, NAND_CMD_RESET, -1, -1); \
+			udelay (10);
+#define nand_deselect() NAND_CTRL |= ~this->NCE;
+
+/*
+ * NAND low-level MTD interface functions
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf);
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code);
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf);
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf);
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code);
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf);
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen);
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr);
+static void nand_sync (struct mtd_info *mtd);
+
+/*
+ * Send command to NAND device
+ */
+static void nand_command (struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+	register unsigned long NAND_IO_ADDR = this->IO_ADDR;
+
+	/* Begin command latch cycle */
+	NAND_CTRL |= this->CLE;
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command != NAND_CMD_SEQIN)	
+		writeb (command, NAND_IO_ADDR);
+	else {
+		if (mtd->oobblock == 256 && column >= 256) {
+			column -= 256;
+			writeb(NAND_CMD_RESET, NAND_IO_ADDR);
+			writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+		else if (mtd->oobblock == 512 && column >= 256) {
+			if (column < 512) {
+				column -= 256;
+				writeb(NAND_CMD_READ1, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+			else {
+				column -= 512;
+				writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+		}
+		else {
+			writeb(NAND_CMD_READ0, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+	}
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_CTRL &= ~this->CLE;
+	NAND_CTRL |= this->ALE;
+
+	/* Serially input address */
+	if (column != -1)
+		writeb (column, NAND_IO_ADDR);
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+		/* One more address cycle for higher density devices */
+		if (mtd->size & 0x0c000000) {
+			writeb ((unsigned char) ((page_addr >> 16) & 0x0f),
+					NAND_IO_ADDR);
+		}
+	}
+
+	/* Latch in address */
+	NAND_CTRL &= ~this->ALE;
+
+	/* Pause for 15us */
+	udelay (15);
+}
+
+/*
+ * NAND read
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_read_ecc (mtd, from, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_read_ecc (mtd, from, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND read with ECC
+ */
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code)
+{
+	int j, col, page, state;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_result;
+	u_char ecc_calc[6];
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_ecc: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+retry:
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* First we calculate the starting page */
+	page = from >> this->page_shift;
+
+	/* Get raw starting column */
+	col = from & (mtd->oobblock - 1);
+
+	/* State machine for devices having pages larger than 256 bytes */
+	state = (col < mtd->eccsize) ? 0 : 1;
+
+	/* Calculate column address within ECC block context */
+	col = (col >= mtd->eccsize) ? (col - mtd->eccsize) : col;
+
+	/* Initialize return value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Loop until all data read */
+	while (*retlen < len) {
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, 0x00, page);
+
+		/* Read in a block big enough for ECC */
+		for (j=0 ; j < mtd->eccsize ; j++)
+			this->data_buf[j] = readb (this->IO_ADDR);
+
+		/* Read in the out-of-band data */
+		if (!state) {
+			nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+			for (j=0 ; j<3 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+		else {
+			nand_command (mtd, NAND_CMD_READOOB, 0x03, page);
+			for (j=3 ; j<6 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+
+		/* Calculate the ECC and verify it */
+		if (!state) {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[0]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[0], &ecc_calc[0]);
+		}
+		else {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[3]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[3], &ecc_calc[3]);
+		}
+		if (ecc_result == -1) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_read_ecc: " \
+				"Failed ECC read, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			if (erase_state)
+				this->state = FL_ERASING;
+			else
+				this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Read the data from ECC data buffer into return buffer */
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = this->data_buf[col++];
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = this->data_buf[j];
+#else
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, col, page);
+
+		/* Read the data directly into the return buffer */ 
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+#endif
+
+		/*
+		 * If the amount of data to be read is greater than
+		 * (256 - col), then all subsequent reads will take
+		 * place on page or half-page (in the case of 512 byte
+		 * page devices) aligned boundaries and the column
+		 * address will be zero. Setting the column address to
+		 * to zero after the first read allows us to simplify
+		 * the reading of data and the if/else statements above.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Increment page address */
+		if ((mtd->oobblock == 256) || state)
+			page++;
+
+		/* Toggle state machine */
+		if (mtd->oobblock == 512)
+			state = state ? 0 : 1;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+	
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND read out-of-band
+ */
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf)
+{
+	int i, col, page;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) from) >> this->page_shift;
+
+	/* Mask to get column */
+	col = from & 0x0f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow read past end of page */
+	if ((col + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_oob: Attempt read past end of page " \
+			"0x%08x, column %i, length %i\n", page, col, len);
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Send the read command */
+	nand_command (mtd, NAND_CMD_READOOB, col, page);	
+
+	/* Read the data */
+	for (i = 0 ; i < len ; i++)
+		buf[i] = readb (this->IO_ADDR);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write
+ */
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_write_ecc (mtd, to, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_write_ecc (mtd, to, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND write with ECC
+ */
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code)
+{
+	int i, page, col, cnt, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Do not allow write past end of page */
+	if ((to + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all data is written */
+	while (*retlen < len) {
+		/* Write data into buffer */
+		if ((col + len) >= mtd->oobblock)
+			for(i=col, cnt=0 ; i < mtd->oobblock ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		else
+			for(i=col, cnt=0 ; cnt < (len - *retlen) ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			ecc_code[i] = 0x00;
+
+		/* Calculate and write the ECC if we have enough data */
+		if ((col < mtd->eccsize) &&
+			((col + (len - *retlen)) >= mtd->eccsize)) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0], &ecc_code[0]);
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Calculate and write the second ECC if we have enough data */
+		if ((mtd->oobblock == 512) &&
+			((col + (len - *retlen)) >= mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256], &ecc_code[3]);
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+
+		/* Write pre-padding bytes into buffer */
+		for (i=0 ; i < col ; i++)
+			this->data_buf[i] = 0xff;
+
+		/* Write post-padding bytes into buffer */
+		if ((col + (len - *retlen)) < mtd->oobblock) {
+			for(i=(col + cnt) ; i < mtd->oobblock ; i++)
+				this->data_buf[i] = 0xff;
+		}
+
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_ecc: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != ecc_code[i]) &&
+					ecc_code[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+
+		/*
+		 * If we are writing a large amount of data and/or it
+		 * crosses page or half-page boundaries, we set the
+		 * the column to zero. It simplifies the program logic.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Update written bytes count */
+		*retlen += cnt;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write out-of-band
+ */
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	int i, column, page, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Mask to get column */
+	column = to & 0x1f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow write past end of page */
+	if ((column + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Write out desired data */
+	nand_command (mtd, NAND_CMD_SEQIN, column + 512, page);
+	for (i=0 ; i<len ; i++)
+		writeb (buf[i], this->IO_ADDR);
+
+	/* Send command to program the OOB data */
+	nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/*
+	 * Wait for program operation to complete. This could
+	 * take up to 3000us (3ms) on some devices, so we try
+	 * and exit as quickly as possible.
+	 */
+	status = 0;
+	for (i=0 ; i<24 ; i++) {
+		/* Delay for 125us */
+		udelay (125);
+
+		/* Check the status */
+		nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+		status = (int) readb (this->IO_ADDR);
+		if (status & 0x40)
+			break;
+	}
+
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: " \
+			"Failed write, page 0x%08x\n", page);
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	nand_command (mtd, NAND_CMD_READOOB, column, page);
+
+	/* Loop through and verify the data */
+	for (i=0 ; i<len ; i++) {
+		if (buf[i] != readb (this->IO_ADDR)) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_oob: " \
+				"Failed write verify, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+	}
+#endif
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write with iovec
+ */
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen)
+{
+	int i, page, col, cnt, len, total_len, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	/* Calculate total length of data */
+	total_len = 0;
+	for (i=0 ; i < count ; i++)
+		total_len += (int) vecs[i].iov_len;
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_writev: to = 0x%08x, len = %i\n", (unsigned int) to,
+			(unsigned int) total_len);
+
+	/* Do not allow write past end of page */
+	if ((to + total_len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all iovecs' data has been written */
+	cnt = col;
+	len = 0;
+	while (count) {
+		/* Do any need pre-fill for partial page programming */
+		for (i=0 ; i < cnt ; i++)
+			this->data_buf[i] = 0xff;
+
+		/*
+		 * Read data out of each tuple until we have a full page
+		 * to write or we've read all the tuples.
+		 */
+		while ((cnt < mtd->oobblock) && count) {
+			this->data_buf[cnt++] =
+				((u_char *) vecs->iov_base)[len++];
+			if (len >= (int) vecs->iov_len) {
+				vecs++;
+				len = 0;
+				count--;
+			}
+		}
+		
+		/* Do any need post-fill for partial page programming */
+		for (i=cnt ; i < mtd->oobblock ; i++)
+			this->data_buf[i] = 0xff;
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			this->ecc_code_buf[i] = 0x00;
+
+		/* Calculate and write the first ECC */
+		if (col >= mtd->eccsize) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0],
+				&(this->ecc_code_buf[0]));
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Calculate and write the second ECC */
+		if ((mtd->oobblock == 512) && (cnt == mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256],
+				&(this->ecc_code_buf[3]));
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_writev: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != this->ecc_code_buf[i]) &&
+					this->ecc_code_buf[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+		/* Update written bytes count */
+		*retlen += (cnt - col);
+
+		/* Reset written byte counter and column */
+		col = cnt = 0;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND erase a block
+ */
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	int i, page, len, status, pages_per_block;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_erase: start = 0x%08x, len = %i\n",
+		(unsigned int) instr->addr, (unsigned int) instr->len);
+
+	/* Start address must align on block boundary */
+	if (instr->addr & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Unaligned address\n");
+		return -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (instr->len & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Length not block aligned\n");
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((instr->len + instr->addr) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Erase past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_ERASING;
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get first page */
+	page = (int) (instr->addr >> this->page_shift);
+
+	/* Calculate pages in each block */
+	pages_per_block = mtd->erasesize / mtd->oobblock;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Device is write protected!!!\n");
+		nand_deselect ();
+		this->state = FL_READY;
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop through the pages */
+	len = instr->len;
+	while (len) {
+		/* Send commands to erase a page */
+		nand_command(mtd, NAND_CMD_ERASE1, -1, page);
+		nand_command(mtd, NAND_CMD_ERASE2, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 4000us (4ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<32 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if block erase succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_erase: " \
+				"Failed erase, page 0x%08x\n", page);
+			nand_deselect ();
+			this->state = FL_READY;
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Increment page address and decrement length */
+		len -= mtd->erasesize;
+		page += pages_per_block;
+
+		/* Release the spin lock */
+		spin_unlock_bh (&this->chip_lock);
+
+erase_retry:
+		/* Check the state and sleep if it changed */
+		spin_lock_bh (&this->chip_lock);
+		if (this->state == FL_ERASING) {
+			continue;
+		}
+		else {
+			set_current_state (TASK_UNINTERRUPTIBLE);
+			add_wait_queue (&this->wq, &wait);
+			spin_unlock_bh (&this->chip_lock);
+			schedule();
+
+			remove_wait_queue (&this->wq, &wait);
+			goto erase_retry;
+		}
+	}
+	spin_unlock_bh (&this->chip_lock);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Do call back function */
+	if (instr->callback)
+		instr->callback (instr);
+
+	/* The device is ready */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND sync
+ */
+static void nand_sync (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
+
+retry:
+	/* Grab the spinlock */
+	spin_lock_bh(&this->chip_lock);
+
+	/* See what's going on */
+	switch(this->state) {
+	case FL_READY:
+	case FL_SYNCING:
+		this->state = FL_SYNCING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		/* Not an idle state */
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule ();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	}
+
+        /* Lock the device */
+	spin_lock_bh (&this->chip_lock);
+
+	/* Set the device to be ready again */
+	if (this->state == FL_SYNCING) {
+		this->state = FL_READY;
+		wake_up (&this->wq);
+	}
+
+        /* Unlock the device */
+	spin_unlock_bh (&this->chip_lock);
+}
+
+/*
+ * Scan for the NAND device
+ */
+int nand_scan (struct mtd_info *mtd)
+{
+	int i, nand_maf_id, nand_dev_id;
+	struct nand_chip *this = mtd->priv;
+
+	/* Select the device */
+	nand_select ();
+
+	/* Send the command for reading device ID */
+	nand_command (mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	nand_maf_id = readb (this->IO_ADDR);
+	nand_dev_id = readb (this->IO_ADDR);
+
+	/* Print and store flash device information */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (nand_maf_id == nand_flash_ids[i].manufacture_id &&
+		    nand_dev_id == nand_flash_ids[i].model_id) {
+			if (!mtd->size) {
+				mtd->name = nand_flash_ids[i].name;
+				mtd->erasesize = nand_flash_ids[i].erasesize;
+				mtd->size = (1 << nand_flash_ids[i].chipshift);
+				mtd->eccsize = 256;
+				if (nand_flash_ids[i].page256) {
+					mtd->oobblock = 256;
+					mtd->oobsize = 8;
+					this->page_shift = 8;
+				}
+				else {
+					mtd->oobblock = 512;
+					mtd->oobsize = 16;
+					this->page_shift = 9;
+				}
+			}
+			printk (KERN_INFO "NAND device: Manufacture ID:" \
+				" 0x%02x, Chip ID: 0x%02x (%s)\n",
+			       nand_maf_id, nand_dev_id, mtd->name);
+			break;
+		}
+	}
+
+	/* Initialize state and spinlock */
+	this->state = FL_READY;
+	spin_lock_init(&this->chip_lock);
+
+	/* Initialize the wait queue */
+    init_waitqueue_head(&this->wq);
+
+	/* De-select the device */
+	nand_deselect ();
+
+	/* Print warning message for no device */
+	if (!mtd->size) {
+		printk (KERN_WARNING "No NAND device found!!!\n");
+		return 1;
+	}
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
+	mtd->module = THIS_MODULE;
+	mtd->ecctype = MTD_ECC_SW;
+	mtd->erase = nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = nand_read;
+	mtd->write = nand_write;
+	mtd->read_ecc = nand_read_ecc;
+	mtd->write_ecc = nand_write_ecc;
+	mtd->read_oob = nand_read_oob;
+	mtd->write_oob = nand_write_oob;
+	mtd->readv = NULL;
+	mtd->writev = nand_writev;
+	mtd->sync = nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = NULL;
+	mtd->resume = NULL;
+
+	/* Return happy */
+	return 0;
+}
+
+EXPORT_SYMBOL(nand_scan);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steven J. Hill <sjhill@cotw.com");
+MODULE_DESCRIPTION("Generic NAND flash driver code");
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/nand_ecc.c linux-2.4.2/drivers/mtd/nand/nand_ecc.c
--- linux-2.4.2.orig/drivers/mtd/nand/nand_ecc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/nand_ecc.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,209 @@
+/*
+ *  drivers/mtd/nand_ecc.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *                     Toshiba America Electronics Components, Inc.
+ *
+ * $Id: nand_ecc.c,v 1.6 2001/06/28 10:52:26 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains an ECC algorithm from Toshiba that detects and
+ * corrects 1 bit errors in a 256 byte block of data.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/*
+ * Pre-calculated 256-way 1 byte column parity
+ */
+static const u_char nand_ecc_precalc_table[] = {
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
+};
+
+
+/*
+ * Creates non-inverted ECC code from line parity
+ */
+static void nand_trans_result(u_char reg2, u_char reg3,
+	u_char *ecc_code)
+{
+	u_char a, b, i, tmp1, tmp2;
+	
+	/* Initialize variables */
+	a = b = 0x80;
+	tmp1 = tmp2 = 0;
+	
+	/* Calculate first ECC byte */
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Calculate second ECC byte */
+	b = 0x80;
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Store two of the ECC bytes */
+	ecc_code[0] = tmp1;
+	ecc_code[1] = tmp2;
+}
+
+/*
+ * Calculate 3 byte ECC code for 256 byte block
+ */
+void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
+{
+	u_char idx, reg1, reg2, reg3;
+	int j;
+	
+	/* Initialize variables */
+	reg1 = reg2 = reg3 = 0;
+	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
+	
+	/* Build up column parity */ 
+	for(j = 0; j < 256; j++) {
+		
+		/* Get CP0 - CP5 from table */
+		idx = nand_ecc_precalc_table[dat[j]];
+		reg1 ^= (idx & 0x3f);
+		
+		/* All bit XOR = 1 ? */
+		if (idx & 0x40) {
+			reg3 ^= (u_char) j;
+			reg2 ^= ~((u_char) j);
+		}
+	}
+	
+	/* Create non-inverted ECC code from line parity */
+	nand_trans_result(reg2, reg3, ecc_code);
+	
+	/* Calculate final ECC code */
+	ecc_code[0] = ~ecc_code[0];
+	ecc_code[1] = ~ecc_code[1];
+	ecc_code[2] = ((~reg1) << 2) | 0x03;
+}
+
+/*
+ * Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	u_char a, b, c, d1, d2, d3, add, bit, i;
+	
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+	
+	if ((d1 | d2 | d3) == 0) {
+		/* No errors */
+		return 0;
+	}
+	else {
+		a = (d1 ^ (d1 >> 1)) & 0x55;
+		b = (d2 ^ (d2 >> 1)) & 0x55;
+		c = (d3 ^ (d3 >> 1)) & 0x54;
+		
+		/* Found and will correct single bit error in the data */
+		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
+			c = 0x80;
+			add = 0;
+			a = 0x80;
+			for (i=0; i<4; i++) {
+				if (d1 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			c = 0x80;
+			for (i=0; i<4; i++) {
+				if (d2 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			bit = 0;
+			b = 0x04;
+			c = 0x80;
+			for (i=0; i<3; i++) {
+				if (d3 & c)
+					bit |= b;
+				c >>= 2;
+				b >>= 1;
+			}
+			b = 0x01;
+			a = dat[add];
+			a ^= (b << bit);
+			dat[add] = a;
+			return 1;
+		}
+		else {
+			i = 0;
+			while (d1) {
+				if (d1 & 0x01)
+					++i;
+				d1 >>= 1;
+			}
+			while (d2) {
+				if (d2 & 0x01)
+					++i;
+				d2 >>= 1;
+			}
+			while (d3) {
+				if (d3 & 0x01)
+					++i;
+				d3 >>= 1;
+			}
+			if (i == 1) {
+				/* ECC Code Error Correction */
+				read_ecc[0] = calc_ecc[0];
+				read_ecc[1] = calc_ecc[1];
+				read_ecc[2] = calc_ecc[2];
+				return 2;
+			}
+			else {
+				/* Uncorrectable Error */
+				return -1;
+			}
+		}
+	}
+	
+	/* Should never happen */
+	return -1;
+}
+
+EXPORT_SYMBOL(nand_calculate_ecc);
+EXPORT_SYMBOL(nand_correct_data);
diff -Naur linux-2.4.2.orig/drivers/mtd/nand/spia.c linux-2.4.2/drivers/mtd/nand/spia.c
--- linux-2.4.2.orig/drivers/mtd/nand/spia.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand/spia.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,160 @@
+/*
+ *  drivers/mtd/nand/spia.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: spia.c,v 1.12 2001/10/02 15:05:14 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   SPIA board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 64Mibit (8MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+/*
+ * MTD structure for SPIA board
+ */
+static struct mtd_info *spia_mtd = NULL;
+
+/*
+ * Values specific to the SPIA board (used with EP7212 processor)
+ */
+#define SPIA_IO_ADDR	= 0xd0000000	/* Start of EP7212 IO address space */
+#define SPIA_FIO_ADDR	= 0xf0000000	/* Address where flash is mapped */
+#define SPIA_PEDR	= 0x0080	/*
+					 * IO offset to Port E data register
+					 * where the CLE, ALE and NCE pins
+					 * are wired to.
+					 */
+#define SPIA_PEDDR	= 0x00c0	/*
+					 * IO offset to Port E data direction
+					 * register so we can control the IO
+					 * lines.
+					 */
+
+/*
+ * Module stuff
+ */
+
+static int spia_io_base = SPIA_IO_BASE;
+static int spia_fio_base = SPIA_FIO_BASE;
+static int spia_pedr = SPIA_PEDR;
+static int spia_peddr = SPIA_PEDDR;
+
+MODULE_PARM(spia_io_base, "i");
+MODULE_PARM(spia_fio_base, "i");
+MODULE_PARM(spia_pedr, "i");
+MODULE_PARM(spia_peddr, "i");
+
+__setup("spia_io_base=",spia_io_base);
+__setup("spia_fio_base=",spia_fio_base);
+__setup("spia_pedr=",spia_pedr);
+__setup("spia_peddr=",spia_peddr);
+
+/*
+ * Define partitions for flash device
+ */
+const static struct mtd_partition partition_info[] = {
+	{ name: "SPIA flash partition 1",
+	  offset: 0,
+	  size: 2*1024*1024 },
+	{ name: "SPIA flash partition 2",
+	  offset: 2*1024*1024,
+	  size: 6*1024*1024 }
+};
+#define NUM_PARTITIONS 2
+
+/*
+ * Main initialization routine
+ */
+int __init spia_init (void)
+{
+	struct nand_chip *this;
+
+	/* Allocate memory for MTD device structure and private data */
+	spia_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+	if (!spia_mtd) {
+		printk ("Unable to allocate SPIA NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&spia_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) spia_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	spia_mtd->priv = this;
+
+	/*
+	 * Set GPIO Port E control register so that the pins are configured
+	 * to be outputs for controlling the NAND flash.
+	 */
+	(*(volatile unsigned char *) (spia_io_base + spia_peddr)) = 0x07;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR = spia_fio_base;
+	this->CTRL_ADDR = spia_io_base + spia_pedr;
+	this->CLE = 0x01;
+	this->ALE = 0x02;
+	this->NCE = 0x04;
+
+	/* Scan to find existance of the device */
+	if (nand_scan (spia_mtd)) {
+		kfree (spia_mtd);
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+	this->data_buf = kmalloc (sizeof(u_char) * (spia_mtd->oobblock + spia_mtd->oobsize), GFP_KERNEL);
+	if (!this->data_buf) {
+		printk ("Unable to allocate NAND data buffer for SPIA.\n");
+		kfree (spia_mtd);
+		return -ENOMEM;
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(spia_mtd, partition_info, NUM_PARTITIONS);
+
+	/* Return happy */
+	return 0;
+}
+module_init(spia_init);
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit spia_cleanup (void)
+{
+	struct nand_chip *this = (struct nand_chip *) &spia_mtd[1];
+
+	/* Unregister the device */
+	del_mtd_device (spia_mtd);
+
+	/* Free internal data buffer */
+	kfree (this->data_buf);
+
+	/* Free the MTD device structure */
+	kfree (spia_mtd);
+}
+module_exit(spia_cleanup);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steven J. Hill <sjhill@cotw.com");
+MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on SPIA board");
diff -Naur linux-2.4.2.orig/drivers/mtd/nand.c linux-2.4.2/drivers/mtd/nand.c
--- linux-2.4.2.orig/drivers/mtd/nand.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,1369 @@
+/*
+ *  drivers/mtd/nand.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: nand.c,v 1.10 2001/03/20 07:26:01 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is the generic MTD driver for NAND flash devices. It should be
+ *   capable of working with almost all NAND chips currently available.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ids.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_MTD_NAND_ECC
+#include <linux/mtd/nand_ecc.h>
+#endif
+
+/*
+ * Macros for low-level register control
+ */
+#define NAND_CTRL (*(volatile unsigned char *) \
+			((struct nand_chip *) mtd->priv)->CTRL_ADDR)
+#define nand_select()	NAND_CTRL &= ~this->NCE; \
+			nand_command(mtd, NAND_CMD_RESET, -1, -1); \
+			udelay (10);
+#define nand_deselect() NAND_CTRL |= ~this->NCE;
+
+/*
+ * NAND low-level MTD interface functions
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf);
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code);
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf);
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf);
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code);
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf);
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen);
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr);
+static void nand_sync (struct mtd_info *mtd);
+
+/*
+ * Send command to NAND device
+ */
+static void nand_command (struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+	register unsigned long NAND_IO_ADDR = this->IO_ADDR;
+
+	/* Begin command latch cycle */
+	NAND_CTRL |= this->CLE;
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command != NAND_CMD_SEQIN)	
+		writeb (command, NAND_IO_ADDR);
+	else {
+		if (mtd->oobblock == 256 && column >= 256) {
+			column -= 256;
+			writeb(NAND_CMD_RESET, NAND_IO_ADDR);
+			writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+		else if (mtd->oobblock == 512 && column >= 256) {
+			if (column < 512) {
+				column -= 256;
+				writeb(NAND_CMD_READ1, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+			else {
+				column -= 512;
+				writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+		}
+		else {
+			writeb(NAND_CMD_READ0, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+	}
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_CTRL &= ~this->CLE;
+	NAND_CTRL |= this->ALE;
+
+	/* Serially input address */
+	if (column != -1)
+		writeb (column, NAND_IO_ADDR);
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+		/* One more address cycle for higher density devices */
+		if (mtd->size & 0x0c000000) {
+			writeb ((unsigned char) ((page_addr >> 16) & 0x0f),
+					NAND_IO_ADDR);
+		}
+	}
+
+	/* Latch in address */
+	NAND_CTRL &= ~this->ALE;
+
+	/* Pause for 15us */
+	udelay (15);
+}
+
+/*
+ * NAND read
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_read_ecc (mtd, from, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_read_ecc (mtd, from, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND read with ECC
+ */
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code)
+{
+	int j, col, page, state;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_result;
+	u_char ecc_calc[6];
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_ecc: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+retry:
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* First we calculate the starting page */
+	page = from >> this->page_shift;
+
+	/* Get raw starting column */
+	col = from & (mtd->oobblock - 1);
+
+	/* State machine for devices having pages larger than 256 bytes */
+	state = (col < mtd->eccsize) ? 0 : 1;
+
+	/* Calculate column address within ECC block context */
+	col = (col >= mtd->eccsize) ? (col - mtd->eccsize) : col;
+
+	/* Initialize return value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Loop until all data read */
+	while (*retlen < len) {
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, 0x00, page);
+
+		/* Read in a block big enough for ECC */
+		for (j=0 ; j < mtd->eccsize ; j++)
+			this->data_buf[j] = readb (this->IO_ADDR);
+
+		/* Read in the out-of-band data */
+		if (!state) {
+			nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+			for (j=0 ; j<3 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+		else {
+			nand_command (mtd, NAND_CMD_READOOB, 0x03, page);
+			for (j=3 ; j<6 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+
+		/* Calculate the ECC and verify it */
+		if (!state) {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[0]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[0], &ecc_calc[0]);
+		}
+		else {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[3]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[3], &ecc_calc[3]);
+		}
+		if (ecc_result == -1) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_read_ecc: " \
+				"Failed ECC read, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			if (erase_state)
+				this->state = FL_ERASING;
+			else
+				this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Read the data from ECC data buffer into return buffer */
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = this->data_buf[col++];
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = this->data_buf[j];
+#else
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, col, page);
+
+		/* Read the data directly into the return buffer */ 
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+#endif
+
+		/*
+		 * If the amount of data to be read is greater than
+		 * (256 - col), then all subsequent reads will take
+		 * place on page or half-page (in the case of 512 byte
+		 * page devices) aligned boundaries and the column
+		 * address will be zero. Setting the column address to
+		 * to zero after the first read allows us to simplify
+		 * the reading of data and the if/else statements above.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Increment page address */
+		if ((mtd->oobblock == 256) || state)
+			page++;
+
+		/* Toggle state machine */
+		if (mtd->oobblock == 512)
+			state = state ? 0 : 1;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+	
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND read out-of-band
+ */
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf)
+{
+	int i, col, page;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) from) >> this->page_shift;
+
+	/* Mask to get column */
+	col = from & 0x0f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow read past end of page */
+	if ((col + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_oob: Attempt read past end of page " \
+			"0x%08x, column %i, length %i\n", page, col, len);
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Send the read command */
+	nand_command (mtd, NAND_CMD_READOOB, col, page);	
+
+	/* Read the data */
+	for (i = 0 ; i < len ; i++)
+		buf[i] = readb (this->IO_ADDR);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write
+ */
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_write_ecc (mtd, to, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_write_ecc (mtd, to, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND write with ECC
+ */
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code)
+{
+	int i, page, col, cnt, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Do not allow write past end of page */
+	if ((to + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all data is written */
+	while (*retlen < len) {
+		/* Write data into buffer */
+		if ((col + len) >= mtd->oobblock)
+			for(i=col, cnt=0 ; i < mtd->oobblock ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		else
+			for(i=col, cnt=0 ; cnt < (len - *retlen) ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			ecc_code[i] = 0x00;
+
+		/* Calculate and write the ECC if we have enough data */
+		if ((col < mtd->eccsize) &&
+			((col + (len - *retlen)) >= mtd->eccsize)) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0], &ecc_code[0]);
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Calculate and write the second ECC if we have enough data */
+		if ((mtd->oobblock == 512) &&
+			((col + (len - *retlen)) >= mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256], &ecc_code[3]);
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+
+		/* Write pre-padding bytes into buffer */
+		for (i=0 ; i < col ; i++)
+			this->data_buf[i] = 0xff;
+
+		/* Write post-padding bytes into buffer */
+		if ((col + (len - *retlen)) < mtd->oobblock) {
+			for(i=(col + cnt) ; i < mtd->oobblock ; i++)
+				this->data_buf[i] = 0xff;
+		}
+
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_ecc: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != ecc_code[i]) &&
+					ecc_code[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+
+		/*
+		 * If we are writing a large amount of data and/or it
+		 * crosses page or half-page boundaries, we set the
+		 * the column to zero. It simplifies the program logic.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Update written bytes count */
+		*retlen += cnt;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write out-of-band
+ */
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	int i, column, page, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Mask to get column */
+	column = to & 0x1f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow write past end of page */
+	if ((column + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Write out desired data */
+	nand_command (mtd, NAND_CMD_SEQIN, column + 512, page);
+	for (i=0 ; i<len ; i++)
+		writeb (buf[i], this->IO_ADDR);
+
+	/* Send command to program the OOB data */
+	nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/*
+	 * Wait for program operation to complete. This could
+	 * take up to 3000us (3ms) on some devices, so we try
+	 * and exit as quickly as possible.
+	 */
+	status = 0;
+	for (i=0 ; i<24 ; i++) {
+		/* Delay for 125us */
+		udelay (125);
+
+		/* Check the status */
+		nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+		status = (int) readb (this->IO_ADDR);
+		if (status & 0x40)
+			break;
+	}
+
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: " \
+			"Failed write, page 0x%08x\n", page);
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	nand_command (mtd, NAND_CMD_READOOB, column, page);
+
+	/* Loop through and verify the data */
+	for (i=0 ; i<len ; i++) {
+		if (buf[i] != readb (this->IO_ADDR)) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_oob: " \
+				"Failed write verify, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+	}
+#endif
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write with iovec
+ */
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen)
+{
+	int i, page, col, cnt, len, total_len, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	/* Calculate total length of data */
+	total_len = 0;
+	for (i=0 ; i < count ; i++)
+		total_len += (int) vecs[i].iov_len;
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_writev: to = 0x%08x, len = %i\n", (unsigned int) to,
+			(unsigned int) total_len);
+
+	/* Do not allow write past end of page */
+	if ((to + total_len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all iovecs' data has been written */
+	cnt = col;
+	len = 0;
+	while (count) {
+		/* Do any need pre-fill for partial page programming */
+		for (i=0 ; i < cnt ; i++)
+			this->data_buf[i] = 0xff;
+
+		/*
+		 * Read data out of each tuple until we have a full page
+		 * to write or we've read all the tuples.
+		 */
+		while ((cnt < mtd->oobblock) && count) {
+			this->data_buf[cnt++] =
+				((u_char *) vecs->iov_base)[len++];
+			if (len >= (int) vecs->iov_len) {
+				vecs++;
+				len = 0;
+				count--;
+			}
+		}
+		
+		/* Do any need post-fill for partial page programming */
+		for (i=cnt ; i < mtd->oobblock ; i++)
+			this->data_buf[i] = 0xff;
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			this->ecc_code_buf[i] = 0x00;
+
+		/* Calculate and write the first ECC */
+		if (col >= mtd->eccsize) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0],
+				&(this->ecc_code_buf[0]));
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Calculate and write the second ECC */
+		if ((mtd->oobblock == 512) && (cnt == mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256],
+				&(this->ecc_code_buf[3]));
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_writev: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != this->ecc_code_buf[i]) &&
+					this->ecc_code_buf[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+		/* Update written bytes count */
+		*retlen += (cnt - col);
+
+		/* Reset written byte counter and column */
+		col = cnt = 0;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND erase a block
+ */
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	int i, page, len, status, pages_per_block;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_erase: start = 0x%08x, len = %i\n",
+		(unsigned int) instr->addr, (unsigned int) instr->len);
+
+	/* Start address must align on block boundary */
+	if (instr->addr & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Unaligned address\n");
+		return -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (instr->len & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Length not block aligned\n");
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((instr->len + instr->addr) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Erase past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_ERASING;
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get first page */
+	page = (int) (instr->addr >> this->page_shift);
+
+	/* Calculate pages in each block */
+	pages_per_block = mtd->erasesize / mtd->oobblock;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Device is write protected!!!\n");
+		nand_deselect ();
+		this->state = FL_READY;
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop through the pages */
+	len = instr->len;
+	while (len) {
+		/* Send commands to erase a page */
+		nand_command(mtd, NAND_CMD_ERASE1, -1, page);
+		nand_command(mtd, NAND_CMD_ERASE2, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 4000us (4ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<32 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if block erase succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_erase: " \
+				"Failed erase, page 0x%08x\n", page);
+			nand_deselect ();
+			this->state = FL_READY;
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Increment page address and decrement length */
+		len -= mtd->erasesize;
+		page += pages_per_block;
+
+		/* Release the spin lock */
+		spin_unlock_bh (&this->chip_lock);
+
+erase_retry:
+		/* Check the state and sleep if it changed */
+		spin_lock_bh (&this->chip_lock);
+		if (this->state == FL_ERASING) {
+			continue;
+		}
+		else {
+			set_current_state (TASK_UNINTERRUPTIBLE);
+			add_wait_queue (&this->wq, &wait);
+			spin_unlock_bh (&this->chip_lock);
+			schedule();
+
+			remove_wait_queue (&this->wq, &wait);
+			goto erase_retry;
+		}
+	}
+	spin_unlock_bh (&this->chip_lock);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Do call back function */
+	if (instr->callback)
+		instr->callback (instr);
+
+	/* The device is ready */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND sync
+ */
+static void nand_sync (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
+
+retry:
+	/* Grab the spinlock */
+	spin_lock_bh(&this->chip_lock);
+
+	/* See what's going on */
+	switch(this->state) {
+	case FL_READY:
+	case FL_SYNCING:
+		this->state = FL_SYNCING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		/* Not an idle state */
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule ();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	}
+
+        /* Lock the device */
+	spin_lock_bh (&this->chip_lock);
+
+	/* Set the device to be ready again */
+	if (this->state == FL_SYNCING) {
+		this->state = FL_READY;
+		wake_up (&this->wq);
+	}
+
+        /* Unlock the device */
+	spin_unlock_bh (&this->chip_lock);
+}
+
+/*
+ * Scan for the NAND device
+ */
+int nand_scan (struct mtd_info *mtd)
+{
+	int i, nand_maf_id, nand_dev_id;
+	struct nand_chip *this = mtd->priv;
+
+	/* Select the device */
+	nand_select ();
+
+	/* Send the command for reading device ID */
+	nand_command (mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	nand_maf_id = readb (this->IO_ADDR);
+	nand_dev_id = readb (this->IO_ADDR);
+
+	/* Print and store flash device information */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (nand_maf_id == nand_flash_ids[i].manufacture_id &&
+		    nand_dev_id == nand_flash_ids[i].model_id) {
+			if (!mtd->size) {
+				mtd->name = nand_flash_ids[i].name;
+				mtd->erasesize = nand_flash_ids[i].erasesize;
+				mtd->size = (1 << nand_flash_ids[i].chipshift);
+				mtd->eccsize = 256;
+				if (nand_flash_ids[i].page256) {
+					mtd->oobblock = 256;
+					mtd->oobsize = 8;
+					this->page_shift = 8;
+				}
+				else {
+					mtd->oobblock = 512;
+					mtd->oobsize = 16;
+					this->page_shift = 9;
+				}
+			}
+			printk (KERN_INFO "NAND device: Manufacture ID:" \
+				" 0x%02x, Chip ID: 0x%02x (%s)\n",
+			       nand_maf_id, nand_dev_id, mtd->name);
+			break;
+		}
+	}
+
+	/* Initialize state and spinlock */
+	this->state = FL_READY;
+	spin_lock_init(&this->chip_lock);
+
+	/* De-select the device */
+	nand_deselect ();
+
+	/* Print warning message for no device */
+	if (!mtd->size) {
+		printk (KERN_WARNING "No NAND device found!!!\n");
+		return 1;
+	}
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
+	mtd->module = THIS_MODULE;
+	mtd->ecctype = MTD_ECC_SW;
+	mtd->erase = nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = nand_read;
+	mtd->write = nand_write;
+	mtd->read_ecc = nand_read_ecc;
+	mtd->write_ecc = nand_write_ecc;
+	mtd->read_oob = nand_read_oob;
+	mtd->write_oob = nand_write_oob;
+	mtd->readv = NULL;
+	mtd->writev = nand_writev;
+	mtd->sync = nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = NULL;
+	mtd->resume = NULL;
+
+	/* Return happy */
+	return 0;
+}
+
+EXPORT_SYMBOL(nand_scan);
diff -Naur linux-2.4.2.orig/drivers/mtd/nand_ecc.c linux-2.4.2/drivers/mtd/nand_ecc.c
--- linux-2.4.2.orig/drivers/mtd/nand_ecc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand_ecc.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,204 @@
+/*
+ *  drivers/mtd/nand_ecc.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *                     Toshiba America Electronics Components, Inc.
+ *
+ * $Id: nand_ecc.c,v 1.4 2001/01/03 20:02:20 mgadbois Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains an ECC algorithm from Toshiba that detects and
+ * corrects 1 bit errors in a 256 byte block of data.
+ */
+
+#include <linux/types.h>
+
+/*
+ * Pre-calculated 256-way 1 byte column parity
+ */
+const u_char nand_ecc_precalc_table[] = {
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
+};
+
+
+/*
+ * Creates non-inverted ECC code from line parity
+ */
+void nand_trans_result(u_char reg2, u_char reg3,
+	u_char *ecc_code)
+{
+	u_char a, b, i, tmp1, tmp2;
+	
+	/* Initialize variables */
+	a = b = 0x80;
+	tmp1 = tmp2 = 0;
+	
+	/* Calculate first ECC byte */
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Calculate second ECC byte */
+	b = 0x80;
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Store two of the ECC bytes */
+	ecc_code[0] = tmp1;
+	ecc_code[1] = tmp2;
+}
+
+/*
+ * Calculate 3 byte ECC code for 256 byte block
+ */
+void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
+{
+	u_char idx, reg1, reg2, reg3;
+	int j;
+	
+	/* Initialize variables */
+	reg1 = reg2 = reg3 = 0;
+	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
+	
+	/* Build up column parity */ 
+	for(j = 0; j < 256; j++) {
+		
+		/* Get CP0 - CP5 from table */
+		idx = nand_ecc_precalc_table[dat[j]];
+		reg1 ^= (idx & 0x3f);
+		
+		/* All bit XOR = 1 ? */
+		if (idx & 0x40) {
+			reg3 ^= (u_char) j;
+			reg2 ^= ~((u_char) j);
+		}
+	}
+	
+	/* Create non-inverted ECC code from line parity */
+	nand_trans_result(reg2, reg3, ecc_code);
+	
+	/* Calculate final ECC code */
+	ecc_code[0] = ~ecc_code[0];
+	ecc_code[1] = ~ecc_code[1];
+	ecc_code[2] = ((~reg1) << 2) | 0x03;
+}
+
+/*
+ * Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	u_char a, b, c, d1, d2, d3, add, bit, i;
+	
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+	
+	if ((d1 | d2 | d3) == 0) {
+		/* No errors */
+		return 0;
+	}
+	else {
+		a = (d1 ^ (d1 >> 1)) & 0x55;
+		b = (d2 ^ (d2 >> 1)) & 0x55;
+		c = (d3 ^ (d3 >> 1)) & 0x54;
+		
+		/* Found and will correct single bit error in the data */
+		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
+			c = 0x80;
+			add = 0;
+			a = 0x80;
+			for (i=0; i<4; i++) {
+				if (d1 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			c = 0x80;
+			for (i=0; i<4; i++) {
+				if (d2 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			bit = 0;
+			b = 0x04;
+			c = 0x80;
+			for (i=0; i<3; i++) {
+				if (d3 & c)
+					bit |= b;
+				c >>= 2;
+				b >>= 1;
+			}
+			b = 0x01;
+			a = dat[add];
+			a ^= (b << bit);
+			dat[add] = a;
+			return 1;
+		}
+		else {
+			i = 0;
+			while (d1) {
+				if (d1 & 0x01)
+					++i;
+				d1 >>= 1;
+			}
+			while (d2) {
+				if (d2 & 0x01)
+					++i;
+				d2 >>= 1;
+			}
+			while (d3) {
+				if (d3 & 0x01)
+					++i;
+				d3 >>= 1;
+			}
+			if (i == 1) {
+				/* ECC Code Error Correction */
+				read_ecc[0] = calc_ecc[0];
+				read_ecc[1] = calc_ecc[1];
+				read_ecc[2] = calc_ecc[2];
+				return 2;
+			}
+			else {
+				/* Uncorrectable Error */
+				return -1;
+			}
+		}
+	}
+	
+	/* Should never happen */
+	return -1;
+}
diff -Naur linux-2.4.2.orig/drivers/mtd/nftl.c linux-2.4.2/drivers/mtd/nftl.c
--- linux-2.4.2.orig/drivers/mtd/nftl.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/nftl.c	Fri Feb 15 14:41:16 2002
@@ -1,56 +1,13 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $ */
+/* $Id: nftl.c,v 1.68 2001/03/26 15:44:47 dwmw2 Exp $ */
 
 /*
   The contents of this file are distributed under the GNU General
-  Public License version 2 ("GPL"). The author places no additional
-  restrictions of any kind on it. However, local legislation in some
-  countries may restrict the use of the algorithms implemented by this
-  code in certain circumstances.
-
-  The legal note below refers only to the _use_ of the code in the 
-  affected jurisdictions, and does not in any way affect the copying,
-  distribution and modification of this code, which are permitted, and
-  indeed required, under the terms of the GPL.
-
-  Section 0 of the GPL says:
- "Activities other than copying, distribution and modification are not
-  covered by this License; they are outside its scope."
-
-  You may copy, distribute and modify this code to your hearts'
-  content - it's just that in some jurisdictions, you may only _use_
-  it under the terms of the patent grant below. This puts it in a
-  similar situation to the ISDN code, which you may need telco
-  approval to use, and indeed any code which has uses that may be
-  restricted in law. For example, certain malicious uses of the
-  networking stack may be illegal, but that doesn't prevent the
-  networking code from being under GPL.
-
-  In fact the ISDN case is worse than this, because modification of
-  the code automatically invalidates its approval. Modification,
-  unlike usage, _is_ one of the rights which is protected by the
-  GPL. Happily, the law in those places where approval is required
-  doesn't actually prevent you from modifying the code - it's just
-  that you may not be allowed to _use_ it once you've done so - and
-  because usage isn't addressed by the GPL, that's just fine.
-
-  dwmw2@infradead.org
-  30/10/0
-
-  LEGAL NOTE: The NFTL format is patented by M-Systems.  They have
-  granted a licence for its use with their DiskOnChip products:
-
-    "M-Systems grants a royalty-free, non-exclusive license under
-    any presently existing M-Systems intellectual property rights
-    necessary for the design and development of NFTL-compatible
-    drivers, file systems and utilities to use the data formats with, 
-    and solely to support, M-Systems' DiskOnChip products"
-
-  A signed copy of this agreement from M-Systems is kept on file by
-  Red Hat UK Limited. In the unlikely event that you need access to it,
-  please contact dwmw2@redhat.com for assistance.  */
+  Public License version 2. The author places no additional
+  restrictions of any kind on it.
+ */
 
 #define PRERELEASE
 
@@ -63,10 +20,11 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/blkpg.h>
+
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
@@ -109,8 +67,8 @@
 static struct gendisk nftl_gendisk = {
         MAJOR_NR,     /* Major number */      
         "nftl",          /* Major name */
-        4,              /* Bits to shift to get real from partition */
-        15,             /* Number of partitions per real */
+        NFTL_PARTN_BITS, /* Bits to shift to get real from partition */
+        (1<<NFTL_PARTN_BITS)-1, /* Number of partitions per real */
 #if LINUX_VERSION_CODE < 0x20328
         MAX_NFTLS,      /* maximum number of real */
         dummy_init,     /* init function */
@@ -209,7 +167,7 @@
 #if LINUX_VERSION_CODE < 0x20328
 	resetup_one_dev(&nftl_gendisk, firstfree);
 #else
-	grok_partitions(&nftl_gendisk, firstfree, 1<<4, nftl->nr_sects);
+	grok_partitions(&nftl_gendisk, firstfree, 1<<NFTL_PARTN_BITS, nftl->nr_sects);
 #endif
 }
 
@@ -654,7 +612,17 @@
 			
 			//printk("Write to VirtualUnitChain %d, calling makefreeblock()\n", thisVUC);
 			writeEUN = NFTL_makefreeblock(nftl, 0xffff);
-			
+
+			if (writeEUN == BLOCK_NIL) {
+				/* OK, we accept that the above comment is 
+				   lying - there may have been free blocks
+				   last time we called NFTL_findfreeblock(),
+				   but they are reserved for when we're
+				   desperate. Well, now we're desperate.
+				*/
+				DEBUG(MTD_DEBUG_LEVEL1, "Using desperate==1 to find free EUN to accommodate write to VUC %d\n", thisVUC);
+				writeEUN = NFTL_findfreeblock(nftl, 1);
+			}
 			if (writeEUN == BLOCK_NIL) {
 				/* Ouch. This should never happen - we should
 				   always be able to make some room somehow. 
@@ -806,8 +774,9 @@
 static int nftl_ioctl(struct inode * inode, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct NFTLrecord *nftl;
+	int p;
 
-	nftl = NFTLs[MINOR(inode->i_rdev) / 16];
+	nftl = NFTLs[MINOR(inode->i_rdev) >> NFTL_PARTN_BITS];
 
 	if (!nftl) return -EINVAL;
 
@@ -837,11 +806,34 @@
 	case BLKRRPART:
 		if (!capable(CAP_SYS_ADMIN)) return -EACCES;
 		if (nftl->usecount > 1) return -EBUSY;
+		/* 
+		 * We have to flush all buffers and invalidate caches,
+		 * or we won't be able to re-use the partitions,
+		 * if there was a change and we don't want to reboot
+		 */
+		p = (1<<NFTL_PARTN_BITS) - 1;
+		while (p-- > 0) {
+			kdev_t devp = MKDEV(MAJOR(inode->i_dev), MINOR(inode->i_dev)+p);
+			if (part_table[p].nr_sects > 0) {
+#if LINUX_VERSION_CODE > 0x20200
+				struct super_block * sb = get_super(devp);
+#endif
+				fsync_dev(devp);
+#if LINUX_VERSION_CODE > 0x20200
+				if (sb)
+					invalidate_inodes(sb);
+#endif
+				invalidate_buffers (devp);
+			}
+			part_table[MINOR(inode->i_dev)+p].start_sect = 0;
+			part_table[MINOR(inode->i_dev)+p].nr_sects = 0;
+		}
+		
 #if LINUX_VERSION_CODE < 0x20328
-		resetup_one_dev(&nftl_gendisk, MINOR(inode->i_rdev) / 16);
+		resetup_one_dev(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS);
 #else
-		grok_partitions(&nftl_gendisk, MINOR(inode->i_rdev) / 16,
-				1<<4, nftl->nr_sects);
+		grok_partitions(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS,
+				1<<NFTL_PARTN_BITS, nftl->nr_sects);
 #endif
 		return 0;
 
@@ -886,7 +878,7 @@
 		buffer = req->buffer;
 		res = 1; /* succeed */
 
-		if (dev >= MAX_NFTLS * 16) {
+		if (dev >= MAX_NFTLS * (1<<NFTL_PARTN_BITS)) {
 			/* there is no such partition */
 			printk("nftl: bad minor number: device = %s\n",
 			       kdevname(req->rq_dev));
@@ -894,7 +886,7 @@
 			goto repeat;
 		}
 		
-		nftl = NFTLs[dev / 16];
+		nftl = NFTLs[dev / (1<<NFTL_PARTN_BITS)];
 		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
 		down(&nftl->mutex);
 		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
@@ -962,7 +954,7 @@
 
 static int nftl_open(struct inode *ip, struct file *fp)
 {
-	int nftlnum = MINOR(ip->i_rdev) / 16;
+	int nftlnum = MINOR(ip->i_rdev) >> NFTL_PARTN_BITS;
 	struct NFTLrecord *thisNFTL;
 	thisNFTL = NFTLs[nftlnum];
 
@@ -1052,14 +1044,14 @@
 static struct mtd_notifier nftl_notifier = {NFTL_notify_add, NFTL_notify_remove, NULL};
 
 /* static int __init init_nftl(void) */
-int __init init_nftl(void)
+mod_init_t init_nftl(void)
 {
 	int i;
 
 	printk(KERN_NOTICE
 	       "M-Systems NAND Flash Translation Layer driver. (C) 1999 MVHI\n");
 #ifdef PRERELEASE 
-	printk(KERN_INFO"$Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $\n");
+	printk(KERN_INFO"$Id: nftl.c,v 1.68 2001/03/26 15:44:47 dwmw2 Exp $\n");
 #endif
 
 	if (register_blkdev(MAJOR_NR, "nftl", &nftl_fops)){
@@ -1086,12 +1078,13 @@
 	return 0;
 }
 
-static void __exit cleanup_nftl(void)
+/*  static void __exit cleanup_nftl(void) */
+mod_exit_t cleanup_nftl(void)
 {
-	struct gendisk *gd, **gdp;
-
-  	unregister_mtd_user(&nftl_notifier);
-  	unregister_blkdev(MAJOR_NR, "nftl");
+        struct gendisk *gd, **gdp;
+     
+        unregister_mtd_user(&nftl_notifier);
+        unregister_blkdev(MAJOR_NR, "nftl");
   	
 #if LINUX_VERSION_CODE < 0x20320
   	blk_dev[MAJOR_NR].request_fn = 0;
@@ -1105,7 +1098,7 @@
     		if (*gdp == &nftl_gendisk) {
       			gd = *gdp; *gdp = gd->next;
       			break;
-    	}
+		}
 }
 
 module_init(init_nftl);
diff -Naur linux-2.4.2.orig/drivers/mtd/nftlcore.c linux-2.4.2/drivers/mtd/nftlcore.c
--- linux-2.4.2.orig/drivers/mtd/nftlcore.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nftlcore.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,1103 @@
+/* Linux driver for NAND Flash Translation Layer      */
+/* (c) 1999 Machine Vision Holdings, Inc.             */
+/* Author: David Woodhouse <dwmw2@infradead.org>      */
+/* $Id: nftlcore.c,v 1.85 2001/11/20 11:42:33 dwmw2 Exp $ */
+
+/*
+  The contents of this file are distributed under the GNU General
+  Public License version 2. The author places no additional
+  restrictions of any kind on it.
+ */
+
+#define PRERELEASE
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/blkpg.h>
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/compatmac.h>
+
+/* maximum number of loops while examining next block, to have a
+   chance to detect consistency problems (they should never happen
+   because of the checks done in the mounting */
+
+#define MAX_LOOPS 10000
+
+/* NFTL block device stuff */
+#define MAJOR_NR NFTL_MAJOR
+#define DEVICE_REQUEST nftl_request
+#define DEVICE_OFF(device)
+
+
+#include <linux/blk.h>
+#include <linux/hdreg.h>
+
+/* Linux-specific block device functions */
+
+/* I _HATE_ the Linux block device setup more than anything else I've ever
+ *  encountered, except ...
+ */
+
+static int nftl_sizes[256];
+static int nftl_blocksizes[256];
+
+/* .. for the Linux partition table handling. */
+struct hd_struct part_table[256];
+
+#if LINUX_VERSION_CODE < 0x20328
+static void dummy_init (struct gendisk *crap)
+{}
+#endif
+
+static struct gendisk nftl_gendisk = {
+	major:		MAJOR_NR,
+	major_name:	"nftl",
+	minor_shift:	NFTL_PARTN_BITS,	/* Bits to shift to get real from partition */
+	max_p:		(1<<NFTL_PARTN_BITS)-1,	/* Number of partitions per real */
+#if LINUX_VERSION_CODE < 0x20328
+	max_nr:		MAX_NFTLS,      /* maximum number of real */
+	init:		dummy_init,     /* init function */
+#endif
+	part:		part_table,     /* hd struct */
+	sizes:		nftl_sizes,     /* block sizes */
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,14)
+#define BLK_INC_USE_COUNT MOD_INC_USE_COUNT
+#define BLK_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define BLK_INC_USE_COUNT do {} while(0)
+#define BLK_DEC_USE_COUNT do {} while(0)
+#endif
+
+struct NFTLrecord *NFTLs[MAX_NFTLS];
+
+static void NFTL_setup(struct mtd_info *mtd)
+{
+	int i;
+	struct NFTLrecord *nftl;
+	unsigned long temp;
+	int firstfree = -1;
+
+	DEBUG(MTD_DEBUG_LEVEL1,"NFTL_setup\n");
+
+	for (i = 0; i < MAX_NFTLS; i++) {
+		if (!NFTLs[i] && firstfree == -1)
+			firstfree = i;
+		else if (NFTLs[i] && NFTLs[i]->mtd == mtd) {
+			/* This is a Spare Media Header for an NFTL we've already found */
+			DEBUG(MTD_DEBUG_LEVEL1, "MTD already mounted as NFTL\n");
+			return;
+		}
+	}
+        if (firstfree == -1) {
+		printk(KERN_WARNING "No more NFTL slot available\n");
+		return;
+        }
+
+	nftl = kmalloc(sizeof(struct NFTLrecord), GFP_KERNEL);
+	if (!nftl) {
+		printk(KERN_WARNING "Out of memory for NFTL data structures\n");
+		return;
+	}
+
+	init_MUTEX(&nftl->mutex);
+
+        /* get physical parameters */
+	nftl->EraseSize = mtd->erasesize;
+        nftl->nb_blocks = mtd->size / mtd->erasesize;
+	nftl->mtd = mtd;
+
+        if (NFTL_mount(nftl) < 0) {
+		printk(KERN_WARNING "Could not mount NFTL device\n");
+		kfree(nftl);
+		return;
+        }
+
+	/* OK, it's a new one. Set up all the data structures. */
+#ifdef PSYCHO_DEBUG
+	printk("Found new NFTL nftl%c\n", firstfree + 'a');
+#endif
+
+        /* linux stuff */
+	nftl->usecount = 0;
+	nftl->cylinders = 1024;
+	nftl->heads = 16;
+
+	temp = nftl->cylinders * nftl->heads;
+	nftl->sectors = nftl->nr_sects / temp;
+	if (nftl->nr_sects % temp) {
+		nftl->sectors++;
+		temp = nftl->cylinders * nftl->sectors;
+		nftl->heads = nftl->nr_sects / temp;
+
+		if (nftl->nr_sects % temp) {
+			nftl->heads++;
+			temp = nftl->heads * nftl->sectors;
+			nftl->cylinders = nftl->nr_sects / temp;
+		}
+	}
+
+	if (nftl->nr_sects != nftl->heads * nftl->cylinders * nftl->sectors) {
+		printk(KERN_WARNING "Cannot calculate an NFTL geometry to "
+		       "match size of 0x%lx.\n", nftl->nr_sects);
+		printk(KERN_WARNING "Using C:%d H:%d S:%d (== 0x%lx sects)\n", 
+		       nftl->cylinders, nftl->heads , nftl->sectors, 
+		       (long)nftl->cylinders * (long)nftl->heads * (long)nftl->sectors );
+
+		/* Oh no we don't have nftl->nr_sects = nftl->heads * nftl->cylinders * nftl->sectors; */
+	}
+	NFTLs[firstfree] = nftl;
+	/* Finally, set up the block device sizes */
+	nftl_sizes[firstfree * 16] = nftl->nr_sects;
+	//nftl_blocksizes[firstfree*16] = 512;
+	part_table[firstfree * 16].nr_sects = nftl->nr_sects;
+
+	nftl_gendisk.nr_real++;
+
+	/* partition check ... */
+#if LINUX_VERSION_CODE < 0x20328
+	resetup_one_dev(&nftl_gendisk, firstfree);
+#else
+	grok_partitions(&nftl_gendisk, firstfree, 1<<NFTL_PARTN_BITS, nftl->nr_sects);
+#endif
+}
+
+static void NFTL_unsetup(int i)
+{
+	struct NFTLrecord *nftl = NFTLs[i];
+
+	DEBUG(MTD_DEBUG_LEVEL1, "NFTL_unsetup %d\n", i);
+	
+	NFTLs[i] = NULL;
+	
+	if (nftl->ReplUnitTable)
+		kfree(nftl->ReplUnitTable);
+	if (nftl->EUNtable)
+		kfree(nftl->EUNtable);
+		      
+	nftl_gendisk.nr_real--;
+	kfree(nftl);
+}
+
+/* Search the MTD device for NFTL partitions */
+static void NFTL_notify_add(struct mtd_info *mtd)
+{
+	DEBUG(MTD_DEBUG_LEVEL1, "NFTL_notify_add for %s\n", mtd->name);
+
+	if (mtd) {
+		if (!mtd->read_oob) {
+			/* If this MTD doesn't have out-of-band data,
+			   then there's no point continuing */
+			DEBUG(MTD_DEBUG_LEVEL1, "No OOB data, quitting\n");
+			return;
+		}
+		DEBUG(MTD_DEBUG_LEVEL3, "mtd->read = %p, size = %d, erasesize = %d\n", 
+		      mtd->read, mtd->size, mtd->erasesize);
+
+                NFTL_setup(mtd);
+	}
+}
+
+static void NFTL_notify_remove(struct mtd_info *mtd)
+{
+	int i;
+
+	for (i = 0; i < MAX_NFTLS; i++) {
+		if (NFTLs[i] && NFTLs[i]->mtd == mtd)
+			NFTL_unsetup(i);
+	}
+}
+
+#ifdef CONFIG_NFTL_RW
+
+/* Actual NFTL access routines */
+/* NFTL_findfreeblock: Find a free Erase Unit on the NFTL partition. This function is used
+ *	when the give Virtual Unit Chain
+ */
+static u16 NFTL_findfreeblock(struct NFTLrecord *nftl, int desperate )
+{
+	/* For a given Virtual Unit Chain: find or create a free block and
+	   add it to the chain */
+	/* We're passed the number of the last EUN in the chain, to save us from
+	   having to look it up again */
+	u16 pot = nftl->LastFreeEUN;
+	int silly = nftl->nb_blocks;
+
+	/* Normally, we force a fold to happen before we run out of free blocks completely */
+	if (!desperate && nftl->numfreeEUNs < 2) {
+		DEBUG(MTD_DEBUG_LEVEL1, "NFTL_findfreeblock: there are too few free EUNs\n");
+		return 0xffff;
+	}
+
+	/* Scan for a free block */
+	do {
+		if (nftl->ReplUnitTable[pot] == BLOCK_FREE) {
+			nftl->LastFreeEUN = pot;
+			nftl->numfreeEUNs--;
+			return pot;
+		}
+
+		/* This will probably point to the MediaHdr unit itself,
+		   right at the beginning of the partition. But that unit
+		   (and the backup unit too) should have the UCI set
+		   up so that it's not selected for overwriting */
+		if (++pot > nftl->lastEUN)
+			pot = le16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN);
+
+		if (!silly--) {
+			printk("Argh! No free blocks found! LastFreeEUN = %d, "
+			       "FirstEUN = %d\n", nftl->LastFreeEUN, 
+			       le16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN));
+			return 0xffff;
+		}
+	} while (pot != nftl->LastFreeEUN);
+
+	return 0xffff;
+}
+
+static u16 NFTL_foldchain (struct NFTLrecord *nftl, unsigned thisVUC, unsigned pendingblock )
+{
+	u16 BlockMap[MAX_SECTORS_PER_UNIT];
+	unsigned char BlockLastState[MAX_SECTORS_PER_UNIT];
+	unsigned char BlockFreeFound[MAX_SECTORS_PER_UNIT];
+	unsigned int thisEUN;
+	int block;
+	int silly;
+	unsigned int targetEUN;
+	struct nftl_oob oob;
+	int inplace = 1;
+        size_t retlen;
+
+	memset(BlockMap, 0xff, sizeof(BlockMap));
+	memset(BlockFreeFound, 0, sizeof(BlockFreeFound));
+
+	thisEUN = nftl->EUNtable[thisVUC];
+
+	if (thisEUN == BLOCK_NIL) {
+		printk(KERN_WARNING "Trying to fold non-existent "
+		       "Virtual Unit Chain %d!\n", thisVUC);
+		return BLOCK_NIL;
+	}
+	
+	/* Scan to find the Erase Unit which holds the actual data for each
+	   512-byte block within the Chain.
+	*/
+        silly = MAX_LOOPS;
+	targetEUN = BLOCK_NIL;
+	while (thisEUN <= nftl->lastEUN ) {
+                unsigned int status, foldmark;
+
+		targetEUN = thisEUN;
+		for (block = 0; block < nftl->EraseSize / 512; block ++) {
+			MTD_READOOB(nftl->mtd,
+				    (thisEUN * nftl->EraseSize) + (block * 512),
+				    16 , &retlen, (char *)&oob);
+			if (block == 2) {
+                                foldmark = oob.u.c.FoldMark | oob.u.c.FoldMark1;
+                                if (foldmark == FOLD_MARK_IN_PROGRESS) {
+                                        DEBUG(MTD_DEBUG_LEVEL1, 
+                                              "Write Inhibited on EUN %d\n", thisEUN);
+					inplace = 0;
+				} else {
+					/* There's no other reason not to do inplace,
+					   except ones that come later. So we don't need
+					   to preserve inplace */
+					inplace = 1;
+				}
+			}
+                        status = oob.b.Status | oob.b.Status1;
+			BlockLastState[block] = status;
+
+			switch(status) {
+			case SECTOR_FREE:
+				BlockFreeFound[block] = 1;
+				break;
+
+			case SECTOR_USED:
+				if (!BlockFreeFound[block])
+					BlockMap[block] = thisEUN;
+				else
+					printk(KERN_WARNING 
+					       "SECTOR_USED found after SECTOR_FREE "
+					       "in Virtual Unit Chain %d for block %d\n",
+					       thisVUC, block);
+				break;
+			case SECTOR_DELETED:
+				if (!BlockFreeFound[block])
+					BlockMap[block] = BLOCK_NIL;
+				else
+					printk(KERN_WARNING 
+					       "SECTOR_DELETED found after SECTOR_FREE "
+					       "in Virtual Unit Chain %d for block %d\n",
+					       thisVUC, block);
+				break;
+
+			case SECTOR_IGNORE:
+				break;
+			default:
+				printk("Unknown status for block %d in EUN %d: %x\n",
+				       block, thisEUN, status);
+			}
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%x\n",
+			       thisVUC);
+			return BLOCK_NIL;
+		}
+		
+		thisEUN = nftl->ReplUnitTable[thisEUN];
+	}
+
+	if (inplace) {
+		/* We're being asked to be a fold-in-place. Check
+		   that all blocks which actually have data associated
+		   with them (i.e. BlockMap[block] != BLOCK_NIL) are 
+		   either already present or SECTOR_FREE in the target
+		   block. If not, we're going to have to fold out-of-place
+		   anyway.
+		*/
+		for (block = 0; block < nftl->EraseSize / 512 ; block++) {
+			if (BlockLastState[block] != SECTOR_FREE &&
+			    BlockMap[block] != BLOCK_NIL &&
+			    BlockMap[block] != targetEUN) {
+				DEBUG(MTD_DEBUG_LEVEL1, "Setting inplace to 0. VUC %d, "
+				      "block %d was %x lastEUN, "
+				      "and is in EUN %d (%s) %d\n",
+				      thisVUC, block, BlockLastState[block],
+				      BlockMap[block], 
+				      BlockMap[block]== targetEUN ? "==" : "!=",
+				      targetEUN);
+				inplace = 0;
+				break;
+			}
+		}
+
+		if (pendingblock >= (thisVUC * (nftl->EraseSize / 512)) &&
+		    pendingblock < ((thisVUC + 1)* (nftl->EraseSize / 512)) &&
+		    BlockLastState[pendingblock - (thisVUC * (nftl->EraseSize / 512))] !=
+		    SECTOR_FREE) {
+			DEBUG(MTD_DEBUG_LEVEL1, "Pending write not free in EUN %d. "
+			      "Folding out of place.\n", targetEUN);
+			inplace = 0;
+		}
+	}
+	
+	if (!inplace) {
+		DEBUG(MTD_DEBUG_LEVEL1, "Cannot fold Virtual Unit Chain %d in place. "
+		      "Trying out-of-place\n", thisVUC);
+		/* We need to find a targetEUN to fold into. */
+		targetEUN = NFTL_findfreeblock(nftl, 1);
+		if (targetEUN == BLOCK_NIL) {
+			/* Ouch. Now we're screwed. We need to do a 
+			   fold-in-place of another chain to make room
+			   for this one. We need a better way of selecting
+			   which chain to fold, because makefreeblock will 
+			   only ask us to fold the same one again.
+			*/
+			printk(KERN_WARNING
+			       "NFTL_findfreeblock(desperate) returns 0xffff.\n");
+			return BLOCK_NIL;
+		}
+	} else {
+            /* We put a fold mark in the chain we are folding only if
+               we fold in place to help the mount check code. If we do
+               not fold in place, it is possible to find the valid
+               chain by selecting the longer one */
+            oob.u.c.FoldMark = oob.u.c.FoldMark1 = cpu_to_le16(FOLD_MARK_IN_PROGRESS);
+            oob.u.c.unused = 0xffffffff;
+            MTD_WRITEOOB(nftl->mtd, (nftl->EraseSize * targetEUN) + 2 * 512 + 8, 
+                         8, &retlen, (char *)&oob.u);
+        }
+
+	/* OK. We now know the location of every block in the Virtual Unit Chain,
+	   and the Erase Unit into which we are supposed to be copying.
+	   Go for it.
+	*/
+	DEBUG(MTD_DEBUG_LEVEL1,"Folding chain %d into unit %d\n", thisVUC, targetEUN);
+	for (block = 0; block < nftl->EraseSize / 512 ; block++) {
+		unsigned char movebuf[512];
+		int ret;
+
+		/* If it's in the target EUN already, or if it's pending write, do nothing */
+		if (BlockMap[block] == targetEUN ||
+		    (pendingblock == (thisVUC * (nftl->EraseSize / 512) + block))) {
+			continue;
+		}
+
+                /* copy only in non free block (free blocks can only
+                   happen in case of media errors or deleted blocks) */
+                if (BlockMap[block] == BLOCK_NIL)
+                        continue;
+                
+                ret = MTD_READECC(nftl->mtd, (nftl->EraseSize * BlockMap[block])
+                                  + (block * 512), 512, &retlen, movebuf, (char *)&oob); 
+                if (ret < 0) {
+                    ret = MTD_READECC(nftl->mtd, (nftl->EraseSize * BlockMap[block])
+                                      + (block * 512), 512, &retlen,
+                                      movebuf, (char *)&oob); 
+                    if (ret != -EIO) 
+                        printk("Error went away on retry.\n");
+                }
+                MTD_WRITEECC(nftl->mtd, (nftl->EraseSize * targetEUN) + (block * 512),
+                             512, &retlen, movebuf, (char *)&oob);
+	}
+        
+        /* add the header so that it is now a valid chain */
+        oob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum
+                = cpu_to_le16(thisVUC);
+        oob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum = 0xffff;
+        
+        MTD_WRITEOOB(nftl->mtd, (nftl->EraseSize * targetEUN) + 8, 
+                     8, &retlen, (char *)&oob.u);
+
+	/* OK. We've moved the whole lot into the new block. Now we have to free the original blocks. */
+
+	/* At this point, we have two different chains for this Virtual Unit, and no way to tell 
+	   them apart. If we crash now, we get confused. However, both contain the same data, so we
+	   shouldn't actually lose data in this case. It's just that when we load up on a medium which
+	   has duplicate chains, we need to free one of the chains because it's not necessary any more.
+	*/
+	thisEUN = nftl->EUNtable[thisVUC];
+	DEBUG(MTD_DEBUG_LEVEL1,"Want to erase\n");
+
+	/* For each block in the old chain (except the targetEUN of course), 
+	   free it and make it available for future use */
+	while (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {
+		unsigned int EUNtmp;
+
+                EUNtmp = nftl->ReplUnitTable[thisEUN];
+
+                if (NFTL_formatblock(nftl, thisEUN) < 0) {
+			/* could not erase : mark block as reserved
+			 * FixMe: Update Bad Unit Table on disk
+			 */
+			nftl->ReplUnitTable[thisEUN] = BLOCK_RESERVED;
+                } else {
+			/* correctly erased : mark it as free */
+			nftl->ReplUnitTable[thisEUN] = BLOCK_FREE;
+			nftl->numfreeEUNs++;
+                }
+                thisEUN = EUNtmp;
+	}
+	
+	/* Make this the new start of chain for thisVUC */
+	nftl->ReplUnitTable[targetEUN] = BLOCK_NIL;
+	nftl->EUNtable[thisVUC] = targetEUN;
+
+	return targetEUN;
+}
+
+u16 NFTL_makefreeblock( struct NFTLrecord *nftl , unsigned pendingblock)
+{
+	/* This is the part that needs some cleverness applied. 
+	   For now, I'm doing the minimum applicable to actually
+	   get the thing to work.
+	   Wear-levelling and other clever stuff needs to be implemented
+	   and we also need to do some assessment of the results when
+	   the system loses power half-way through the routine.
+	*/
+	u16 LongestChain = 0;
+	u16 ChainLength = 0, thislen;
+	u16 chain, EUN;
+
+	for (chain = 0; chain < le32_to_cpu(nftl->MediaHdr.FormattedSize) / nftl->EraseSize; chain++) {
+		EUN = nftl->EUNtable[chain];
+		thislen = 0;
+
+		while (EUN <= nftl->lastEUN) {
+			thislen++;
+			//printk("VUC %d reaches len %d with EUN %d\n", chain, thislen, EUN);
+			EUN = nftl->ReplUnitTable[EUN] & 0x7fff;
+			if (thislen > 0xff00) {
+				printk("Endless loop in Virtual Chain %d: Unit %x\n",
+				       chain, EUN);
+			}
+			if (thislen > 0xff10) {
+				/* Actually, don't return failure. Just ignore this chain and
+				   get on with it. */
+				thislen = 0;
+				break;
+			}
+		}
+
+		if (thislen > ChainLength) {
+			//printk("New longest chain is %d with length %d\n", chain, thislen);
+			ChainLength = thislen;
+			LongestChain = chain;
+		}
+	}
+
+	if (ChainLength < 2) {
+		printk(KERN_WARNING "No Virtual Unit Chains available for folding. "
+		       "Failing request\n");
+		return 0xffff;
+	}
+
+	return NFTL_foldchain (nftl, LongestChain, pendingblock);
+}
+
+/* NFTL_findwriteunit: Return the unit number into which we can write 
+                       for this block. Make it available if it isn't already
+*/
+static inline u16 NFTL_findwriteunit(struct NFTLrecord *nftl, unsigned block)
+{
+	u16 lastEUN;
+	u16 thisVUC = block / (nftl->EraseSize / 512);
+	unsigned int writeEUN;
+	unsigned long blockofs = (block * 512) & (nftl->EraseSize -1);
+	size_t retlen;
+	int silly, silly2 = 3;
+	struct nftl_oob oob;
+
+	do {
+		/* Scan the media to find a unit in the VUC which has
+		   a free space for the block in question.
+		*/
+
+		/* This condition catches the 0x[7f]fff cases, as well as 
+		   being a sanity check for past-end-of-media access
+		*/
+		lastEUN = BLOCK_NIL;
+		writeEUN = nftl->EUNtable[thisVUC];
+                silly = MAX_LOOPS;
+		while (writeEUN <= nftl->lastEUN) {
+			struct nftl_bci bci;
+			size_t retlen;
+                        unsigned int status;
+
+			lastEUN = writeEUN;
+
+			MTD_READOOB(nftl->mtd, (writeEUN * nftl->EraseSize) + blockofs,
+				    8, &retlen, (char *)&bci);
+			
+			DEBUG(MTD_DEBUG_LEVEL2, "Status of block %d in EUN %d is %x\n",
+			      block , writeEUN, le16_to_cpu(bci.Status));
+
+                        status = bci.Status | bci.Status1;
+			switch(status) {
+			case SECTOR_FREE:
+				return writeEUN;
+
+			case SECTOR_DELETED:
+			case SECTOR_USED:
+			case SECTOR_IGNORE:
+				break;
+			default:
+				// Invalid block. Don't use it any more. Must implement.
+				break;			
+			}
+			
+			if (!silly--) { 
+				printk(KERN_WARNING
+				       "Infinite loop in Virtual Unit Chain 0x%x\n",
+				       thisVUC);
+				return 0xffff;
+			}
+
+			/* Skip to next block in chain */
+			writeEUN = nftl->ReplUnitTable[writeEUN];
+		}
+
+		/* OK. We didn't find one in the existing chain, or there 
+		   is no existing chain. */
+
+		/* Try to find an already-free block */
+		writeEUN = NFTL_findfreeblock(nftl, 0);
+
+		if (writeEUN == BLOCK_NIL) {
+			/* That didn't work - there were no free blocks just
+			   waiting to be picked up. We're going to have to fold
+			   a chain to make room.
+			*/
+
+			/* First remember the start of this chain */
+			//u16 startEUN = nftl->EUNtable[thisVUC];
+			
+			//printk("Write to VirtualUnitChain %d, calling makefreeblock()\n", thisVUC);
+			writeEUN = NFTL_makefreeblock(nftl, 0xffff);
+
+			if (writeEUN == BLOCK_NIL) {
+				/* OK, we accept that the above comment is 
+				   lying - there may have been free blocks
+				   last time we called NFTL_findfreeblock(),
+				   but they are reserved for when we're
+				   desperate. Well, now we're desperate.
+				*/
+				DEBUG(MTD_DEBUG_LEVEL1, "Using desperate==1 to find free EUN to accommodate write to VUC %d\n", thisVUC);
+				writeEUN = NFTL_findfreeblock(nftl, 1);
+			}
+			if (writeEUN == BLOCK_NIL) {
+				/* Ouch. This should never happen - we should
+				   always be able to make some room somehow. 
+				   If we get here, we've allocated more storage 
+				   space than actual media, or our makefreeblock
+				   routine is missing something.
+				*/
+				printk(KERN_WARNING "Cannot make free space.\n");
+				return BLOCK_NIL;
+			}			
+			//printk("Restarting scan\n");
+			lastEUN = BLOCK_NIL;
+			continue;
+		}
+
+		/* We've found a free block. Insert it into the chain. */
+		
+		if (lastEUN != BLOCK_NIL) {
+                    thisVUC |= 0x8000; /* It's a replacement block */
+		} else {
+                    /* The first block in a new chain */
+                    nftl->EUNtable[thisVUC] = writeEUN;
+		}
+
+		/* set up the actual EUN we're writing into */
+		/* Both in our cache... */
+		nftl->ReplUnitTable[writeEUN] = BLOCK_NIL;
+
+		/* ... and on the flash itself */
+		MTD_READOOB(nftl->mtd, writeEUN * nftl->EraseSize + 8, 8,
+			    &retlen, (char *)&oob.u);
+
+		oob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum = cpu_to_le16(thisVUC);
+
+		MTD_WRITEOOB(nftl->mtd, writeEUN * nftl->EraseSize + 8, 8,
+                             &retlen, (char *)&oob.u);
+
+                /* we link the new block to the chain only after the
+                   block is ready. It avoids the case where the chain
+                   could point to a free block */
+                if (lastEUN != BLOCK_NIL) {
+			/* Both in our cache... */
+			nftl->ReplUnitTable[lastEUN] = writeEUN;
+			/* ... and on the flash itself */
+			MTD_READOOB(nftl->mtd, (lastEUN * nftl->EraseSize) + 8,
+				    8, &retlen, (char *)&oob.u);
+
+			oob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum
+				= cpu_to_le16(writeEUN);
+
+			MTD_WRITEOOB(nftl->mtd, (lastEUN * nftl->EraseSize) + 8,
+				     8, &retlen, (char *)&oob.u);
+		}
+
+		return writeEUN;
+
+	} while (silly2--);
+
+	printk(KERN_WARNING "Error folding to make room for Virtual Unit Chain 0x%x\n",
+	       thisVUC);
+	return 0xffff;
+}
+
+static int NFTL_writeblock(struct NFTLrecord *nftl, unsigned block, char *buffer)
+{
+	u16 writeEUN;
+	unsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);
+	size_t retlen;
+	u8 eccbuf[6];
+
+	writeEUN = NFTL_findwriteunit(nftl, block);
+
+	if (writeEUN == BLOCK_NIL) {
+		printk(KERN_WARNING
+		       "NFTL_writeblock(): Cannot find block to write to\n");
+		/* If we _still_ haven't got a block to use, we're screwed */
+		return 1;
+	}
+
+	MTD_WRITEECC(nftl->mtd, (writeEUN * nftl->EraseSize) + blockofs,
+		     512, &retlen, (char *)buffer, (char *)eccbuf);
+        /* no need to write SECTOR_USED flags since they are written in mtd_writeecc */
+
+	return 0;
+}
+#endif /* CONFIG_NFTL_RW */
+
+static int NFTL_readblock(struct NFTLrecord *nftl, unsigned block, char *buffer)
+{
+	u16 lastgoodEUN;
+	u16 thisEUN = nftl->EUNtable[block / (nftl->EraseSize / 512)];
+	unsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);
+        unsigned int status;
+	int silly = MAX_LOOPS;
+        size_t retlen;
+        struct nftl_bci bci;
+
+	lastgoodEUN = BLOCK_NIL;
+
+        if (thisEUN != BLOCK_NIL) {
+		while (thisEUN < nftl->nb_blocks) {
+			if (MTD_READOOB(nftl->mtd, (thisEUN * nftl->EraseSize) + blockofs,
+					8, &retlen, (char *)&bci) < 0)
+				status = SECTOR_IGNORE;
+			else
+				status = bci.Status | bci.Status1;
+
+			switch (status) {
+			case SECTOR_FREE:
+				/* no modification of a sector should follow a free sector */
+				goto the_end;
+			case SECTOR_DELETED:
+				lastgoodEUN = BLOCK_NIL;
+				break;
+			case SECTOR_USED:
+				lastgoodEUN = thisEUN;
+				break;
+			case SECTOR_IGNORE:
+				break;
+			default:
+				printk("Unknown status for block %d in EUN %d: %x\n",
+				       block, thisEUN, status);
+				break;
+			}
+
+			if (!silly--) {
+				printk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%x\n",
+				       block / (nftl->EraseSize / 512));
+				return 1;
+			}
+			thisEUN = nftl->ReplUnitTable[thisEUN];
+		}
+        }
+
+ the_end:
+	if (lastgoodEUN == BLOCK_NIL) {
+		/* the requested block is not on the media, return all 0x00 */
+		memset(buffer, 0, 512);
+	} else {
+		loff_t ptr = (lastgoodEUN * nftl->EraseSize) + blockofs;
+		size_t retlen;
+		u_char eccbuf[6];
+		if (MTD_READECC(nftl->mtd, ptr, 512, &retlen, buffer, eccbuf))
+			return -EIO;
+	}
+	return 0;
+}
+
+static int nftl_ioctl(struct inode * inode, struct file * file, unsigned int cmd, unsigned long arg)
+{
+	struct NFTLrecord *nftl;
+	int p;
+
+	nftl = NFTLs[MINOR(inode->i_rdev) >> NFTL_PARTN_BITS];
+
+	if (!nftl) return -EINVAL;
+
+	switch (cmd) {
+	case HDIO_GETGEO: {
+		struct hd_geometry g;
+
+		g.heads = nftl->heads;
+		g.sectors = nftl->sectors;
+		g.cylinders = nftl->cylinders;
+		g.start = part_table[MINOR(inode->i_rdev)].start_sect;
+		return copy_to_user((void *)arg, &g, sizeof g) ? -EFAULT : 0;
+	}
+	case BLKGETSIZE:   /* Return device size */
+		return put_user(part_table[MINOR(inode->i_rdev)].nr_sects,
+                                (unsigned long *) arg);
+
+#ifdef BLKGETSIZE64
+	case BLKGETSIZE64:
+		return put_user((u64)part_table[MINOR(inode->i_rdev)].nr_sects << 9,
+                                (u64 *)arg);
+#endif
+
+	case BLKFLSBUF:
+		if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+		fsync_dev(inode->i_rdev);
+		invalidate_buffers(inode->i_rdev);
+		if (nftl->mtd->sync)
+			nftl->mtd->sync(nftl->mtd);
+		return 0;
+
+	case BLKRRPART:
+		if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+		if (nftl->usecount > 1) return -EBUSY;
+		/* 
+		 * We have to flush all buffers and invalidate caches,
+		 * or we won't be able to re-use the partitions,
+		 * if there was a change and we don't want to reboot
+		 */
+		p = (1<<NFTL_PARTN_BITS) - 1;
+		while (p-- > 0) {
+			kdev_t devp = MKDEV(MAJOR(inode->i_dev), MINOR(inode->i_dev)+p);
+			if (part_table[p].nr_sects > 0)
+				invalidate_device (devp, 1);
+
+			part_table[MINOR(inode->i_dev)+p].start_sect = 0;
+			part_table[MINOR(inode->i_dev)+p].nr_sects = 0;
+		}
+		
+#if LINUX_VERSION_CODE < 0x20328
+		resetup_one_dev(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS);
+#else
+		grok_partitions(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS,
+				1<<NFTL_PARTN_BITS, nftl->nr_sects);
+#endif
+		return 0;
+
+#if (LINUX_VERSION_CODE < 0x20303)		
+	RO_IOCTLS(inode->i_rdev, arg);  /* ref. linux/blk.h */
+#else
+	case BLKROSET:
+	case BLKROGET:
+	case BLKSSZGET:
+		return blk_ioctl(inode->i_rdev, cmd, arg);
+#endif
+
+	default:
+		return -EINVAL;
+	}
+}
+
+void nftl_request(RQFUNC_ARG)
+{
+	unsigned int dev, block, nsect;
+	struct NFTLrecord *nftl;
+	char *buffer;
+	struct request *req;
+	int res;
+
+	while (1) {
+		INIT_REQUEST;	/* blk.h */
+		req = CURRENT;
+		
+		/* We can do this because the generic code knows not to
+		   touch the request at the head of the queue */
+		spin_unlock_irq(&io_request_lock);
+
+		DEBUG(MTD_DEBUG_LEVEL2, "NFTL_request\n");
+		DEBUG(MTD_DEBUG_LEVEL3, "NFTL %s request, from sector 0x%04lx for 0x%04lx sectors\n",
+		      (req->cmd == READ) ? "Read " : "Write",
+		      req->sector, req->current_nr_sectors);
+
+		dev = MINOR(req->rq_dev);
+		block = req->sector;
+		nsect = req->current_nr_sectors;
+		buffer = req->buffer;
+		res = 1; /* succeed */
+
+		if (dev >= MAX_NFTLS * (1<<NFTL_PARTN_BITS)) {
+			/* there is no such partition */
+			printk("nftl: bad minor number: device = %s\n",
+			       kdevname(req->rq_dev));
+			res = 0; /* fail */
+			goto repeat;
+		}
+		
+		nftl = NFTLs[dev / (1<<NFTL_PARTN_BITS)];
+		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
+		down(&nftl->mutex);
+		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
+
+		if (block + nsect > part_table[dev].nr_sects) {
+			/* access past the end of device */
+			printk("nftl%c%d: bad access: block = %d, count = %d\n",
+			       (MINOR(req->rq_dev)>>6)+'a', dev & 0xf, block, nsect);
+			up(&nftl->mutex);
+			res = 0; /* fail */
+			goto repeat;
+		}
+		
+		block += part_table[dev].start_sect;
+		
+		if (req->cmd == READ) {
+			DEBUG(MTD_DEBUG_LEVEL2, "NFTL read request of 0x%x sectors @ %x "
+			      "(req->nr_sectors == %lx)\n", nsect, block, req->nr_sectors);
+	
+			for ( ; nsect > 0; nsect-- , block++, buffer += 512) {
+				/* Read a single sector to req->buffer + (512 * i) */
+				if (NFTL_readblock(nftl, block, buffer)) {
+					DEBUG(MTD_DEBUG_LEVEL2, "NFTL read request failed\n");
+					up(&nftl->mutex);
+					res = 0;
+					goto repeat;
+				}
+			}
+
+			DEBUG(MTD_DEBUG_LEVEL2,"NFTL read request completed OK\n");
+			up(&nftl->mutex);
+			goto repeat;
+		} else if (req->cmd == WRITE) {
+			DEBUG(MTD_DEBUG_LEVEL2, "NFTL write request of 0x%x sectors @ %x "
+			      "(req->nr_sectors == %lx)\n", nsect, block,
+			      req->nr_sectors);
+#ifdef CONFIG_NFTL_RW
+			for ( ; nsect > 0; nsect-- , block++, buffer += 512) {
+				/* Read a single sector to req->buffer + (512 * i) */
+				if (NFTL_writeblock(nftl, block, buffer)) {
+					DEBUG(MTD_DEBUG_LEVEL1,"NFTL write request failed\n");
+					up(&nftl->mutex);
+					res = 0;
+					goto repeat;
+				}
+			}
+			DEBUG(MTD_DEBUG_LEVEL2,"NFTL write request completed OK\n");
+#else
+			res = 0; /* Writes always fail */
+#endif /* CONFIG_NFTL_RW */
+			up(&nftl->mutex);
+			goto repeat;
+		} else {
+			DEBUG(MTD_DEBUG_LEVEL0, "NFTL unknown request\n");
+			up(&nftl->mutex);
+			res = 0;
+			goto repeat;
+		}
+	repeat: 
+		DEBUG(MTD_DEBUG_LEVEL3, "end_request(%d)\n", res);
+		spin_lock_irq(&io_request_lock);
+		end_request(res);
+	}
+}
+
+static int nftl_open(struct inode *ip, struct file *fp)
+{
+	int nftlnum = MINOR(ip->i_rdev) >> NFTL_PARTN_BITS;
+	struct NFTLrecord *thisNFTL;
+	thisNFTL = NFTLs[nftlnum];
+
+	DEBUG(MTD_DEBUG_LEVEL2,"NFTL_open\n");
+
+#ifdef CONFIG_KMOD
+	if (!thisNFTL && nftlnum == 0) {
+		request_module("docprobe");
+		thisNFTL = NFTLs[nftlnum];
+	}
+#endif
+	if (!thisNFTL) {
+		DEBUG(MTD_DEBUG_LEVEL2,"ENODEV: thisNFTL = %d, minor = %d, ip = %p, fp = %p\n", 
+		      nftlnum, ip->i_rdev, ip, fp);
+		return -ENODEV;
+	}
+
+#ifndef CONFIG_NFTL_RW
+	if (fp->f_mode & FMODE_WRITE)
+		return -EROFS;
+#endif /* !CONFIG_NFTL_RW */
+
+	thisNFTL->usecount++;
+	BLK_INC_USE_COUNT;
+	if (!get_mtd_device(thisNFTL->mtd, -1)) {
+		BLK_DEC_USE_COUNT;
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int nftl_release(struct inode *inode, struct file *fp)
+{
+	struct NFTLrecord *thisNFTL;
+
+	thisNFTL = NFTLs[MINOR(inode->i_rdev) / 16];
+
+	DEBUG(MTD_DEBUG_LEVEL2, "NFTL_release\n");
+
+	if (thisNFTL->mtd->sync)
+		thisNFTL->mtd->sync(thisNFTL->mtd);
+	thisNFTL->usecount--;
+	BLK_DEC_USE_COUNT;
+
+	put_mtd_device(thisNFTL->mtd);
+
+	return 0;
+}
+#if LINUX_VERSION_CODE < 0x20326
+static struct file_operations nftl_fops = {
+	read:		block_read,
+	write:		block_write,
+	ioctl:		nftl_ioctl,
+	open:		nftl_open,
+	release:	nftl_release,
+	fsync:		block_fsync,
+};
+#else
+static struct block_device_operations nftl_fops = 
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,14)
+	owner:		THIS_MODULE,
+#endif
+	open:		nftl_open,
+	release:	nftl_release,
+	ioctl: 		nftl_ioctl
+};
+#endif
+
+
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+
+static struct mtd_notifier nftl_notifier = {
+	add:	NFTL_notify_add,
+	remove:	NFTL_notify_remove
+};
+
+extern char nftlmountrev[];
+
+int __init init_nftl(void)
+{
+	int i;
+
+#ifdef PRERELEASE 
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.85 $, nftlmount.c %s\n", nftlmountrev);
+#endif
+
+	if (register_blkdev(MAJOR_NR, "nftl", &nftl_fops)){
+		printk("unable to register NFTL block device on major %d\n", MAJOR_NR);
+		return -EBUSY;
+	} else {
+		blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), &nftl_request);
+
+		/* set block size to 1kB each */
+		for (i = 0; i < 256; i++) {
+			nftl_blocksizes[i] = 1024;
+		}
+		blksize_size[MAJOR_NR] = nftl_blocksizes;
+
+		add_gendisk(&nftl_gendisk);
+	}
+	
+	register_mtd_user(&nftl_notifier);
+
+	return 0;
+}
+
+static void __exit cleanup_nftl(void)
+{
+  	unregister_mtd_user(&nftl_notifier);
+  	unregister_blkdev(MAJOR_NR, "nftl");
+  	
+  	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+
+	del_gendisk(&nftl_gendisk);
+}
+
+module_init(init_nftl);
+module_exit(cleanup_nftl);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>, Fabrice Bellard <fabrice.bellard@netgem.com> et al.");
+MODULE_DESCRIPTION("Support code for NAND Flash Translation Layer, used on M-Systems DiskOnChip 2000 and Millennium");
diff -Naur linux-2.4.2.orig/drivers/mtd/nftlmount.c linux-2.4.2/drivers/mtd/nftlmount.c
--- linux-2.4.2.orig/drivers/mtd/nftlmount.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/nftlmount.c	Fri Feb 15 14:41:16 2002
@@ -4,7 +4,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: nftlmount.c,v 1.11 2000/11/17 12:24:09 ollie Exp $
+ * $Id: nftlmount.c,v 1.25 2001/11/30 16:46:27 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,6 +20,8 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
+#define __NO_VERSION__
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -37,6 +39,8 @@
 
 #define SECTORSIZE 512
 
+char nftlmountrev[]="$Revision: 1.25 $";
+
 /* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the
  *	various device information of the NFTL partition and Bad Unit Table. Update
  *	the ReplUnitTable[] table accroding to the Bad Unit Table. ReplUnitTable[]
@@ -46,87 +50,152 @@
 {
 	struct nftl_uci1 h1;
 	struct nftl_oob oob;
-	unsigned int block, boot_record_count;
+	unsigned int block, boot_record_count = 0;
 	int retlen;
 	u8 buf[SECTORSIZE];
 	struct NFTLMediaHeader *mh = &nftl->MediaHdr;
+	unsigned int i;
 
 	nftl->MediaUnit = BLOCK_NIL;
 	nftl->SpareMediaUnit = BLOCK_NIL;
-	boot_record_count = 0;
 
 	/* search for a valid boot record */
 	for (block = 0; block < nftl->nb_blocks; block++) {
-		unsigned int erase_mark;
+		int ret;
 
-		/* read ANAND header. To be safer with BIOS, also use erase mark as discriminant */
-		if (MTD_READOOB(nftl->mtd, block * nftl->EraseSize + SECTORSIZE + 8,
-				8, &retlen, (char *)&h1) < 0)
+		/* Check for ANAND header first. Then can whinge if it's found but later
+		   checks fail */
+		if ((ret = MTD_READ(nftl->mtd, block * nftl->EraseSize, SECTORSIZE, &retlen, buf))) {
+			static int warncount = 5;
+
+			if (warncount) {
+				printk(KERN_WARNING "Block read at 0x%x of mtd%d failed: %d\n",
+				       block * nftl->EraseSize, nftl->mtd->index, ret);
+				if (!--warncount)
+					printk(KERN_WARNING "Further failures for this block will not be printed\n");
+			}
 			continue;
+		}
 
-		erase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));
-		if (erase_mark != ERASE_MARK) 
+		if (retlen < 6 || memcmp(buf, "ANAND", 6)) {
+			/* ANAND\0 not found. Continue */
+#if 0
+			printk(KERN_DEBUG "ANAND header not found at 0x%x in mtd%d\n", 
+			       block * nftl->EraseSize, nftl->mtd->index);
+#endif			
 			continue;
+		}
 
-		if (MTD_READECC(nftl->mtd, block * nftl->EraseSize, SECTORSIZE,
-				&retlen, buf, (char *)&oob) < 0)
+		/* To be safer with BIOS, also use erase mark as discriminant */
+		if ((ret = MTD_READOOB(nftl->mtd, block * nftl->EraseSize + SECTORSIZE + 8,
+				8, &retlen, (char *)&h1) < 0)) {
+			printk(KERN_WARNING "ANAND header found at 0x%x in mtd%d, but OOB data read failed (err %d)\n",
+			       block * nftl->EraseSize, nftl->mtd->index, ret);
 			continue;
+		}
 
-		memcpy(mh, buf, sizeof(struct NFTLMediaHeader));
-		if (memcmp(mh->DataOrgID, "ANAND", 6) == 0) {
-			/* first boot record */
-			if (boot_record_count == 0) {
-				unsigned int i;
-				/* header found : read the bad block table data */
-				if (mh->UnitSizeFactor != 0xff) {
-					printk("Sorry, we don't support UnitSizeFactor "
-					       "of != 1 yet\n");
-					goto ReplUnitTable;
-				}
+#if 0 /* Some people seem to have devices without ECC or erase marks
+	 on the Media Header blocks. There are enough other sanity
+	 checks in here that we can probably do without it.
+      */
+		if (le16_to_cpu(h1.EraseMark | h1.EraseMark1) != ERASE_MARK) {
+			printk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but erase mark not present (0x%04x,0x%04x instead)\n",
+			       block * nftl->EraseSize, nftl->mtd->index, 
+			       le16_to_cpu(h1.EraseMark), le16_to_cpu(h1.EraseMark1));
+			continue;
+		}
 
-				nftl->nb_boot_blocks = le16_to_cpu(mh->FirstPhysicalEUN);
-				if ((nftl->nb_boot_blocks + 2) >= nftl->nb_blocks)
-					goto ReplUnitTable; /* small consistency check */
-
-				nftl->numvunits = le32_to_cpu(mh->FormattedSize) / nftl->EraseSize;
-				if (nftl->numvunits > (nftl->nb_blocks - nftl->nb_boot_blocks - 2))
-					goto ReplUnitTable; /* small consistency check */
-
-				/* FixMe: with bad blocks, the total size available is not FormattedSize any
-				   more !!! */
-				nftl->nr_sects  = nftl->numvunits * (nftl->EraseSize / SECTORSIZE);
-				nftl->MediaUnit = block;
-
-				/* read the Bad Erase Unit Table and modify ReplUnitTable[] accordingly */
-				for (i = 0; i < nftl->nb_blocks; i++) {
-					if ((i & (SECTORSIZE - 1)) == 0) {
-						/* read one sector for every SECTORSIZE of blocks */
-						if (MTD_READECC(nftl->mtd, block * nftl->EraseSize +
-								i + SECTORSIZE, SECTORSIZE,
-								&retlen, buf, (char *)&oob) < 0)
-							goto ReplUnitTable;
-					}
-					/* mark the Bad Erase Unit as RESERVED in ReplUnitTable */
-					if (buf[i & (SECTORSIZE - 1)] != 0xff)
-						nftl->ReplUnitTable[i] = BLOCK_RESERVED;
-				}
+		/* Finally reread to check ECC */
+		if ((ret = MTD_READECC(nftl->mtd, block * nftl->EraseSize, SECTORSIZE,
+				&retlen, buf, (char *)&oob) < 0)) {
+			printk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but ECC read failed (err %d)\n",
+			       block * nftl->EraseSize, nftl->mtd->index, ret);
+			continue;
+		}
 
-				boot_record_count++;
-			} else if (boot_record_count == 1) {
-				nftl->SpareMediaUnit = block;
-				boot_record_count++;
-				break;
+		/* Paranoia. Check the ANAND header is still there after the ECC read */
+		if (memcmp(buf, "ANAND", 6)) {
+			printk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but went away on reread!\n",
+			       block * nftl->EraseSize, nftl->mtd->index);
+			printk(KERN_NOTICE "New data are: %02x %02x %02x %02x %02x %02x\n",
+			       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+			continue;
+		}
+#endif
+			       
+		/* OK, we like it. */
+
+		if (boot_record_count) {
+			/* We've already processed one. So we just check if
+			   this one is the same as the first one we found */
+			if (memcmp(mh, buf, sizeof(struct NFTLMediaHeader))) {
+				printk(KERN_NOTICE "NFTL Media Headers at 0x%x and 0x%x disagree.\n",
+				       nftl->MediaUnit * nftl->EraseSize, block * nftl->EraseSize);
+				/* if (debug) Print both side by side */
+				return -1;
 			}
+			if (boot_record_count == 1)
+				nftl->SpareMediaUnit = block;
+
+			boot_record_count++;
+			continue;
 		}
-	ReplUnitTable:;
-	}
 
-	if (boot_record_count == 0) {
-		/* no boot record found */
-		return -1;
-	} else {
-		return 0;
-	}
+		/* This is the first we've seen. Copy the media header structure into place */
+		memcpy(mh, buf, sizeof(struct NFTLMediaHeader));
+
+		/* Do some sanity checks on it */
+		if (mh->UnitSizeFactor != 0xff) {
+			printk(KERN_NOTICE "Sorry, we don't support UnitSizeFactor "
+			       "of != 1 yet.\n");
+			return -1;
+		}
+
+		nftl->nb_boot_blocks = le16_to_cpu(mh->FirstPhysicalEUN);
+		if ((nftl->nb_boot_blocks + 2) >= nftl->nb_blocks) {
+			printk(KERN_NOTICE "NFTL Media Header sanity check failed:\n");
+			printk(KERN_NOTICE "nb_boot_blocks (%d) + 2 > nb_blocks (%d)\n", 
+			       nftl->nb_boot_blocks, nftl->nb_blocks);
+			return -1;
+		}
+
+		nftl->numvunits = le32_to_cpu(mh->FormattedSize) / nftl->EraseSize;
+		if (nftl->numvunits > (nftl->nb_blocks - nftl->nb_boot_blocks - 2)) {
+			printk(KERN_NOTICE "NFTL Media Header sanity check failed:\n");
+			printk(KERN_NOTICE "numvunits (%d) > nb_blocks (%d) - nb_boot_blocks(%d) - 2\n",
+			       nftl->numvunits, nftl->nb_blocks, nftl->nb_boot_blocks);
+			return -1;
+		}
+		
+		nftl->nr_sects  = nftl->numvunits * (nftl->EraseSize / SECTORSIZE);
+		
+		/* If we're not using the last sectors in the device for some reason,
+		   reduce nb_blocks accordingly so we forget they're there */
+		nftl->nb_blocks = le16_to_cpu(mh->NumEraseUnits) + le16_to_cpu(mh->FirstPhysicalEUN);
+
+		/* read the Bad Erase Unit Table and modify ReplUnitTable[] accordingly */
+		for (i = 0; i < nftl->nb_blocks; i++) {
+			if ((i & (SECTORSIZE - 1)) == 0) {
+				/* read one sector for every SECTORSIZE of blocks */
+				if ((ret = MTD_READECC(nftl->mtd, block * nftl->EraseSize +
+						       i + SECTORSIZE, SECTORSIZE,
+						       &retlen, buf, (char *)&oob)) < 0) {
+					printk(KERN_NOTICE "Read of bad sector table failed (err %d)\n",
+					       ret);
+					return -1;
+				}
+			}
+			/* mark the Bad Erase Unit as RESERVED in ReplUnitTable */
+			if (buf[i & (SECTORSIZE - 1)] != 0xff)
+				nftl->ReplUnitTable[i] = BLOCK_RESERVED;
+		}
+		
+		nftl->MediaUnit = block;
+		boot_record_count++;
+		
+	} /* foreach (block) */
+		
+	return boot_record_count?0:-1;
 }
 
 static int memcmpb(void *a, int c, int n)
@@ -359,8 +428,7 @@
 {
 	struct nftl_uci1 h1;
 	unsigned int erase_mark;
-	int i, retlen;
-	unsigned char buf[SECTORSIZE];
+	int retlen;
 
 	/* check erase mark. */
 	if (MTD_READOOB(nftl->mtd, block * nftl->EraseSize + SECTORSIZE + 8, 8, 
diff -Naur linux-2.4.2.orig/drivers/mtd/nora.c linux-2.4.2/drivers/mtd/nora.c
--- linux-2.4.2.orig/drivers/mtd/nora.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/nora.c	Fri Feb 15 14:41:16 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: nora.c,v 1.17 2000/12/03 19:32:21 dwmw2 Exp $
+ * $Id: nora.c,v 1.18 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * This is so simple I love it.
  */
@@ -179,9 +179,7 @@
 
 	mymtd = do_cfi_probe(&nora_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
 		
 		add_mtd_device(&nora_mtds[2]);
 		add_mtd_device(&nora_mtds[0]);
diff -Naur linux-2.4.2.orig/drivers/mtd/octagon-5066.c linux-2.4.2/drivers/mtd/octagon-5066.c
--- linux-2.4.2.orig/drivers/mtd/octagon-5066.c	Sat Feb 17 01:02:36 2001
+++ linux-2.4.2/drivers/mtd/octagon-5066.c	Fri Feb 15 14:41:16 2002
@@ -1,4 +1,4 @@
-// $Id: octagon-5066.c,v 1.12.2.1 2001/02/15 10:12:48 dwmw2 Exp $
+// $Id: octagon-5066.c,v 1.15 2001/03/17 16:17:35 dwmw2 Exp $
 /* ######################################################################
 
    Octagon 5066 MTD Driver. 
@@ -25,7 +25,7 @@
    ##################################################################### */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <asm/io.h>
@@ -188,7 +188,7 @@
    change pages while monitoring the window. A change in the window, 
    controlled by the PAGE_IO port is a functioning 5066 board. This will
    fail if the thing in the socket is set to a uniform value. */
-static int __init OctProbe()
+static int __init OctProbe(void)
 {
    unsigned int Base = (1 << 6);
    unsigned long I;
@@ -264,9 +264,9 @@
 		if (!oct5066_mtd[i])
 			oct5066_mtd[i] = do_jedec_probe(&oct5066_map[i]);
 		if (!oct5066_mtd[i])
-			oct5066_mtd[i] = do_ram_probe(&oct5066_map[i]);
+			oct5066_mtd[i] = do_map_ram_probe(&oct5066_map[i]);
 		if (!oct5066_mtd[i])
-			oct5066_mtd[i] = do_rom_probe(&oct5066_map[i]);
+			oct5066_mtd[i] = do_map_rom_probe(&oct5066_map[i]);
 		if (oct5066_mtd[i]) {
 			oct5066_mtd[i]->module = THIS_MODULE;
 			add_mtd_device(oct5066_mtd[i]);
diff -Naur linux-2.4.2.orig/drivers/mtd/physmap.c linux-2.4.2/drivers/mtd/physmap.c
--- linux-2.4.2.orig/drivers/mtd/physmap.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/physmap.c	Fri Feb 15 14:41:16 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: physmap.c,v 1.8 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: physmap.c,v 1.11 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * Normal mappings of chips in physical memory
  */
@@ -21,17 +21,17 @@
 
 __u8 physmap_read8(struct map_info *map, unsigned long ofs)
 {
-	return readb(map->map_priv_1 + ofs);
+	return __raw_readb(map->map_priv_1 + ofs);
 }
 
 __u16 physmap_read16(struct map_info *map, unsigned long ofs)
 {
-	return readw(map->map_priv_1 + ofs);
+	return __raw_readw(map->map_priv_1 + ofs);
 }
 
 __u32 physmap_read32(struct map_info *map, unsigned long ofs)
 {
-	return readl(map->map_priv_1 + ofs);
+	return __raw_readl(map->map_priv_1 + ofs);
 }
 
 void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
@@ -41,17 +41,20 @@
 
 void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
 {
-	writeb(d, map->map_priv_1 + adr);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
 {
-	writew(d, map->map_priv_1 + adr);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
 {
-	writel(d, map->map_priv_1 + adr);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
@@ -78,7 +81,7 @@
 #define cleanup_physmap cleanup_module
 #endif
 
-int __init init_physmap(void)
+mod_init_t init_physmap(void)
 {
        	printk(KERN_NOTICE "physmap flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 	physmap_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
@@ -89,9 +92,8 @@
 	}
 	mymtd = do_cfi_probe(&physmap_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
+
 		add_mtd_device(mymtd);
 		return 0;
 	}
@@ -100,7 +102,7 @@
 	return -ENXIO;
 }
 
-static void __exit cleanup_physmap(void)
+mod_exit_t cleanup_physmap(void)
 {
 	if (mymtd) {
 		del_mtd_device(mymtd);
diff -Naur linux-2.4.2.orig/drivers/mtd/pmc551.c linux-2.4.2/drivers/mtd/pmc551.c
--- linux-2.4.2.orig/drivers/mtd/pmc551.c	Sat Feb 17 01:02:36 2001
+++ linux-2.4.2/drivers/mtd/pmc551.c	Fri Feb 15 14:41:16 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.c,v 1.11 2000/11/23 13:40:12 dwmw2 Exp $
+ * $Id: pmc551.c,v 1.13 2001/01/11 15:08:59 dwmw2 Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -78,7 +78,7 @@
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -483,7 +483,7 @@
         pci_write_config_word( dev, PMC551_SDRAM_CMD, 0x00bf );
 
         /*
-         * Wait until command has gone through
+         * Wait untill command has gone through
          * FIXME: register spinning issue
          */
         do {	pci_read_config_word( dev, PMC551_SDRAM_CMD, &cmd );
@@ -635,13 +635,11 @@
 /*
  * Kernel version specific module stuffages
  */
-#if LINUX_VERSION_CODE < 0x20211
-#ifdef MODULE
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_pmc551 init_module
 #define cleanup_pmc551 cleanup_module
 #endif
-#define __exit
-#endif
 
 #if defined(MODULE)
 MODULE_AUTHOR("Mark Ferrell <mferrell@mvista.com>");
@@ -709,7 +707,7 @@
                        PCI_Device->irq);
 
                 /*
-                 * The PMC551 device acts VERY weird if you don't init it
+                 * The PMC551 device acts VERY wierd if you don't init it
                  * first.  i.e. it will not correctly report devsel.  If for
                  * some reason the sdram is in a wrote-protected state the
                  * device will DEVSEL when it is written to causing problems
@@ -804,7 +802,7 @@
 
                 if (add_mtd_device(mtd)) {
                         printk(KERN_NOTICE "pmc551: Failed to register new device\n");
-			iounmap(priv->start);
+			iounmap(((struct mypriv *)mtd->priv)->start);
                         kfree(mtd->priv);
                         kfree(mtd);
                         break;
@@ -857,7 +855,5 @@
 	printk(KERN_NOTICE "pmc551: %d pmc551 devices unloaded\n", found);
 }
 
-#if LINUX_VERSION_CODE >= 0x20211
 module_init(init_pmc551);
 module_exit(cleanup_pmc551);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/pnc2000.c linux-2.4.2/drivers/mtd/pnc2000.c
--- linux-2.4.2.orig/drivers/mtd/pnc2000.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/pnc2000.c	Fri Feb 15 14:41:16 2002
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: pnc2000.c,v 1.4 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: pnc2000.c,v 1.6 2000/12/21 23:52:43 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -107,11 +107,11 @@
 static struct mtd_info *mymtd;
 
 #if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
-#define init_pnc init_module
+#define init_pnc2000 init_module
 #define cleanup_pnc cleanup_module
 #endif
 
-int __init init_pnc(void)
+int __init init_pnc2000(void)
 {
 	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 
@@ -124,7 +124,7 @@
 	return -ENXIO;
 }
 
-static void __exit cleanup_pnc(void)
+static void __exit cleanup_pnc2000(void)
 {
 	if (mymtd) {
 		del_mtd_partitions(mymtd);
@@ -132,5 +132,5 @@
 	}
 }
 
-module_init(init_pnc);
-module_exit(cleanup_pnc);
+module_init(init_pnc2000);
+module_exit(cleanup_pnc2000);
diff -Naur linux-2.4.2.orig/drivers/mtd/redboot.c linux-2.4.2/drivers/mtd/redboot.c
--- linux-2.4.2.orig/drivers/mtd/redboot.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/redboot.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,162 @@
+/*
+ * $Id: redboot.c,v 1.6 2001/10/25 09:16:06 dwmw2 Exp $
+ *
+ * Parse RedBoot-style Flash Image System (FIS) tables and
+ * produce a Linux partition array to match.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+struct fis_image_desc {
+    unsigned char name[16];      // Null terminated name
+    unsigned long flash_base;    // Address within FLASH of image
+    unsigned long mem_base;      // Address in memory where it executes
+    unsigned long size;          // Length of image
+    unsigned long entry_point;   // Execution entry point
+    unsigned long data_length;   // Length of actual data
+    unsigned char _pad[256-(16+7*sizeof(unsigned long))];
+    unsigned long desc_cksum;    // Checksum over image descriptor
+    unsigned long file_cksum;    // Checksum over image data
+};
+
+struct fis_list {
+	struct fis_image_desc *img;
+	struct fis_list *next;
+};
+
+static inline int redboot_checksum(struct fis_image_desc *img)
+{
+	/* RedBoot doesn't actually write the desc_cksum field yet AFAICT */
+	return 1;
+}
+
+int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+{
+	int nrparts = 0;
+	struct fis_image_desc *buf;
+	struct mtd_partition *parts;
+	struct fis_list *fl = NULL, *tmp_fl;
+	int ret, i;
+	size_t retlen;
+	char *names;
+	int namelen = 0;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	/* Read the start of the last erase block */
+	ret = master->read(master, master->size - master->erasesize,
+			   PAGE_SIZE, &retlen, (void *)buf);
+
+	if (ret)
+		goto out;
+
+	if (retlen != PAGE_SIZE) {
+		ret = -EIO;
+		goto out;
+	}
+
+	/* RedBoot image could appear in any of the first three slots */
+	for (i = 0; i < 3; i++) {
+		if (!memcmp(buf[i].name, "RedBoot", 8))
+			break;
+	}
+	if (i == 3) {
+		/* Didn't find it */
+		printk(KERN_NOTICE "No RedBoot partition table detected in %s\n",
+		       master->name);
+		ret = 0;
+		goto out;
+	}
+
+	for (i = 0; i < PAGE_SIZE / sizeof(struct fis_image_desc); i++) {
+		struct fis_list *new_fl, **prev;
+
+		if (buf[i].name[0] == 0xff)
+			break;
+		if (!redboot_checksum(&buf[i]))
+			break;
+
+		new_fl = kmalloc(sizeof(struct fis_list), GFP_KERNEL);
+		namelen += strlen(buf[i].name)+1;
+		if (!new_fl) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		new_fl->img = &buf[i];
+		buf[i].flash_base &= master->size-1;
+
+		/* I'm sure the JFFS2 code has done me permanent damage.
+		 * I now think the following is _normal_
+		 */
+		prev = &fl;
+		while(*prev && (*prev)->img->flash_base < new_fl->img->flash_base)
+			prev = &(*prev)->next;
+		new_fl->next = *prev;
+		*prev = new_fl;
+
+		nrparts++;
+	}
+	if (fl->img->flash_base)
+		nrparts++;
+
+	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
+		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize < tmp_fl->next->img->flash_base)
+			nrparts++;
+	}
+	parts = kmalloc(sizeof(*parts)*nrparts + namelen, GFP_KERNEL);
+
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	names = (char *)&parts[nrparts];
+	memset(parts, 0, sizeof(*parts)*nrparts + namelen);
+	i=0;
+
+	if (fl->img->flash_base) {
+	       parts[0].name = "unallocated space";
+	       parts[0].size = fl->img->flash_base;
+	       parts[0].offset = 0;
+	}
+	for ( ; i<nrparts; i++) {
+		parts[i].size = fl->img->size;
+		parts[i].offset = fl->img->flash_base;
+		parts[i].name = names;
+
+		strcpy(names, fl->img->name);
+		names += strlen(names)+1;
+
+		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize < fl->next->img->flash_base) {
+			i++;
+			parts[i].offset = parts[i-1].size + parts[i-1].offset;
+			parts[i].size = fl->next->img->flash_base - parts[i].offset;
+			parts[i].name = "unallocated space";
+		}
+		tmp_fl = fl;
+		fl = fl->next;
+		kfree(tmp_fl);
+	}
+	ret = nrparts;
+	*pparts = parts;
+ out:
+	while (fl) {
+		struct fis_list *old = fl;
+		fl = fl->next;
+		kfree(old);
+	}
+	kfree(buf);
+	return ret;
+}
+
+EXPORT_SYMBOL(parse_redboot_partitions);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>");
+MODULE_DESCRIPTION("Parsing code for RedBoot Flash Image System (FIS) tables");
diff -Naur linux-2.4.2.orig/drivers/mtd/rpxlite.c linux-2.4.2/drivers/mtd/rpxlite.c
--- linux-2.4.2.orig/drivers/mtd/rpxlite.c	Sun Feb  4 19:05:30 2001
+++ linux-2.4.2/drivers/mtd/rpxlite.c	Fri Feb 15 14:41:16 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: rpxlite.c,v 1.8 2000/12/09 22:00:31 dwmw2 Exp $
+ * $Id: rpxlite.c,v 1.11 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * Handle mapping of the flash on the RPX Lite and CLLF boards
  */
@@ -19,7 +19,7 @@
 
 __u8 rpxlite_read8(struct map_info *map, unsigned long ofs)
 {
-	return readb(map->map_priv_1 * ofs);
+	return readb(map->map_priv_1 + ofs);
 }
 
 __u16 rpxlite_read16(struct map_info *map, unsigned long ofs)
@@ -87,9 +87,7 @@
 	}
 	mymtd = do_cfi_probe(&rpxlite_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
 		add_mtd_device(mymtd);
 		return 0;
 	}
diff -Naur linux-2.4.2.orig/drivers/mtd/sa1100-flash.c linux-2.4.2/drivers/mtd/sa1100-flash.c
--- linux-2.4.2.orig/drivers/mtd/sa1100-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sa1100-flash.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,534 @@
+/*
+ * Flash memory access on SA11x0 based devices
+ * 
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ * 
+ * $Id: sa1100-flash.c,v 1.9 2001/03/26 12:02:19 dwmw2 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+
+
+#ifndef CONFIG_ARCH_SA1100
+#error This is for SA1100 architecture only
+#endif
+
+
+#define WINDOW_ADDR 0xe8000000
+
+static __u8 sa1100_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(WINDOW_ADDR + ofs);
+}
+
+static __u16 sa1100_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(WINDOW_ADDR + ofs);
+}
+
+static __u32 sa1100_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(WINDOW_ADDR + ofs);
+}
+
+static void sa1100_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(WINDOW_ADDR + from), len);
+}
+
+static void sa1100_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(WINDOW_ADDR + to), from, len);
+}
+
+
+#ifdef CONFIG_SA1100_BITSY
+
+static void bitsy_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp)
+		set_bitsy_egpio(EGPIO_BITSY_VPP_ON);
+	else
+		clr_bitsy_egpio(EGPIO_BITSY_VPP_ON);
+}
+
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+
+static void jornada720_set_vpp(int vpp)
+{
+  if (vpp)
+      PPSR |= 0x80;
+  else
+      PPSR &= ~0x80;
+  PPDR |= 0x80;
+}
+
+#endif
+
+static struct map_info sa1100_map = {
+	name:		"SA1100",
+	read8:		sa1100_read8,
+	read16:		sa1100_read16,
+	read32:		sa1100_read32,
+	copy_from:	sa1100_copy_from,
+	write8:		sa1100_write8,
+	write16:	sa1100_write16,
+	write32:	sa1100_write32,
+	copy_to:	sa1100_copy_to
+};
+
+
+/*
+ * Here are partition information for all known SA1100-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ * 
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the 
+ * value specified in the mapping definition in arch/arm/mm/mm-sa1100.c 
+ * for the corresponding machine.
+ */
+
+#ifdef CONFIG_SA1100_ASSABET
+
+static unsigned long assabet_max_flash_size = 0x02000000;
+static struct mtd_partition assabet_partitions[] = {
+	{ offset: 0,			size: 0x00040000, 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x000c0000, 	},
+	{ offset: MTDPART_OFS_APPEND,	size: MTDPART_SIZ_FULL 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+static unsigned long huw_webpanel_max_flash_size = 0x01000000;
+static struct mtd_partition huw_webpanel_partitions[] = {
+	{ 
+	  name: "Loader",
+	  size: 0x00040000,
+	  offset: 0,
+	},{
+	  name: "Sector 1",
+	  size: 0x00040000,
+	  offset: MTDPART_OFS_APPEND,
+	},{
+	  size: MTDPART_SIZ_FULL,
+	  offset: MTDPART_OFS_APPEND,
+	}
+};
+#endif /* CONFIG_SA1100_HUW_WEBPANEL */
+
+
+#ifdef CONFIG_SA1100_BITSY
+
+static unsigned long bitsy_max_flash_size = 0x02000000;
+static struct mtd_partition bitsy_partitions[] = {
+	{
+		name: "BITSY boot firmware",
+		size: 0x00040000,
+		offset: 0,
+		mask_flags: MTD_WRITEABLE  /* force read-only */
+	},{
+		name: "BITSY kernel",
+		size: 0x00080000,
+		offset: 0x40000
+	},{
+		name: "BITSY params",
+		size: 0x00040000,
+		offset: 0xC0000
+	},{
+#ifdef CONFIG_JFFS2_FS
+		name: "BITSY root jffs2",
+		offset: 0x00100000,
+		size: MTDPART_SIZ_FULL
+#else
+		name: "BITSY initrd",
+		size: 0x00100000,
+		offset: 0x00100000
+	},{
+		name: "BITSY root cramfs",
+		size: 0x00300000,
+		offset: 0x00200000
+	},{
+		name: "BITSY usr cramfs",
+		size: 0x00800000,
+		offset: 0x00500000
+	},{
+		name: "BITSY usr local",
+		offset: 0x00d00000,
+		size: MTDPART_SIZ_FULL
+#endif
+	}
+};
+
+#endif
+#ifdef CONFIG_SA1100_FREEBIRD
+static unsigned long freebird_max_flash_size = 0x02000000;
+static struct mtd_partition freebird_partitions[] = {
+#if CONFIG_SA1100_FREEBIRD_NEW
+    {
+     name: "firmware",
+     size: 0x00040000,
+     offset: 0,
+     mask_flags: MTD_WRITEABLE  /* force read-only */
+    },{
+     name: "kernel",
+     size: 0x00080000,
+     offset: 0x40000
+    },{
+     name: "params",
+     size: 0x00040000,
+     offset: 0xC0000
+    },{
+     name: "initrd",
+     size: 0x00100000,
+     offset: 0x00100000
+    },{
+     name: "root cramfs",
+     size: 0x00300000,
+     offset: 0x00200000
+    },{
+     name: "usr cramfs",
+     size: 0x00800000,
+     offset: 0x00500000
+    },{
+	 name: "local",
+	 offset: 0x00d00000,
+	 size: 0
+	}
+#else
+	{ offset: 0,            		size: 0x00040000,   },
+	{ offset: MTDPART_OFS_APPEND,   size: 0x000c0000,   },
+	{ offset: MTDPART_OFS_APPEND,	size: 0x00400000,	},
+	{ offset: MTDPART_OFS_APPEND,   size: MTDPART_SIZ_FULL  }
+#endif
+	};
+#endif
+																									
+
+#ifdef CONFIG_SA1100_CERF
+
+static unsigned long cerf_max_flash_size = 0x01000000;
+static struct mtd_partition cerf_partitions[] = {
+	{ offset: 0,			size: 0x00800000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x00800000 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+
+static unsigned long graphicsclient_max_flash_size = 0x01000000;
+static struct mtd_partition graphicsclient_partitions[] = {
+	{ 
+	 name: "Bootloader + zImage",
+	 offset: 0,
+	 size: 0x100000
+	},
+	{ 
+         name: "ramdisk.gz",
+         offset: MTDPART_OFS_APPEND,
+         size: 0x300000 		
+	},
+	{ 
+	  name: "User FS",
+          offset: MTDPART_OFS_APPEND,	
+          size: MTDPART_SIZ_FULL
+	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_LART
+
+static unsigned long lart_max_flash_size = 0x00400000;
+static struct mtd_partition lart_partitions[] = {
+	{ offset: 0,			size: 0x020000 		},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x0e0000 		},
+	{ offset: MTDPART_OFS_APPEND,	size: MTDPART_SIZ_FULL 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+
+static unsigned long pangolin_max_flash_size = 0x04000000;
+static struct mtd_partition pangolin_partitions[] = {
+	{
+	  name: "boot firmware",
+	  offset: 0x00000000,
+	  size: 0x00080000,
+	  mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  name: "kernel",
+	  offset: 0x00080000,
+	  size: 0x00100000,
+	},
+	{
+	  name: "initrd",
+	  offset: 0x00180000,
+	  size: 0x00200000,
+	},
+	{
+	  name: "initrd-test",
+	  offset: 0x00400000,
+	  size: 0x03C00000,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+
+static unsigned long yopy_max_flash_size = 0x08000000;
+static struct mtd_partition yopy_partitions[] = {
+	{
+		name: "boot firmware",
+		offset: 0x00000000,
+		size: 0x00040000,
+		mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		name: "kernel",
+		offset: 0x00080000,
+		size: 0x00080000,
+	},
+	{
+		name: "initrd",
+		offset: 0x00100000,
+		size: 0x00300000,
+	},
+	{
+		name: "root",
+		offset: 0x00400000,
+		size: 0x01000000,
+	},
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+
+static unsigned long jornada720_max_flash_size = 0x02000000;
+static struct mtd_partition jornada720_partitions[] = {
+	{
+		name: "JORNADA720 boot firmware",
+		size: 0x00040000,
+		offset: 0,
+		mask_flags: MTD_WRITEABLE  /* force read-only */
+	},{
+		name: "JORNADA720 kernel",
+		size: 0x000c0000,
+		offset: 0x40000
+	},{
+		name: "JORNADA720 params",
+		size: 0x00040000,
+		offset: 0x100000
+	},{
+		name: "JORNADA720 initrd",
+		size: 0x00100000,
+		offset: 0x00140000
+	},{
+		name: "JORNADA720 root cramfs",
+		size: 0x00300000,
+		offset: 0x00240000
+	},{
+		name: "JORNADA720 usr cramfs",
+		size: 0x00800000,
+		offset: 0x00540000
+	},{
+		name: "JORNADA720 usr local",
+		offset: 0x00d00000,
+		size: 0  /* will expand to the end of the flash */
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+
+static unsigned long sherman_max_flash_size = 0x02000000;
+static struct mtd_partition sherman_partitions[] = {
+	{ offset: 0,			size: 0x50000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x70000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x600000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0xA0000 	}
+};
+
+#endif
+
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+static int redboot_nr_parts;
+static struct mtd_partition *redboot_parts;
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+
+int __init sa1100_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int buswidth = (MSC0 & MSC_RBW) ? 2 : 4;
+	
+#ifdef CONFIG_SA1100_ASSABET
+	if (machine_is_assabet()) {
+		parts = assabet_partitions;
+		nb_parts = NB_OF(assabet_partitions);
+		sa1100_map.size = assabet_max_flash_size;
+	}
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+	if (machine_is_huw_webpanel()) {
+		parts = huw_webpanel_partitions;
+		nb_parts = NB_OF(huw_webpanel_partitions);
+		sa1100_map.size = huw_webpanel_max_flash_size;
+	}
+#endif
+
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		parts = bitsy_partitions;
+		nb_parts = NB_OF(bitsy_partitions);
+		sa1100_map.size = bitsy_max_flash_size;
+		sa1100_map.set_vpp = bitsy_set_vpp;
+	}
+#endif
+#ifdef CONFIG_SA1100_FREEBIRD
+	if (machine_is_freebird()) {
+		parts = freebird_partitions;
+		nb_parts = NB_OF(freebird_partitions);
+		sa1100_map.size = freebird_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_CERF
+	if (machine_is_cerf()) {
+		parts = cerf_partitions;
+		nb_parts = NB_OF(cerf_partitions);
+		sa1100_map.size = cerf_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+	if (machine_is_graphicsclient()) {
+		parts = graphicsclient_partitions;
+		nb_parts = NB_OF(graphicsclient_partitions);
+		sa1100_map.size = graphicsclient_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_LART
+	if (machine_is_lart()) {
+		parts = lart_partitions;
+		nb_parts = NB_OF(lart_partitions);
+		sa1100_map.size = lart_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_PANGOLIN
+	if (machine_is_pangolin()) {
+		parts = pangolin_partitions;
+		nb_parts = NB_OF(pangolin_partitions);
+		sa1100_map.size = pangolin_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_JORNADA720
+	if (machine_is_jornada720()) {
+		parts = jornada720_partitions;
+		nb_parts = NB_OF(jornada720_partitions);
+		sa1100_map.size = jornada720_max_flash_size;
+		sa1100_map.set_vpp = jornada720_set_vpp;
+	}
+#endif
+#ifdef CONFIG_SA1100_YOPY
+	if (machine_is_yopy()) {
+		parts = yopy_partitions;
+		nb_parts = NB_OF(yopy_partitions);
+		sa1100_map.size = yopy_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_SHERMAN
+	if (machine_is_sherman()) {
+		parts = sherman_partitions;
+		nb_parts = NB_OF(sherman_partitions);
+		sa1100_map.size = sherman_max_flash_size;
+	}
+#endif
+	sa1100_map.buswidth = buswidth;
+
+	if (!nb_parts) {
+		printk(KERN_WARNING "MTD: no known flash definition for this SA1100 machine\n");
+		return -ENXIO;
+	}
+	printk(KERN_NOTICE "SA1100 flash: probing for %d partitions (buswidth = %d)\n",
+		nb_parts, buswidth);
+
+	mymtd = do_cfi_probe(&sa1100_map);
+	if (!mymtd)
+		return -ENXIO;
+
+	mymtd->module = THIS_MODULE;
+
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+	redboot_nr_parts = parse_redboot_partitions(mymtd, &redboot_parts);
+	if (redboot_nr_parts > 0) {
+		int i;
+
+		parts = redboot_parts;
+		nb_parts = redboot_nr_parts;
+
+		for (i=0; i<nb_parts; i++) {
+			printk(KERN_NOTICE "RedBoot Partition: \"%s\", 0x%08lx-0x%08lx\n",
+			       parts[i].name, parts[i].offset, parts[i].offset+parts[i].size);
+		}
+	} else {
+		printk(KERN_NOTICE "No RedBoot partition table found. Using default partitioning\n");
+	}
+#endif
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	printk(KERN_NOTICE "SA1100 flash access initialized\n");
+	return 0;
+}
+
+static void __exit sa1100_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+		if (redboot_parts)
+			kfree(redboot_parts);
+#endif
+	}
+}
+
+module_init(sa1100_mtd_init);
+module_exit(sa1100_mtd_cleanup);
diff -Naur linux-2.4.2.orig/drivers/mtd/sbc_mediagx.c linux-2.4.2/drivers/mtd/sbc_mediagx.c
--- linux-2.4.2.orig/drivers/mtd/sbc_mediagx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sbc_mediagx.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,250 @@
+/* sbc_mediagx.c -- MTD map driver for Arcom Control Systems SBC-MediaGX
+ 
+   Copyright (C) 2000 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: sbc_mediagx.c,v 1.11 2001/03/17 16:24:05 dwmw2 Exp $
+
+The SBC-MediaGX has up to 16 Mbyte of Intel StrataFlash (28F320/28F640) in x8
+mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   16 kbyte memory window at 0xdc000-0xdffff
+   Two IO address locations for paging
+   0x258
+       bit 0-7: address bit 14-21
+   0x259
+       bit 0-1: address bit 22-23
+       bit 7:   0 - reset/powered down
+                1 - device enabled
+
+The single flash device is divided into 3 partition which appear as seperate
+MTD devices.
+*/
+#include <linux/module.h>
+#include <linux/malloc.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_START 0xdc000
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 14
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x258
+#define PAGE_IO_SIZE 2
+
+/* bit 7 of 0x259 must be 1 to enable device. */
+#define DEVICE_ENABLE 0x8000
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t sbc_mediagx_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "SBC-MediaGX flash boot partition", 
+      offset: 0, 
+      size: 640*1024 },
+    { name: "SBC-MediaGX flash partition 1", 
+      offset: 640*1024, 
+      size: 2*1024*1024-640*1024 },
+    { name: "SBC-MediaGX flash partition 2", 
+      offset: 2*1024*1024 }
+};
+#define NUM_PARTITIONS 3
+
+static inline void sbc_mediagx_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+
+	if( page!=page_in_window ) {
+		outw( page | DEVICE_ENABLE, PAGE_IO );
+		page_in_window = page;
+	}
+}
+
+
+static __u8 sbc_mediagx_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static __u16 sbc_mediagx_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static __u32 sbc_mediagx_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static void sbc_mediagx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&sbc_mediagx_spin);
+		sbc_mediagx_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&sbc_mediagx_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void sbc_mediagx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&sbc_mediagx_spin);
+		sbc_mediagx_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&sbc_mediagx_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info sbc_mediagx_map = {
+	name: "SBC-MediaGX flash",
+	size: 16*1024*1024, /* this must be set to a maximum possible amount
+			 of flash so the cfi probe routines find all
+			 the chips */
+	buswidth: 1,
+	read8: sbc_mediagx_read8,
+	read16: sbc_mediagx_read16,
+	read32: sbc_mediagx_read32,
+	copy_from: sbc_mediagx_copy_from,
+	write8: sbc_mediagx_write8,
+	write16: sbc_mediagx_write16,
+	write32: sbc_mediagx_write32,
+	copy_to: sbc_mediagx_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_sbc_mediagx init_module
+#define cleanup_sbc_mediagx cleanup_module
+#endif
+
+mod_exit_t cleanup_sbc_mediagx(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+mod_init_t init_sbc_mediagx(void)
+{
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			sbc_mediagx_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			sbc_mediagx_map.name );
+		return -EIO;
+	}
+	
+	request_region( PAGE_IO, PAGE_IO_SIZE, "SBC-MediaGX flash" );
+	
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		sbc_mediagx_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	/* Probe for chip. */
+	all_mtd = do_cfi_probe( &sbc_mediagx_map );
+	if( !all_mtd ) {
+		cleanup_sbc_mediagx();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions(all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_sbc_mediagx);
+module_exit(cleanup_sbc_mediagx);
diff -Naur linux-2.4.2.orig/drivers/mtd/sc520cdp.c linux-2.4.2/drivers/mtd/sc520cdp.c
--- linux-2.4.2.orig/drivers/mtd/sc520cdp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sc520cdp.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,163 @@
+/* sc520cdp.c -- MTD map driver for AMD SC520 Customer Development Platform
+ *
+ * Copyright (C) 2001 Sysgo Real-Time Solutions GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * $Id: sc520cdp.c,v 1.2 2001/03/17 19:08:45 dwmw2 Exp $
+ *
+ *
+ * The SC520CDP is an evaluation board for the Elan SC520 processor available
+ * from AMD. It has two banks of 32-bit Flash ROM, each 8 Megabytes in size.
+ * For details see http://www.amd.com/products/epd/desiging/evalboards/18.elansc520/520_cdp_brief/index.html
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_ADDR_0	0x08400000
+#define WINDOW_ADDR_1	0x08C00000
+#define WINDOW_SIZE		0x00800000
+
+static __u8 sc520cdp_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 sc520cdp_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 sc520cdp_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void sc520cdp_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void sc520cdp_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info sc520cdp_map[] = {
+	{
+		name: "SC520CDP Flash Bank #0",
+		size: WINDOW_SIZE,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_0
+	},
+	{
+		name: "SC520CDP Flash Bank #1",
+		size: WINDOW_SIZE,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_1
+	},
+};
+
+#define NUM_FLASH_BANKS	(sizeof(sc520cdp_map)/sizeof(struct map_info))
+
+static struct mtd_info *mymtd[NUM_FLASH_BANKS];
+
+
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_sc520cdp init_module
+#define cleanup_sc520cdp cleanup_module
+#endif
+
+static int __init init_sc520cdp(void)
+{
+	int i;
+	
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		printk(KERN_NOTICE "SC520 CDP flash device: %x at %lx\n", WINDOW_SIZE, sc520cdp_map[i].map_priv_2);
+		sc520cdp_map[i].map_priv_1 = (unsigned long)ioremap(sc520cdp_map[i].map_priv_2, WINDOW_SIZE);
+
+		if (!sc520cdp_map[i].map_priv_1) {
+			printk("Failed to ioremap\n");
+			return -EIO;
+		}
+		mymtd[i] = do_cfi_probe(&sc520cdp_map[i]);
+		if (mymtd[i]) {
+			mymtd[i]->module = THIS_MODULE;
+			add_mtd_device(mymtd[i]);
+		}
+		else {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+			return -ENXIO;
+		}
+	}
+	return 0;
+}
+
+static void __exit cleanup_sc520cdp(void)
+{
+	int i;
+	
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		if (mymtd[i]) {
+			del_mtd_device(mymtd[i]);
+			map_destroy(mymtd[i]);
+		}
+		if (sc520cdp_map[i].map_priv_1) {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+			sc520cdp_map[i].map_priv_1 = 0;
+		}
+	}
+}
+
+module_init(init_sc520cdp);
+module_exit(cleanup_sc520cdp);
diff -Naur linux-2.4.2.orig/drivers/mtd/sharp.c linux-2.4.2/drivers/mtd/sharp.c
--- linux-2.4.2.orig/drivers/mtd/sharp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sharp.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,474 @@
+/*
+ * MTD map driver for pre-CFI Sharp flash chips
+ *
+ * Copyright 2000 David Schleef <ds@lineo.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/delay.h>
+
+struct mtd_info *sharp_probe(struct map_info *);
+
+static int sharp_probe_map(struct map_info *map);
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf);
+static int sharp_write(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, const u_char *buf);
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr);
+static void sharp_sync(struct mtd_info *mtd);
+static int sharp_suspend(struct mtd_info *mtd);
+static void sharp_resume(struct mtd_info *mtd);
+static void sharp_destroy(struct mtd_info *mtd);
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum);
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+
+static struct map_driver sharp_driver={
+	name:		"sharp",
+	module:		THIS_MODULE,
+	probe:		sharp_probe,
+};
+
+struct sharp_info{
+	struct flchip *chip;
+	int bogus;
+	int chipshift;
+	int numchips;
+	struct flchip chips[1];
+};
+
+
+struct mtd_info *sharp_probe(struct map_info *map)
+{
+	struct mtd_info *mtd = NULL;
+	struct sharp_info *sharp = NULL;
+	int width;
+
+	width = sharp_probe_map(map);
+	if(!width)
+		return NULL;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if(!mtd)
+		return NULL;
+
+	sharp = kmalloc(sizeof(*sharp), GFP_KERNEL);
+	if(!sharp)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	mtd->erasesize = 0x10000 * width;
+	mtd->size = 0x200000 * width;
+	mtd->erase = sharp_erase;
+	mtd->read = sharp_read;
+	mtd->write = sharp_write;
+	mtd->sync = sharp_sync;
+	mtd->suspend = sharp_suspend;
+	mtd->resume = sharp_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+
+	sharp->chipshift = 23;
+	sharp->numchips = 1;
+	sharp->chips[0].start = 0;
+	sharp->chips[0].state = FL_READY;
+	sharp->chips[0].mutex = &sharp->chips[0]._spinlock;
+	init_waitqueue_head(&sharp->chips[0].wq);
+	spin_lock_init(&sharp->chips[0]._spinlock);
+
+	map->fldrv_destroy = sharp_destroy;
+	map->fldrv_priv = sharp;
+
+	return mtd;
+}
+
+static int sharp_probe_map(struct map_info *map)
+{
+	unsigned long tmp;
+	unsigned long base = 0;
+	u32 read0, read4;
+
+	tmp = map->read32(map, base+0);
+
+	map->write32(map, 0x90909090, base+0);
+
+	read0=map->read32(map, base+0);
+	read4=map->read32(map, base+4);
+	if(read0 == 0x89898989){
+		printk("Looks like sharp flash\n");
+		if((read4 == 0xaaaaaaaa) || (read4 == 0xa0a0a0a0)) {
+			/* aa - 16Mb (that's 2MB to you and me) */
+			/* a0 - 16Mb -Z4 */
+			return 4;
+		}else{
+			printk("Sort-of looks like sharp flash, 0x%08x 0x%08x\n",
+				read0,read4);
+		}
+	}else if((map->read32(map, base+0) == 0x90909090)){
+		/* RAM, probably */
+		printk("Looks like RAM\n");
+		map->write32(map, tmp, base+0);
+	}else{
+		printk("Doesn't look like sharp flash, 0x%08x 0x%08x\n",
+			read0,read4);
+	}
+
+	return 0;
+}
+
+/* This function returns with the chip->mutex lock held. */
+static int sharp_wait(struct map_info *map, struct flchip *chip)
+{
+	__u16 status;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+	int adr = 0;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	switch(chip->state){
+	case FL_READY:
+		map->write32(map,0x70707070,adr);
+		chip->state = FL_STATUS;
+	case FL_STATUS:
+		status = map->read32(map,adr);
+//printk("status=%08x\n",status);
+
+		udelay(100);
+		if((status & 0x80808080)!=0x80808080){
+//printk(".status=%08x\n",status);
+			udelay(100);
+		}
+		break;
+	default:
+		printk("Waiting for chip\n");
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	map->write32(map,0xffffffff, adr);
+
+	chip->state = FL_READY;
+
+	return 0;
+}
+
+static void sharp_release(struct flchip *chip)
+{
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+}
+
+/* Needs to be called _with_ lock, and returns with lock
+ * unless there is an error */
+static int sharp_wait_state(struct map_info *map,struct flchip *chip,
+	int state,unsigned long adr)
+{
+	int timeo;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if(chip->state != state){
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current))
+			return -EINTR;
+		
+		timeo = jiffies + (HZ/2);
+
+		spin_lock_bh(chip->mutex);
+	}
+	if(chip->state != state){
+		return 0;
+	}
+
+	return 1;
+}
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int chipnum;
+	int ret = 0;
+	int ofs = 0;
+
+	chipnum = (from >> sharp->chipshift);
+	ofs = from & ((1 << sharp->chipshift)-1);
+
+	*retlen = 0;
+
+	while(len){
+		unsigned long thislen;
+
+		if(chipnum>=sharp->numchips)
+			break;
+
+		thislen = len;
+		if(ofs+thislen >= (1<<sharp->chipshift))
+			thislen = (1<<sharp->chipshift) - ofs;
+
+		ret = sharp_wait(map,&sharp->chips[chipnum]);
+		if(ret<0)
+			break;
+
+		map->copy_from(map,buf,ofs,thislen);
+
+		sharp_release(&sharp->chips[chipnum]);
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int sharp_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int ret = 0;
+	int i,j;
+	int chipnum;
+	unsigned long ofs;
+	union { u32 l; unsigned char uc[4]; } tbuf;
+
+	*retlen = 0;
+
+	while(len){
+		tbuf.l = 0xffffffff;
+		chipnum = to >> sharp->chipshift;
+		ofs = to & ((1<<sharp->chipshift)-1);
+
+		j=0;
+		for(i=ofs&3;i<4 && len;i++){
+			tbuf.uc[i] = *buf;
+			buf++;
+			to++;
+			len--;
+			j++;
+		}
+		sharp_write_oneword(map, &sharp->chips[chipnum], ofs&~3, tbuf.l);
+		if(ret<0)
+			return ret;
+		(*retlen)+=j;
+	}
+
+	return 0;
+}
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum)
+{
+	int ret;
+	int timeo;
+	int z;
+
+	ret = sharp_wait(map,chip);
+
+	map->write32(map,0x40404040,adr);
+	/* cpu_to_le32 -> hack to fix the writel be->le conversion */
+	map->write32(map,cpu_to_le32(datum),adr);
+
+	chip->state = FL_WRITING;
+
+	timeo = jiffies + (HZ/2);
+
+	spin_unlock_bh(chip->mutex);
+	udelay(chip->word_write_time);
+	spin_lock_bh(chip->mutex);
+
+	while(1){
+		ret = sharp_wait_state(map,chip,FL_WRITING,adr);
+		if(ret < 0)return ret;
+		if(ret==1)break;
+
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in read\n");
+			return -EIO;
+		}
+
+		spin_unlock_bh(chip->mutex);
+
+		z++;
+
+		udelay(1);
+
+		spin_lock_bh(chip->mutex);
+		continue;
+	}
+	chip->word_write_time += (z)?+1:-1;
+	if(chip->word_write_time<1)chip->word_write_time = 1;
+
+	chip->state = FL_STATUS;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	unsigned long adr,len;
+	int chipnum, ret=0;
+
+printk("sharp_erase()\n");
+	if(instr->addr & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len + instr->addr > mtd->size)
+		return -EINVAL;
+
+	chipnum = instr->addr >> sharp->chipshift;
+	adr = instr->addr & ((1<<sharp->chipshift)-1);
+	len = instr->len;
+
+	while(len){
+		ret = sharp_erase_oneblock(map, &sharp->chips[chipnum], adr);
+		if(ret)return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+		if(adr >> sharp->chipshift){
+			adr = 0;
+			chipnum++;
+			if(chipnum>=sharp->numchips)
+				break;
+		}
+	}
+
+printk("callback: %p\n",instr->callback);
+	if(instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	int timeo;
+
+printk("sharp_erase_oneblock()\n");
+	ret = sharp_wait(map,chip);
+
+	map->write32(map,0x20202020,adr);
+	map->write32(map,0xd0d0d0d0,adr);
+
+	chip->state = FL_ERASING;
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	timeo = jiffies + HZ;
+
+	while(1){
+		ret = sharp_wait_state(map,chip,FL_ERASING,adr);
+		if(ret < 0)return ret;
+		if(ret==1)break;
+
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in erase\n");
+			return -EIO;
+		}
+
+		spin_unlock_bh(chip->mutex);
+
+		udelay(1);
+
+		spin_lock_bh(chip->mutex);
+		continue;
+	}
+
+	chip->state = FL_STATUS;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+printk("sharp_erase_oneblock() done\n");
+
+	return 0;
+}
+
+static void sharp_sync(struct mtd_info *mtd)
+{
+	printk("sharp_sync()\n");
+	
+}
+
+static int sharp_suspend(struct mtd_info *mtd)
+{
+	printk("sharp_suspend()\n");
+	return -EINVAL;
+}
+
+static void sharp_resume(struct mtd_info *mtd)
+{
+	printk("sharp_resume()\n");
+	
+}
+
+static void sharp_destroy(struct mtd_info *mtd)
+{
+	printk("sharp_destroy()\n");
+
+}
+
+
+static int __init sharp_init(void)
+{
+	printk("MTD Sharp chip driver <ds@lineo.com>\n");
+	mtd_register_map_driver(&sharp_driver);
+}
+
+static void __exit sharp_cleanup(void)
+{
+	mtd_unregister_map_driver(&sharp_driver);
+}
+
+module_init(sharp_init);
+module_cleanup(sharp_cleanup);
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/slram.c linux-2.4.2/drivers/mtd/slram.c
--- linux-2.4.2.orig/drivers/mtd/slram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/slram.c	Fri Feb 15 14:41:16 2002
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: slram.c,v 1.10 2000/07/03 10:01:38 dwmw2 Exp $
+  $Id: slram.c,v 1.14 2001/01/11 15:17:42 dwmw2 Exp $
 
 ======================================================================*/
 
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -106,15 +106,12 @@
 static u_long length = 33554432;
 static u_long end = 0;
 
-#if LINUX_VERSION_CODE < 0x20300
 #ifdef MODULE
+#if LINUX_VERSION_CODE < 0x20212
 #define init_slram init_module
 #define cleanup_slram cleanup_module
 #endif
-#define __exit
-#endif
 
-#ifdef MODULE
 MODULE_PARM(start,"l");
 MODULE_PARM(length,"l");
 MODULE_PARM(end,"l");
@@ -179,8 +176,10 @@
 		return -ENOMEM;
 	}
 	
-	
-	((struct mypriv *)mymtd->priv)->start = ioremap(start, length);
+	if (!(((struct mypriv *)mymtd->priv)->start = ioremap(start, length))) {
+		printk(KERN_NOTICE "slram: ioremap failed\n");
+		return -EIO;
+	}
 	((struct mypriv *)mymtd->priv)->end = ((struct mypriv *)mymtd->priv)->start + length;
 
 
@@ -200,9 +199,9 @@
 	if (add_mtd_device(mymtd))
 	{
 		printk("Failed to register new device\n");
-	        iounmap(((struct mypriv *)mymtd->priv)->start);
 		kfree(mymtd->priv);
 		kfree(mymtd);
+		iounmap(((struct mypriv *)mymtd->priv)->start);
 		return -EAGAIN;
 	}
 	printk("Registered physmem device from %dKb to %dKb\n",
@@ -215,13 +214,11 @@
 
 static void __exit cleanup_slram(void)
 {
+	del_mtd_device(mymtd);
 	iounmap(((struct mypriv *)mymtd->priv)->start);
 	kfree (mymtd->priv);
-	del_mtd_device(mymtd);
 	kfree(mymtd);
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_slram);
 module_exit(cleanup_slram);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/spia.c linux-2.4.2/drivers/mtd/spia.c
--- linux-2.4.2.orig/drivers/mtd/spia.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/spia.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,129 @@
+/*
+ *  drivers/mtd/spia.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: spia.c,v 1.7 2000/12/04 16:14:19 sjhill Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   SPIA board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 64Mbit (8MB x 8 bits) NAND flash device.
+ */
+
+#include <linux/malloc.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+/*
+ * MTD structure for SPIA board
+ */
+static struct mtd_info *spia_mtd = NULL;
+
+/*
+ * Module stuff
+ */
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+  #define spia_init init_module
+  #define spia_cleanup cleanup_module
+#endif
+
+/*
+ * Define partitions for flash device
+ */
+const static struct mtd_partition partition_info[] = {
+	{ name: "SPIA flash partition 1",
+	  offset: 0,
+	  size: 2*1024*1024 },
+	{ name: "SPIA flash partition 2",
+	  offset: 2*1024*1024,
+	  size: 6*1024*1024 }
+};
+#define NUM_PARTITIONS 2
+
+/*
+ * Main initialization routine
+ */
+int __init spia_init (void)
+{
+	struct nand_chip *this;
+
+	/* Allocate memory for MTD device structure and private data */
+	spia_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+	if (!spia_mtd) {
+		printk ("Unable to allocate SPIA NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&spia_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) spia_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	spia_mtd->priv = this;
+
+	/*
+	 * Set GPIO Port E control register so that the pins are configured
+	 * to be outputs for controlling the NAND flash.
+	 */
+	(*(volatile unsigned char *) (IO_BASE + PEDDR)) = 0x07;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR = FIO_BASE;
+	this->CTRL_ADDR = IO_BASE + PEDR;
+	this->CLE = 0x01;
+	this->ALE = 0x02;
+	this->NCE = 0x04;
+
+	/* Scan to find existance of the device */
+	if (nand_scan (spia_mtd)) {
+		kfree (spia_mtd);
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+	this->data_buf = kmalloc (sizeof(u_char) * (spia_mtd->oobblock + spia_mtd->oobsize), GFP_KERNEL);
+	if (!this->data_buf) {
+		printk ("Unable to allocate NAND data buffer for SPIA.\n");
+		kfree (spia_mtd);
+		return -ENOMEM;
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(spia_mtd, partition_info, NUM_PARTITIONS);
+
+	/* Return happy */
+	return 0;
+}
+module_init(spia_init);
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit spia_cleanup (void)
+{
+	struct nand_chip *this = (struct nand_chip *) &spia_mtd[1];
+
+	/* Unregister the device */
+	del_mtd_device (spia_mtd);
+
+	/* Free internal data buffer */
+	kfree (this->data_buf);
+
+	/* Free the MTD device structure */
+	kfree (spia_mtd);
+}
+module_exit(spia_cleanup);
+#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/sun_uflash.c linux-2.4.2/drivers/mtd/sun_uflash.c
--- linux-2.4.2.orig/drivers/mtd/sun_uflash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sun_uflash.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,224 @@
+/* $Id: sun_uflash.c,v 1.1 2001/03/17 12:13:54 dwmw2 Exp $
+ *
+ * sun_uflash - Driver implementation for user-programmable flash
+ * present on many Sun Microsystems SME boardsets.
+ *
+ * This driver does NOT provide access to the OBP-flash for
+ * safety reasons-- use <linux>/drivers/sbus/char/flash.c instead.
+ *
+ * Copyright (c) 2001 Eric Brower (ebrower@usa.net)
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/ebus.h>
+#include <asm/oplib.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+#define UFLASH_OBPNAME	"flashprom"
+#define UFLASH_DEVNAME 	"userflash"
+
+#define UFLASH_WINDOW_SIZE	0x200000
+#define UFLASH_BUSWIDTH		1			/* EBus is 8-bit */
+
+MODULE_AUTHOR
+	("Eric Brower <ebrower@usa.net>");
+MODULE_DESCRIPTION
+	("User-programmable flash device on Sun Microsystems boardsets");
+MODULE_SUPPORTED_DEVICE
+	("userflash");
+
+static LIST_HEAD(device_list);
+struct uflash_dev {
+	char *			name;	/* device name */
+	struct map_info 	map;	/* mtd map info */
+	struct mtd_info *	mtd;	/* mtd info */
+	struct list_head	list;
+};
+
+__u8 uflash_read8(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readb(map->map_priv_1 + ofs));
+}
+
+__u16 uflash_read16(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readw(map->map_priv_1 + ofs));
+}
+
+__u32 uflash_read32(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readl(map->map_priv_1 + ofs));
+}
+
+void uflash_copy_from(struct map_info *map, void *to, unsigned long from, 
+		      ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void uflash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+}
+
+void uflash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+}
+
+void uflash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+}
+
+void uflash_copy_to(struct map_info *map, unsigned long to, const void *from,
+		    ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info uflash_map_templ = {
+		name:		"SUNW,???-????",
+		size:		UFLASH_WINDOW_SIZE,
+		buswidth:	UFLASH_BUSWIDTH,
+		read8:		uflash_read8,
+		read16:		uflash_read16,
+		read32:		uflash_read32,
+		copy_from:	uflash_copy_from,
+		write8:		uflash_write8,
+		write16:	uflash_write16,
+		write32:	uflash_write32,
+		copy_to:	uflash_copy_to
+};
+
+int uflash_devinit(struct linux_ebus_device* edev)
+{
+	int iTmp, nregs;
+	struct linux_prom_registers regs[2];
+	struct uflash_dev *pdev;
+
+	iTmp = prom_getproperty(
+		edev->prom_node, "reg", (void *)regs, sizeof(regs));
+	if ((iTmp % sizeof(regs[0])) != 0) {
+		printk("%s: Strange reg property size %d\n", 
+			UFLASH_DEVNAME, iTmp);
+		return -ENODEV;
+	}
+
+	nregs = iTmp / sizeof(regs[0]);
+
+	if (nregs != 1) {
+		/* Non-CFI userflash device-- once I find one we
+		 * can work on supporting it.
+		 */
+		printk("%s: unsupported device at 0x%lx (%d regs): " \
+			"email ebrower@usa.net\n", 
+			UFLASH_DEVNAME, edev->resource[0].start, nregs);
+		return -ENODEV;
+	}
+
+	if(0 == (pdev = kmalloc(sizeof(struct uflash_dev), GFP_KERNEL))) {
+		printk("%s: unable to kmalloc new device\n", UFLASH_DEVNAME);
+		return(-ENOMEM);
+	}
+	
+	/* copy defaults and tweak parameters */
+	memcpy(&pdev->map, &uflash_map_templ, sizeof(uflash_map_templ));
+	pdev->map.size = regs[0].reg_size;
+
+	iTmp = prom_getproplen(edev->prom_node, "model");
+	pdev->name = kmalloc(iTmp, GFP_KERNEL);
+	prom_getstring(edev->prom_node, "model", pdev->name, iTmp);
+	if(0 != pdev->name && 0 < strlen(pdev->name)) {
+		pdev->map.name = pdev->name;
+	}
+
+	pdev->map.map_priv_1 = 
+		(unsigned long)ioremap_nocache(edev->resource[0].start, pdev->map.size);
+	if(0 == pdev->map.map_priv_1) {
+		printk("%s: failed to map device\n", __FUNCTION__);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-1);
+	}
+
+	/* MTD registration */
+	pdev->mtd = do_cfi_probe(&pdev->map);
+	if(0 == pdev->mtd) {
+		iounmap((void *)pdev->map.map_priv_1);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-ENXIO);
+	}
+
+	list_add(&pdev->list, &device_list);
+
+	pdev->mtd->module = THIS_MODULE;
+
+	add_mtd_device(pdev->mtd);
+	return(0);
+}
+
+static int __init uflash_init(void)
+{
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, UFLASH_OBPNAME)) {
+				if(0 > prom_getproplen(edev->prom_node, "user")) {
+					DEBUG(2, "%s: ignoring device at 0x%lx\n",
+							UFLASH_DEVNAME, edev->resource[0].start);
+				} else {
+					uflash_devinit(edev);
+				}
+			}
+		}
+	}
+
+	if(list_empty(&device_list)) {
+		printk("%s: unable to locate device\n", UFLASH_DEVNAME);
+		return -ENODEV;
+	}
+	return(0);
+}
+
+static void __exit uflash_cleanup(void)
+{
+	struct list_head *udevlist;
+	struct uflash_dev *udev;
+
+	list_for_each(udevlist, &device_list) {
+		udev = list_entry(udevlist, struct uflash_dev, list);
+		DEBUG(2, "%s: removing device %s\n", 
+			UFLASH_DEVNAME, udev->name);
+
+		if(0 != udev->mtd) {
+			del_mtd_device(udev->mtd);
+			map_destroy(udev->mtd);
+		}
+		if(0 != udev->map.map_priv_1) {
+			iounmap((void*)udev->map.map_priv_1);
+			udev->map.map_priv_1 = 0;
+		}
+		if(0 != udev->name) {
+			kfree(udev->name);
+		}
+		kfree(udev);
+	}	
+}
+
+module_init(uflash_init);
+module_exit(uflash_cleanup);
diff -Naur linux-2.4.2.orig/drivers/mtd/vmax301.c linux-2.4.2/drivers/mtd/vmax301.c
--- linux-2.4.2.orig/drivers/mtd/vmax301.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/vmax301.c	Fri Feb 15 14:41:16 2002
@@ -1,4 +1,4 @@
-// $Id: vmax301.c,v 1.15 2000/11/27 08:50:22 dwmw2 Exp $
+// $Id: vmax301.c,v 1.19 2001/03/17 16:18:29 dwmw2 Exp $
 /* ######################################################################
 
    Tempustech VMAX SBC301 MTD Driver.
@@ -17,7 +17,7 @@
    ##################################################################### */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <asm/spinlock.h>
@@ -219,9 +219,9 @@
 		if (!vmax_mtd[i])
 			vmax_mtd[i] = do_jedec_probe(&vmax_map[i]);
 		if (!vmax_mtd[i])
-			vmax_mtd[i] = do_ram_probe(&vmax_map[i]);
+			vmax_mtd[i] = do_map_ram_probe(&vmax_map[i]);
 		if (!vmax_mtd[i])
-			vmax_mtd[i] = do_rom_probe(&vmax_map[i]);
+			vmax_mtd[i] = do_map_rom_probe(&vmax_map[i]);
 		if (vmax_mtd[i]) {
 			vmax_mtd[i]->module = THIS_MODULE;
 			add_mtd_device(vmax_mtd[i]);
@@ -229,7 +229,7 @@
 	}
 
 	if (!vmax_mtd[1] && !vmax_mtd[2]) {
-		iounmap(iomapadr);
+		iounmap((void *)iomapadr);
 		return -ENXIO;
 	}
 
diff -Naur linux-2.4.2.orig/fs/Config.in linux-2.4.2/fs/Config.in
--- linux-2.4.2.orig/fs/Config.in	Mon Jan 15 21:42:32 2001
+++ linux-2.4.2/fs/Config.in	Fri Feb 15 14:41:16 2002
@@ -30,6 +30,7 @@
 if [ "$CONFIG_JFFS_FS" != "n" ] ; then
 	int 'JFFS debugging verbosity (0 = quiet, 3 = noisy)' CONFIG_JFFS_FS_VERBOSE 0
 fi
+tristate 'Journalling Flash File System (JFFS2) support (EXPERIMENTAL)' CONFIG_JFFS2_FS
 tristate 'Compressed ROM file system support' CONFIG_CRAMFS
 tristate 'Simple RAM-based file system support' CONFIG_RAMFS
 
diff -Naur linux-2.4.2.orig/fs/Makefile linux-2.4.2/fs/Makefile
--- linux-2.4.2.orig/fs/Makefile	Mon Jan 15 21:42:32 2001
+++ linux-2.4.2/fs/Makefile	Fri Feb 15 14:41:16 2002
@@ -51,6 +51,7 @@
 subdir-$(CONFIG_UFS_FS)		+= ufs
 subdir-$(CONFIG_EFS_FS)		+= efs
 subdir-$(CONFIG_JFFS_FS)	+= jffs
+subdir-$(CONFIG_JFFS2_FS)       += jffs2
 subdir-$(CONFIG_AFFS_FS)	+= affs
 subdir-$(CONFIG_ROMFS_FS)	+= romfs
 subdir-$(CONFIG_QNX4FS_FS)	+= qnx4
diff -Naur linux-2.4.2.orig/fs/binfmt_elf.c linux-2.4.2/fs/binfmt_elf.c
--- linux-2.4.2.orig/fs/binfmt_elf.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/binfmt_elf.c	Fri Feb 15 14:41:16 2002
@@ -163,7 +163,9 @@
 	sp -= 3*2;
 	NEW_AUX_ENT(0, AT_HWCAP, hwcap);
 	NEW_AUX_ENT(1, AT_PAGESZ, ELF_EXEC_PAGESIZE);
+#ifndef CONFIG_DBOX2
 	NEW_AUX_ENT(2, AT_CLKTCK, CLOCKS_PER_SEC);
+#endif
 
 	if (exec) {
 		sp -= 10*2;
diff -Naur linux-2.4.2.orig/fs/jffs/GNUmakefile linux-2.4.2/fs/jffs/GNUmakefile
--- linux-2.4.2.orig/fs/jffs/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/GNUmakefile	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,34 @@
+# GNUmakefile for JFFS build outside kernel tree
+# $Id: GNUmakefile,v 1.1 2001/09/23 23:13:05 dwmw2 Exp $
+
+LINUXDIR=/usr/src/linux
+
+ifndef VERSION
+
+# Someone just typed 'make'
+
+modules:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` modules
+
+dep:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` dep
+
+clean:
+	rm -f *.o
+
+else
+
+ifndef CONFIG_JFFS_FS
+
+CC += -I$(shell pwd)/../../include
+
+CONFIG_JFFS_FS := m
+CONFIG_JFFS_PROC_FS := y
+EXTRA_CFLAGS += -DCONFIG_JFFS_FS_VERBOSE=1 -g -DCONFIG_JFFS_PROC_FS=1
+
+endif
+
+include Makefile
+
+
+endif
diff -Naur linux-2.4.2.orig/fs/jffs/Makefile linux-2.4.2/fs/jffs/Makefile
--- linux-2.4.2.orig/fs/jffs/Makefile	Fri Dec 29 23:07:23 2000
+++ linux-2.4.2/fs/jffs/Makefile	Fri Feb 15 14:41:16 2002
@@ -1,7 +1,7 @@
 #
 # Makefile for the linux Journalling Flash FileSystem (JFFS) routines.
 #
-# $Id: Makefile,v 1.7 2000/08/04 12:46:34 dwmw2 Exp $
+# $Id: Makefile,v 1.11 2001/09/25 20:59:41 dwmw2 Exp $
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
@@ -9,28 +9,24 @@
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
 
-ifndef CONFIG_JFFS_FS
+list-multi := jffs.o
 
-# We're being invoked outside a normal kernel build. Fake it
-EXTRA_CFLAGS= -I$(shell pwd)/../../include
-
-# You need to change this to build for 2.2, dunno how to check for it.
-
-#INODE_O := inode-v22.o
-INODE_O := inode-v23.o
-
-else
+jffs-objs := jffs_fm.o intrep.o
 
 ifeq ($(PATCHLEVEL),2)
-	INODE_O := inode-v22.o
+	jffs-objs += inode-v22.o
 else
-	INODE_O := inode-v23.o
+	jffs-objs += inode-v23.o
 endif
 
+ifeq ($(CONFIG_JFFS_PROC_FS),y)
+	jffs-objs += jffs_proc.o
 endif
 
 O_TARGET := jffs.o
-obj-m    := $(O_TARGET)
-obj-y    := jffs_fm.o intrep.o $(INODE_O)
+
+obj-y := $(jffs-objs)
+obj-m := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
+
diff -Naur linux-2.4.2.orig/fs/jffs/inode-v22.c linux-2.4.2/fs/jffs/inode-v22.c
--- linux-2.4.2.orig/fs/jffs/inode-v22.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/inode-v22.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,1965 @@
+/*
+ * JFFS -- Journalling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 1999, 2000  Axis Communications AB.
+ *
+ * Created by Finn Hakansson <finn@axis.com>.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * $Id: inode-v22.c,v 1.67 2001/09/23 23:28:36 dwmw2 Exp $
+ *
+ * Ported to Linux 2.2.x by Sebastien Cote:
+ * Copyright (C) 2000 Matrox Electronic Systems
+ *
+ * Copyright 2000, 2001  Red Hat, Inc.
+ */
+
+/* inode.c -- Contains the code that is called from the VFS.  */
+
+/* Argh. Some architectures have kernel_thread in asm/processor.h
+   Some have it in unistd.h and you need to define __KERNEL_SYSCALLS__
+   Pass me a baseball bat and the person responsible.
+   dwmw2
+*/
+#define __KERNEL_SYSCALLS__
+#include <linux/sched.h>
+#include <linux/unistd.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/jffs.h>
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <linux/stat.h>
+#include <linux/blkdev.h>
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#if CONFIG_JFFS_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include "jffs_fm.h"
+#include "intrep.h"
+#if CONFIG_JFFS_PROC_FS
+#include "jffs_proc.h"
+#endif
+
+static int jffs_remove(struct inode *dir, struct dentry *dentry, int type);
+
+static struct super_operations jffs_ops;
+static struct file_operations jffs_file_operations;
+static struct inode_operations jffs_file_inode_operations;
+static struct file_operations jffs_dir_operations;
+static struct inode_operations jffs_dir_inode_operations;
+static struct inode_operations jffs_symlink_inode_operations;
+
+kmem_cache_t     *node_cache = NULL;
+kmem_cache_t     *fm_cache = NULL;
+
+/* Called by the VFS at mount time to initialize the whole file system.  */
+static struct super_block *
+jffs_read_super(struct super_block *sb, void *data, int silent)
+{
+	kdev_t dev = sb->s_dev;
+	struct inode *root_inode;
+	struct jffs_control *c;
+	
+	D1(printk(KERN_NOTICE "JFFS: Trying to mount device %s.\n",
+			kdevname(dev)));
+	
+	if (MAJOR(dev)!=MTD_BLOCK_MAJOR) {
+		printk(KERN_WARNING "JFFS: Trying to mount non-mtd device.\n");
+		return 0;
+	}
+	
+	MOD_INC_USE_COUNT;
+	lock_super(sb);
+	
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->u.generic_sbp = (void *) 0;
+	
+	/* Build the file system.  */
+	if (jffs_build_fs(sb) < 0) {
+		goto jffs_sb_err1;
+	}
+	
+	/*
+	 * set up enough so that we can read an inode
+	 */
+	sb->s_magic = JFFS_MAGIC_SB_BITMASK;
+	sb->s_op = &jffs_ops;
+	
+	unlock_super(sb);
+	
+	root_inode = iget(sb, JFFS_MIN_INO);
+	if (!root_inode)
+		goto jffs_sb_err2;
+	
+	/* Get the root directory of this file system.  */
+	if (!(sb->s_root = d_alloc_root(root_inode, NULL))) {
+		goto jffs_sb_err3;
+	}
+	
+	c = (struct jffs_control *) sb->u.generic_sbp;
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	/* Set up the jffs proc file system.  */
+	if (jffs_register_jffs_proc_dir(dev, c) < 0) {
+		printk(KERN_WARNING "JFFS: Failed to initialize the JFFS "
+			"proc file system for device %s.\n",
+			kdevname(dev));
+	}
+#endif
+	
+	/* Set the Garbage Collection thresholds */
+	
+	/* GC if free space goes below 5% of the total size */
+	c->gc_minfree_threshold = c->fmc->flash_size / 20;
+	
+	if (c->gc_minfree_threshold < c->fmc->sector_size)
+		c->gc_minfree_threshold = c->fmc->sector_size;
+	
+	/* GC if dirty space exceeds 33% of the total size. */
+	c->gc_maxdirty_threshold = c->fmc->flash_size / 3;
+	
+	if (c->gc_maxdirty_threshold < c->fmc->sector_size)
+		c->gc_maxdirty_threshold = c->fmc->sector_size;
+	
+	c->thread_pid = kernel_thread (jffs_garbage_collect_thread,
+			(void *) c,
+			CLONE_FS | CLONE_FILES);
+	D1(printk(KERN_NOTICE "JFFS: GC thread pid=%d.\n", (int) c->thread_pid));
+	
+	D1(printk(KERN_NOTICE "JFFS: Successfully mounted device %s.\n",
+			kdevname(dev)));
+	return sb;
+	
+	jffs_sb_err3:
+	iput(root_inode);
+	jffs_sb_err2:
+	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
+	jffs_sb_err1:
+	unlock_super(sb);
+	MOD_DEC_USE_COUNT;
+	printk(KERN_WARNING "JFFS: Failed to mount device %s.\n",
+		kdevname(dev));
+	return 0;
+}
+
+
+/* This function is called when the file system is umounted.  */
+static void
+jffs_put_super(struct super_block *sb)
+{
+	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
+	D1(kdev_t dev = sb->s_dev);
+	
+	D2(printk("jffs_put_super()\n"));
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_unregister_jffs_proc_dir(c);
+#endif
+	
+	if (c->gc_task) {
+		D1(printk (KERN_NOTICE "jffs_put_super(): Telling gc thread to die.\n"));
+		send_sig(SIGKILL, c->gc_task, 1);
+	}
+	down (&c->gc_thread_sem);
+	
+	D1(printk (KERN_NOTICE "jffs_put_super(): Successfully waited on thread.\n"));
+	
+	sb->s_dev = 0;
+	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
+	MOD_DEC_USE_COUNT;
+	D1(printk(KERN_NOTICE "JFFS: Successfully unmounted device %s.\n",
+			kdevname(dev)));
+}
+
+
+/* This function is called when user commands like chmod, chgrp and
+   chown are executed. System calls like trunc() results in a call
+   to this function.  */
+static int
+jffs_notify_change(struct dentry *dentry, struct iattr *iattr)
+{
+	struct inode *inode = dentry->d_inode;
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_fmcontrol *fmc;
+	struct jffs_file *f;
+	struct jffs_node *new_node;
+	int update_all;
+	int res;
+	int recoverable = 0;
+	
+	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	fmc = c->fmc;
+	
+	if ((res = inode_change_ok(inode, iattr)))
+		return res;
+	
+	D3(printk (KERN_NOTICE "notify_change(): down biglock\n"));
+	down(&fmc->biglock);
+	
+	f = jffs_find_file(c, inode->i_ino);
+	
+	ASSERT(if (!f) {
+		printk("jffs_notify_change(): Invalid inode number: %lu\n",
+			inode->i_ino);
+		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
+		up(&fmc->biglock);
+		return -EINVAL;
+	});
+	
+	D1(printk("***jffs_notify_change(): file: \"%s\", ino: %u\n",
+			f->name, f->ino));
+	
+	update_all = iattr->ia_valid & ATTR_FORCE;
+	
+	if ( (update_all || iattr->ia_valid & ATTR_SIZE)
+		&& (iattr->ia_size + 128 < f->size) ) {
+		/* We're shrinking the file by more than 128 bytes.
+		   We'll be able to GC and recover this space, so
+		   allow it to go into the reserved space. */
+		recoverable = 1;
+	}
+	
+	if (!(new_node = jffs_alloc_node())) {
+		D(printk("jffs_notify_change(): Allocation failed!\n"));
+		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
+		up(&fmc->biglock);
+		return -ENOMEM;
+	}
+	
+	new_node->data_offset = 0;
+	new_node->removed_size = 0;
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = f->ino;
+	raw_inode.pino = f->pino;
+/*  	raw_inode.version = f->highest_version + 1; */
+	raw_inode.mode = f->mode;
+	raw_inode.uid = f->uid;
+	raw_inode.gid = f->gid;
+	raw_inode.atime = f->atime;
+	raw_inode.mtime = f->mtime;
+	raw_inode.ctime = f->ctime;
+	raw_inode.dsize = 0;
+	raw_inode.offset = 0;
+	raw_inode.rsize = 0;
+	raw_inode.dsize = 0;
+	raw_inode.nsize = f->nsize;
+	raw_inode.nlink = f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	if (update_all || iattr->ia_valid & ATTR_MODE) {
+		raw_inode.mode = iattr->ia_mode;
+		inode->i_mode = iattr->ia_mode;
+	}
+	if (update_all || iattr->ia_valid & ATTR_UID) {
+		raw_inode.uid = iattr->ia_uid;
+		inode->i_uid = iattr->ia_uid;
+	}
+	if (update_all || iattr->ia_valid & ATTR_GID) {
+		raw_inode.gid = iattr->ia_gid;
+		inode->i_gid = iattr->ia_gid;
+	}
+	if (update_all || iattr->ia_valid & ATTR_SIZE) {
+		int len;
+		D1(printk("jffs_notify_change(): Changing size "
+				"to %lu bytes!\n", (long)iattr->ia_size));
+		raw_inode.offset = iattr->ia_size;
+		
+		/* Calculate how many bytes need to be removed from
+		   the end.  */
+		if (f->size < iattr->ia_size) {
+			len = 0;
+		}
+		else {
+			len = f->size - iattr->ia_size;
+		}
+		
+		raw_inode.rsize = len;
+		
+		/* The updated node will be a removal node, with
+		   base at the new size and size of the nbr of bytes
+		   to be removed.  */
+		new_node->data_offset = iattr->ia_size;
+		new_node->removed_size = len;
+		inode->i_size = iattr->ia_size;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+		
+		if (len) {
+			invalidate_inode_pages(inode);
+		}
+		inode->i_ctime = CURRENT_TIME;
+		inode->i_mtime = inode->i_ctime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_ATIME) {
+		raw_inode.atime = iattr->ia_atime;
+		inode->i_atime = iattr->ia_atime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_MTIME) {
+		raw_inode.mtime = iattr->ia_mtime;
+		inode->i_mtime = iattr->ia_mtime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_CTIME) {
+		raw_inode.ctime = iattr->ia_ctime;
+		inode->i_ctime = iattr->ia_ctime;
+	}
+	
+	/* Write this node to the flash.  */
+	if ((res = jffs_write_node(c, new_node, &raw_inode, f->name, 0, recoverable, f)) < 0) {
+		D(printk("jffs_notify_change(): The write failed!\n"));
+		jffs_free_node(new_node);
+		D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
+		up(&c->fmc->biglock);
+		return res;
+	}
+	
+	jffs_insert_node(c, f, &raw_inode, 0, new_node);
+	
+	mark_inode_dirty(inode);
+	D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return 0;
+} /* jffs_notify_change()  */
+
+
+struct inode *
+jffs_new_inode(const struct inode *dir, struct jffs_raw_inode *raw_inode,
+	int *err)
+{
+	struct super_block *sb;
+	struct inode *inode;
+	struct jffs_control *c;
+	struct jffs_file *f;
+	
+	inode = get_empty_inode();
+	if (!inode) {
+		*err = -ENOMEM;
+		return NULL;
+	}
+	
+	sb = dir->i_sb;
+	c = (struct jffs_control *)sb->u.generic_sbp;
+	
+	inode->i_sb = sb;
+	inode->i_dev = sb->s_dev;
+	inode->i_ino = raw_inode->ino;
+	inode->i_mode = raw_inode->mode;
+	inode->i_nlink = raw_inode->nlink;
+	inode->i_uid = raw_inode->uid;
+	inode->i_gid = raw_inode->gid;
+	inode->i_rdev = 0;
+	inode->i_size = raw_inode->dsize;
+	inode->i_atime = raw_inode->atime;
+	inode->i_mtime = raw_inode->mtime;
+	inode->i_ctime = raw_inode->ctime;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	inode->i_version = 0;
+	inode->i_flags = sb->s_flags;
+	
+	f = jffs_find_file(c, raw_inode->ino);
+
+	inode->u.generic_ip = (void *)f;
+	
+	insert_inode_hash(inode);
+	
+	return inode;
+}
+
+
+/* Get statistics of the file system.  */
+int
+jffs_statfs(struct super_block *sb, struct statfs *buf, int bufsiz)
+{
+	struct statfs tmp;
+	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
+	struct jffs_fmcontrol *fmc = c->fmc;
+	
+	D2(printk("jffs_statfs()\n"));
+	
+	tmp.f_type = JFFS_MAGIC_SB_BITMASK;
+	tmp.f_bsize = PAGE_CACHE_SIZE;
+	tmp.f_blocks = (fmc->flash_size / PAGE_CACHE_SIZE)
+		- (fmc->min_free_size / PAGE_CACHE_SIZE);
+	tmp.f_bfree = (jffs_free_size1(fmc) + jffs_free_size2(fmc) +
+		       fmc->dirty_size - fmc->min_free_size)
+			       >> PAGE_CACHE_SHIFT;
+	tmp.f_bavail =  tmp.f_bfree;
+	
+	/* Find out how many files there are in the filesystem.  */
+	tmp.f_files = jffs_foreach_file(c, jffs_file_count);
+	tmp.f_ffree = tmp.f_bfree;
+	/* tmp.f_fsid = 0; */
+	tmp.f_namelen = JFFS_MAX_NAME_LEN;
+	return copy_to_user(buf, &tmp, bufsiz) ? -EFAULT : 0;
+}
+
+
+/* Rename a file.  */
+int
+jffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+	struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *old_dir_f;
+	struct jffs_file *new_dir_f;
+	struct jffs_file *del_f;
+	struct jffs_file *f;
+	struct jffs_node *node;
+	struct inode *inode;
+	int result = 0;
+	__u32 rename_data = 0;
+	
+	D2(printk("***jffs_rename()\n"));
+	
+	D(printk("jffs_rename(): old_dir: 0x%p, old name: 0x%p, "
+			"new_dir: 0x%p, new name: 0x%p\n",
+			old_dir, old_dentry->d_name.name,
+			new_dir, new_dentry->d_name.name));
+	
+	if (!new_dir->i_nlink) {
+		D(printk("jffs_rename(): new_dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	c = (struct jffs_control *)old_dir->i_sb->u.generic_sbp;
+	ASSERT(if (!c) {
+		printk(KERN_ERR "jffs_rename(): The old_dir inode "
+			"didn't have a reference to a jffs_file struct\n");
+		return -EIO;
+	});
+	
+	result = -ENOTDIR;
+	if (!(old_dir_f = (struct jffs_file *)old_dir->u.generic_ip)) {
+		D(printk("jffs_rename(): Old dir invalid.\n"));
+		goto jffs_rename_end;
+	}
+	
+	/* Try to find the file to move.  */
+	result = -ENOENT;
+	if (!(f = jffs_find_child(old_dir_f, old_dentry->d_name.name,
+					old_dentry->d_name.len))) {
+		goto jffs_rename_end;
+	}
+	
+	/* Find the new directory.  */
+	result = -ENOTDIR;
+	if (!(new_dir_f = (struct jffs_file *)new_dir->u.generic_ip)) {
+		D(printk("jffs_rename(): New dir invalid.\n"));
+		goto jffs_rename_end;
+	}
+	D3(printk (KERN_NOTICE "rename(): down biglock\n"));
+	down(&c->fmc->biglock);
+	/* Create a node and initialize as much as needed.  */
+	result = -ENOMEM;
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_rename(): Allocation failed: node == 0\n"));
+		goto jffs_rename_end;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = f->ino;
+	raw_inode.pino = new_dir_f->ino;
+/*  	raw_inode.version = f->highest_version + 1; */
+	raw_inode.mode = f->mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = current->fsgid;
+#if 0
+	raw_inode.uid = f->uid;
+	raw_inode.gid = f->gid;
+#endif
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = f->ctime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = new_dentry->d_name.len;
+	raw_inode.nlink = f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* See if there already exists a file with the same name as
+	   new_name.  */
+	if ((del_f = jffs_find_child(new_dir_f, new_dentry->d_name.name,
+					new_dentry->d_name.len))) {
+		raw_inode.rename = 1;
+		raw_inode.dsize = sizeof(__u32);
+		rename_data = del_f->ino;
+	}
+	
+	/* Write the new node to the flash memory.  */
+	if ((result = jffs_write_node(c, node, &raw_inode, new_dentry->d_name.name,
+					(unsigned char*)&rename_data, 0, f)) < 0) {
+		D(printk("jffs_rename(): Failed to write node to flash.\n"));
+		jffs_free_node(node);
+		goto jffs_rename_end;
+	}
+	raw_inode.dsize = 0;
+	
+	if (raw_inode.rename) {
+		/* The file with the same name must be deleted.  */
+		//FIXME deadlock	        down(&c->fmc->gclock);
+		if ((result = jffs_remove(new_dir, new_dentry, del_f->mode)) < 0) {
+			/* This is really bad.  */
+			printk(KERN_ERR "JFFS: An error occurred in "
+				"rename().\n");
+		}
+		//		up(&c->fmc->gclock);
+	}
+	
+	if (old_dir_f != new_dir_f) {
+		/* Remove the file from its old position in the
+		   filesystem tree.  */
+		jffs_unlink_file_from_tree(f);
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((result = jffs_insert_node(c, f, &raw_inode,
+					new_dentry->d_name.name, node)) < 0) {
+		D(printk(KERN_ERR "jffs_rename(): jffs_insert_node() "
+				"failed!\n"));
+	}
+	
+	if (old_dir_f != new_dir_f) {
+		/* Insert the file to its new position in the
+		   file system.  */
+		jffs_insert_file_into_tree(f);
+	}
+	
+	/* This is a kind of update of the inode we're about to make
+	   here.  This is what they do in ext2fs.  Kind of.  */
+	if ((inode = iget(new_dir->i_sb, f->ino))) {
+		inode->i_ctime = CURRENT_TIME;
+		mark_inode_dirty(inode);
+		iput(inode);
+	}
+	
+	jffs_rename_end:
+	D3(printk (KERN_NOTICE "rename(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_rename()  */
+
+
+/* Read the contents of a directory.  Used by programs like `ls'
+   for instance.  */
+static int
+jffs_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct jffs_file *f;
+	struct dentry *dentry = filp->f_dentry;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	int j;
+	int ddino;
+	
+	D3(printk (KERN_NOTICE "readdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	D2(printk("jffs_readdir(): inode: 0x%p, filp: 0x%p\n", inode, filp));
+	if (filp->f_pos == 0) {
+		D3(printk("jffs_readdir(): \".\" %lu\n", inode->i_ino));
+		if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos = 1;
+	}
+	if (filp->f_pos == 1) {
+		if (inode->i_ino == JFFS_MIN_INO) {
+			ddino = JFFS_MIN_INO;
+		}
+		else {
+			ddino = ((struct jffs_file *)inode->u.generic_ip)->pino;
+		}
+		D3(printk("jffs_readdir(): \"..\" %u\n", ddino));
+		if (filldir(dirent, "..", 2, filp->f_pos, ddino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos++;
+	}
+	f = ((struct jffs_file *)inode->u.generic_ip)->children;
+	
+	j=2;
+	while(f && (f->deleted || j++ < filp->f_pos )) {
+		f = f->sibling_next;
+	}
+	
+	while (f) {
+		D3(printk("jffs_readdir(): \"%s\" ino: %u\n",
+				(f->name ? f->name : ""), f->ino));
+		if (filldir(dirent, f->name, f->nsize,
+				filp->f_pos , f->ino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos++;
+		do {
+			f = f->sibling_next;
+		} while(f && f->deleted);
+	}
+	D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return filp->f_pos;
+} /* jffs_readdir()  */
+
+
+/* Find a file in a directory. If the file exists, return its
+   corresponding dentry.  */
+static struct dentry *
+jffs_lookup(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_file *d;
+	struct jffs_file *f;
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int len;
+	int r = 0;
+	const char *name;
+	struct inode *inode = NULL;
+	
+	len = dentry->d_name.len;
+	name = dentry->d_name.name;
+	
+	D3({
+		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
+		memcpy(s, name, len);
+		s[len] = '\0';
+		printk("jffs_lookup(): dir: 0x%p, name: \"%s\"\n", dir, s);
+		kfree(s);
+	});
+	
+	D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	r = -ENAMETOOLONG;
+	if (len > JFFS_MAX_NAME_LEN) {
+		goto jffs_lookup_end;
+	}
+	
+	r = -EACCES;
+	if (!(d = (struct jffs_file *)dir->u.generic_ip)) {
+		D(printk("jffs_lookup(): No such inode! (%lu)\n",
+			 dir->i_ino));
+		goto jffs_lookup_end;
+	}
+	
+	/* Get the corresponding inode to the file.  */
+	
+	/* iget calls jffs_read_inode, so we need to drop the biglock
+	   before calling iget.  Unfortunately, the GC has a tendency
+	   to sneak in here, because iget sometimes calls schedule ().
+	*/
+
+	if ((len == 1) && (name[0] == '.')) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, d->ino))) {
+			D(printk("jffs_lookup(): . iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else if ((len == 2) && (name[0] == '.') && (name[1] == '.')) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, d->pino))) {
+			D(printk("jffs_lookup(): .. iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else if ((f = jffs_find_child(d, name, len))) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, f->ino))) {
+			D(printk("jffs_lookup(): iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else {
+		D3(printk("jffs_lookup(): Couldn't find the file. "
+			  "f = 0x%p, name = \"%s\", d = 0x%p, d->ino = %u\n",
+			  f, name, d, d->ino));
+		inode = NULL;
+	}
+	
+	d_add(dentry, inode);
+	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return NULL;
+	
+ jffs_lookup_end:
+	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+ jffs_lookup_end_no_biglock:
+	return ERR_PTR(r);
+} /* jffs_lookup()  */
+
+
+/* Try to read a page of data from a file.  */
+static int
+jffs_readpage(struct file *file, struct page *page)
+{
+	unsigned long buf;
+	unsigned long read_len;
+	int result = -EIO;
+	struct dentry *dentry = file->f_dentry;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_file *f = (struct jffs_file *)inode->u.generic_ip;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	int r;
+	
+	D2(printk("***jffs_readpage(): file = \"%s\", page->offset = %lu\n",
+			(f->name ? f->name : ""), page->offset));
+	
+	atomic_inc(&page->count);
+	set_bit(PG_locked, &page->flags);
+	set_bit(PG_free_after, &page->flags);
+	
+	buf = page_address(page);
+	clear_bit(PG_uptodate, &page->flags);
+	clear_bit(PG_error, &page->flags);
+	D3(printk (KERN_NOTICE "readpage(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	if (page->offset < inode->i_size) {
+		read_len = min_t(long, inode->i_size - page->offset, PAGE_SIZE);
+		r = jffs_read_data(f, (char *)buf, page->offset, read_len);
+		if (r == read_len) {
+			if (read_len < PAGE_SIZE) {
+				memset((void *)(buf + read_len), 0,
+					PAGE_SIZE - read_len);
+			}
+			set_bit(PG_uptodate, &page->flags);
+			result = 0;
+		}
+		D(else {
+			printk("***jffs_readpage(): Read error! "
+				"Wanted to read %lu bytes but only "
+				"read %d bytes.\n", read_len, r);
+		});
+	}
+	D3(printk (KERN_NOTICE "readpage(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (result) {
+		set_bit(PG_error, &page->flags);
+		memset((void *)buf, 0, PAGE_SIZE);
+	}
+	clear_bit(PG_locked, &page->flags);
+	wake_up(&page->wait);
+	free_page(buf);
+	
+	D3(printk("jffs_readpage(): Leaving...\n"));
+	
+	return result;
+} /* jffs_readpage()  */
+
+
+/* Create a new directory.  */
+static int
+jffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_node *node;
+	struct jffs_file *dir_f;
+	struct inode *inode;
+	int dir_mode;
+	int result = 0;
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
+		memcpy(_name, dentry->d_name.name, len);
+		_name[len] = '\0';
+		printk("***jffs_mkdir(): dir = 0x%p, name = \"%s\", "
+		       "len = %d, mode = 0x%08x\n", dir, _name, len, mode);
+		kfree(_name);
+	});
+	
+	if (!dir->i_nlink) {
+		D(printk("jffs_mkdir(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+		
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_mkdir(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+	
+	c = dir_f->c;
+	D3(printk (KERN_NOTICE "mkdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	dir_mode = S_IFDIR | (mode & (S_IRWXUGO|S_ISVTX)
+			      & ~current->fs->umask);
+	if (dir->i_mode & S_ISGID) {
+		dir_mode |= S_ISGID;
+	}
+	
+	/* Create a node and initialize it as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_mkdir(): Allocation failed: node == 0\n"));
+		result = -ENOMEM;
+		goto jffs_mkdir_end;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = dir_mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	/*	raw_inode.gid = current->fsgid; */
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* Write the new node to the flash.  */
+	if ((result = jffs_write_node(c, node, &raw_inode,
+				      dentry->d_name.name, 0, 0, NULL)) < 0) {
+		D(printk("jffs_mkdir(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_mkdir_end;
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((result = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+				       node)) < 0) {
+		goto jffs_mkdir_end;
+	}
+	
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		result = err;
+		goto jffs_mkdir_end;
+	}
+	
+	inode->i_op = &jffs_dir_inode_operations;
+	inode->i_op->default_file_ops = &jffs_dir_operations;
+	
+	mark_inode_dirty(dir);
+	d_instantiate(dentry, inode);
+	
+	result = 0;
+ jffs_mkdir_end:
+	D3(printk (KERN_NOTICE "mkdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_mkdir()  */
+
+
+/* Remove a directory.  */
+static int
+jffs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int ret;
+	D3(printk("***jffs_rmdir()\n"));
+	D3(printk (KERN_NOTICE "rmdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	ret = jffs_remove(dir, dentry, S_IFDIR);
+	D3(printk (KERN_NOTICE "rmdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+}
+
+
+/* Remove any kind of file except for directories.  */
+static int
+jffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int ret;
+	
+	D3(printk("***jffs_unlink()\n"));
+	D3(printk (KERN_NOTICE "unlink(): down biglock\n"));
+	down(&c->fmc->biglock);
+	ret = jffs_remove(dir, dentry, 0);
+	D3(printk (KERN_NOTICE "unlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+}
+
+
+/* Remove a JFFS entry, i.e. plain files, directories, etc.  Here we
+   shouldn't test for free space on the device.  */
+static int
+jffs_remove(struct inode *dir, struct dentry *dentry, int type)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *dir_f; /* The file-to-remove's parent.  */
+	struct jffs_file *del_f; /* The file to remove.  */
+	struct jffs_node *del_node;
+	struct inode *inode = 0;
+	int result = 0;
+	
+	D1({
+		int len = dentry->d_name.len;
+		const char *name = dentry->d_name.name;
+		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
+		memcpy(_name, name, len);
+		_name[len] = '\0';
+		printk("***jffs_remove(): file = \"%s\", ino = %ld\n", _name, dentry->d_inode->i_ino);
+		kfree(_name);
+	});
+	
+	dir_f = (struct jffs_file *) dir->u.generic_ip;
+	c = dir_f->c;
+	
+	result = -ENOENT;
+	if (!(del_f = jffs_find_child(dir_f, dentry->d_name.name,
+				      dentry->d_name.len))) {
+		D(printk("jffs_remove(): jffs_find_child() failed.\n"));
+		goto jffs_remove_end;
+	}
+	
+	if (S_ISDIR(type)) {
+		struct jffs_file *child = del_f->children;
+		
+		result = -ENOTDIR;
+		if (!S_ISDIR(del_f->mode)) { /* Is this really needed for 2.2? */
+			D(printk("jffs_remove(): S_ISDIR but isn't\n"));
+			goto jffs_remove_end;
+		}
+		
+		while(child) {
+			if( !child->deleted ) {
+				result = -ENOTEMPTY;
+				goto jffs_remove_end;
+			}
+			child = child->sibling_next;
+		}
+	}
+	else if (S_ISDIR(del_f->mode)) {
+		D(printk("jffs_remove(): node is a directory "
+			 "but it shouldn't be.\n"));
+		result = -EPERM;
+		goto jffs_remove_end;
+	}
+	
+	inode = dentry->d_inode;
+	
+	result = -EIO;
+	if (del_f->ino != inode->i_ino) {
+		D(printk("jffs_remove(): wrong inodes\n"));
+		goto jffs_remove_end;
+	}
+	
+	if (!inode->i_nlink) {
+		printk("Deleting nonexistent file inode: %lu, nlink: %d\n",
+		       inode->i_ino, inode->i_nlink);
+		inode->i_nlink=1;
+	}
+	
+	/* Create a node for the deletion.  */
+	result = -ENOMEM;
+	if (!(del_node = jffs_alloc_node())) {
+		D(printk("jffs_remove(): Allocation failed!\n"));
+		goto jffs_remove_end;
+	}
+	del_node->data_offset = 0;
+	del_node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = del_f->ino;
+	raw_inode.pino = del_f->pino;
+	/*  	raw_inode.version = del_f->highest_version + 1; */
+	raw_inode.mode = del_f->mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = del_f->mtime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = 0;
+	raw_inode.nlink = del_f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 1;
+
+	/* Write the new node to the flash memory.  */
+	if (jffs_write_node(c, del_node, &raw_inode, 0, 0, 1, del_f) < 0) {
+		jffs_free_node(del_node);
+		result = -EIO;
+		goto jffs_remove_end;
+	}
+
+	/* Update the file.  This operation will make the file disappear
+	   from the in-memory file system structures.  */
+	jffs_insert_node(c, del_f, &raw_inode, 0, del_node);
+
+	dir->i_version = ++global_event;
+	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
+	mark_inode_dirty(dir);
+	inode->i_nlink--;
+	inode->i_ctime = dir->i_ctime;
+	mark_inode_dirty(inode);
+
+	d_delete(dentry);	/* This also frees the inode */
+
+	result = 0;
+ jffs_remove_end:
+	return result;
+} /* jffs_remove()  */
+
+
+static int
+jffs_mknod(struct inode *dir, struct dentry *dentry, int mode, int rdev)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_file *dir_f;
+	struct jffs_node *node = 0;
+	struct jffs_control *c;
+	struct inode *inode;
+	int result = 0;
+	kdev_t dev = to_kdev_t(rdev);
+	int err;
+	
+	D1(printk("***jffs_mknod()\n"));
+	
+	if (!dir->i_nlink) {
+		D(printk("jffs_mknod(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	c = dir_f->c;
+	
+	D3(printk (KERN_NOTICE "mknod(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	/* Create and initialize a new node.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_mknod(): Allocation failed!\n"));
+		result = -ENOMEM;
+		goto jffs_mknod_err;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	/*	raw_inode.gid = current->fsgid; */
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = sizeof(kdev_t);
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
+					(unsigned char *)&dev, 0, NULL)) < 0) {
+		D(printk("jffs_mknod(): jffs_write_node() failed.\n"));
+		result = err;
+		goto jffs_mknod_err;
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+					node)) < 0) {
+		result = err;
+		goto jffs_mknod_end;
+	}
+	
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		result = err;
+		goto jffs_mknod_end;
+	}
+	
+	inode->i_mode = mode;
+	if (S_ISREG(mode))
+		inode->i_op = &jffs_file_inode_operations;
+	if (S_ISCHR(mode)) {
+		inode->i_op = &chrdev_inode_operations;
+		inode->i_rdev = to_kdev_t(rdev);
+	}
+	else if (S_ISBLK(mode)) {
+		inode->i_op = &blkdev_inode_operations;
+		inode->i_rdev = to_kdev_t(rdev);
+	}
+	else if (S_ISFIFO(mode))
+		init_fifo(inode);
+	else if (S_ISSOCK(mode))
+		;
+	else
+		printk(KERN_DEBUG "jffs_mknod: bogus imode (%o)\n", mode);
+	
+	d_instantiate(dentry, inode);
+	
+	goto jffs_mknod_end;
+	
+	jffs_mknod_err:
+	if (node) {
+		jffs_free_node(node);
+	}
+	
+	jffs_mknod_end:
+	D3(printk (KERN_NOTICE "mknod(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_mknod()  */
+
+
+static int
+jffs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *dir_f;
+	struct jffs_node *node;
+	struct inode *inode;
+	
+	int symname_len = strlen(symname);
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *_name = (char *)kmalloc(len + 1, GFP_KERNEL);
+		char *_symname = (char *)kmalloc(symname_len + 1, GFP_KERNEL);
+		memcpy(_name, dentry->d_name.name, len);
+		_name[len] = '\0';
+		memcpy(_symname, symname, symname_len);
+		_symname[symname_len] = '\0';
+		printk("***jffs_symlink(): dir = 0x%p, "
+		       "dentry->dname.name = \"%s\", "
+		       "symname = \"%s\"\n", dir, _name, _symname);
+		kfree(_name);
+		kfree(_symname);
+	});
+
+	if (!dir->i_nlink) {
+		D(printk("jffs_symlink(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_symlink(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+
+	c = dir_f->c;
+
+	/* Create a node and initialize it as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_symlink(): Allocation failed: node = NULL\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "symlink(): down biglock\n"));
+	down(&c->fmc->biglock);
+
+	node->data_offset = 0;
+	node->removed_size = 0;
+
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = S_IFLNK | S_IRWXUGO;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = symname_len;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
+				   (const unsigned char *)symname, 0, NULL)) < 0) {
+		D(printk("jffs_symlink(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_symlink_end;
+	}
+
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+				    node)) < 0) {
+		goto jffs_symlink_end;
+	}
+
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		goto jffs_symlink_end;
+	}
+	err = 0;
+
+	inode->i_mode = S_IFLNK | S_IRWXUGO;
+	inode->i_op = &jffs_symlink_inode_operations;
+
+	d_instantiate(dentry, inode);
+
+ jffs_symlink_end:
+	D3(printk (KERN_NOTICE "symlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+
+	return err;
+} /* jffs_symlink()  */
+
+
+/* Shamelessly stolen from kernel 2.3.99-pre8 */
+static int
+vfs_readlink(struct dentry *dentry, char *buffer, int buflen,
+	const char *link)
+{
+	int len;
+	
+	len = PTR_ERR(link);
+	if (IS_ERR(link))
+		goto out;
+	
+	len = strlen(link);
+	if (len > (unsigned) buflen)
+		len = buflen;
+	if (copy_to_user(buffer, link, len))
+		len = -EFAULT;
+	out:
+	return len;
+}
+
+
+/* Read the path that a symbolic link is referring to.  */
+static int
+jffs_readlink(struct dentry *dentry, char *buffer, int buflen)
+{
+	struct jffs_file *f;
+	struct inode *inode = dentry->d_inode;
+	char *link;
+	int result;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	
+	D(printk("***jffs_readlink()\n"));
+	
+	/* Continue only if the file is a symbolic link.  */
+	if (!S_ISLNK(inode->i_mode)) {
+		//		iput(inode);
+		return -EINVAL;
+	}
+	
+	f = (struct jffs_file *)inode->u.generic_ip;
+	ASSERT(if (!f) {
+		printk(KERN_ERR "jffs_readlink(): No reference to a "
+			"jffs_file struct in inode.\n");
+		return -EIO;
+	});
+	if (!(link = (char *)kmalloc(f->size + 1, GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "readlink(): down biglock\n"));
+	
+	down(&c->fmc->biglock);
+	
+	result = jffs_read_data(f, link, 0, f->size);
+	
+	D3(printk (KERN_NOTICE "readlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (result < 0) {
+		kfree(link);
+		return result;
+	}
+	link[result] = '\0';
+	/*	for (i = 0; (i < buflen) && (i < result); i++) {
+		put_user(link[i], buffer++);
+	}
+	UPDATE_ATIME(inode);*/
+	result = vfs_readlink(dentry, buffer, buflen, link);
+	kfree(link);
+	
+	D(printk("jffs_readlink:   Leaving...\n"));
+	return result;
+} /* jffs_readlink()  */
+
+
+static struct dentry *
+jffs_follow_link(struct dentry *dentry, struct dentry *base,
+	unsigned int flags)
+{
+	struct jffs_file *f;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	struct dentry *res;
+	char *link;
+	int r;
+	
+	D(printk("jffs_follow_link(): "
+			"dentry = 0x%p, inode = 0x%p, flag = 0x%08x\n",
+			dentry, inode, flags));
+	
+	f = (struct jffs_file *)inode->u.generic_ip;
+	
+	if (!(link = (char *)kmalloc(f->size + 1, GFP_KERNEL))) {
+		return ERR_PTR(-ENOMEM);
+	}
+	D3(printk (KERN_NOTICE "follow_link(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	r = jffs_read_data(f, link, 0, f->size);
+	D3(printk (KERN_NOTICE "follow_link(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (r < f->size) {
+		D(printk("jffs_follow_link(): Failed to read symname.\n"));
+		kfree(link);
+		return ERR_PTR(-EIO);
+	}
+	link[r] = '\0';
+	
+	UPDATE_ATIME(dentry->d_inode);
+	
+	if (IS_ERR(link)) {
+		dput(base);
+		res = (struct dentry *)link;
+	}
+	
+	else {
+		res = lookup_dentry(link, base, flags);
+	}
+	
+	kfree(link);
+	
+	D(printk("jffs_follow_link:   Leaving...\n"));
+	return res;
+} /* jffs_follow_link()  */
+
+/* Create an inode inside a JFFS directory (dir) and return it.
+ *
+ * By the time this is called, we already have created
+ * the directory cache entry for the new file, but it
+ * is so far negative - it has no inode.
+ *
+ * If the create succeeds, we fill in the inode information
+ * with d_instantiate().
+ */
+static int
+jffs_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_node *node;
+	struct jffs_file *dir_f; /* JFFS representation of the directory.  */
+	struct inode *inode;
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
+		memcpy(s, dentry->d_name.name, len);
+		s[len] = '\0';
+		printk("jffs_create(): dir: 0x%p, name: \"%s\"\n", dir, s);
+		kfree(s);
+	});
+
+	if (!dir->i_nlink) {
+		D(printk("jffs_create(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_create(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+
+	c = dir_f->c;
+
+	/* Create a node and initialize as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_create(): Allocation failed: node == 0\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "create(): down biglock\n"));
+	down(&c->fmc->biglock);
+
+	node->data_offset = 0;
+	node->removed_size = 0;
+
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode,
+				   dentry->d_name.name, 0, 0, NULL)) < 0) {
+		D(printk("jffs_create(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_create_end;
+	}
+
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode,
+				    dentry->d_name.name, node)) < 0) {
+		goto jffs_create_end;
+	}
+
+	/* Initialize an inode.  */
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		goto jffs_create_end;
+	}
+	err = 0;
+	inode->i_op = &jffs_file_inode_operations;
+	inode->i_op->default_file_ops = &jffs_file_operations;
+	inode->i_nrpages = 0;
+
+	d_instantiate(dentry, inode);
+
+ jffs_create_end:
+	D3(printk (KERN_NOTICE "create(): up biglock\n"));
+	up(&c->fmc->biglock);
+
+	return err;
+} /* jffs_create()  */
+
+
+/* Write, append or rewrite data to an existing file.  */
+static ssize_t
+jffs_file_write(struct file *filp, const char *buf, size_t count,
+	loff_t *ppos)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *f;
+	struct jffs_node *node;
+	struct inode *inode = filp->f_dentry->d_inode;
+	unsigned char *vbuf;
+	int recoverable = 0;
+	size_t written = 0;
+	__u32 thiscount = count;
+	loff_t pos;
+	int err = 0;
+	
+	D2(printk("***jffs_file_write(): inode: 0x%p (ino: %lu), "
+			"filp: 0x%p, buf: 0x%p, count: %d\n",
+			inode, inode->i_ino, filp, buf, count));
+	
+	if (!inode) {
+		D(printk("jffs_file_write(): inode == NULL\n"));
+		return -EINVAL;
+	}
+	
+	if (inode->i_sb->s_flags & MS_RDONLY) {
+		D(printk("jffs_file_write(): MS_RDONLY\n"));
+		return -EROFS;
+	}
+	
+	if (!S_ISREG(inode->i_mode)) {
+		D(printk("jffs_file_write(): inode->i_mode == 0x%08x\n",
+				inode->i_mode));
+		return -EINVAL;
+	}
+	
+	if (!(f = (struct jffs_file *)inode->u.generic_ip)) {
+		D(printk("jffs_file_write(): inode->u.generic_ip = 0x%p\n",
+				inode->u.generic_ip));
+		return -EINVAL;
+	}
+	
+	c = f->c;
+	
+	if (filp->f_flags & O_APPEND) {
+		pos = inode->i_size;
+	}
+	else {
+		pos = *ppos;
+	}
+	
+	thiscount = min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
+	
+	if (!(vbuf = kmalloc(thiscount, GFP_KERNEL))) {
+		D(printk("jffs_file_write(): failed to allocate bounce buffer. Fix me to use page cache\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "file_write(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	/* Urgh. POSIX says we can do short writes if we feel like it.
+	 * In practice, we can't. Nothing will cope. So we loop until
+	 * we're done.
+	 *
+	 * <_Anarchy_> posix and reality are not interconnected on this issue
+	 */
+	while (count) {
+		/* FIXME: This is entirely gratuitous use of bounce buffers.
+		   Get a clue and use the page cache.
+		   /me wanders off to get a crash course on Linux VFS
+		   dwmw2
+		*/
+		if (copy_from_user(vbuf, buf, thiscount)) {
+			err = -EFAULT;
+			goto out;
+		}
+		
+		/* Things are going to be written so we could allocate and
+		   initialize the necessary data structures now.  */
+		if (!(node = jffs_alloc_node())) {
+			D(printk("jffs_file_write(): node == 0\n"));
+			err = -ENOMEM;
+			goto out;
+		}
+		
+		node->data_offset = pos;
+		node->removed_size = 0;
+		
+		/* Initialize the raw inode.  */
+		raw_inode.magic = JFFS_MAGIC_BITMASK;
+		raw_inode.ino = f->ino;
+		raw_inode.pino = f->pino;
+/*  		raw_inode.version = f->highest_version + 1; */
+		raw_inode.mode = f->mode;
+		
+		raw_inode.uid = f->uid;
+		raw_inode.gid = f->gid;
+		raw_inode.atime = CURRENT_TIME;
+		raw_inode.mtime = raw_inode.atime;
+		raw_inode.ctime = f->ctime;
+		raw_inode.offset = pos;
+		raw_inode.dsize = thiscount;
+		raw_inode.rsize = 0;
+		raw_inode.nsize = f->nsize;
+		raw_inode.nlink = f->nlink;
+		raw_inode.spare = 0;
+		raw_inode.rename = 0;
+		raw_inode.deleted = 0;
+		
+		if (pos < f->size) {
+			node->removed_size = raw_inode.rsize = min(thiscount, (__u32)f->size - pos));
+			
+			/* If this node is going entirely over the top of old data,
+			   we can allow it to go into the reserved space, because
+			   we can that GC can reclaim the space later.
+			*/
+			if (pos + thiscount < f->size) {
+				/* If all the data we're overwriting are _real_,
+				   not just holes, then:
+				   recoverable = 1;
+				*/
+			}
+		}
+		
+		/* Write the new node to the flash.  */
+		/* NOTE: We would be quite happy if jffs_write_node() wrote a
+		   smaller node than we were expecting. There's no need for it
+		   to waste the space at the end of the flash just because it's
+		   a little smaller than what we asked for. But that's a whole
+		   new can of worms which I'm not going to open this week. dwmw2.
+		*/
+		if ((err = jffs_write_node (c, node, &raw_inode, f->name,
+						(const unsigned char *)vbuf,
+						recoverable, f)) < 0) {
+			D(printk("jffs_file_write(): jffs_write_node() failed.\n"));
+			jffs_free_node(node);
+			goto out;
+		}
+		
+		written += err;
+		buf += err;
+		count -= err;
+		pos += err;
+		
+		/* Insert the new node into the file system.  */
+		if ((err = jffs_insert_node(c, f, &raw_inode, 0, node)) < 0) {
+			goto out;
+		}
+		
+		D3(printk("jffs_file_write(): new f_pos %ld.\n", (long)pos));
+		
+		thiscount = min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
+	}
+	out:
+	D3(printk (KERN_NOTICE "file_write(): up biglock\n"));
+	up(&c->fmc->biglock);
+	*ppos = pos;
+	kfree(vbuf);
+	
+	/* Fix things in the real inode.  */
+	if (pos > inode->i_size) {
+		inode->i_size = pos;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+	}
+	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+	mark_inode_dirty(inode);
+	invalidate_inode_pages(inode);
+	
+	/* What if there was an error, _and_ we've written some data. */
+	if (written)
+		return written;
+	else
+		return err;
+} /* jffs_file_write()  */
+
+
+/* This is our ioctl() routine.  */
+static int
+jffs_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	struct jffs_control *c;
+	int ret = 0;
+	
+	D2(printk("***jffs_ioctl(): cmd = 0x%08x, arg = 0x%08lx\n",
+			cmd, arg));
+	
+	if (!(c = (struct jffs_control *)inode->i_sb->u.generic_sbp)) {
+		printk(KERN_ERR "JFFS: Bad inode in ioctl() call. "
+			"(cmd = 0x%08x)\n", cmd);
+		return -EIO;
+	}
+	D3(printk (KERN_NOTICE "ioctl(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	switch (cmd) {
+		case JFFS_PRINT_HASH:
+			jffs_print_hash_table(c);
+			break;
+		case JFFS_PRINT_TREE:
+			jffs_print_tree(c->root, 0);
+			break;
+		case JFFS_GET_STATUS:
+			{
+				struct jffs_flash_status fst;
+				struct jffs_fmcontrol *fmc = c->fmc;
+				printk("Flash status -- ");
+				if (!access_ok(VERIFY_WRITE,
+						(struct jffs_flash_status *)arg,
+						sizeof(struct jffs_flash_status))) {
+					D(printk("jffs_ioctl(): Bad arg in "
+							"JFFS_GET_STATUS ioctl!\n"));
+					ret = -EFAULT;
+					break;
+				}
+				fst.size = fmc->flash_size;
+				fst.used = fmc->used_size;
+				fst.dirty = fmc->dirty_size;
+				fst.begin = fmc->head->offset;
+				fst.end = fmc->tail->offset + fmc->tail->size;
+				printk("size: %d, used: %d, dirty: %d, "
+					"begin: %d, end: %d\n",
+					fst.size, fst.used, fst.dirty,
+					fst.begin, fst.end);
+				if (copy_to_user((struct jffs_flash_status *)arg,
+						&fst, sizeof(struct jffs_flash_status))) {
+					ret = -EFAULT;
+				}
+			}
+			break;
+		default:
+			ret = -ENOTTY;
+	}
+	D3(printk (KERN_NOTICE "ioctl(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+} /* jffs_ioctl()  */
+
+
+static int jffs_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	/* Don't allow shared writable mmaps - we don't handle them correctly */
+	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
+		return -EINVAL;
+	
+	return generic_file_mmap(file, vma);
+} /* jffs_file_mmap() */
+
+static int jffs_fsync(struct file *f, struct dentry *d)
+{
+	/* We currently have O_SYNC operations at all times.
+	   Do nothing.
+	*/
+	return 0;
+}
+
+static struct file_operations jffs_file_operations =
+{
+	read:  generic_file_read,    /* read */
+	write: jffs_file_write,      /* write */
+	ioctl: jffs_ioctl,           /* ioctl */
+	mmap:  jffs_file_mmap,    /* mmap */
+	fsync: jffs_fsync,
+};
+
+
+static struct inode_operations jffs_file_inode_operations =
+{
+	&jffs_file_operations,
+	lookup:  jffs_lookup,          /* lookup */
+	readpage: jffs_readpage,
+};
+
+
+static struct file_operations jffs_dir_operations =
+{
+	readdir: jffs_readdir,
+};
+
+
+static struct inode_operations jffs_dir_inode_operations =
+{
+	&jffs_dir_operations,
+	create:   jffs_create,
+	lookup:   jffs_lookup,
+	unlink:   jffs_unlink,
+	symlink:  jffs_symlink,
+	mkdir:    jffs_mkdir,
+	rmdir:    jffs_rmdir,
+	mknod:    jffs_mknod,
+	rename:   jffs_rename,
+};
+
+
+static struct inode_operations jffs_symlink_inode_operations =
+{
+	readlink:    jffs_readlink,
+	follow_link: jffs_follow_link,
+};
+
+
+/* Initialize an inode for the VFS.  */
+static void
+jffs_read_inode(struct inode *inode)
+{
+	struct jffs_file *f;
+	struct jffs_control *c;
+	
+	D3(printk("jffs_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
+	
+	if (!inode->i_sb) {
+		D(printk("jffs_read_inode(): !inode->i_sb ==> "
+				"No super block!\n"));
+		return;
+	}
+	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	D3(printk (KERN_NOTICE "read_inode(): down biglock\n"));
+	down(&c->fmc->biglock);
+	if (!(f = jffs_find_file(c, inode->i_ino))) {
+		D(printk("jffs_read_inode(): No such inode (%lu).\n",
+				inode->i_ino));
+		D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
+		up(&c->fmc->biglock);
+		return;
+	}
+	inode->u.generic_ip = (void *)f;
+	inode->i_mode = f->mode;
+	inode->i_nlink = f->nlink;
+	inode->i_uid = f->uid;
+	inode->i_gid = f->gid;
+	inode->i_size = f->size;
+	inode->i_atime = f->atime;
+	inode->i_mtime = f->mtime;
+	inode->i_ctime = f->ctime;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &jffs_file_inode_operations;
+		inode->i_op->default_file_ops = &jffs_file_operations;
+	}
+	else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &jffs_dir_inode_operations;
+		inode->i_op->default_file_ops = &jffs_dir_operations;
+	}
+	else if (S_ISLNK(inode->i_mode)) {
+		inode->i_op = &jffs_symlink_inode_operations;
+	} else if (S_ISCHR(inode->i_mode)) {
+		inode->i_op = &chrdev_inode_operations;
+	} else if (S_ISBLK(inode->i_mode)) {
+		inode->i_op = &blkdev_inode_operations;
+	} else if (S_ISFIFO(inode->i_mode)) {
+		init_fifo(inode);
+	}
+	
+	/* If the node is a device of some sort, then the number of the
+	   device should be read from the flash memory and then added
+	   to the inode's i_rdev member.  */
+	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {
+		kdev_t rdev;
+		jffs_read_data(f, (char *)&rdev, 0, sizeof(kdev_t));
+		inode->i_rdev = kdev_t_to_nr(rdev);
+	}
+
+	D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
+	up(&c->fmc->biglock);
+}
+
+
+void
+jffs_delete_inode(struct inode *inode)
+{
+	struct jffs_file *f;
+	struct jffs_control *c;
+	D3(printk("jffs_delete_inode(): inode->i_ino == %lu\n",
+			inode->i_ino));
+	
+	lock_kernel();
+	
+	inode->i_size = 0;
+	inode->i_blocks = 0;
+	clear_inode(inode);
+	if (inode->i_nlink == 0) {
+		c = (struct jffs_control *) inode->i_sb->u.generic_sbp;
+		f = (struct jffs_file *) jffs_find_file (c, inode->i_ino);
+		jffs_possibly_delete_file(f);
+	}
+	
+	unlock_kernel();
+}
+
+
+void
+jffs_write_super(struct super_block *sb)
+{
+	struct jffs_control *c = (struct jffs_control *)sb->u.generic_sbp;
+	
+	jffs_garbage_collect_trigger(c);
+}
+
+
+static struct super_operations jffs_ops =
+{
+	read_inode:    jffs_read_inode,
+	delete_inode:  jffs_delete_inode,
+	put_super:     jffs_put_super,
+	write_super:   jffs_write_super,
+	statfs:        jffs_statfs,
+	notify_change: jffs_notify_change,
+};
+
+
+static struct file_system_type jffs_fs_type =
+{
+	"jffs",
+	FS_REQUIRES_DEV,
+	jffs_read_super,
+	NULL
+};
+
+#ifdef MODULE
+EXPORT_NO_SYMBOLS;
+#define init_jffs_fs init_module
+#endif
+
+int
+init_jffs_fs(void)
+{
+	printk(KERN_INFO "JFFS version " JFFS_VERSION_STRING 
+	       ", (C) 1999, 2000 Axis Communications AB\n");
+	
+#ifdef CONFIG_JFFS_PROC_FS
+#ifdef KERNEL_VERSION /* Not defined for kernel 2.0.*.  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,0)
+	jffs_proc_root = create_proc_entry ("jffs",
+			S_IFDIR | S_IRUGO | S_IXUGO, &proc_root_fs);
+#else
+	proc_register_dynamic(&proc_root_fs, &jffs_proc_root);
+#endif /* Linux version.  */
+#else
+	proc_register_dynamic(&proc_root_fs, &jffs_proc_root);
+#endif /* KERNEL_VERSION  */
+#endif /* CONFIG_JFFS_PROC_FS  */
+	
+	fm_cache = kmem_cache_create("jffs_fm", sizeof(struct jffs_fm),
+				     0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	node_cache = kmem_cache_create("jffs_node",sizeof(struct jffs_node),
+			0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	
+	return register_filesystem(&jffs_fs_type);
+}
+
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	unregister_filesystem(&jffs_fs_type);
+	kmem_cache_destroy(fm_cache);
+	kmem_cache_destroy(node_cache);
+}
+#endif
diff -Naur linux-2.4.2.orig/fs/jffs/inode-v23.c linux-2.4.2/fs/jffs/inode-v23.c
--- linux-2.4.2.orig/fs/jffs/inode-v23.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/inode-v23.c	Fri Feb 15 14:41:16 2002
@@ -10,12 +10,12 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: inode-v23.c,v 1.43 2000/08/22 08:00:22 dwmw2 Exp $
- *
+ * $Id: inode-v23.c,v 1.71 2002/01/22 09:50:11 cdavies Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
  *
+ * Copyright 2000, 2001  Red Hat, Inc.
  */
 
 /* inode.c -- Contains the code that is called from the VFS.  */
@@ -48,11 +48,21 @@
 #include <linux/stat.h>
 #include <linux/blkdev.h>
 #include <linux/quotaops.h>
+#include <linux/compatmac.h>
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 #include <asm/uaccess.h>
+
 #include "jffs_fm.h"
 #include "intrep.h"
+#if CONFIG_JFFS_PROC_FS
+#include "jffs_proc.h"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,2)
+#define minor(x) MINOR(x)
+#define major(x) MAJOR(x)
+#endif
 
 static int jffs_remove(struct inode *dir, struct dentry *dentry, int type);
 
@@ -63,6 +73,8 @@
 static struct inode_operations jffs_dir_inode_operations;
 static struct address_space_operations jffs_address_operations;
 
+kmem_cache_t     *node_cache = NULL;
+kmem_cache_t     *fm_cache = NULL;
 
 /* Called by the VFS at mount time to initialize the whole file system.  */
 static struct super_block *
@@ -75,7 +87,7 @@
 	D1(printk(KERN_NOTICE "JFFS: Trying to mount device %s.\n",
 		  kdevname(dev)));
 
-	if (MAJOR(dev) != MTD_BLOCK_MAJOR) {
+	if (major(dev) != MTD_BLOCK_MAJOR) {
 		printk(KERN_WARNING "JFFS: Trying to mount a "
 		       "non-mtd device.\n");
 		return 0;
@@ -84,6 +96,7 @@
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->u.generic_sbp = (void *) 0;
+	sb->s_maxbytes = 0xFFFFFFFF;
 
 	/* Build the file system.  */
 	if (jffs_build_fs(sb) < 0) {
@@ -107,6 +120,15 @@
 
 	c = (struct jffs_control *) sb->u.generic_sbp;
 
+#ifdef CONFIG_JFFS_PROC_FS
+	/* Set up the jffs proc file system.  */
+	if (jffs_register_jffs_proc_dir(dev, c) < 0) {
+		printk(KERN_WARNING "JFFS: Failed to initialize the JFFS "
+			"proc file system for device %s.\n",
+			kdevname(dev));
+	}
+#endif
+
 	/* Set the Garbage Collection thresholds */
 
 	/* GC if free space goes below 5% of the total size */
@@ -151,15 +173,18 @@
 
 	D2(printk("jffs_put_super()\n"));
 
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_unregister_jffs_proc_dir(c);
+#endif
+
 	if (c->gc_task) {
 		D1(printk (KERN_NOTICE "jffs_put_super(): Telling gc thread to die.\n"));
 		send_sig(SIGKILL, c->gc_task, 1);
 	}
-	down (&c->gc_thread_sem);
+	wait_for_completion(&c->gc_thread_comp);
 
 	D1(printk (KERN_NOTICE "jffs_put_super(): Successfully waited on thread.\n"));
 
-	sb->s_dev = 0;
 	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
 	D1(printk(KERN_NOTICE "JFFS: Successfully unmounted device %s.\n",
 	       kdevname(dev)));
@@ -214,15 +239,13 @@
 		recoverable = 1;
         }
 
-	if (!(new_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	if (!(new_node = jffs_alloc_node())) {
 		D(printk("jffs_setattr(): Allocation failed!\n"));
 		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
 		up(&fmc->biglock);
 		return -ENOMEM;
 	}
 
-	DJM(no_jffs_node++);
 	new_node->data_offset = 0;
 	new_node->removed_size = 0;
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
@@ -303,8 +326,7 @@
 	/* Write this node to the flash.  */
 	if ((res = jffs_write_node(c, new_node, &raw_inode, f->name, 0, recoverable, f)) < 0) {
 		D(printk("jffs_notify_change(): The write failed!\n"));
-		kfree(new_node);
-		DJM(no_jffs_node--);
+		jffs_free_node(new_node);
 		D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
 		up(&c->fmc->biglock);
 		return res;
@@ -326,6 +348,7 @@
 	struct super_block * sb;
 	struct inode * inode;
 	struct jffs_control *c;
+	struct jffs_file *f;
 
 	sb = dir->i_sb;
 	inode = new_inode(sb);
@@ -341,7 +364,7 @@
 	inode->i_nlink = raw_inode->nlink;
 	inode->i_uid = raw_inode->uid;
 	inode->i_gid = raw_inode->gid;
-	inode->i_rdev = 0;
+	inode->i_rdev.value = 0;
 	inode->i_size = raw_inode->dsize;
 	inode->i_atime = raw_inode->atime;
 	inode->i_mtime = raw_inode->mtime;
@@ -349,8 +372,10 @@
 	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = (inode->i_size + 511) >> 9;
 	inode->i_version = 0;
-	inode->u.generic_ip = (void *)jffs_find_file(c, raw_inode->ino);
 
+	f = jffs_find_file(c, raw_inode->ino);
+
+	inode->u.generic_ip = (void *)f;
 	insert_inode_hash(inode);
 
 	return inode;
@@ -369,9 +394,9 @@
 	buf->f_bsize = PAGE_CACHE_SIZE;
 	buf->f_blocks = (fmc->flash_size / PAGE_CACHE_SIZE)
 		       - (fmc->min_free_size / PAGE_CACHE_SIZE);
-	buf->f_bfree = (jffs_free_size1(fmc) / PAGE_CACHE_SIZE
-		       + jffs_free_size2(fmc) / PAGE_CACHE_SIZE)
-		      - (fmc->min_free_size / PAGE_CACHE_SIZE);
+	buf->f_bfree = (jffs_free_size1(fmc) + jffs_free_size2(fmc) +
+		       fmc->dirty_size - fmc->min_free_size)
+			       >> PAGE_CACHE_SHIFT;
 	buf->f_bavail = buf->f_bfree;
 
 	/* Find out how many files there are in the filesystem.  */
@@ -400,7 +425,7 @@
 	__u32 rename_data = 0;
 
 	D2(printk("***jffs_rename()\n"));
-	
+
 	D(printk("jffs_rename(): old_dir: 0x%p, old name: 0x%p, "
 		 "new_dir: 0x%p, new name: 0x%p\n",
 		 old_dir, old_dentry->d_name.name,
@@ -436,12 +461,10 @@
 	down(&c->fmc->biglock);
 	/* Create a node and initialize as much as needed.  */
 	result = -ENOMEM;
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_rename(): Allocation failed: node == 0\n"));
 		goto jffs_rename_end;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
 
@@ -483,8 +506,7 @@
 				      new_dentry->d_name.name,
 				      (unsigned char*)&rename_data, 0, f)) < 0) {
 		D(printk("jffs_rename(): Failed to write node to flash.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_rename_end;
 	}
 	raw_inode.dsize = 0;
@@ -553,7 +575,7 @@
 	if (filp->f_pos == 0) {
 		D3(printk("jffs_readdir(): \".\" %lu\n", inode->i_ino));
 		if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino, DT_DIR) < 0) {
-		  D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 			up(&c->fmc->biglock);
 			return 0;
 		}
@@ -569,17 +591,20 @@
 		}
 		D3(printk("jffs_readdir(): \"..\" %u\n", ddino));
 		if (filldir(dirent, "..", 2, filp->f_pos, ddino, DT_DIR) < 0) {
-		  D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 			up(&c->fmc->biglock);
 			return 0;
 		}
 		filp->f_pos++;
 	}
 	f = ((struct jffs_file *)inode->u.generic_ip)->children;
-	for (j = 2; (j < filp->f_pos) && f; j++) {
-	        f = f->sibling_next;
+
+	j = 2;
+	while(f && (f->deleted || j++ < filp->f_pos )) {
+		f = f->sibling_next;
 	}
-	for (; f ; f = f->sibling_next) {
+
+	while (f) {
 		D3(printk("jffs_readdir(): \"%s\" ino: %u\n",
 			  (f->name ? f->name : ""), f->ino));
 		if (filldir(dirent, f->name, f->nsize,
@@ -589,6 +614,9 @@
 			return 0;
 		}
 		filp->f_pos++;
+		do {
+			f = f->sibling_next;
+		} while(f && f->deleted);
 	}
 	D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 	up(&c->fmc->biglock);
@@ -639,11 +667,11 @@
 
 	/* iget calls jffs_read_inode, so we need to drop the biglock
            before calling iget.  Unfortunately, the GC has a tendency
-           to sneak in here, because iget sometimes calls schedule (). 
-         */
+           to sneak in here, because iget sometimes calls schedule ().
+	*/
 
 	if ((len == 1) && (name[0] == '.')) {
-                D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 		up(&c->fmc->biglock);
 		if (!(inode = iget(dir->i_sb, d->ino))) {
 			D(printk("jffs_lookup(): . iget() ==> NULL\n"));
@@ -692,12 +720,12 @@
 
 /* Try to read a page of data from a file.  */
 static int
-jffs_readpage(struct file *file, struct page *page)
+jffs_do_readpage_nolock(struct file *file, struct page *page)
 {
 	void *buf;
 	unsigned long read_len;
-	int result = -EIO;
-	struct inode *inode = page->mapping->host;
+	int result;
+	struct inode *inode = (struct inode*)page->mapping->host;
 	struct jffs_file *f = (struct jffs_file *)inode->u.generic_ip;
 	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
 	int r;
@@ -715,43 +743,51 @@
 	D3(printk (KERN_NOTICE "readpage(): down biglock\n"));
 	down(&c->fmc->biglock);
 
+	read_len = 0;
+	result = 0;
+
 	offset = page->index << PAGE_CACHE_SHIFT;
 	if (offset < inode->i_size) {
-		read_len = jffs_min(inode->i_size - offset, PAGE_SIZE);
+		read_len = min_t(long, inode->i_size - offset, PAGE_SIZE);
 		r = jffs_read_data(f, buf, offset, read_len);
-		if (r == read_len) {
-			if (read_len < PAGE_SIZE) {
-				memset(buf + read_len, 0,
-				       PAGE_SIZE - read_len);
-			}
-			SetPageUptodate(page);
-			result = 0;
+		if (r != read_len) {
+			result = -EIO;
+			D(
+			        printk("***jffs_readpage(): Read error! "
+				       "Wanted to read %lu bytes but only "
+				       "read %d bytes.\n", read_len, r);
+			  );
 		}
-		D(else {
-			printk("***jffs_readpage(): Read error! "
-			       "Wanted to read %lu bytes but only "
-			       "read %d bytes.\n", read_len, r);
-		});
+
 	}
 
+	/* This handles the case of partial or no read in above */
+	if(read_len < PAGE_SIZE)
+	        memset(buf + read_len, 0, PAGE_SIZE - read_len);
+
 	D3(printk (KERN_NOTICE "readpage(): up biglock\n"));
 	up(&c->fmc->biglock);
-	
+
 	if (result) {
-		memset(buf, 0, PAGE_SIZE);
 	        SetPageError(page);
+	}else {
+	        SetPageUptodate(page);	        
 	}
 	flush_dcache_page(page);
 
-	UnlockPage(page);
-
 	put_page(page);
 
 	D3(printk("jffs_readpage(): Leaving...\n"));
 
 	return result;
-} /* jffs_readpage()  */
+} /* jffs_do_readpage_nolock()  */
 
+static int jffs_readpage(struct file *file, struct page *page)
+{
+	int ret = jffs_do_readpage_nolock(file, page);
+	UnlockPage(page);
+	return ret;
+}
 
 /* Create a new directory.  */
 static int
@@ -795,13 +831,11 @@
 	}
 
 	/* Create a node and initialize it as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_mkdir(): Allocation failed: node == 0\n"));
 		result = -ENOMEM;
 		goto jffs_mkdir_end;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
 
@@ -830,8 +864,7 @@
 	if ((result = jffs_write_node(c, node, &raw_inode,
 				      dentry->d_name.name, 0, 0, NULL)) < 0) {
 		D(printk("jffs_mkdir(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_mkdir_end;
 	}
 
@@ -908,8 +941,8 @@
 	int result = 0;
 
 	D1({
-	        int len = dentry->d_name.len;
-	        const char *name = dentry->d_name.name;
+		int len = dentry->d_name.len;
+		const char *name = dentry->d_name.name;
 		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
 		memcpy(_name, name, len);
 		_name[len] = '\0';
@@ -928,11 +961,15 @@
 	}
 
 	if (S_ISDIR(type)) {
-		if (del_f->children) {
-			result = -ENOTEMPTY;
-			goto jffs_remove_end;
+		struct jffs_file *child = del_f->children;
+		while(child) {
+			if( !child->deleted ) {
+				result = -ENOTEMPTY;
+				goto jffs_remove_end;
+			}
+			child = child->sibling_next;
 		}
-	}
+	}            
 	else if (S_ISDIR(del_f->mode)) {
 		D(printk("jffs_remove(): node is a directory "
 			 "but it shouldn't be.\n"));
@@ -954,12 +991,10 @@
 
 	/* Create a node for the deletion.  */
 	result = -ENOMEM;
-	if (!(del_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	if (!(del_node = jffs_alloc_node())) {
 		D(printk("jffs_remove(): Allocation failed!\n"));
 		goto jffs_remove_end;
 	}
-	DJM(no_jffs_node++);
 	del_node->data_offset = 0;
 	del_node->removed_size = 0;
 
@@ -985,8 +1020,7 @@
 
 	/* Write the new node to the flash memory.  */
 	if (jffs_write_node(c, del_node, &raw_inode, 0, 0, 1, del_f) < 0) {
-		kfree(del_node);
-		DJM(no_jffs_node--);
+		jffs_free_node(del_node);
 		result = -EIO;
 		goto jffs_remove_end;
 	}
@@ -999,9 +1033,6 @@
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	mark_inode_dirty(dir);
 	inode->i_nlink--;
-	if (inode->i_nlink == 0) {
-		inode->u.generic_ip = 0;
-	}
 	inode->i_ctime = dir->i_ctime;
 	mark_inode_dirty(inode);
 
@@ -1034,13 +1065,11 @@
 	down(&c->fmc->biglock);
 
 	/* Create and initialize a new node.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_mknod(): Allocation failed!\n"));
 		result = -ENOMEM;
 		goto jffs_mknod_err;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
 
@@ -1067,7 +1096,7 @@
 
 	/* Write the new node to the flash.  */
 	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
-				  (unsigned char *)&dev, 0, NULL)) < 0) {
+				   (unsigned char *)&dev, 0, NULL)) < 0) {
 		D(printk("jffs_mknod(): jffs_write_node() failed.\n"));
 		result = err;
 		goto jffs_mknod_err;
@@ -1094,8 +1123,7 @@
 
 jffs_mknod_err:
 	if (node) {
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 	}
 
 jffs_mknod_end:
@@ -1118,7 +1146,7 @@
 	int err;
 
 	D1({
-	        int len = dentry->d_name.len;
+		int len = dentry->d_name.len; 
 		char *_name = (char *)kmalloc(len + 1, GFP_KERNEL);
 		char *_symname = (char *)kmalloc(symname_len + 1, GFP_KERNEL);
 		memcpy(_name, dentry->d_name.name, len);
@@ -1142,15 +1170,13 @@
 	c = dir_f->c;
 
 	/* Create a node and initialize it as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_symlink(): Allocation failed: node = NULL\n"));
 		return -ENOMEM;
 	}
 	D3(printk (KERN_NOTICE "symlink(): down biglock\n"));
 	down(&c->fmc->biglock);
 
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
 
@@ -1178,8 +1204,7 @@
 	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
 				   (const unsigned char *)symname, 0, NULL)) < 0) {
 		D(printk("jffs_symlink(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_symlink_end;
 	}
 
@@ -1225,7 +1250,7 @@
 	int err;
 
 	D1({
-	        int len = dentry->d_name.len;
+		int len = dentry->d_name.len;
 		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
 		memcpy(s, dentry->d_name.name, len);
 		s[len] = '\0';
@@ -1243,15 +1268,13 @@
 	c = dir_f->c;
 
 	/* Create a node and initialize as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_create(): Allocation failed: node == 0\n"));
 		return -ENOMEM;
 	}
 	D3(printk (KERN_NOTICE "create(): down biglock\n"));
 	down(&c->fmc->biglock);
 
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
 
@@ -1279,8 +1302,7 @@
 	if ((err = jffs_write_node(c, node, &raw_inode,
 				   dentry->d_name.name, 0, 0, NULL)) < 0) {
 		D(printk("jffs_create(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_create_end;
 	}
 
@@ -1320,11 +1342,10 @@
 	struct jffs_node *node;
 	struct dentry *dentry = filp->f_dentry;
 	struct inode *inode = dentry->d_inode;
-	unsigned char *vbuf;
 	int recoverable = 0;
 	size_t written = 0;
 	__u32 thiscount = count;
-	loff_t pos;
+	loff_t pos = *ppos;
 	int err;
 
 	inode = filp->f_dentry->d_inode;
@@ -1333,52 +1354,39 @@
 		  "filp: 0x%p, buf: 0x%p, count: %d\n",
 		  inode, inode->i_ino, filp, buf, count));
 
-	err = filp->f_error;
-	if (err) {
-		filp->f_error = 0;
-		return err;
-	}
-
-	down(&inode->i_sem);
-
+#if 0
 	if (inode->i_sb->s_flags & MS_RDONLY) {
 		D(printk("jffs_file_write(): MS_RDONLY\n"));
 		err = -EROFS;
 		goto out_isem;
 	}
-
+#endif	
 	err = -EINVAL;
 
 	if (!S_ISREG(inode->i_mode)) {
 		D(printk("jffs_file_write(): inode->i_mode == 0x%08x\n",
-			 inode->i_mode));
+				inode->i_mode));
 		goto out_isem;
 	}
 
 	if (!(f = (struct jffs_file *)inode->u.generic_ip)) {
 		D(printk("jffs_file_write(): inode->u.generic_ip = 0x%p\n",
-			 inode->u.generic_ip));
+				inode->u.generic_ip));
 		goto out_isem;
 	}
 
 	c = f->c;
 
-	if (filp->f_flags & O_APPEND)
-		pos = inode->i_size;
-	else
-		pos = *ppos;
-	
-	if (pos < 0) {
-		goto out_isem;
-	}
-	
-	thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
-
-	if (!(vbuf = kmalloc(thiscount, GFP_KERNEL))) {
-		D(printk("jffs_file_write(): failed to allocate bounce buffer. Fix me to use page cache\n"));
-		err = -ENOMEM;
-		goto out_isem;
-	}
+	/*
+	 * This will never trigger with sane page sizes.  leave it in
+	 * anyway, since I'm thinking about how to merge larger writes
+	 * (the current idea is to poke a thread that does the actual
+	 * I/O and starts by doing a down(&inode->i_sem).  then we
+	 * would need to get the page cache pages and have a list of
+	 * I/O requests and do write-merging here.
+	 * -- prumpf
+	 */
+	thiscount = min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
 
 	D3(printk (KERN_NOTICE "file_write(): down biglock\n"));
 	down(&c->fmc->biglock);
@@ -1390,37 +1398,24 @@
 	 * <_Anarchy_> posix and reality are not interconnected on this issue
 	 */
 	while (count) {
-
-		/* FIXME: This is entirely gratuitous use of bounce buffers.
-		   Get a clue and use the page cache. 
-		   /me wanders off to get a crash course on Linux VFS
-		   dwmw2
-		*/
-		if (copy_from_user(vbuf, buf, thiscount)) {
-			err = -EFAULT;
-			goto out;
-		}
-		
 		/* Things are going to be written so we could allocate and
 		   initialize the necessary data structures now.  */
-		if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-							  GFP_KERNEL))) {
+		if (!(node = jffs_alloc_node())) {
 			D(printk("jffs_file_write(): node == 0\n"));
 			err = -ENOMEM;
 			goto out;
 		}
-		DJM(no_jffs_node++);
-		
+
 		node->data_offset = pos;
 		node->removed_size = 0;
-		
+
 		/* Initialize the raw inode.  */
 		raw_inode.magic = JFFS_MAGIC_BITMASK;
 		raw_inode.ino = f->ino;
 		raw_inode.pino = f->pino;
 
 		raw_inode.mode = f->mode;
-		
+
 		raw_inode.uid = f->uid;
 		raw_inode.gid = f->gid;
 		raw_inode.atime = CURRENT_TIME;
@@ -1434,13 +1429,13 @@
 		raw_inode.spare = 0;
 		raw_inode.rename = 0;
 		raw_inode.deleted = 0;
-		
+
 		if (pos < f->size) {
-			node->removed_size = raw_inode.rsize = jffs_min(thiscount, f->size - pos);
-			
-			/* If this node is going entirely over the top of old data, 
-			   we can allow it to go into the reserved space, because 
-			   we can that GC can reclaim the space later.
+			node->removed_size = raw_inode.rsize = min(thiscount, (__u32)(f->size - pos));
+
+			/* If this node is going entirely over the top of old data,
+			   we can allow it to go into the reserved space, because
+			   we know that GC can reclaim the space later.
 			*/
 			if (pos + thiscount < f->size) {
 				/* If all the data we're overwriting are _real_,
@@ -1449,20 +1444,20 @@
 				*/
 			}
 		}
-		
+
 		/* Write the new node to the flash.  */
-		/* NOTE: We would be quite happy if jffs_write_node() wrote a 
-		   smaller node than we were expecting. There's no need for it 
-		   to waste the space at the end of the flash just because it's 
+		/* NOTE: We would be quite happy if jffs_write_node() wrote a
+		   smaller node than we were expecting. There's no need for it
+		   to waste the space at the end of the flash just because it's
 		   a little smaller than what we asked for. But that's a whole
-		   new can of worms which I'm not going to open this week. dwmw2.
+		   new can of worms which I'm not going to open this week. 
+		   -- dwmw2.
 		*/
 		if ((err = jffs_write_node(c, node, &raw_inode, f->name,
-					   (const unsigned char *)vbuf,
+					   (const unsigned char *)buf,
 					   recoverable, f)) < 0) {
 			D(printk("jffs_file_write(): jffs_write_node() failed.\n"));
-			kfree(node);
-			DJM(no_jffs_node--);
+			jffs_free_node(node);
 			goto out;
 		}
 
@@ -1478,13 +1473,11 @@
 
 		D3(printk("jffs_file_write(): new f_pos %ld.\n", (long)pos));
 
-		thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
+		thiscount = min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
 	}
  out:
 	D3(printk (KERN_NOTICE "file_write(): up biglock\n"));
 	up(&c->fmc->biglock);
-	*ppos = pos;
-	kfree(vbuf);
 
 	/* Fix things in the real inode.  */
 	if (pos > inode->i_size) {
@@ -1496,15 +1489,32 @@
 	invalidate_inode_pages(inode);
 
  out_isem:
-	up(&inode->i_sem);
-	
-	/* What if there was an error, _and_ we've written some data. */
-	if (written)
-		return written;
-	else
-		return err;
+	return err;
 } /* jffs_file_write()  */
 
+static ssize_t
+jffs_prepare_write(struct file *filp, struct page *page,
+                  unsigned from, unsigned to)
+{
+	/* FIXME: we should detect some error conditions here */
+
+	/* Bugger that. We should make sure the page is uptodate */
+	if (!Page_Uptodate(page) && (from || to < PAGE_CACHE_SIZE))
+		return jffs_do_readpage_nolock(filp, page);
+
+	return 0;
+} /* jffs_prepare_write() */
+
+static ssize_t
+jffs_commit_write(struct file *filp, struct page *page,
+                 unsigned from, unsigned to)
+{
+       void *addr = page_address(page) + from;
+       /* XXX: PAGE_CACHE_SHIFT or PAGE_SHIFT */
+       loff_t pos = (page->index<<PAGE_CACHE_SHIFT) + from;
+
+       return jffs_file_write(filp, addr, to-from, &pos);
+} /* jffs_commit_write() */
 
 /* This is our ioctl() routine.  */
 static int
@@ -1557,7 +1567,7 @@
 			if (copy_to_user((struct jffs_flash_status *)arg,
 					 &fst,
 					 sizeof(struct jffs_flash_status))) {
-			  ret = -EFAULT;
+				ret = -EFAULT;
 			}
 		}
 		break;
@@ -1572,24 +1582,31 @@
 
 static struct address_space_operations jffs_address_operations = {
 	readpage: jffs_readpage,
+	prepare_write: jffs_prepare_write,
+	commit_write: jffs_commit_write,
 };
 
 static int jffs_fsync(struct file *f, struct dentry *d, int datasync)
 {
-	/* We currently have O_SYNC operations at all times. 
-	   Do nothing
+	/* We currently have O_SYNC operations at all times.
+	   Do nothing.
 	*/
 	return 0;
 }
 
 
+extern int generic_file_open(struct inode *, struct file *) __attribute__((weak));
+extern loff_t generic_file_llseek(struct file *, loff_t, int) __attribute__((weak));
+
 static struct file_operations jffs_file_operations =
 {
-	read:  generic_file_read,    /* read */
-	write: jffs_file_write,      /* write */
-	ioctl: jffs_ioctl,           /* ioctl */
-	mmap:  generic_file_mmap,    /* mmap */
-	fsync: jffs_fsync,
+	open:	generic_file_open,
+	llseek:	generic_file_llseek,
+	read:	generic_file_read,
+	write:	generic_file_write,
+	ioctl:	jffs_ioctl,
+	mmap:	generic_file_mmap,
+	fsync:	jffs_fsync,
 };
 
 
@@ -1676,6 +1693,7 @@
 		jffs_read_data(f, (char *)&rdev, 0, sizeof(kdev_t));
 		init_special_inode(inode, inode->i_mode, kdev_t_to_nr(rdev));
 	}
+
 	D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
 	up(&c->fmc->biglock);
 }
@@ -1684,13 +1702,22 @@
 void
 jffs_delete_inode(struct inode *inode)
 {
+	struct jffs_file *f;
+	struct jffs_control *c;
 	D3(printk("jffs_delete_inode(): inode->i_ino == %lu\n",
 		  inode->i_ino));
 
 	lock_kernel();
 	inode->i_size = 0;
 	inode->i_blocks = 0;
+	inode->u.generic_ip = 0;
 	clear_inode(inode);
+	if (inode->i_nlink == 0) {
+		c = (struct jffs_control *) inode->i_sb->u.generic_sbp;
+		f = (struct jffs_file *) jffs_find_file (c, inode->i_ino);
+		jffs_possibly_delete_file(f);
+	}
+
 	unlock_kernel();
 }
 
@@ -1703,7 +1730,6 @@
 	jffs_garbage_collect_trigger(c);
 }
 
-
 static struct super_operations jffs_ops =
 {
 	read_inode:   jffs_read_inode,
@@ -1719,9 +1745,16 @@
 static int __init
 init_jffs_fs(void)
 {
-	printk("JFFS version "
-	       JFFS_VERSION_STRING
-	       ", (C) 1999, 2000  Axis Communications AB\n");
+	printk(KERN_INFO "JFFS version " JFFS_VERSION_STRING
+		", (C) 1999, 2000  Axis Communications AB\n");
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_proc_root = proc_mkdir("jffs", proc_root_fs);
+#endif
+	fm_cache = kmem_cache_create("jffs_fm", sizeof(struct jffs_fm),
+				     0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	node_cache = kmem_cache_create("jffs_node",sizeof(struct jffs_node),
+				       0, SLAB_HWCACHE_ALIGN, NULL, NULL);
 	return register_filesystem(&jffs_fs_type);
 }
 
@@ -1729,9 +1762,15 @@
 exit_jffs_fs(void)
 {
 	unregister_filesystem(&jffs_fs_type);
+	kmem_cache_destroy(fm_cache);
+	kmem_cache_destroy(node_cache);
 }
 
 EXPORT_NO_SYMBOLS;
 
 module_init(init_jffs_fs)
 module_exit(exit_jffs_fs)
+
+MODULE_DESCRIPTION("The Journalling Flash File System");
+MODULE_AUTHOR("Axis Communications AB.");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.4.2.orig/fs/jffs/intrep.c linux-2.4.2/fs/jffs/intrep.c
--- linux-2.4.2.orig/fs/jffs/intrep.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/intrep.c	Fri Feb 15 14:41:16 2002
@@ -10,8 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * - Based on Id: intrep.c,v 1.71 2000/10/27 16:51:29 dwmw2 Exp
- * - With the ctype() changes from v1.77.
+ * $Id: intrep.c,v 1.103 2001/12/10 17:37:12 asanochkin Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -57,6 +56,7 @@
  */
 
 #define __NO_VERSION__
+#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/jffs.h>
@@ -74,9 +74,9 @@
 #include "intrep.h"
 #include "jffs_fm.h"
 
-#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
-long no_jffs_file = 0;
 long no_jffs_node = 0;
+long no_jffs_file = 0;
+#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
 long no_jffs_control = 0;
 long no_jffs_raw_inode = 0;
 long no_jffs_node_ref = 0;
@@ -88,9 +88,24 @@
 
 static int jffs_scan_flash(struct jffs_control *c);
 static int jffs_update_file(struct jffs_file *f, struct jffs_node *node);
-static __u8 flash_read_u8(struct mtd_info *mtd, loff_t from);
 
-#if 1
+#if CONFIG_JFFS_FS_VERBOSE > 0
+static __u8
+flash_read_u8(struct mtd_info *mtd, loff_t from)
+{
+	size_t retlen;
+	__u8 ret;
+	int res;
+
+	res = MTD_READ(mtd, from, 1, &retlen, &ret);
+	if (retlen != 1) {
+		printk("Didn't read a byte in flash_read_u8(). Returned %d\n", res);
+		return 0;
+	}
+
+	return ret;
+}
+
 static void
 jffs_hexdump(struct mtd_info *mtd, loff_t pos, int size)
 {
@@ -136,6 +151,7 @@
 		size -= 16;
 	}
 }
+
 #endif
 
 #define flash_safe_acquire(arg)
@@ -150,7 +166,7 @@
 	int res;
 
 	D3(printk(KERN_NOTICE "flash_safe_read(%p, %08x, %p, %08x)\n",
-		  mtd, from, buf, count));
+		  mtd, (unsigned int) from, buf, count));
 
 	res = MTD_READ(mtd, from, count, &retlen, buf);
 	if (retlen != count) {
@@ -177,33 +193,58 @@
 }
 
 
-static __u8
-flash_read_u8(struct mtd_info *mtd, loff_t from)
+static int
+flash_safe_write(struct mtd_info *mtd, loff_t to,
+		 const u_char *buf, size_t count)
 {
 	size_t retlen;
-	__u8 ret;
 	int res;
 
-	res = MTD_READ(mtd, from, 1, &retlen, &ret);
-	if (retlen != 1) {
-		printk("Didn't read a byte in flash_read_u8(). Returned %d\n", res);
-		return 0;
-	}
+	D3(printk(KERN_NOTICE "flash_safe_write(%p, %08x, %p, %08x)\n",
+		  mtd, (unsigned int) to, buf, count));
 
-	return ret;
+	res = MTD_WRITE(mtd, to, count, &retlen, buf);
+	if (retlen != count) {
+		printk("Didn't write all bytes in flash_safe_write(). Returned %d\n", res);
+	}
+	return res?res:retlen;
 }
 
 
 static int
-flash_safe_write(struct mtd_info *mtd, loff_t to,
-		 const u_char *buf, size_t count)
+flash_safe_writev(struct mtd_info *mtd, const struct iovec *vecs,
+			unsigned long iovec_cnt, loff_t to)
 {
-	size_t retlen;
+	size_t retlen, retlen_a;
+	int i;
 	int res;
 
-	res = MTD_WRITE(mtd, to, count, &retlen, buf);
-	if (retlen != count) {
-		printk("Didn't write all bytes in flash_safe_write(). Returned %d\n", res);
+	D3(printk(KERN_NOTICE "flash_safe_writev(%p, %08x, %p)\n",
+		  mtd, (unsigned int) to, vecs));
+	
+	if (mtd->writev) {
+		res = MTD_WRITEV(mtd, vecs, iovec_cnt, to, &retlen);
+		return res ? res : retlen;
+	}
+	/* Not implemented writev. Repeatedly use write - on the not so
+	   unreasonable assumption that the mtd driver doesn't care how
+	   many write cycles we use. */
+	res=0;
+	retlen=0;
+
+	for (i=0; !res && i<iovec_cnt; i++) {
+		res = MTD_WRITE(mtd, to, vecs[i].iov_len, &retlen_a, vecs[i].iov_base);
+		if (retlen_a != vecs[i].iov_len) {
+			printk("Didn't write all bytes in flash_safe_writev(). Returned %d\n", res);
+			if (i != iovec_cnt-1)
+				return -EIO;
+		}
+		/* If res is non-zero, retlen_a is undefined, but we don't
+		   care because in that case it's not going to be 
+		   returned anyway.
+		*/
+		to += retlen_a;
+		retlen += retlen_a;
 	}
 	return res?res:retlen;
 }
@@ -213,20 +254,20 @@
 flash_memset(struct mtd_info *mtd, loff_t to,
 	     const u_char c, size_t size)
 {
-	static unsigned char pattern[16];
+	static unsigned char pattern[64];
 	int i;
 
 	/* fill up pattern */
 
-	for(i = 0; i < 16; i++)
+	for(i = 0; i < 64; i++)
 		pattern[i] = c;
 
-	/* write as many 16-byte chunks as we can */
+	/* write as many 64-byte chunks as we can */
 
-	while (size >= 16) {
-		flash_safe_write(mtd, to, pattern, 16);
-		size -= 16;
-		to += 16;
+	while (size >= 64) {
+		flash_safe_write(mtd, to, pattern, 64);
+		size -= 64;
+		to += 64;
 	}
 
 	/* and the rest */
@@ -292,21 +333,6 @@
 	return 0;
 }
 
-
-inline int
-jffs_min(int a, int b)
-{
-	return (a < b ? a : b);
-}
-
-
-inline int
-jffs_max(int a, int b)
-{
-	return (a > b ? a : b);
-}
-
-
 /* This routine calculates checksums in JFFS.  */
 __u32
 jffs_checksum(const void *data, int size)
@@ -321,8 +347,8 @@
 }
 
 
-__u32
-jffs_checksum_flash(struct mtd_info *mtd, loff_t start, int size)
+int
+jffs_checksum_flash(struct mtd_info *mtd, loff_t start, int size, __u32 *result)
 {
 	__u32 sum = 0;
 	loff_t ptr = start;
@@ -331,7 +357,10 @@
 
 	/* Allocate read buffer */
 	read_buf = (__u8 *) kmalloc (sizeof(__u8) * 4096, GFP_KERNEL);
-
+	if (!read_buf) {
+		printk(KERN_NOTICE "kmalloc failed in jffs_checksum_flash()\n");
+		return -ENOMEM;
+	}
 	/* Loop until checksum done */
 	while (size) {
 		/* Get amount of data to read */
@@ -358,8 +387,10 @@
 
 	/* Return result */
 	D3(printk("checksum result: 0x%08x\n", sum));
-	return sum;
+	*result = sum;
+	return 0;
 }
+
 static __inline__ void jffs_fm_write_lock(struct jffs_fmcontrol *fmc)
 {
   //	down(&fmc->wlock);
@@ -383,7 +414,7 @@
 		D(printk("jffs_create_file(): Failed!\n"));
 		return 0;
 	}
-	DJM(no_jffs_file++);
+	no_jffs_file++;
 	memset(f, 0, sizeof(struct jffs_file));
 	f->ino = raw_inode->ino;
 	f->pino = raw_inode->pino;
@@ -487,11 +518,10 @@
 						 GFP_KERNEL))) {
 		return -ENOMEM;
 	}
-	DJM(no_jffs_file++);
-	if (!(node = (struct jffs_node *)kmalloc(sizeof(struct jffs_node),
-						 GFP_KERNEL))) {
+	no_jffs_file++;
+	if (!(node = jffs_alloc_node())) {
 		kfree(root);
-		DJM(no_jffs_file--);
+		no_jffs_file--;
 		return -ENOMEM;
 	}
 	DJM(no_jffs_node++);
@@ -525,7 +555,26 @@
 	c->building_fs = 1;
 	c->sb = sb;
 	if ((err = jffs_scan_flash(c)) < 0) {
-		goto jffs_build_fs_fail;
+		if(err == -EAGAIN){
+			/* scan_flash() wants us to try once more. A flipping 
+			   bits sector was detect in the middle of the scan flash.
+			   Clean up old allocated memory before going in.
+			*/
+			D1(printk("jffs_build_fs: Cleaning up all control structures,"
+				  " reallocating them and trying mount again.\n"));
+			jffs_cleanup_control(c);
+			if (!(c = jffs_create_control(sb->s_dev))) {
+				return -ENOMEM;
+			}
+			c->building_fs = 1;
+			c->sb = sb;
+
+			if ((err = jffs_scan_flash(c)) < 0) {
+				goto jffs_build_fs_fail;
+			}			
+		}else{
+			goto jffs_build_fs_fail;
+		}
 	}
 
 	/* Add a virtual root node if no one exists.  */
@@ -580,6 +629,125 @@
 } /* jffs_build_fs()  */
 
 
+/*
+  This checks for sectors that were being erased in their previous 
+  lifetimes and for some reason or the other (power fail etc.), 
+  the erase cycles never completed.
+  As the flash array would have reverted back to read status, 
+  these sectors are detected by the symptom of the "flipping bits",
+  i.e. bits being read back differently from the same location in
+  flash if read multiple times.
+  The only solution to this is to re-erase the entire
+  sector.
+  Unfortunately detecting "flipping bits" is not a simple exercise
+  as a bit may be read back at 1 or 0 depending on the alignment 
+  of the stars in the universe.
+  The level of confidence is in direct proportion to the number of 
+  scans done. By power fail testing I (Vipin) have been able to 
+  proove that reading twice is not enough.
+  Maybe 4 times? Change NUM_REREADS to a higher number if you want
+  a (even) higher degree of confidence in your mount process. 
+  A higher number would of course slow down your mount.
+*/
+int check_partly_erased_sectors(struct jffs_fmcontrol *fmc){
+
+#define NUM_REREADS             4 /* see note above */
+#define READ_AHEAD_BYTES        4096 /* must be a multiple of 4, 
+					usually set to kernel page size */
+
+	__u8 *read_buf1;
+	__u8 *read_buf2;
+
+	int err = 0;
+	int retlen;
+	int i;
+	int cnt;
+	__u32 offset;
+	loff_t pos = 0;
+	loff_t end = fmc->flash_size;
+
+
+	/* Allocate read buffers */
+	read_buf1 = (__u8 *) kmalloc (sizeof(__u8) * READ_AHEAD_BYTES, GFP_KERNEL);
+	if (!read_buf1)
+		return -ENOMEM;
+
+	read_buf2 = (__u8 *) kmalloc (sizeof(__u8) * READ_AHEAD_BYTES, GFP_KERNEL);
+	if (!read_buf2) {
+		kfree(read_buf1);
+		return -ENOMEM;
+	}
+
+ CHECK_NEXT:
+	while(pos < end){
+		
+		D1(printk("check_partly_erased_sector():checking sector which contains"
+			  " offset 0x%x for flipping bits..\n", (__u32)pos));
+		
+		retlen = flash_safe_read(fmc->mtd, pos,
+					 &read_buf1[0], READ_AHEAD_BYTES);
+		retlen &= ~3;
+		
+		for(cnt = 0; cnt < NUM_REREADS; cnt++){
+			(void)flash_safe_read(fmc->mtd, pos,
+					      &read_buf2[0], READ_AHEAD_BYTES);
+			
+			for (i=0 ; i < retlen ; i+=4) {
+				/* buffers MUST match, double word for word! */
+				if(*((__u32 *) &read_buf1[i]) !=
+				   *((__u32 *) &read_buf2[i])
+				   ){
+				        /* flipping bits detected, time to erase sector */
+					/* This will help us log some statistics etc. */
+					D1(printk("Flipping bits detected in re-read round:%i of %i\n",
+					       cnt, NUM_REREADS));
+					D1(printk("check_partly_erased_sectors:flipping bits detected"
+						  " @offset:0x%x(0x%x!=0x%x)\n",
+						  (__u32)pos+i, *((__u32 *) &read_buf1[i]), 
+						  *((__u32 *) &read_buf2[i])));
+					
+				        /* calculate start of present sector */
+					offset = (((__u32)pos+i)/(__u32)fmc->sector_size) * (__u32)fmc->sector_size;
+					
+					D1(printk("check_partly_erased_sector():erasing sector starting 0x%x.\n",
+						  offset));
+					
+					if (flash_erase_region(fmc->mtd,
+							       offset, fmc->sector_size) < 0) {
+						printk(KERN_ERR "JFFS: Erase of flash failed. "
+						       "offset = %u, erase_size = %d\n",
+						       offset , fmc->sector_size);
+						
+						err = -EIO;
+						goto returnBack;
+
+					}else{
+						D1(printk("JFFS: Erase of flash sector @0x%x successful.\n",
+						       offset));
+						/* skip ahead to the next sector */
+						pos = (((__u32)pos+i)/(__u32)fmc->sector_size) * (__u32)fmc->sector_size;
+						pos += fmc->sector_size;
+						goto CHECK_NEXT;
+					}
+				}
+			}
+		}
+		pos += READ_AHEAD_BYTES;
+	}
+
+ returnBack:
+	kfree(read_buf1);
+	kfree(read_buf2);
+
+	D2(printk("check_partly_erased_sector():Done checking all sectors till offset 0x%x for flipping bits.\n",
+		  (__u32)pos));
+
+	return err;
+
+}/* end check_partly_erased_sectors() */
+
+
+
 /* Scan the whole flash memory in order to find all nodes in the
    file systems.  */
 static int
@@ -593,20 +761,54 @@
 	__u8 tmp_accurate;
 	__u16 tmp_chksum;
 	__u32 deleted_file;
-	loff_t pos = fmc->flash_start;
+	loff_t pos = 0;
 	loff_t start;
-	loff_t end = fmc->flash_start + fmc->flash_size;
+	loff_t test_start;
+	loff_t end = fmc->flash_size;
 	__u8 *read_buf;
 	int i, len, retlen;
+	__u32 offset;
+
+	__u32 free_chunk_size1;
+	__u32 free_chunk_size2;
+
+	__u32 largest_hole         = 0;
+	__u32 hole_end_offset      = 0;
+	__u32 head_offset;
+	
+#define NUMFREEALLOWED     2        /* 2 chunks of at least erase size space allowed */
+	int num_free_space = 0;       /* Flag err if more than TWO
+				       free blocks found. This is NOT allowed
+				       by the current jffs design.
+				    */
+	int num_free_spc_not_accp = 0; /* For debugging purposed keep count 
+					of how much free space was rejected and
+					marked dirty
+				     */
 
 	D1(printk("jffs_scan_flash(): start pos = 0x%lx, end = 0x%lx\n",
 		  (long)pos, (long)end));
 
 	flash_safe_acquire(fmc->mtd);
 
+	/*
+	  check and make sure that any sector does not suffer
+	  from the "partly erased, bit flipping syndrome" (TM Vipin :)
+	  If so, offending sectors will be erased.
+	*/
+	if(check_partly_erased_sectors(fmc) < 0){
+
+		flash_safe_release(fmc->mtd);
+		return -EIO; /* bad, bad, bad error. Cannot continue.*/
+	}
+
 	/* Allocate read buffer */
 	read_buf = (__u8 *) kmalloc (sizeof(__u8) * 4096, GFP_KERNEL);
-
+	if (!read_buf) {
+		flash_safe_release(fmc->mtd);
+		return -ENOMEM;
+	}
+			      
 	/* Start the scan.  */
 	while (pos < end) {
 		deleted_file = 0;
@@ -616,32 +818,40 @@
 
 		switch (flash_read_u32(fmc->mtd, pos)) {
 		case JFFS_EMPTY_BITMASK:
-			/* We have found 0xff at this position.  We have to
+			/* We have found 0xffffffff at this position.  We have to
 			   scan the rest of the flash till the end or till
-			   something else than 0xff is found.  */
-			D1(printk("jffs_scan_flash(): 0xff at pos 0x%lx.\n",
+			   something else than 0xffffffff is found.
+		           Keep going till we do not find JFFS_EMPTY_BITMASK 
+			   anymore */
+
+			D1(printk("jffs_scan_flash(): 0xffffffff at pos 0x%lx.\n",
 				  (long)pos));
 
-			len = end - pos < 4096 ? end - pos : 4096;
+		        while(pos < end){
 
-			retlen = flash_safe_read(fmc->mtd, pos,
+			      len = end - pos < 4096 ? end - pos : 4096;
+			      
+			      retlen = flash_safe_read(fmc->mtd, pos,
 						 &read_buf[0], len);
 
-			retlen &= ~3;
-
-			for (i=0 ; i < retlen ; i+=4, pos += 4) {
-				if(*((__u32 *) &read_buf[i]) !=
-						JFFS_EMPTY_BITMASK)
+			      retlen &= ~3;
+			      
+			      for (i=0 ; i < retlen ; i+=4, pos += 4) {
+				      if(*((__u32 *) &read_buf[i]) !=
+					 JFFS_EMPTY_BITMASK)
 					break;
+			      }
+			      if (i == retlen)
+				    continue;
+			      else
+				    break;
 			}
-			if (i == retlen)
-				continue;
-
-			D1(printk("jffs_scan_flash(): 0xff ended at "
-				  "pos 0x%lx.\n", (long)pos));
 
+			D1(printk("jffs_scan_flash():0xffffffff ended at pos 0x%lx.\n",
+				  (long)pos));
+			
 			/* If some free space ends in the middle of a sector,
-				treat it as dirty rather than clean.
+			   treat it as dirty rather than clean.
 			   This is to handle the case where one thread 
 			   allocated space for a node, but didn't get to
 			   actually _write_ it before power was lost, leaving
@@ -654,20 +864,155 @@
 				   only from the beginning of this sector
 				   (or from start) 
 				*/
-				if (start < (pos & ~(fmc->sector_size-1))) {
-					D1(printk("Reducing start to 0x%x from 0x%x\n", pos & ~(fmc->sector_size-1), start));
-					start = pos & ~(fmc->sector_size-1);
+
+			        test_start = pos & ~(fmc->sector_size-1); /* end of last sector */
+
+				if (start < test_start) {
+
+				        /* free space started in the previous sector! */
+
+					if((num_free_space < NUMFREEALLOWED) && 
+					   ((unsigned int)(test_start - start) >= fmc->sector_size)){
+
+				                /*
+						  Count it in if we are still under NUMFREEALLOWED *and* it is 
+						  at least 1 erase sector in length. This will keep us from 
+						  picking any little ole' space as "free".
+						*/
+					  
+					        D1(printk("Reducing end of free space to 0x%x from 0x%x\n",
+							  (unsigned int)test_start, (unsigned int)pos));
+
+						D1(printk("Free space accepted: Starting 0x%x for 0x%x bytes\n",
+							  (unsigned int) start,
+							  (unsigned int)(test_start - start)));
+
+						D1(printk("Reducing start to 0x%x from 0x%x\n",
+						          test_start, start));
+						if (largest_hole < test_start - start){
+							
+							D3(printk("was hole = %x end_offset = %x\n",
+							          largest_hole, hole_end_offset));
+							if (fmc->head) {
+								largest_hole    = test_start - start;
+								hole_end_offset = test_start;
+							}
+						}
+
+						D3(printk("now = %x end_offset = %x\n",
+					        	largest_hole, hole_end_offset));
+
+						/* below, space from "start" to "pos" will be marked dirty. */
+						start = test_start; 
+						
+						/* Being in here means that we have found at least an entire 
+						   erase sector size of free space ending on a sector boundary.
+						   Keep track of free spaces accepted.
+						*/
+						num_free_space++;
+					}else{
+					        num_free_spc_not_accp++;
+					        D1(printk("Free space (#%i) found but *Not* accepted: Starting"
+							  " 0x%x for 0x%x bytes\n",
+							  num_free_spc_not_accp, (unsigned int)start, 
+							  (unsigned int)((unsigned int)(pos & ~(fmc->sector_size-1)) - (unsigned int)start)));
+					        
+					}
+					
 				}
-				D1(printk("Dirty space: 0x%x for 0x%x bytes\n", start, (pos - start)));
-				jffs_fmalloced(fmc, (__u32) start,
-					       (__u32) (pos - start), 0);
+				if((((__u32)(pos - start)) != 0)){
+
+				        D1(printk("Dirty space: Starting 0x%x for 0x%x bytes\n",
+						  (unsigned int) start, (unsigned int) (pos - start)));
+					jffs_fmalloced(fmc, (__u32) start,
+						       (__u32) (pos - start), 0);
+				}else{
+					/* "Flipping bits" detected. This means that our scan for them
+					   did not catch this offset. See check_partly_erased_sectors() for
+					   more info.
+					*/
+				        
+					D1(printk("jffs_scan_flash():wants to allocate dirty flash "
+						  "space for 0 bytes.\n"));
+					D1(printk("jffs_scan_flash(): Flipping bits! We will free "
+						  "all allocated memory, erase this sector and remount\n"));
+
+					/* calculate start of present sector */
+					offset = (((__u32)pos)/(__u32)fmc->sector_size) * (__u32)fmc->sector_size;
+					
+					D1(printk("jffs_scan_flash():erasing sector starting 0x%x.\n",
+						  offset));
+					
+					if (flash_erase_region(fmc->mtd,
+							       offset, fmc->sector_size) < 0) {
+						printk(KERN_ERR "JFFS: Erase of flash failed. "
+						       "offset = %u, erase_size = %d\n",
+						       offset , fmc->sector_size);
+
+						flash_safe_release(fmc->mtd);
+						kfree (read_buf);
+						return -1; /* bad, bad, bad! */
+
+					}
+					flash_safe_release(fmc->mtd);
+					kfree (read_buf);
+
+					return -EAGAIN; /* erased offending sector. Try mount one more time please. */
+				}
+			}else{
+			        /* Being in here means that we have found free space that ends on an erase sector
+				   boundary.
+				   Count it in if we are still under NUMFREEALLOWED *and* it is at least 1 erase 
+				   sector in length. This will keep us from picking any little ole' space as "free".
+				 */
+			         if((num_free_space < NUMFREEALLOWED) && 
+				    ((unsigned int)(pos - start) >= fmc->sector_size)){
+				           /* We really don't do anything to mark space as free, except *not* 
+					      mark it dirty and just advance the "pos" location pointer. 
+					      It will automatically be picked up as free space.
+					    */ 
+				           num_free_space++;
+				           D1(printk("Free space accepted: Starting 0x%x for 0x%x bytes\n",
+						     (unsigned int) start, (unsigned int) (pos - start)));
+
+					   if (largest_hole < pos - start) {
+						   
+						   D3(printk("was hole = %x end_offset = %x\n",
+						          largest_hole, hole_end_offset));
+						   if (fmc->head){
+							   largest_hole    = pos - start;
+							   hole_end_offset = pos;
+							}
+
+						   D3(printk("now = %x end_offset = %x\n",
+						          largest_hole, hole_end_offset));
+						}
+				 }else{
+				         num_free_spc_not_accp++;
+					 D1(printk("Free space (#%i) found but *Not* accepted: Starting "
+						   "0x%x for 0x%x bytes\n", num_free_spc_not_accp, 
+						   (unsigned int) start, 
+						   (unsigned int) (pos - start)));
+					 
+					 /* Mark this space as dirty. We already have our free space. */
+					 D1(printk("Dirty space: Starting 0x%x for 0x%x bytes\n",
+						   (unsigned int) start, (unsigned int) (pos - start)));
+					 jffs_fmalloced(fmc, (__u32) start,
+							(__u32) (pos - start), 0);				           
+				}
+				 
+			}
+			if(num_free_space > NUMFREEALLOWED){
+			         printk(KERN_WARNING "jffs_scan_flash(): Found free space "
+					"number %i. Only %i free space is allowed.\n",
+					num_free_space, NUMFREEALLOWED);			      
 			}
 			continue;
 
 		case JFFS_DIRTY_BITMASK:
-			/* We have found 0x00 at this position.  Scan as far
+			/* We have found 0x00000000 at this position.  Scan as far
 			   as possible to find out how much is dirty.  */
-			D1(printk("jffs_scan_flash(): 0x00 at pos 0x%lx.\n",
+			D1(printk("jffs_scan_flash(): 0x00000000 at pos 0x%lx.\n",
 				  (long)pos));
 			for (; pos < end
 			       && JFFS_DIRTY_BITMASK == flash_read_u32(fmc->mtd, pos);
@@ -688,71 +1033,38 @@
 			   to scan for the magic pattern.  */
 			D1(printk("*************** Dirty flash memory or "
 				  "bad inode: "
-				  "hexdump(pos = 0x%lx, len = 128):\n",
-				  (long)pos));
-			D1(jffs_hexdump(fmc->mtd, pos, 128));
-		cont_dirty:
+				  "hexdump(pos = 0x%lx, len = %d):\n",
+				  (long)pos,
+				  end - pos > 128 ? 128 : end - pos));
+			D1(jffs_hexdump(fmc->mtd, pos,
+			                end - pos > 128 ? 128 : end - pos));
+
 			for (pos += 4; pos < end; pos += 4) {
 				switch (flash_read_u32(fmc->mtd, pos)) {
 				case JFFS_MAGIC_BITMASK:
-					jffs_fmalloced(fmc, (__u32) start,
-						       (__u32) (pos - start),
-						       0);
-					goto cont_scan;
 				case JFFS_EMPTY_BITMASK:
-					/* First, mark as dirty the region
-					   which really does contain crap. */
-					jffs_fmalloced(fmc, (__u32) start,
-						       (__u32) (pos - start),
-						       0);
-
-					/* Then, scan the region which looks free.
-					   Depending on how large it is, we may
-					   mark it dirty too.
-					*/
-					start = pos;
-					for (; pos < end ; pos += 4) {
-						switch (flash_read_u32(fmc->mtd, pos)) {
-						case JFFS_MAGIC_BITMASK:
-							if (pos - start < fmc->max_chunk_size) {
-								/* Not much free space. Mark it dirty. */
-								jffs_fmalloced(fmc, (__u32)start,
-									       (__u32)pos-start, 0);
-							}
-							goto cont_scan;
+					/* handle these in the main switch() loop */
+					goto cont_scan;
 
-						case JFFS_EMPTY_BITMASK:
-							/* More empty space */
-							continue;
-				
-						default: 
-							/* i.e. more dirt */
-							if (pos - start < fmc->max_chunk_size) {
-								/* There wasn't much before the dirt
-								   started again. Just mark it all dirty
-								*/
-								goto cont_dirty;
-							}
-							/* There was quite a lot of free space. Leave it
-							   free.
-							*/
-							goto cont_scan;
-						}
-					}
 				default:
 					break;
 				}
 			}
+
 			cont_scan:
+			/* First, mark as dirty the region
+			   which really does contain crap. */
+			jffs_fmalloced(fmc, (__u32) start,
+				       (__u32) (pos - start),
+				       0);
+			
 			continue;
-		}
+		}/* switch */
 
 		/* We have found the beginning of an inode.  Create a
 		   node for it unless there already is one available.  */
 		if (!node) {
-			if (!(node = (struct jffs_node *)
-				     kmalloc(sizeof(struct jffs_node),
-					     GFP_KERNEL))) {
+			if (!(node = jffs_alloc_node())) {
 				/* Free read buffer */
 				kfree (read_buf);
 
@@ -860,7 +1172,13 @@
 			if (raw_inode.rename) {
 				deleted_file = flash_read_u32(fmc->mtd, pos);
 			}
-			checksum = jffs_checksum_flash(fmc->mtd, pos, raw_inode.dsize);
+			if (jffs_checksum_flash(fmc->mtd, pos, raw_inode.dsize, &checksum)) {
+				printk("jffs_checksum_flash() failed to calculate a checksum\n");
+				jffs_fmalloced(fmc, (__u32) start,
+					       (__u32) (pos - start), 0);
+				/* Reuse this unused struct jffs_node.  */
+				continue;
+			}				
 			pos += raw_inode.dsize
 			       + JFFS_GET_PAD_BYTES(raw_inode.dsize);
 
@@ -901,7 +1219,7 @@
 						  node);
 			if (!node->fm) {
 				D(printk("jffs_scan_flash(): !node->fm\n"));
-				kfree(node);
+				jffs_free_node(node);
 				DJM(no_jffs_node--);
 
 				/* Free read buffer */
@@ -912,12 +1230,6 @@
 
 				return -ENOMEM;
 			}
-			if ((err = jffs_insert_node(c, 0, &raw_inode,
-						    name, node)) < 0) {
-				printk("JFFS: Failed to handle raw inode. "
-				       "(err = %d)\n", err);
-				break;
-			}
 			if (raw_inode.rename) {
 				struct jffs_delete_list *dl
 				= (struct jffs_delete_list *)
@@ -925,7 +1237,7 @@
 					  GFP_KERNEL);
 				if (!dl) {
 					D(printk("jffs_scan_flash: !dl\n"));
-					kfree(node);
+					jffs_free_node(node);
 					DJM(no_jffs_node--);
 
 					/* Release the flash device */
@@ -941,6 +1253,12 @@
 				c->delete_list = dl;
 				node->data_size = 0;
 			}
+			if ((err = jffs_insert_node(c, 0, &raw_inode,
+						    name, node)) < 0) {
+				printk("JFFS: Failed to handle raw inode. "
+				       "(err = %d)\n", err);
+				break;
+			}
 			D3(jffs_print_node(node));
 			node = 0; /* Don't free the node!  */
 		}
@@ -954,18 +1272,52 @@
 	}
 
 	if (node) {
-		kfree(node);
+		jffs_free_node(node);
 		DJM(no_jffs_node--);
 	}
-	jffs_build_end(fmc);
+	if (fmc->head && fmc->tail_extra &&
+	    fmc->head->offset + fmc->flash_size -
+			fmc->tail_extra->offset - fmc->tail_extra->size > largest_hole) {
+		head_offset = fmc->head->offset;
+	}
+	else {
+		head_offset = hole_end_offset;
+	}
+	
+	if (jffs_build_end(fmc, head_offset) < 0) {
+		D(printk("jffs_build_end() failed\n"));
+		return -ENOMEM;
+	}
 
 	/* Free read buffer */
 	kfree (read_buf);
 
+	if(!num_free_space){
+	        printk(KERN_WARNING "jffs_scan_flash(): Did not find even a single "
+		       "chunk of free space. This is BAD!\n");
+	}
+
 	/* Return happy */
 	D3(printk("jffs_scan_flash(): Leaving...\n"));
 	flash_safe_release(fmc->mtd);
-	return 0;
+
+	/* This is to trap the "free size accounting screwed error. */
+	free_chunk_size1 = jffs_free_size1(fmc);
+	free_chunk_size2 = jffs_free_size2(fmc);
+
+	if (free_chunk_size1 + free_chunk_size2 != fmc->free_size) {
+
+		printk(KERN_WARNING "jffs_scan_falsh():Free size accounting screwed\n");
+		printk(KERN_WARNING "jfffs_scan_flash():free_chunk_size1 == 0x%x, "
+		       "free_chunk_size2 == 0x%x, fmc->free_size == 0x%x\n", 
+		       free_chunk_size1, free_chunk_size2, fmc->free_size);
+
+		return -1; /* Do NOT mount f/s so that we can inspect what happened.
+			      Mounting this  screwed up f/s will screw us up anyway.
+			    */
+	}	
+
+	return 0; /* as far as we are concerned, we are happy! */
 } /* jffs_scan_flash()  */
 
 
@@ -1018,12 +1370,11 @@
 		f->atime = raw_inode->atime;
 		f->mtime = raw_inode->mtime;
 		f->ctime = raw_inode->ctime;
-		f->deleted = raw_inode->deleted;
 	}
 	else if ((f->highest_version < node->version)
 		 || (node->version == 0)) {
 		/* Insert at the end of the list.  I.e. this node is the
-		   oldest one so far.  */
+		   newest one so far.  */
 		node->version_prev = f->version_tail;
 		node->version_next = 0;
 		f->version_tail->version_next = node;
@@ -1037,7 +1388,6 @@
 		f->atime = raw_inode->atime;
 		f->mtime = raw_inode->mtime;
 		f->ctime = raw_inode->ctime;
-		f->deleted = raw_inode->deleted;
 	}
 	else if (f->version_head->version > node->version) {
 		/* Insert at the bottom of the list.  */
@@ -1048,9 +1398,6 @@
 		if (!f->name) {
 			update_name = 1;
 		}
-		if (raw_inode->deleted) {
-			f->deleted = raw_inode->deleted;
-		}
 	}
 	else {
 		struct jffs_node *n;
@@ -1074,6 +1421,11 @@
 		}
 	}
 
+	/* Deletion is irreversible. If any 'deleted' node is ever
+	   written, the file is deleted */
+	if (raw_inode->deleted)
+		f->deleted = raw_inode->deleted;
+
 	/* Perhaps update the name.  */
 	if (raw_inode->nsize && update_name && name && *name && (name != f->name)) {
 		if (f->name) {
@@ -1098,16 +1450,15 @@
 		if (insert_into_tree) {
 			jffs_insert_file_into_tree(f);
 		}
-		if (f->deleted) {
-			/* Mark all versions of the node as obsolete.  */
-			jffs_possibly_delete_file(f);
-		}
-		else {
-			if (node->data_size || node->removed_size) {
-				jffs_update_file(f, node);
-			}
-			jffs_remove_redundant_nodes(f);
+		/* Once upon a time, we would call jffs_possibly_delete_file()
+		   here. That causes an oops if someone's still got the file
+		   open, so now we only do it in jffs_delete_inode()
+		   -- dwmw2
+		*/
+		if (node->data_size || node->removed_size) {
+			jffs_update_file(f, node);
 		}
+		jffs_remove_redundant_nodes(f);
 
 		jffs_garbage_collect_trigger(c);
 
@@ -1216,7 +1567,7 @@
 				  mod_type));
 			jffs_unlink_node_from_version_list(f, cur);
 			jffs_fmfree(f->c->fmc, cur->fm, cur);
-			kfree(cur);
+			jffs_free_node(cur);
 			DJM(no_jffs_node--);
 		}
 		else {
@@ -1346,7 +1697,7 @@
 	D3(printk("jffs_find_child()\n"));
 
 	for (f = dir->children; f; f = f->sibling_next) {
-		if (f->name
+		if (!f->deleted && f->name
 		    && !strncmp(f->name, name, len)
 		    && f->name[len] == '\0') {
 			break;
@@ -1436,7 +1787,10 @@
 		struct jffs_file *f)
 {
 	struct jffs_fmcontrol *fmc = c->fmc;
-	struct jffs_fm *fm = NULL;
+	struct jffs_fm *fm;
+	struct iovec node_iovec[4];
+	unsigned long iovec_cnt;
+
 	__u32 pos;
 	int err;
 	__u32 slack = 0;
@@ -1475,6 +1829,9 @@
 
 	jffs_fm_write_lock(fmc);
 
+retry:
+	fm = NULL;
+	err = 0;
 	while (!fm) {
 
 		/* Deadlocks suck. */
@@ -1544,6 +1901,10 @@
 	if (f) {
 		raw_inode->version = f->highest_version + 1;
 		D1(printk (KERN_NOTICE "jffs_write_node(): setting version of %s to %d\n", f->name, raw_inode->version));
+
+		/* if the file was deleted, set the deleted bit in the raw inode */
+		if (f->deleted)
+			raw_inode->deleted = 1;
 	}
 
 	/* Compute the checksum for the data and name chunks.  */
@@ -1562,44 +1923,48 @@
 		  "flash at pos 0x%lx:\n", (long)pos));
 	D3(jffs_print_raw_inode(raw_inode));
 
-	/* Step 1: Write the raw jffs inode to the flash.  */
-	if ((err = flash_safe_write(fmc->mtd, pos,
-				    (u_char *)raw_inode,
-				    sizeof(struct jffs_raw_inode))) < 0) {
-		jffs_fmfree_partly(fmc, fm,
-				   total_name_size + total_data_size);
-		jffs_fm_write_unlock(fmc);
-		printk(KERN_ERR "JFFS: jffs_write_node: Failed to write "
-		       "raw_inode.\n");
-		return err;
-	}
-	pos += sizeof(struct jffs_raw_inode);
+	/* The actual raw JFFS node */
+	node_iovec[0].iov_base = (void *) raw_inode;
+	node_iovec[0].iov_len = (size_t) sizeof(struct jffs_raw_inode);
+	iovec_cnt = 1;
 
-	/* Step 2: Write the name, if there is any.  */
+	/* Get name and size if there is one */
 	if (raw_inode->nsize) {
-		if ((err = flash_safe_write(fmc->mtd, pos,
-					    (u_char *)name,
-					    raw_inode->nsize)) < 0) {
-			jffs_fmfree_partly(fmc, fm, total_data_size);
-			jffs_fm_write_unlock(fmc);
-			printk(KERN_ERR "JFFS: jffs_write_node: Failed to "
-                              "write the name.\n");
-			return err;
+		node_iovec[iovec_cnt].iov_base = (void *) name;
+		node_iovec[iovec_cnt].iov_len = (size_t) raw_inode->nsize;
+		iovec_cnt++;
+
+		if (JFFS_GET_PAD_BYTES(raw_inode->nsize)) {
+			static char allff[3]={255,255,255};
+			/* Add some extra padding if necessary */
+			node_iovec[iovec_cnt].iov_base = allff;
+			node_iovec[iovec_cnt].iov_len =
+				JFFS_GET_PAD_BYTES(raw_inode->nsize);
+			iovec_cnt++;
 		}
-		pos += total_name_size;
 	}
 
-	/* Step 3: Append the actual data, if any.  */
+	/* Get data and size if there is any */
 	if (raw_inode->dsize) {
-		if ((err = flash_safe_write(fmc->mtd, pos, data,
-					    raw_inode->dsize)) < 0) {
-			jffs_fmfree_partly(fmc, fm, 0);
-			jffs_fm_write_unlock(fmc);
-			printk(KERN_ERR "JFFS: jffs_write_node: Failed to "
-			       "write the data.\n");
-			return err;
-		}
+		node_iovec[iovec_cnt].iov_base = (void *) data;
+		node_iovec[iovec_cnt].iov_len = (size_t) raw_inode->dsize;
+		iovec_cnt++;
+		/* No need to pad this because we're not actually putting
+		   anything after it.
+		*/
 	}
+
+	if ((err = flash_safe_writev(fmc->mtd, node_iovec, iovec_cnt,
+				    pos) < 0)) {
+		jffs_fmfree_partly(fmc, fm, 0);
+		jffs_fm_write_unlock(fmc);
+		printk(KERN_ERR "JFFS: jffs_write_node: Failed to write, "
+		       "requested %i, wrote %i\n", total_size, err);
+		goto retry;
+	}
+	if (raw_inode->deleted)
+		f->deleted = 1;
+
 	jffs_fm_write_unlock(fmc);
 	D3(printk("jffs_write_node(): Leaving...\n"));
 	return raw_inode->dsize;
@@ -1624,7 +1989,7 @@
 		  "version: %u, node_offset: %u\n",
 		  f->name, node->ino, node->version, node_offset));
 
-	r = jffs_min(avail, max_size);
+	r = min(avail, max_size);
 	D3(printk(KERN_NOTICE "jffs_get_node_data\n"));
 	flash_safe_read(fmc->mtd, pos, buf, r);
 
@@ -1677,7 +2042,7 @@
 		int r;
 		if (!node->fm) {
 			/* This node does not refer to real data.  */
-			r = jffs_min(size - read_data,
+			r = min(size - read_data,
 				     node->data_size - node_offset);
 			memset(&buf[read_data], 0, r);
 		}
@@ -1735,7 +2100,7 @@
 	while (node) {
 		p = node;
 		node = node->version_next;
-		kfree(p);
+		jffs_free_node(p);
 		DJM(no_jffs_node--);
 	}
 	return 0;
@@ -1754,10 +2119,15 @@
 		DJM(no_name--);
 	}
 	kfree(f);
-	DJM(no_jffs_file--);
+	no_jffs_file--;
 	return 0;
 }
 
+long
+jffs_get_file_count(void)
+{
+	return no_jffs_file;
+}
 
 /* See if a file is deleted. If so, mark that file's nodes as obsolete.  */
 int
@@ -1871,9 +2241,7 @@
 			D3(printk("jffs_delete_data(): Split node with "
 				  "version number %u.\n", n->version));
 
-			if (!(new_node = (struct jffs_node *)
-					 kmalloc(sizeof(struct jffs_node),
-						 GFP_KERNEL))) {
+			if (!(new_node = jffs_alloc_node())) {
 				D(printk("jffs_delete_data(): -ENOMEM\n"));
 				return -ENOMEM;
 			}
@@ -1919,7 +2287,7 @@
 		else {
 			/* No.  No need to split the node.  Just remove
 			   the end of the node.  */
-			int r = jffs_min(n->data_offset + n->data_size
+			int r = min(n->data_offset + n->data_size
 					 - offset, remove_size);
 			n->data_size -= r;
 			remove_size -= r;
@@ -1942,7 +2310,7 @@
 			}
 			jffs_unlink_node_from_range_list(f, p);
 			jffs_unlink_node_from_version_list(f, p);
-			kfree(p);
+			jffs_free_node(p);
 			DJM(no_jffs_node--);
 		}
 		else {
@@ -2058,9 +2426,7 @@
 		   front of this insertion.  This "virtual node" will not
 		   be associated with any space on the flash device.  */
 		struct jffs_node *virtual_node;
-		if (!(virtual_node = (struct jffs_node *)
-				     kmalloc(sizeof(struct jffs_node),
-					     GFP_KERNEL))) {
+		if (!(virtual_node = jffs_alloc_node())) {
 			return -ENOMEM;
 		}
 
@@ -2340,7 +2706,7 @@
 
 /* Rewrite `size' bytes, and begin at `node'.  */
 int
-jffs_rewrite_data(struct jffs_file *f, struct jffs_node *node, int size)
+jffs_rewrite_data(struct jffs_file *f, struct jffs_node *node, __u32 size)
 {
 	struct jffs_control *c = f->c;
 	struct jffs_fmcontrol *fmc = c->fmc;
@@ -2358,8 +2724,7 @@
 		  f->ino, (f->name ? f->name : "(null)"), size));
 
 	/* Create and initialize the new node.  */
-	if (!(new_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	if (!(new_node = jffs_alloc_node())) {
 		D(printk("jffs_rewrite_data(): "
 			 "Failed to allocate node.\n"));
 		return -ENOMEM;
@@ -2374,13 +2739,15 @@
 	new_node->fm_offset = sizeof(struct jffs_raw_inode)
 			      + total_name_size;
 
+retry:
 	jffs_fm_write_lock(fmc);
+	err = 0;
 
 	if ((err = jffs_fmalloc(fmc, total_size, new_node, &fm)) < 0) {
 		DJM(no_jffs_node--);
 		jffs_fm_write_unlock(fmc);
 		D(printk("jffs_rewrite_data(): Failed to allocate fm.\n"));
-		kfree(new_node);
+		jffs_free_node(new_node);
 		return err;
 	}
 	else if (!fm->nodes) {
@@ -2420,7 +2787,7 @@
 	raw_inode.nlink = f->nlink;
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
-	raw_inode.deleted = 0;
+	raw_inode.deleted = f->deleted;
 	raw_inode.accurate = 0xff;
 	raw_inode.dchksum = 0;
 	raw_inode.nchksum = 0;
@@ -2441,23 +2808,27 @@
 				   total_name_size + total_data_size);
 		jffs_fm_write_unlock(fmc);
 		printk(KERN_ERR "JFFS: jffs_rewrite_data: Write error during "
-		       "rewrite. (raw inode)\n");
-		return err;
+			"rewrite. (raw inode)\n");
+		printk(KERN_ERR "JFFS: jffs_rewrite_data: Now retrying "
+			"rewrite. (raw inode)\n");
+		goto retry;
 	}
 	pos += sizeof(struct jffs_raw_inode);
 
 	/* Write the name to the flash memory.  */
 	if (f->nsize) {
 		D3(printk("jffs_rewrite_data(): Writing name \"%s\" to "
-			  "pos 0x%ul.\n", f->name, (long)pos));
+			  "pos 0x%ul.\n", f->name, (unsigned int) pos));
 		if ((err = flash_safe_write(fmc->mtd, pos,
 					    (u_char *)f->name,
 					    f->nsize)) < 0) {
 			jffs_fmfree_partly(fmc, fm, total_data_size);
 			jffs_fm_write_unlock(fmc);
 			printk(KERN_ERR "JFFS: jffs_rewrite_data: Write "
-			       "error during rewrite. (name)\n");
-			return err;
+				"error during rewrite. (name)\n");
+			printk(KERN_ERR "JFFS: jffs_rewrite_data: Now retrying "
+				"rewrite. (name)\n");
+			goto retry;
 		}
 		pos += total_name_size;
 		raw_inode.nchksum = jffs_checksum(f->name, f->nsize);
@@ -2475,7 +2846,7 @@
 		}
 
 		while (size) {
-			__u32 s = jffs_min(size, PAGE_SIZE);
+			__u32 s = min(size, (__u32)PAGE_SIZE);
 			if ((r = jffs_read_data(f, (char *)page,
 						offset, s)) < s) {
 				free_page((unsigned long)page);
@@ -2494,7 +2865,7 @@
 				printk(KERN_ERR "JFFS: jffs_rewrite_data: "
 				       "Write error during rewrite. "
 				       "(data)\n");
-				return err;
+				goto retry;
 			}
 			pos += r;
 			size -= r;
@@ -2521,7 +2892,7 @@
 		jffs_fm_write_unlock(fmc);
 		printk(KERN_ERR "JFFS: jffs_rewrite_data: Write error during "
 		       "rewrite. (checksum)\n");
-		return err;
+		goto retry;
 	}
 
 	/* Now make the file system aware of the newly written node.  */
@@ -2543,9 +2914,10 @@
 	struct jffs_fmcontrol *fmc = c->fmc;
 	struct jffs_node *node;
 	struct jffs_file *f;
-	int size, err = 0;
-	int data_size;
-	int total_name_size;
+	int err = 0;
+	__u32 size;
+	__u32 data_size;
+	__u32 total_name_size;
 	__u32 extra_available;
 	__u32 space_needed;
 	__u32 free_chunk_size1 = jffs_free_size1(fmc);
@@ -2671,8 +3043,8 @@
 	    sizeof(struct jffs_raw_inode) + extra_available) {
 		D1(printk("Reducing size of new node from %d to %ld to avoid "
 		       "catching our tail\n", size, 
-			  JFFS_PAD(node->data_size) + JFFS_PAD(node->name_size) + 
-			  sizeof(struct jffs_raw_inode) + extra_available));
+			  (long) (JFFS_PAD(node->data_size) + JFFS_PAD(node->name_size) + 
+			  sizeof(struct jffs_raw_inode) + extra_available)));
 		D1(printk("space_needed = %d, extra_available = %d\n", 
 			  space_needed, extra_available));
 
@@ -2804,7 +3176,7 @@
 		return err;
 	}
 
-	offset = fmc->head->offset - fmc->flash_start;
+	offset = fmc->head->offset;
 
 	/* Now, let's try to do the erase.  */
 	if ((err = flash_erase_region(fmc->mtd,
@@ -2962,17 +3334,31 @@
 		   c->fmc->free_size, c->fmc->dirty_size, c->fmc->sector_size));
 
 	/* If there's not enough dirty space to free a block, there's no point. */
-	if (c->fmc->dirty_size < c->fmc->sector_size)
+	if (c->fmc->dirty_size < c->fmc->sector_size) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Not waking. Insufficient dirty space\n"));
 		return 0;
-
+	}
+#if 1
+	/* If there is too much RAM used by the various structures, GC */
+	if (jffs_get_node_inuse() > (c->fmc->used_size/c->fmc->max_chunk_size * 5 + jffs_get_file_count() * 2 + 50)) {
+		/* FIXME: Provide proof that this test can be satisfied. We
+		   don't want a filesystem doing endless GC just because this
+		   condition cannot ever be false.
+		*/
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to number of nodes\n"));
+		return 1;
+	}
+#endif
 	/* If there are fewer free bytes than the threshold, GC */
-	if (c->fmc->dirty_size < c->gc_minfree_threshold)
+	if (c->fmc->free_size < c->gc_minfree_threshold) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to insufficent free space\n"));
 		return 1;
-
+	}
 	/* If there are more dirty bytes than the threshold, GC */
-	if (c->fmc->dirty_size > c->gc_maxdirty_threshold)
+	if (c->fmc->dirty_size > c->gc_maxdirty_threshold) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to excessive dirty space\n"));
 		return 1;
-	
+	}	
 	/* FIXME: What about the "There are many versions of a node" condition? */
 
 	return 0;
@@ -3008,7 +3394,7 @@
 
 	current->session = 1;
 	current->pgrp = 1;
-	init_MUTEX_LOCKED(&c->gc_thread_sem); /* barrier */ 
+	init_completion(&c->gc_thread_comp); /* barrier */ 
 	spin_lock_irq(&current->sigmask_lock);
 	siginitsetinv (&current->blocked, sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
 	recalc_sigpending(current);
@@ -3054,18 +3440,12 @@
 			case SIGKILL:
 				D1(printk("jffs_garbage_collect_thread(): SIGKILL received.\n"));
 				c->gc_task = NULL;
-				unlock_kernel();
-				up_and_exit(&c->gc_thread_sem, 0);
+				complete_and_exit(&c->gc_thread_comp, 0);
 			}
 		}
 
 
 		D1(printk (KERN_NOTICE "jffs_garbage_collect_thread(): collecting.\n"));
-
-		if (fmc->dirty_size < fmc->sector_size) {
-			D1(printk(KERN_WARNING "jffs_garbage_collect_thread with insufficient dirty space (0x%x)\n", fmc->dirty_size));
-			continue;
-		}
 
 		D3(printk (KERN_NOTICE "g_c_thread(): down biglock\n"));
 		down(&fmc->biglock);
diff -Naur linux-2.4.2.orig/fs/jffs/intrep.h linux-2.4.2/fs/jffs/intrep.h
--- linux-2.4.2.orig/fs/jffs/intrep.h	Mon Dec 11 22:26:54 2000
+++ linux-2.4.2/fs/jffs/intrep.h	Fri Feb 15 14:41:16 2002
@@ -10,15 +10,18 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: intrep.h,v 1.11 2000/08/17 22:46:46 bmatthews Exp $
+ * $Id: intrep.h,v 1.14 2001/09/23 23:28:37 dwmw2 Exp $
  *
  */
 
 #ifndef __LINUX_JFFS_INTREP_H__
 #define __LINUX_JFFS_INTREP_H__
 #include "jffs_fm.h"
-inline int jffs_min(int a, int b);
-inline int jffs_max(int a, int b);
+struct jffs_node *jffs_alloc_node(void);
+void jffs_free_node(struct jffs_node *n);
+int jffs_get_node_inuse(void);
+long jffs_get_file_count(void);
+
 __u32 jffs_checksum(const void *data, int size);
 
 void jffs_cleanup_control(struct jffs_control *c);
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_fm.c linux-2.4.2/fs/jffs/jffs_fm.c
--- linux-2.4.2.orig/fs/jffs/jffs_fm.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/jffs_fm.c	Fri Feb 15 14:41:16 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs_fm.c,v 1.18 2000/08/21 10:41:45 dwmw2 Exp $
+ * $Id: jffs_fm.c,v 1.29 2002/01/22 09:48:16 cdavies Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -20,12 +20,20 @@
 #include <linux/slab.h>
 #include <linux/blkdev.h>
 #include <linux/jffs.h>
+#include <linux/compatmac.h>
 #include "jffs_fm.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,2)
+#define minor(x) MINOR(x)
+#define major(x) MAJOR(x)
+#endif
+
 #if defined(JFFS_MARK_OBSOLETE) && JFFS_MARK_OBSOLETE
 static int jffs_mark_obsolete(struct jffs_fmcontrol *fmc, __u32 fm_offset);
 #endif
 
+extern kmem_cache_t     *fm_cache;
+extern kmem_cache_t     *node_cache;
 
 /* This function creates a new shiny flash memory control structure.  */
 struct jffs_fmcontrol *
@@ -44,15 +52,16 @@
 	}
 	DJM(no_jffs_fmcontrol++);
 
-	mtd = get_mtd_device(NULL, MINOR(dev));
+	mtd = get_mtd_device(NULL, minor(dev));
 
-	if (!mtd)
+	if (!mtd) {
+		kfree(fmc);
+		DJM(no_jffs_fmcontrol--);
 		return NULL;
+	}
 	
 	/* Retrieve the size of the flash memory.  */
-	fmc->flash_start = 0;
 	fmc->flash_size = mtd->size;
-	D3(printk("  fmc->flash_start = 0x%08x\n", fmc->flash_start));
 	D3(printk("  fmc->flash_size = %d bytes\n", fmc->flash_size));
 
 	fmc->used_size = 0;
@@ -68,8 +77,11 @@
 		   to write out larger nodes than the ones it's obsoleting.
 		   We should fix it so it doesn't have to write the name
 		   _every_ time. Later.
+	   + another 2 sectors because people keep getting GC stuck and
+	           we don't know why. This scares me - I want formal proof
+		   of correctness of whatever number we put here. dwmw2.
 	*/
-	fmc->min_free_size = fmc->sector_size << 1;
+	fmc->min_free_size = fmc->sector_size << 2;
 	fmc->mtd = mtd;
 	fmc->c = c;
 	fmc->head = 0;
@@ -83,8 +95,8 @@
 
 /* When the flash memory scan has completed, this function should be called
    before use of the control structure.  */
-void
-jffs_build_end(struct jffs_fmcontrol *fmc)
+int
+jffs_build_end(struct jffs_fmcontrol *fmc, __u32 head_offset)
 {
 	D3(printk("jffs_build_end()\n"));
 
@@ -93,13 +105,100 @@
 		fmc->tail = fmc->tail_extra;
 	}
 	else if (fmc->head_extra) {
-		fmc->tail_extra->next = fmc->head;
-		fmc->head->prev = fmc->tail_extra;
-		fmc->head = fmc->head_extra;
+		struct jffs_fm *fm, *cur;
+
+		if (head_offset == fmc->head->offset){
+			fmc->tail->next = fmc->head_extra;
+			fmc->head_extra->prev = fmc->tail;
+			fmc->tail = fmc->tail_extra;
+		}
+		else {
+			fmc->tail_extra->next = fmc->head;
+			fmc->head->prev = fmc->tail_extra;
+			fmc->head = fmc->head_extra;
+			while (fmc->head->offset != head_offset){
+				fmc->tail->next = fmc->head;
+				fmc->head = fmc->head->next;
+				fmc->head->prev = 0;
+				fmc->tail->next->prev = fmc->tail;
+				fmc->tail = fmc->tail->next;
+				fmc->tail->next = 0;
+			}
+		}
+				/* Make sure the only free space we have is between tail and head.
+				 */
+		for (cur = fmc->head; cur && cur != fmc->tail;) {
+			if (cur->offset + cur->size < cur->next->offset) {
+				if (!(fm = kmalloc(sizeof(struct jffs_fm), GFP_KERNEL))) {
+					D(printk("jffs_buid_end(): kmalloc failed!\n"));
+					return -ENOMEM;
+				}
+				DJM(no_jffs_fm++);
+				fm->size = cur->next->offset - cur->offset - cur->size;
+				fm->offset = cur->offset + cur->size;
+				fm->nodes = 0;
+				fm->next = cur->next;
+				fm->prev = cur;
+				cur->next->prev = fm;
+				cur->next = fm;
+				cur = fm->next;
+				fmc->free_size -= fm->size;
+				fmc->dirty_size += fm->size;
+			}
+			else if (cur->offset > cur->next->offset) {
+				if (cur->offset + cur->size < fmc->flash_size){
+					if (!(fm = kmalloc(sizeof(struct jffs_fm), GFP_KERNEL))){
+						
+						D(printk("jffs_buid_end(): kmalloc failed!\n"));
+						return -ENOMEM;
+					}
+					DJM(no_jffs_fm++);
+					fm->size = fmc->flash_size -
+					           cur->offset - cur->size;
+					fm->nodes = 0;
+					fm->offset = cur->offset + cur->size;
+					fm->next = cur->next;
+					fm->prev = cur;
+					cur->next->prev = fm;
+					cur->next = fm;
+					cur = fm->next;
+					fmc->free_size -= fm->size;
+					fmc->dirty_size += fm->size;
+				}
+				else {
+					cur = cur->next;
+				}
+				if (cur->offset > 0) {
+					
+					if (!(fm = kmalloc(sizeof(struct jffs_fm), GFP_KERNEL))) {
+						D(printk("jffs_buid_end(): kmalloc failed!\n"));
+						return -ENOMEM;
+					}
+					DJM(no_jffs_fm++);
+					fm->size = cur->offset;
+					fm->nodes = 0;
+					fm->offset = 0;
+					fm->next = cur;
+					fm->prev = cur->prev;
+					cur->prev->next = fm;
+					cur->prev = fm;
+					fmc->free_size -= fm->size;
+					fmc->dirty_size += fm->size;
+				}
+			}
+			else if (cur->offset + cur->size != cur->next->offset) {
+				printk("jffs_build_end(): Internal error.\n");
+				return -EINVAL;
+			}
+			else {
+				cur = cur->next;
+			}
+		}
 	}
 	fmc->head_extra = 0; /* These two instructions should be omitted.  */
 	fmc->tail_extra = 0;
 	D3(jffs_print_fmcontrol(fmc));
+	return 0;
 }
 
 
@@ -114,8 +213,7 @@
 
 		while ((cur = next)) {
 			next = next->next;
-			kfree(cur);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(cur);
 		}
 		put_mtd_device(fmc->mtd);
 		kfree(fmc);
@@ -132,7 +230,7 @@
 {
 	__u32 head;
 	__u32 tail;
-	__u32 end = fmc->flash_start + fmc->flash_size;
+	__u32 end = fmc->flash_size;
 
 	if (!fmc->head) {
 		/* There is nothing on the flash.  */
@@ -143,11 +241,11 @@
 	head = fmc->head->offset;
 	tail = fmc->tail->offset + fmc->tail->size;
 	if (tail == end) {
-		tail = fmc->flash_start;
+		tail = 0;
 	}
 	ASSERT(else if (tail > end) {
 		printk(KERN_WARNING "jffs_free_size1(): tail > end\n");
-		tail = fmc->flash_start;
+		tail = 0;
 	});
 
 	if (head <= tail) {
@@ -175,12 +273,12 @@
 	if (fmc->head) {
 		__u32 head = fmc->head->offset;
 		__u32 tail = fmc->tail->offset + fmc->tail->size;
-		if (tail == fmc->flash_start + fmc->flash_size) {
-			tail = fmc->flash_start;
+		if (tail == fmc->flash_size) {
+			tail = 0;
 		}
 
 		if (tail >= head) {
-			return head - fmc->flash_start;
+			return head;
 		}
 	}
 	return 0;
@@ -203,12 +301,10 @@
 
 	*result = 0;
 
-	if (!(fm = (struct jffs_fm*)kmalloc(sizeof(struct jffs_fm),
-					    GFP_KERNEL))) {
+	if (!(fm = jffs_alloc_fm())) {
 		D(printk("jffs_fmalloc(): kmalloc() failed! (fm)\n"));
 		return -ENOMEM;
 	}
-	DJM(no_jffs_fm++);
 
 	free_chunk_size1 = jffs_free_size1(fmc);
 	free_chunk_size2 = jffs_free_size2(fmc);
@@ -227,8 +323,7 @@
 					  GFP_KERNEL))) {
 			D(printk("jffs_fmalloc(): kmalloc() failed! "
 				 "(node_ref)\n"));
-			kfree(fm);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(fm);
 			return -ENOMEM;
 		}
 		DJM(no_jffs_node_ref++);
@@ -236,22 +331,19 @@
 		fm->nodes->next = 0;
 		if (fmc->tail) {
 			fm->offset = fmc->tail->offset + fmc->tail->size;
-			if (fm->offset
-			    == fmc->flash_start + fmc->flash_size) {
-				fm->offset = fmc->flash_start;
+			if (fm->offset == fmc->flash_size) {
+				fm->offset = 0;
 			}
-			ASSERT(else if (fm->offset
-					> fmc->flash_start
-					  + fmc->flash_size) {
+			ASSERT(else if (fm->offset > fmc->flash_size) {
 				printk(KERN_WARNING "jffs_fmalloc(): "
 				       "offset > flash_end\n");
-				fm->offset = fmc->flash_start;
+				fm->offset = 0;
 			});
 		}
 		else {
 			/* There don't have to be files in the file
 			   system yet.  */
-			fm->offset = fmc->flash_start;
+			fm->offset = 0;
 		}
 		fm->size = size;
 		fmc->free_size -= size;
@@ -260,8 +352,7 @@
 	else if (size > free_chunk_size2) {
 		printk(KERN_WARNING "JFFS: Tried to allocate a too "
 		       "large flash memory chunk. (size = %u)\n", size);
-		kfree(fm);
-		DJM(no_jffs_fm--);
+		jffs_free_fm(fm);
 		return -ENOSPC;
 	}
 	else {
@@ -347,7 +438,6 @@
 			return -1;
 		}
 #endif
-		fmc->c->sb->s_dirt = 1;
 	}
 
 	ASSERT(if (!del) {
@@ -369,13 +459,11 @@
 
 	D3(printk("jffs_fmalloced()\n"));
 
-	if (!(fm = (struct jffs_fm *)kmalloc(sizeof(struct jffs_fm),
-					     GFP_KERNEL))) {
+	if (!(fm = jffs_alloc_fm())) {
 		D(printk("jffs_fmalloced(0x%p, %u, %u, 0x%p): failed!\n",
 			 fmc, offset, size, node));
 		return 0;
 	}
-	DJM(no_jffs_fm++);
 	fm->offset = offset;
 	fm->size = size;
 	fm->prev = 0;
@@ -388,8 +476,7 @@
 				  kmalloc(sizeof(struct jffs_node_ref),
 					  GFP_KERNEL))) {
 			D(printk("jffs_fmalloced(): !fm->nodes\n"));
-			kfree(fm);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(fm);
 			return 0;
 		}
 		DJM(no_jffs_node_ref++);
@@ -466,6 +553,7 @@
 	fmc->used_size -= fm->size;
 	if (fm == fmc->tail) {
 		fm->size -= size;
+		fmc->free_size += size;
 	}
 	fmc->dirty_size += fm->size;
 }
@@ -532,8 +620,7 @@
 			fm = fm->next;
 			fm->prev = 0;
 			fmc->head = fm;
-			kfree(del);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(del);
 		}
 		else {
 			fm->size -= erased_size;
@@ -628,11 +715,11 @@
 		return -1;
 	}
 	else if (offset > mtd->size) {
-		printk(KERN_WARNING "jffs_flash_erasable_size given offset off the end of device (%x > %lx)\n", offset, mtd->size);
+		printk(KERN_WARNING "jffs_flash_erasable_size given offset off the end of device (%x > %x)\n", offset, mtd->size);
 		return -2;
 	}
 	else if (offset + size > mtd->size) {
-		printk(KERN_WARNING "jffs_flash_erasable_size() given length which runs off the end of device (ofs %x + len %x = %x, > %lx)\n", offset,size, offset+size, mtd->size);
+		printk(KERN_WARNING "jffs_flash_erasable_size() given length which runs off the end of device (ofs %x + len %x = %x, > %x)\n", offset,size, offset+size, mtd->size);
 		return -3;
 	}
 
@@ -661,7 +748,7 @@
 
 	/* Calculate how much space that is dirty.  */
 	for (fm = fmc->head; fm && !fm->nodes; fm = fm->next) {
-		if (size && fm->offset == fmc->flash_start) {
+		if (size && fm->offset == 0) {
 			/* We have reached the beginning of the flash.  */
 			break;
 		}
@@ -671,14 +758,13 @@
 	/* Someone's signature contained this:
 	   There's a fine line between fishing and just standing on
 	   the shore like an idiot...  */
-	ret = jffs_flash_erasable_size(fmc->mtd,
-				       fmc->head->offset - fmc->flash_start, size);
+	ret = jffs_flash_erasable_size(fmc->mtd, fmc->head->offset, size);
 
 	ASSERT(if (ret < 0) {
 		printk("jffs_erasable_size: flash_erasable_size() "
 		       "returned something less than zero (%ld).\n", ret);
 		printk("jffs_erasable_size: offset = 0x%08x\n",
-		       fmc->head->offset - fmc->flash_start);
+		       fmc->head->offset);
 	});
 
 	/* If there is dirt on the flash (which is the reason to why
@@ -702,21 +788,58 @@
 			if (del->next) {
 				del->next->prev = head;
 			}
-			kfree(del);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(del);
 		}
 	}
 
 	return (ret >= 0 ? ret : 0);
 }
 
+struct jffs_fm *jffs_alloc_fm(void)
+{
+	struct jffs_fm *fm;
+
+	fm = kmem_cache_alloc(fm_cache,GFP_KERNEL);
+	DJM(if (fm) no_jffs_fm++;);
+	
+	return fm;
+}
+
+void jffs_free_fm(struct jffs_fm *n)
+{
+	kmem_cache_free(fm_cache,n);
+	DJM(no_jffs_fm--);
+}
+
+
+
+struct jffs_node *jffs_alloc_node(void)
+{
+	struct jffs_node *n;
+
+	n = (struct jffs_node *)kmem_cache_alloc(node_cache,GFP_KERNEL);
+	if(n != NULL)
+		no_jffs_node++;
+	return n;
+}
+
+void jffs_free_node(struct jffs_node *n)
+{
+	kmem_cache_free(node_cache,n);
+	no_jffs_node--;
+}
+
+
+int jffs_get_node_inuse(void)
+{
+	return no_jffs_node;
+}
 
 void
 jffs_print_fmcontrol(struct jffs_fmcontrol *fmc)
 {
 	D(printk("struct jffs_fmcontrol: 0x%p\n", fmc));
 	D(printk("{\n"));
-	D(printk("        0x%08x, /* flash_start  */\n", fmc->flash_start));
 	D(printk("        %u, /* flash_size  */\n", fmc->flash_size));
 	D(printk("        %u, /* used_size  */\n", fmc->used_size));
 	D(printk("        %u, /* dirty_size  */\n", fmc->dirty_size));
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_fm.h linux-2.4.2/fs/jffs/jffs_fm.h
--- linux-2.4.2.orig/fs/jffs/jffs_fm.h	Mon Dec 11 22:26:54 2000
+++ linux-2.4.2/fs/jffs/jffs_fm.h	Fri Feb 15 14:41:16 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs_fm.h,v 1.10 2000/08/17 15:42:44 dwmw2 Exp $
+ * $Id: jffs_fm.h,v 1.14 2001/12/10 17:37:12 asanochkin Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -59,10 +59,15 @@
 
 /* How many padding bytes should be inserted between two chunks of data
    on the flash?  */
-#define JFFS_GET_PAD_BYTES(size) ((JFFS_ALIGN_SIZE                     \
-				  - ((__u32)(size) % JFFS_ALIGN_SIZE)) \
-				  % JFFS_ALIGN_SIZE)
+#define JFFS_GET_PAD_BYTES(size) ( (JFFS_ALIGN_SIZE-1) & -(__u32)(size) )
 #define JFFS_PAD(size) ( (size + (JFFS_ALIGN_SIZE-1)) & ~(JFFS_ALIGN_SIZE-1) )
+
+
+
+void jffs_free_fm(struct jffs_fm *n);
+struct jffs_fm *jffs_alloc_fm(void);
+
+
 struct jffs_node_ref
 {
 	struct jffs_node *node;
@@ -82,7 +87,6 @@
 
 struct jffs_fmcontrol
 {
-	__u32 flash_start;
 	__u32 flash_size;
 	__u32 used_size;
 	__u32 dirty_size;
@@ -117,8 +121,9 @@
    flash memory so it will be referenced by the head member.  */
 
 
+
 struct jffs_fmcontrol *jffs_build_begin(struct jffs_control *c, kdev_t dev);
-void jffs_build_end(struct jffs_fmcontrol *fmc);
+int jffs_build_end(struct jffs_fmcontrol *fmc, __u32 head_offset);
 void jffs_cleanup_fmcontrol(struct jffs_fmcontrol *fmc);
 
 int jffs_fmalloc(struct jffs_fmcontrol *fmc, __u32 size,
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_proc.c linux-2.4.2/fs/jffs/jffs_proc.c
--- linux-2.4.2.orig/fs/jffs/jffs_proc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/jffs_proc.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,269 @@
+/*
+ * JFFS -- Journaling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 2000  Axis Communications AB.
+ *
+ * Created by Simon Kagstrom <simonk@axis.com>.
+ *
+ * $Id: jffs_proc.c,v 1.5 2001/06/02 14:34:55 dwmw2 Exp $
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  Overview:
+ *   This file defines JFFS partition entries in the proc file system.
+ *
+ *  TODO:
+ *   Create some more proc files for different kinds of info, i.e. statistics
+ *   about written and read bytes, number of calls to different routines,
+ *   reports about failures.
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/jffs.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include "jffs_fm.h"
+#include "jffs_proc.h"
+
+/*
+ * Structure for a JFFS partition in the system
+ */
+struct jffs_partition_dir {
+	struct jffs_control *c;
+	struct proc_dir_entry *part_root;
+	struct proc_dir_entry *part_info;
+	struct proc_dir_entry *part_layout;
+	struct jffs_partition_dir *next;
+};
+
+/*
+ * Structure for top-level entry in '/proc/fs' directory
+ */
+struct proc_dir_entry *jffs_proc_root;
+
+/*
+ * Linked list of 'jffs_partition_dirs' to help us track
+ * the mounted JFFS partitions in the system
+ */
+static struct jffs_partition_dir *jffs_part_dirs = 0;
+
+/*
+ * Read functions for entries
+ */
+static int jffs_proc_info_read(char *page, char **start, off_t off,
+		int count, int *eof, void *data);
+static int jffs_proc_layout_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data);
+
+
+/*
+ * Register a JFFS partition directory (called upon mount)
+ */
+int jffs_register_jffs_proc_dir(kdev_t dev, struct jffs_control *c)
+{
+	struct jffs_partition_dir *part_dir;
+	struct proc_dir_entry *part_info = 0;
+	struct proc_dir_entry *part_layout = 0;
+	struct proc_dir_entry *part_root = 0;
+
+	/* Allocate structure for local JFFS partition table */
+	if (!(part_dir = (struct jffs_partition_dir *)
+		kmalloc (sizeof (struct jffs_partition_dir), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	/* Create entry for this partition */
+	if ((part_root = create_proc_entry (kdevname(dev),
+		S_IFDIR | S_IRUGO | S_IXUGO, jffs_proc_root))) {
+		part_root->read_proc = jffs_proc_info_read;
+		part_root->data = (void *) c;
+	}
+	else {
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Create entry for 'info' file */
+	if ((part_info = create_proc_entry ("info", 0, part_root))) {
+		part_info->read_proc = jffs_proc_info_read;
+		part_info->data = (void *) c;
+	}
+	else {
+		remove_proc_entry (part_root->name, jffs_proc_root);
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Create entry for 'layout' file */
+	if ((part_layout = create_proc_entry ("layout", 0, part_root))) {
+		part_layout->read_proc = jffs_proc_layout_read;
+		part_layout->data = (void *) c;
+	}
+	else {
+		remove_proc_entry (part_info->name, part_root);
+		remove_proc_entry (part_root->name, jffs_proc_root);
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Fill in structure for table and insert in the list */
+	part_dir->c = c;
+	part_dir->part_root = part_root;
+	part_dir->part_info = part_info;
+	part_dir->part_layout = part_layout;
+	part_dir->next = jffs_part_dirs;
+	jffs_part_dirs = part_dir;
+
+	/* Return happy */
+	return 0;
+}
+
+
+/*
+ * Unregister a JFFS partition directory (called at umount)
+ */
+int jffs_unregister_jffs_proc_dir(struct jffs_control *c)
+{
+	struct jffs_partition_dir *part_dir = jffs_part_dirs;
+	struct jffs_partition_dir *prev_part_dir = 0;
+
+	while (part_dir) {
+		if (part_dir->c == c) {
+			/* Remove entries for partition */
+			remove_proc_entry (part_dir->part_info->name,
+				part_dir->part_root);
+			remove_proc_entry (part_dir->part_layout->name,
+				part_dir->part_root);
+			remove_proc_entry (part_dir->part_root->name,
+				jffs_proc_root);
+
+			/* Remove entry from list */
+			if (prev_part_dir)
+				prev_part_dir->next = part_dir->next;
+			else
+				jffs_part_dirs = part_dir->next;
+
+			/*
+			 * Check to see if this is the last one
+			 * and remove the entry from '/proc/fs'
+			 * if it is.
+			 */
+			if (jffs_part_dirs == part_dir->next)
+#if LINUX_VERSION_CODE < 0x020300
+				remove_proc_entry ("jffs", &proc_root_fs);
+#else
+				remove_proc_entry ("jffs", proc_root_fs);
+#endif
+
+			/* Free memory for entry */
+			kfree(part_dir);
+
+			/* Return happy */
+			return 0;
+		}
+
+		/* Move to next entry */
+		prev_part_dir = part_dir;
+		part_dir = part_dir->next;
+	}
+
+	/* Return unhappy */
+	return -1;
+}
+
+
+/*
+ * Read a JFFS partition's `info' file
+ */
+static int jffs_proc_info_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	struct jffs_control *c = (struct jffs_control *) data;
+	int len = 0;
+
+	/* Get information on the parition */
+	len += sprintf (page,
+		"partition size:     %08lX (%u)\n"
+		"sector size:        %08lX (%u)\n"
+		"used size:          %08lX (%u)\n"
+		"dirty size:         %08lX (%u)\n"
+		"free size:          %08lX (%u)\n\n",
+		(unsigned long) c->fmc->flash_size, c->fmc->flash_size,
+		(unsigned long) c->fmc->sector_size, c->fmc->sector_size,
+		(unsigned long) c->fmc->used_size, c->fmc->used_size,
+		(unsigned long) c->fmc->dirty_size, c->fmc->dirty_size,
+		(unsigned long) (c->fmc->flash_size -
+			(c->fmc->used_size + c->fmc->dirty_size)),
+		c->fmc->flash_size - (c->fmc->used_size + c->fmc->dirty_size));
+
+	/* We're done */
+	*eof = 1;
+
+	/* Return length */
+	return len;
+}
+
+
+/*
+ * Read a JFFS partition's `layout' file
+ */
+static int jffs_proc_layout_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	struct jffs_control *c = (struct jffs_control *) data;
+	struct jffs_fm *fm = 0;
+	struct jffs_fm *last_fm = 0;
+	int len = 0;
+
+	/* Get the first item in the list */
+ 	fm = c->fmc->head;
+
+	/* Print free space */
+	if (fm && fm->offset) {
+		len += sprintf (page, "00000000 %08lX free\n",
+			(unsigned long) fm->offset);
+	}
+
+	/* Loop through all of the flash control structures */
+	while (fm && (len < (off + count))) {
+		if (fm->nodes) {
+			len += sprintf (page + len,
+				"%08lX %08lX ino=%08lX, ver=%08lX\n",
+				(unsigned long) fm->offset,
+				(unsigned long) fm->size,
+				(unsigned long) fm->nodes->node->ino,
+				(unsigned long) fm->nodes->node->version);
+		}
+		else {
+			len += sprintf (page + len,
+				"%08lX %08lX dirty\n",
+				(unsigned long) fm->offset,
+				(unsigned long) fm->size);
+		}
+		last_fm = fm;
+		fm = fm->next;
+	}
+
+	/* Print free space */
+	if ((len < (off + count)) && last_fm
+	    && (last_fm->offset < c->fmc->flash_size)) {
+		len += sprintf (page + len,
+			       "%08lX %08lX free\n",
+			       (unsigned long) last_fm->offset + 
+				last_fm->size,
+			       (unsigned long) (c->fmc->flash_size -
+						    (last_fm->offset + last_fm->size)));
+	}
+
+	/* We're done */
+	*eof = 1;
+
+	/* Return length */
+	return len;
+}
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_proc.h linux-2.4.2/fs/jffs/jffs_proc.h
--- linux-2.4.2.orig/fs/jffs/jffs_proc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/jffs_proc.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,28 @@
+/*
+ * JFFS -- Journaling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 2000  Axis Communications AB.
+ *
+ * Created by Simon Kagstrom <simonk@axis.com>.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * $Id: jffs_proc.h,v 1.2 2000/11/15 22:04:12 sjhill Exp $
+ */
+
+/* jffs_proc.h defines a structure for inclusion in the proc-file system.  */
+#ifndef __LINUX_JFFS_PROC_H__
+#define __LINUX_JFFS_PROC_H__
+
+#include <linux/proc_fs.h>
+
+/* The proc_dir_entry for jffs (defined in jffs_proc.c).  */
+extern struct proc_dir_entry *jffs_proc_root;
+
+int jffs_register_jffs_proc_dir(kdev_t dev, struct jffs_control *c);
+int jffs_unregister_jffs_proc_dir(struct jffs_control *c);
+
+#endif /* __LINUX_JFFS_PROC_H__ */
diff -Naur linux-2.4.2.orig/fs/jffs2/.cvsignore linux-2.4.2/fs/jffs2/.cvsignore
--- linux-2.4.2.orig/fs/jffs2/.cvsignore	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/.cvsignore	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+*.flags
\ No newline at end of file
diff -Naur linux-2.4.2.orig/fs/jffs2/CVS/Entries linux-2.4.2/fs/jffs2/CVS/Entries
--- linux-2.4.2.orig/fs/jffs2/CVS/Entries	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/CVS/Entries	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,35 @@
+/.cvsignore/1.1/Tue Feb 13 10:46:44 2001//
+/Makefile/1.22/Mon Apr 23 21:20:47 2001//
+/TODO/1.3/Thu Mar  1 23:26:48 2001//
+/background.c/1.11/Mon Jul  2 14:35:45 2001//
+/build.c/1.16/Thu Mar 15 15:38:23 2001//
+/compr.c/1.16/Thu Mar 15 15:38:23 2001//
+/compr_rtime.c/1.5/Thu Mar 15 15:38:23 2001//
+/compr_rubin.c/1.12/Sat Jun  2 22:27:14 2001//
+/compr_rubin.h/1.5/Mon Feb 26 13:50:01 2001//
+/compr_zlib.c/1.6/Wed Apr 18 15:04:00 2001//
+/comprtest.c/1.4/Wed Feb 21 14:03:20 2001//
+/crc32.c/1.3/Wed Feb  7 16:45:32 2001//
+/crc32.h/1.3/Mon Feb 26 14:44:37 2001//
+/dir.c/1.42/Thu May 24 22:24:39 2001//
+/erase.c/1.19/Sun Mar 25 22:36:12 2001//
+/file.c/1.55/Tue May 29 09:19:24 2001//
+/gc.c/1.51/Thu May 24 22:24:39 2001//
+/histo.h/1.1/Mon Feb 12 17:45:43 2001//
+/histo_mips.h/1.2/Mon Feb 26 13:50:02 2001//
+/ioctl.c/1.5/Thu Mar 15 15:38:24 2001//
+/malloc.c/1.16/Thu Mar 15 15:38:24 2001//
+/nodelist.c/1.28/Tue Mar 27 06:20:04 2001//
+/nodelist.h/1.45/Tue Mar 20 17:43:57 2001//
+/nodemgmt.c/1.39/Wed Apr 11 22:20:26 2001//
+/pushpull.c/1.6/Thu Mar 15 15:38:24 2001//
+/pushpull.h/1.4/Thu Mar 15 15:38:24 2001//
+/read.c/1.13/Tue May  1 16:24:44 2001//
+/readinode.c/1.56/Thu Jul 26 20:32:39 2001//
+/scan.c/1.49/Mon Jul  2 16:40:01 2001//
+/super.c/1.44/Thu May 31 20:47:48 2001//
+/symlink.c/1.5/Thu Mar 15 15:38:24 2001//
+/write.c/1.28/Tue May  1 16:25:25 2001//
+/zlib.c/1.1/Wed Feb 28 10:09:45 2001/-ko/
+/zlib.h/1.1/Wed Feb 28 10:09:45 2001/-ko/
+D
diff -Naur linux-2.4.2.orig/fs/jffs2/CVS/Entries.Log linux-2.4.2/fs/jffs2/CVS/Entries.Log
--- linux-2.4.2.orig/fs/jffs2/CVS/Entries.Log	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/CVS/Entries.Log	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,2 @@
+A D/compressors////
+A D/test////
diff -Naur linux-2.4.2.orig/fs/jffs2/CVS/Repository linux-2.4.2/fs/jffs2/CVS/Repository
--- linux-2.4.2.orig/fs/jffs2/CVS/Repository	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/CVS/Repository	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+mtd/fs/jffs2
diff -Naur linux-2.4.2.orig/fs/jffs2/CVS/Root linux-2.4.2/fs/jffs2/CVS/Root
--- linux-2.4.2.orig/fs/jffs2/CVS/Root	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/CVS/Root	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+:pserver:anoncvs@cvs.infradead.org:/home/cvs
diff -Naur linux-2.4.2.orig/fs/jffs2/GNUmakefile linux-2.4.2/fs/jffs2/GNUmakefile
--- linux-2.4.2.orig/fs/jffs2/GNUmakefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/GNUmakefile	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,38 @@
+# GNUmakefile for JFFS2 build outside kernel tree
+# $Id: GNUmakefile,v 1.2 2002/01/03 14:57:56 dwmw2 Exp $
+
+LINUXDIR=/lib/modules/$(shell uname -r)/build
+
+ifndef VERSION
+
+# Someone just typed 'make'
+
+modules:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` modules
+
+dep:
+	make -C $(LINUXDIR) SUBDIRS=`pwd` dep
+
+clean:
+	rm -f *.o
+
+else
+
+ifndef CONFIG_JFFS2_FS
+
+CC += -I$(shell pwd)/../../include
+
+CONFIG_JFFS2_FS := m
+EXTRA_CFLAGS += -DCONFIG_JFFS2_FS_DEBUG=1 -g
+
+endif
+
+# Check whether we've put the JFFS2 stuff in the superblock and inode unions
+OUT_OF_KERNEL_CFLAGS := $(shell grep -q jffs2 $(TOPDIR)/include/linux/fs.h || echo "-DJFFS2_OUT_OF_KERNEL")
+EXTRA_CFLAGS += $(OUT_OF_KERNEL_CFLAGS)
+
+
+include Makefile
+
+
+endif
diff -Naur linux-2.4.2.orig/fs/jffs2/Makefile linux-2.4.2/fs/jffs2/Makefile
--- linux-2.4.2.orig/fs/jffs2/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/Makefile	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,40 @@
+#
+# Makefile for the linux Journalling Flash FileSystem (JFFS) routines.
+#
+# $Id: Makefile,v 1.22 2001/04/23 21:20:47 dwmw2 Exp $
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+ifndef CONFIG_JFFS2_FS
+
+CC += -I$(shell pwd)/../../include
+
+obj-m := jffs2.o comprmod.o
+# We're being invoked outside a normal kernel build. Fake it
+EXTRA_CFLAGS= -DCONFIG_JFFS2_FS_DEBUG=1 -g
+endif
+
+EXTRA_CFLAGS += -DJFFS2_OUT_OF_KERNEL
+
+obj-$(CONFIG_JFFS2_FS)	+= jffs2.o
+
+COMPR_OBJS	:= compr.o compr_rubin.o compr_rtime.o pushpull.o \
+			compr_zlib.o zlib.o
+JFFS2_OBJS	:= crc32.o dir.o file.o ioctl.o nodelist.o malloc.o \
+	read.o nodemgmt.o readinode.o super.o write.o scan.o gc.o \
+	symlink.o build.o erase.o background.o
+
+jffs2-objs	:= $(COMPR_OBJS) $(JFFS2_OBJS)
+comprmod-objs	:= $(COMPR_OBJS) comprtest.o
+
+jffs2.o: $(jffs2-objs)
+	$(LD) -r -o $@ $(jffs2-objs)
+
+comprmod.o: $(comprmod-objs)
+	$(LD) -r -o $@ $(comprmod-objs)
+
+include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/fs/jffs2/TODO linux-2.4.2/fs/jffs2/TODO
--- linux-2.4.2.orig/fs/jffs2/TODO	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/TODO	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,20 @@
+$Id: TODO,v 1.3 2001/03/01 23:26:48 dwmw2 Exp $
+
+ - disable compression in commit_write()? Or at least optimise the 'always write
+	whole page' bit.
+ - fix zlib. It's ugly as hell and there are at least three copies in the kernel tree
+ - fine-tune the allocation / GC thresholds
+ - chattr support - turning on/off and tuning compression per-inode
+ - checkpointing (do we need this? scan is quite fast)
+ - make the scan code populate real inodes so read_inode just after 
+	mount doesn't have to read the flash twice for large files.
+	Make this a per-inode option, changable with chattr, so you can
+	decide which inodes should be in-core immediately after mount.
+ - stop it depending on a block device. mount(8) needs a change for this.
+ - make it work on NAND flash. We need to know when we can GC
+	deletion dirents, etc. And think about holes/truncation. It can
+	all be done reasonably simply, but it need implementing.
+ - NAND flash will require new dirent/dnode structures on the medium with
+	ECC data in rather than just the CRC we're using ATM.
+ - test, test, test
+
diff -Naur linux-2.4.2.orig/fs/jffs2/background.c linux-2.4.2/fs/jffs2/background.c
--- linux-2.4.2.orig/fs/jffs2/background.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/background.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,172 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: background.c,v 1.11 2001/07/02 14:35:45 dwmw2 Exp $
+ *
+ */
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include "nodelist.h"
+
+
+static int jffs2_garbage_collect_thread(void *);
+static int thread_should_wake(struct jffs2_sb_info *c);
+
+void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
+{
+	spin_lock_bh(&c->erase_completion_lock);
+        if (c->gc_task && thread_should_wake(c))
+                send_sig(SIGHUP, c->gc_task, 1);
+	spin_unlock_bh(&c->erase_completion_lock);
+}
+
+int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)
+{
+	pid_t pid;
+	int ret = 0;
+	init_MUTEX_LOCKED(&c->gc_thread_sem);
+	
+	pid = kernel_thread(jffs2_garbage_collect_thread, c, CLONE_FS|CLONE_FILES);
+	if (pid < 0) {
+		printk(KERN_WARNING "fork failed for JFFS2 garbage collect thread: %d\n", -pid);
+		ret = pid;
+	} else {
+		/* Wait for it... */
+		D1(printk(KERN_DEBUG "JFFS2: Garbage collect thread is pid %d\n", pid));
+		down(&c->gc_thread_sem);
+	}
+	up(&c->gc_thread_sem);
+ 
+	return ret;
+}
+
+void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)
+{
+	spin_lock_bh(&c->erase_completion_lock);
+	if (c->gc_task) {
+		D1(printk(KERN_DEBUG "jffs2: Killing GC task %d\n", c->gc_task->pid));
+		send_sig(SIGKILL, c->gc_task, 1);
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	down(&c->gc_thread_sem);
+}
+
+static int jffs2_garbage_collect_thread(void *_c)
+{
+	struct jffs2_sb_info *c = _c;
+
+	daemonize();
+	current->tty = NULL;
+	c->gc_task = current;
+	up(&c->gc_thread_sem);
+
+        sprintf(current->comm, "jffs2_gcd_mtd%d", c->mtd->index);
+
+	/* FIXME in the 2.2 backport */
+	current->nice = 10;
+
+	for (;;) {
+		spin_lock_irq(&current->sigmask_lock);
+		siginitsetinv (&current->blocked, sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
+		recalc_sigpending(current);
+		spin_unlock_irq(&current->sigmask_lock);
+
+		if (!thread_should_wake(c)) {
+                        set_current_state (TASK_INTERRUPTIBLE);
+			D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread sleeping...\n"));
+		}
+                
+                schedule(); /* Yes, we do this even if we want to go
+			       on immediately - we're a low priority 
+			       background task. */
+
+                /* Put_super will send a SIGKILL and then wait on the sem. 
+                 */
+                while (signal_pending(current)) {
+                        siginfo_t info;
+                        unsigned long signr;
+
+                        spin_lock_irq(&current->sigmask_lock);
+                        signr = dequeue_signal(&current->blocked, &info);
+                        spin_unlock_irq(&current->sigmask_lock);
+
+                        switch(signr) {
+                        case SIGSTOP:
+                                D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGSTOP received.\n"));
+                                set_current_state(TASK_STOPPED);
+                                schedule();
+                                break;
+
+                        case SIGKILL:
+                                D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGKILL received.\n"));
+				spin_lock_bh(&c->erase_completion_lock);
+                                c->gc_task = NULL;
+				spin_unlock_bh(&c->erase_completion_lock);
+				up_and_exit(&c->gc_thread_sem, 0);
+
+			case SIGHUP:
+				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGHUP received.\n"));
+				break;
+			default:
+				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): signal %ld received\n", signr));
+
+                        }
+                }
+		/* We don't want SIGHUP to interrupt us. STOP and KILL are OK though. */
+		spin_lock_irq(&current->sigmask_lock);
+		siginitsetinv (&current->blocked, sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
+		recalc_sigpending(current);
+		spin_unlock_irq(&current->sigmask_lock);
+
+		D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): pass\n"));
+		jffs2_garbage_collect_pass(c);
+	}
+}
+
+static int thread_should_wake(struct jffs2_sb_info *c)
+{
+	D1(printk(KERN_DEBUG "thread_should_wake(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x\n", 
+		  c->nr_free_blocks, c->nr_erasing_blocks, c->dirty_size));
+	if (c->nr_free_blocks + c->nr_erasing_blocks < JFFS2_RESERVED_BLOCKS_GCTRIGGER &&
+	    c->dirty_size > c->sector_size)
+		return 1;
+	else 
+		return 0;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/build.c linux-2.4.2/fs/jffs2/build.c
--- linux-2.4.2.orig/fs/jffs2/build.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/build.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,257 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: build.c,v 1.16 2001/03/15 15:38:23 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/jffs2.h>
+#include <linux/slab.h>
+#include "nodelist.h"
+
+int jffs2_build_inode_pass1(struct jffs2_sb_info *, struct jffs2_inode_cache *);
+int jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *, struct jffs2_inode_cache *);
+
+
+#define for_each_inode(i, c, ic) for (i=0; i<INOCACHE_HASHSIZE; i++) for (ic=c->inocache_list[i]; ic; ic=ic->next) 
+
+/* Scan plan:
+ - Scan physical nodes. Build map of inodes/dirents. Allocate inocaches as we go
+ - Scan directory tree from top down, setting nlink in inocaches
+ - Scan inocaches for inodes with nlink==0
+*/
+int jffs2_build_filesystem(struct jffs2_sb_info *c)
+{
+	int ret;
+	int i;
+	struct jffs2_inode_cache *ic;
+
+	/* First, scan the medium and build all the inode caches with
+	   lists of physical nodes */
+	ret = jffs2_scan_medium(c);
+	if (ret)
+		return ret;
+
+	D1(printk(KERN_DEBUG "Scanned flash completely\n"));
+	/* Now build the data map for each inode, marking obsoleted nodes
+	   as such, and also increase nlink of any children. */
+	for_each_inode(i, c, ic) {
+		D1(printk(KERN_DEBUG "Pass 1: ino #%u\n", ic->ino));
+		ret = jffs2_build_inode_pass1(c, ic);
+		if (ret) {
+			D1(printk(KERN_WARNING "Eep. jffs2_build_inode_pass1 for ino %d returned %d\n", ic->ino, ret));
+			return ret;
+		}
+	}
+	D1(printk(KERN_DEBUG "Pass 1 complete\n"));
+
+	/* Next, scan for inodes with nlink == 0 and remove them. If
+	   they were directories, then decrement the nlink of their
+	   children too, and repeat the scan. As that's going to be
+	   a fairly uncommon occurrence, it's not so evil to do it this
+	   way. Recursion bad. */
+	do { 
+		D1(printk(KERN_DEBUG "Pass 2 (re)starting\n"));
+		ret = 0;
+		for_each_inode(i, c, ic) {
+			D1(printk(KERN_DEBUG "Pass 2: ino #%u, nlink %d, ic %p, nodes %p\n", ic->ino, ic->nlink, ic, ic->nodes));
+			if (ic->nlink)
+				continue;
+			
+			ret = jffs2_build_remove_unlinked_inode(c, ic);
+			if (ret)
+				break;
+		/* -EAGAIN means the inode's nlink was zero, so we deleted it,
+		   and furthermore that it had children and their nlink has now
+		   gone to zero too. So we have to restart the scan. */
+		} 
+	} while(ret == -EAGAIN);
+	
+	D1(printk(KERN_DEBUG "Pass 2 complete\n"));
+	
+	/* Finally, we can scan again and free the dirent nodes and scan_info structs */
+	for_each_inode(i, c, ic) {
+		struct jffs2_scan_info *scan = ic->scan;
+		struct jffs2_full_dirent *fd;
+		D1(printk(KERN_DEBUG "Pass 3: ino #%u, ic %p, nodes %p\n", ic->ino, ic, ic->nodes));
+		if (!scan) {
+			if (ic->nlink) {
+				D1(printk(KERN_WARNING "Why no scan struct for ino #%u which has nlink %d?\n", ic->ino, ic->nlink));
+			}
+			continue;
+		}
+		ic->scan = NULL;
+		while(scan->dents) {
+			fd = scan->dents;
+			scan->dents = fd->next;
+			jffs2_free_full_dirent(fd);
+		}
+		kfree(scan);
+	}
+	D1(printk(KERN_DEBUG "Pass 3 complete\n"));
+
+	return ret;
+}
+	
+int jffs2_build_inode_pass1(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)
+{
+	struct jffs2_tmp_dnode_info *tn;
+	struct jffs2_full_dirent *fd;
+	struct jffs2_node_frag *fraglist = NULL;
+	struct jffs2_tmp_dnode_info *metadata = NULL;
+
+	D1(printk(KERN_DEBUG "jffs2_build_inode building inode #%u\n", ic->ino));
+	if (ic->ino > c->highest_ino)
+		c->highest_ino = ic->ino;
+
+	if (!ic->scan->tmpnodes && ic->ino != 1) {
+		D1(printk(KERN_DEBUG "jffs2_build_inode: ino #%u has no data nodes!\n", ic->ino));
+	}
+	/* Build the list to make sure any obsolete nodes are marked as such */
+	while(ic->scan->tmpnodes) {
+		tn = ic->scan->tmpnodes;
+		ic->scan->tmpnodes = tn->next;
+		
+		if (metadata && tn->version > metadata->version) {
+			D1(printk(KERN_DEBUG "jffs2_build_inode_pass1 ignoring old metadata at 0x%08x\n",
+				  metadata->fn->raw->flash_offset &~3));
+			
+			jffs2_free_full_dnode(metadata->fn);
+			jffs2_free_tmp_dnode_info(metadata);
+			metadata = NULL;
+		}
+			
+		if (tn->fn->size) {
+			jffs2_add_full_dnode_to_fraglist (c, &fraglist, tn->fn);
+			jffs2_free_tmp_dnode_info(tn);
+		} else {
+			if (!metadata) {
+				metadata = tn;
+			} else {
+				D1(printk(KERN_DEBUG "jffs2_build_inode_pass1 ignoring new metadata at 0x%08x\n",
+					  tn->fn->raw->flash_offset &~3));
+				
+				jffs2_free_full_dnode(tn->fn);
+				jffs2_free_tmp_dnode_info(tn);
+			}
+		}
+	}
+		
+	/* OK. Now clear up */
+	if (metadata) {
+		jffs2_free_full_dnode(metadata->fn);
+		jffs2_free_tmp_dnode_info(metadata);
+	}
+	metadata = NULL;
+	
+	while (fraglist) {
+		struct jffs2_node_frag *frag;
+		frag = fraglist;
+		fraglist = fraglist->next;
+		
+		if (frag->node && !(--frag->node->frags)) {
+			jffs2_free_full_dnode(frag->node);
+		}
+		jffs2_free_node_frag(frag);
+	}
+
+	/* Now for each child, increase nlink */
+	for(fd=ic->scan->dents; fd; fd = fd->next) {
+		struct jffs2_inode_cache *child_ic;
+		if (!fd->ino)
+			continue;
+
+		child_ic = jffs2_get_ino_cache(c, fd->ino);
+		if (!child_ic) {
+			printk(KERN_NOTICE "Eep. Child \"%s\" (ino #%u) of dir ino #%u doesn't exist!\n",
+				  fd->name, fd->ino, ic->ino);
+			continue;
+		}
+
+		if (child_ic->nlink++ && fd->type == DT_DIR) {
+			printk(KERN_NOTICE "Child dir \"%s\" (ino #%u) of dir ino #%u appears to be a hard link\n", fd->name, fd->ino, ic->ino);
+			/* What do we do about it? */
+		}
+		D1(printk(KERN_DEBUG "Increased nlink for child \"%s\" (ino #%u)\n", fd->name, fd->ino));
+		/* Can't free them. We might need them in pass 2 */
+	}
+	return 0;
+}
+
+int jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)
+{
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dirent *fd;
+	int ret = 0;
+
+	if(!ic->scan) {
+		D1(printk(KERN_DEBUG "ino #%u was already removed\n", ic->ino));
+		return 0;
+	}
+
+	D1(printk(KERN_DEBUG "JFFS2: Removing ino #%u with nlink == zero.\n", ic->ino));
+	
+	for (raw = ic->nodes; raw != (void *)ic; raw = raw->next_in_ino) {
+		D1(printk(KERN_DEBUG "obsoleting node at 0x%08x\n", raw->flash_offset&~3));
+		jffs2_mark_node_obsolete(c, raw);
+	}
+
+	if (ic->scan->dents) {
+		printk(KERN_NOTICE "Inode #%u was a directory with children - removing those too...\n", ic->ino);
+	
+		while(ic->scan->dents) {
+			struct jffs2_inode_cache *child_ic;
+
+			fd = ic->scan->dents;
+			ic->scan->dents = fd->next;
+
+			D1(printk(KERN_DEBUG "Removing child \"%s\", ino #%u\n",
+				  fd->name, fd->ino));
+			
+			child_ic = jffs2_get_ino_cache(c, fd->ino);
+			if (!child_ic) {
+				printk(KERN_NOTICE "Cannot remove child \"%s\", ino #%u, because it doesn't exist\n", fd->name, fd->ino);
+				continue;
+			}
+			jffs2_free_full_dirent(fd);
+			child_ic->nlink--;
+		}
+		ret = -EAGAIN;
+	}
+	kfree(ic->scan);
+	ic->scan = NULL;
+	//	jffs2_del_ino_cache(c, ic);
+	//	jffs2_free_inode_cache(ic);
+	return ret;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/compr.c linux-2.4.2/fs/jffs2/compr.c
--- linux-2.4.2.orig/fs/jffs2/compr.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compr.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,143 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by Arjan van de Ven <arjanv@redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr.c,v 1.16 2001/03/15 15:38:23 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/jffs2.h>
+
+int zlib_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void zlib_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+
+
+/* jffs2_compress:
+ * @data: Pointer to uncompressed data
+ * @cdata: Pointer to buffer for compressed data
+ * @datalen: On entry, holds the amount of data available for compression.
+ *	On exit, expected to hold the amount of data actually compressed.
+ * @cdatalen: On entry, holds the amount of space available for compressed
+ *	data. On exit, expected to hold the actual size of the compressed
+ *	data.
+ *
+ * Returns: Byte to be stored with data indicating compression type used.
+ * Zero is used to show that the data could not be compressed - the 
+ * compressed version was actually larger than the original.
+ *
+ * If the cdata buffer isn't large enough to hold all the uncompressed data,
+ * jffs2_compress should compress as much as will fit, and should set 
+ * *datalen accordingly to show the amount of data which were compressed.
+ */
+unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		    __u32 *datalen, __u32 *cdatalen)
+{
+	int ret;
+
+	ret = zlib_compress(data_in, cpage_out, datalen, cdatalen);
+	if (!ret) {
+		return JFFS2_COMPR_ZLIB;
+	}
+
+	ret = dynrubin_compress(data_in, cpage_out, datalen, cdatalen);
+	if (!ret) {
+		return JFFS2_COMPR_DYNRUBIN;
+	}
+
+#if 0 /* Phase this one out */
+	ret = rubinmips_compress(data_in, cpage_out, datalen, cdatalen);
+	if (!ret) {
+		return JFFS2_COMPR_RUBINMIPS;
+	}
+#endif
+	ret = rtime_compress(data_in, cpage_out, datalen, cdatalen);
+	if (!ret) {
+		return JFFS2_COMPR_RTIME;
+	}
+#if 0
+	/* We don't need to copy. Let the caller special-case the COMPR_NONE case. */
+	/* If we get here, no compression is going to work */
+	/* But we might want to use the fragmentation part -- Arjan */
+	memcpy(cpage_out,data_in,min(*datalen,*cdatalen));
+	if (*datalen > *cdatalen)
+		*datalen = *cdatalen;
+#endif		
+	return JFFS2_COMPR_NONE; /* We failed to compress */
+
+}
+
+
+int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen)
+{
+	switch (comprtype) {
+	case JFFS2_COMPR_NONE:
+		/* This should be special-cased elsewhere, but we might as well deal with it */
+		memcpy(data_out, cdata_in, datalen);
+		break;
+
+	case JFFS2_COMPR_ZERO:
+		memset(data_out, 0, datalen);
+		break;
+
+	case JFFS2_COMPR_ZLIB:
+		zlib_decompress(cdata_in, data_out, cdatalen, datalen);
+		break;
+
+	case JFFS2_COMPR_RTIME:
+		rtime_decompress(cdata_in, data_out, cdatalen, datalen);
+		break;
+#if 1 /* Phase this one out */
+	case JFFS2_COMPR_RUBINMIPS:
+		rubinmips_decompress(cdata_in, data_out, cdatalen, datalen);
+		break;
+#endif
+	case JFFS2_COMPR_DYNRUBIN:
+		dynrubin_decompress(cdata_in, data_out, cdatalen, datalen);
+		break;
+
+	default:
+		printk(KERN_NOTICE "Unknown JFFS2 compression type 0x%02x\n", comprtype);
+		return -EIO;
+	}
+	return 0;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/compr_rtime.c linux-2.4.2/fs/jffs2/compr_rtime.c
--- linux-2.4.2.orig/fs/jffs2/compr_rtime.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compr_rtime.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,128 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by Arjan van de Ven <arjanv@redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_rtime.c,v 1.5 2001/03/15 15:38:23 dwmw2 Exp $
+ *
+ *
+ * Very simple lz77-ish encoder.
+ *
+ * Theory of operation: Both encoder and decoder have a list of "last
+ * occurances" for every possible source-value; after sending the
+ * first source-byte, the second byte indicated the "run" length of
+ * matches
+ *
+ * The algorithm is intended to only send "whole bytes", no bit-messing.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h> 
+
+/* _compress returns the compressed size, -1 if bigger */
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
+{
+	int positions[256];
+	int outpos = 0;
+	int pos=0;
+
+	memset(positions,0,sizeof(positions)); 
+	
+	while (pos < (*sourcelen) && outpos <= (*dstlen)-2) {
+		int backpos, runlen=0;
+		unsigned char value;
+		
+		value = data_in[pos];
+
+		cpage_out[outpos++] = data_in[pos++];
+		
+		backpos = positions[value];
+		positions[value]=pos;
+		
+		while ((backpos < pos) && (pos < (*sourcelen)) &&
+		       (data_in[pos]==data_in[backpos++]) && (runlen<255)) {
+			pos++;
+			runlen++;
+		}
+		cpage_out[outpos++] = runlen;
+	}
+
+	if (outpos >= pos) {
+		/* We failed */
+		return -1;
+	}
+	
+	/* Tell the caller how much we managed to compress, and how much space it took */
+	*sourcelen = pos;
+	*dstlen = outpos;
+	return 0;
+}		   
+
+
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen)
+{
+	int positions[256];
+	int outpos = 0;
+	int pos=0;
+	
+	memset(positions,0,sizeof(positions)); 
+	
+	while (outpos<destlen) {
+		unsigned char value;
+		int backoffs;
+		int repeat;
+		
+		value = data_in[pos++];
+		cpage_out[outpos++] = value; /* first the verbatim copied byte */
+		repeat = data_in[pos++];
+		backoffs = positions[value];
+		
+		positions[value]=outpos;
+		if (repeat) {
+			if (backoffs + repeat >= outpos) {
+				while(repeat) {
+					cpage_out[outpos++] = cpage_out[backoffs++];
+					repeat--;
+				}
+			} else {
+				memcpy(&cpage_out[outpos],&cpage_out[backoffs],repeat);
+				outpos+=repeat;		
+			}
+		}
+	}		
+}		   
+
+
diff -Naur linux-2.4.2.orig/fs/jffs2/compr_rubin.c linux-2.4.2/fs/jffs2/compr_rubin.c
--- linux-2.4.2.orig/fs/jffs2/compr_rubin.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compr_rubin.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,327 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by Arjan van de Ven <arjanv@redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_rubin.c,v 1.12 2001/06/02 22:27:14 nico Exp $
+ *
+ */
+
+ 
+#include <linux/string.h>
+#include <linux/types.h>
+#include "compr_rubin.h"
+#include "histo_mips.h"
+
+
+
+void init_rubin(struct rubin_state *rs, int div, int *bits)
+{	
+	int c;
+
+	rs->q = 0;
+	rs->p = (long) (2 * UPPER_BIT_RUBIN);
+	rs->bit_number = (long) 0;
+	rs->bit_divider = div;
+	for (c=0; c<8; c++)
+		rs->bits[c] = bits[c];
+}
+
+
+int encode(struct rubin_state *rs, long A, long B, int symbol)
+{
+
+	long i0, i1;
+	int ret;
+
+	while ((rs->q >= UPPER_BIT_RUBIN) || ((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {
+		rs->bit_number++;
+		
+		ret = pushbit(&rs->pp, (rs->q & UPPER_BIT_RUBIN) ? 1 : 0, 0);
+		if (ret)
+			return ret;
+		rs->q &= LOWER_BITS_RUBIN;
+		rs->q <<= 1;
+		rs->p <<= 1;
+	}
+	i0 = A * rs->p / (A + B);
+	if (i0 <= 0) {
+		i0 = 1;
+	}
+	if (i0 >= rs->p) {
+		i0 = rs->p - 1;
+	}
+	i1 = rs->p - i0;
+
+	if (symbol == 0)
+		rs->p = i0;
+	else {
+		rs->p = i1;
+		rs->q += i0;
+	}
+	return 0;
+}
+
+
+void end_rubin(struct rubin_state *rs)
+{				
+
+	int i;
+
+	for (i = 0; i < RUBIN_REG_SIZE; i++) {
+		pushbit(&rs->pp, (UPPER_BIT_RUBIN & rs->q) ? 1 : 0, 1);
+		rs->q &= LOWER_BITS_RUBIN;
+		rs->q <<= 1;
+	}
+}
+
+
+void init_decode(struct rubin_state *rs, int div, int *bits)
+{
+	init_rubin(rs, div, bits);		
+
+	/* behalve lower */
+	rs->rec_q = 0;
+
+	for (rs->bit_number = 0; rs->bit_number++ < RUBIN_REG_SIZE; rs->rec_q = rs->rec_q * 2 + (long) (pullbit(&rs->pp)))
+		;
+}
+
+
+
+int decode(struct rubin_state *rs, long A, long B)
+{
+
+	char c;
+	long i0, i1, threshold;
+	int symbol;
+	
+
+	while ((rs->q >= UPPER_BIT_RUBIN) || ((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {
+		c = pullbit(&rs->pp);
+		rs->bit_number++;
+		rs->q &= LOWER_BITS_RUBIN;
+		rs->q <<= 1;
+		rs->p <<= 1;
+		rs->rec_q &= LOWER_BITS_RUBIN;
+		rs->rec_q <<= 1;
+		rs->rec_q += c;
+	};
+	i0 = A * rs->p / (A + B);
+	if (i0 <= 0) {
+		i0 = 1;
+	}
+	if (i0 >= rs->p) {
+		i0 = rs->p - 1;
+	}
+	i1 = rs->p - i0;
+
+
+	threshold = rs->q + i0;
+	if (rs->rec_q < threshold) {
+		symbol = 0;
+		rs->p = i0;
+	} else {
+		symbol = 1;
+		rs->p = i1;
+		rs->q += i0;
+	}
+	
+	return symbol;
+}
+
+
+
+static int out_byte(struct rubin_state *rs, unsigned char byte)
+{
+	int i, ret;
+	struct rubin_state rs_copy;
+	rs_copy = *rs;
+
+	for (i=0;i<8;i++) {
+		ret = encode(rs, rs->bit_divider-rs->bits[i],rs->bits[i],byte&1);
+		if (ret) {
+			/* Failed. Restore old state */
+			*rs = rs_copy;
+			return ret;
+		}
+		byte=byte>>1;
+	}
+	return 0;
+}
+
+static int in_byte(struct rubin_state *rs)
+{
+	int i;
+	int result=0;
+	for (i=0;i<8;i++) {
+		result |=  decode(rs, rs->bit_divider-rs->bits[i],rs->bits[i])<<i;
+	}
+	return result;
+}
+
+
+
+int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in, 
+		      unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen)
+	{
+	int outpos = 0;
+	int pos=0;
+	struct rubin_state rs;
+
+	init_pushpull(&rs.pp, cpage_out, *dstlen * 8, 0, 32);
+
+	init_rubin(&rs, bit_divider, bits);
+	
+	while (pos < (*sourcelen) && !out_byte(&rs, data_in[pos]))
+		pos++;
+	
+	end_rubin(&rs);
+
+	if (outpos > pos) {
+		/* We failed */
+		return -1;
+	}
+	
+	/* Tell the caller how much we managed to compress, 
+	 * and how much space it took */
+	
+	outpos = (pushedbits(&rs.pp)+7)/8;
+	
+	if (outpos >= pos)
+		return -1; /* We didn't actually compress */
+	*sourcelen = pos;
+	*dstlen = outpos;
+	return 0;
+}		   
+#if 0
+/* _compress returns the compressed size, -1 if bigger */
+int rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
+{
+	return rubin_do_compress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
+}
+#endif
+int dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
+{
+	int bits[8];
+	unsigned char histo[256];
+	int i;
+	int ret;
+	__u32 mysrclen, mydstlen;
+
+	mysrclen = *sourcelen;
+	mydstlen = *dstlen - 8;
+
+	if (*dstlen <= 12)
+		return -1;
+
+	memset(histo, 0, 256);
+	for (i=0; i<mysrclen; i++) {
+		histo[data_in[i]]++;
+	}
+	memset(bits, 0, sizeof(int)*8);
+	for (i=0; i<256; i++) {
+		if (i&128)
+			bits[7] += histo[i];
+		if (i&64)
+			bits[6] += histo[i];
+		if (i&32)
+			bits[5] += histo[i];
+		if (i&16)
+			bits[4] += histo[i];
+		if (i&8)
+			bits[3] += histo[i];
+		if (i&4)
+			bits[2] += histo[i];
+		if (i&2)
+			bits[1] += histo[i];
+		if (i&1)
+			bits[0] += histo[i];
+	}
+
+	for (i=0; i<8; i++) {
+		bits[i] = (bits[i] * 256) / mysrclen;
+		if (!bits[i]) bits[i] = 1;
+		if (bits[i] > 255) bits[i] = 255;
+		cpage_out[i] = bits[i];
+	}
+
+	ret = rubin_do_compress(256, bits, data_in, cpage_out+8, &mysrclen, &mydstlen);
+	if (ret) 
+		return ret;
+
+	/* Add back the 8 bytes we took for the probabilities */
+	mydstlen += 8;
+
+	if (mysrclen <= mydstlen) {
+		/* We compressed */
+		return -1;
+	}
+
+	*sourcelen = mysrclen;
+	*dstlen = mydstlen;
+	return 0;
+}
+
+void rubin_do_decompress(int bit_divider, int *bits, unsigned char *cdata_in, 
+			 unsigned char *page_out, __u32 srclen, __u32 destlen)
+{
+	int outpos = 0;
+	struct rubin_state rs;
+	
+	init_pushpull(&rs.pp, cdata_in, srclen, 0, 0);
+	init_decode(&rs, bit_divider, bits);
+	
+	while (outpos < destlen) {
+		page_out[outpos++] = in_byte(&rs);
+	}
+}		   
+
+
+void rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 sourcelen, __u32 dstlen)
+{
+	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
+}
+
+void dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 sourcelen, __u32 dstlen)
+{
+	int bits[8];
+	int c;
+
+	for (c=0; c<8; c++)
+		bits[c] = data_in[c];
+
+	rubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8, dstlen);
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/compr_rubin.h linux-2.4.2/fs/jffs2/compr_rubin.h
--- linux-2.4.2.orig/fs/jffs2/compr_rubin.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compr_rubin.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,28 @@
+/* Rubin encoder/decoder header       */
+/* work started at   : aug   3, 1994  */
+/* last modification : aug  15, 1994  */
+/* $Id: compr_rubin.h,v 1.5 2001/02/26 13:50:01 dwmw2 Exp $ */
+
+#include "pushpull.h"
+
+#define RUBIN_REG_SIZE   16
+#define UPPER_BIT_RUBIN    (((long) 1)<<(RUBIN_REG_SIZE-1))
+#define LOWER_BITS_RUBIN   ((((long) 1)<<(RUBIN_REG_SIZE-1))-1)
+
+
+struct rubin_state {
+	unsigned long p;		
+	unsigned long q;	
+	unsigned long rec_q;
+	long bit_number;
+	struct pushpull pp;
+	int bit_divider;
+	int bits[8];
+};
+
+
+void init_rubin (struct rubin_state *rs, int div, int *bits);
+int encode (struct rubin_state *, long, long, int);
+void end_rubin (struct rubin_state *);
+void init_decode (struct rubin_state *, int div, int *bits);
+int decode (struct rubin_state *, long, long);
diff -Naur linux-2.4.2.orig/fs/jffs2/compr_zlib.c linux-2.4.2/fs/jffs2/compr_zlib.c
--- linux-2.4.2.orig/fs/jffs2/compr_zlib.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compr_zlib.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,172 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_zlib.c,v 1.6 2001/04/18 15:04:00 dwmw2 Exp $
+ *
+ */
+
+#include "zlib.h"
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+
+static void *zalloc(void *opaque, unsigned nr, unsigned size)
+{
+	/* How much does it request? Should we use vmalloc? Or be dynamic? */
+	return kmalloc(nr * size, GFP_KERNEL);
+}
+
+static void zfree(void *opaque, void *addr)
+{
+	kfree(addr);
+}
+#else
+#define min(x,y) ((x)<(y)?(x):(y))
+#ifndef D1
+#define D1(x)
+#endif
+#define KERN_DEBUG
+#define KERN_NOTICE
+#define KERN_WARNING
+#define printk printf
+#include <stdio.h>
+#include <asm/types.h>
+#endif
+
+	/* Plan: call deflate() with avail_in == *sourcelen, 
+		avail_out = *dstlen - 12 and flush == Z_FINISH. 
+		If it doesn't manage to finish,	call it again with
+		avail_in == 0 and avail_out set to the remaining 12
+		bytes for it to clean up. 
+	   Q: Is 12 bytes sufficient?
+	*/
+#define STREAM_END_SPACE 12
+
+int zlib_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
+{
+	z_stream strm;
+	int ret;
+
+	if (*dstlen <= STREAM_END_SPACE)
+		return -1;
+
+#ifdef __KERNEL__
+	strm.zalloc = zalloc;
+	strm.zfree = zfree;
+#else
+	strm.zalloc = (void *)0;
+	strm.zfree = (void *)0;
+#endif
+
+	if (Z_OK != deflateInit(&strm, 3)) {
+		printk(KERN_WARNING "deflateInit failed\n");
+		return -1;
+	}
+	strm.next_in = data_in;
+	strm.total_in = 0;
+	
+	strm.next_out = cpage_out;
+	strm.total_out = 0;
+
+	while (strm.total_out < *dstlen - STREAM_END_SPACE && strm.total_in < *sourcelen) {
+		strm.avail_out = *dstlen - (strm.total_out + STREAM_END_SPACE);
+		strm.avail_in = min(*sourcelen-strm.total_in, strm.avail_out);
+		D1(printk(KERN_DEBUG "calling deflate with avail_in %d, avail_out %d\n",
+			  strm.avail_in, strm.avail_out));
+		ret = deflate(&strm, Z_PARTIAL_FLUSH);
+		D1(printk(KERN_DEBUG "deflate returned with avail_in %d, avail_out %d, total_in %ld, total_out %ld\n", 
+			  strm.avail_in, strm.avail_out, strm.total_in, strm.total_out));
+		if (ret != Z_OK) {
+			D1(printk(KERN_DEBUG "deflate in loop returned %d\n", ret));
+			deflateEnd(&strm);
+			return -1;
+		}
+	}
+	strm.avail_out += STREAM_END_SPACE;
+	strm.avail_in = 0;
+	ret = deflate(&strm, Z_FINISH);
+	if (ret != Z_STREAM_END) {
+		D1(printk(KERN_DEBUG "final deflate returned %d\n", ret));
+		deflateEnd(&strm);
+		return -1;
+	}
+	deflateEnd(&strm);
+
+	D1(printk(KERN_DEBUG "zlib compressed %ld bytes into %ld\n", strm.total_in, strm.total_out));
+
+	if (strm.total_out >= strm.total_in)
+		return -1;
+
+
+	*dstlen = strm.total_out;
+	*sourcelen = strm.total_in;
+	return 0;
+}
+
+void zlib_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen)
+{
+	z_stream strm;
+	int ret;
+
+#ifdef __KERNEL__
+	strm.zalloc = zalloc;
+	strm.zfree = zfree;
+#else
+	strm.zalloc = (void *)0;
+	strm.zfree = (void *)0;
+#endif
+
+	if (Z_OK != inflateInit(&strm)) {
+		printk(KERN_WARNING "inflateInit failed\n");
+		return;
+	}
+	strm.next_in = data_in;
+	strm.avail_in = srclen;
+	strm.total_in = 0;
+	
+	strm.next_out = cpage_out;
+	strm.avail_out = destlen;
+	strm.total_out = 0;
+
+	while((ret = inflate(&strm, Z_FINISH)) == Z_OK)
+		;
+	if (ret != Z_STREAM_END) {
+		printk(KERN_NOTICE "inflate returned %d\n", ret);
+	}
+	inflateEnd(&strm);
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/compressors/CVS/Entries linux-2.4.2/fs/jffs2/compressors/CVS/Entries
--- linux-2.4.2.orig/fs/jffs2/compressors/CVS/Entries	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compressors/CVS/Entries	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+D
diff -Naur linux-2.4.2.orig/fs/jffs2/compressors/CVS/Repository linux-2.4.2/fs/jffs2/compressors/CVS/Repository
--- linux-2.4.2.orig/fs/jffs2/compressors/CVS/Repository	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compressors/CVS/Repository	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+mtd/fs/jffs2/compressors
diff -Naur linux-2.4.2.orig/fs/jffs2/compressors/CVS/Root linux-2.4.2/fs/jffs2/compressors/CVS/Root
--- linux-2.4.2.orig/fs/jffs2/compressors/CVS/Root	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/compressors/CVS/Root	Fri Feb 15 14:41:16 2002
@@ -0,0 +1 @@
+:pserver:anoncvs@cvs.infradead.org:/home/cvs
diff -Naur linux-2.4.2.orig/fs/jffs2/comprtest.c linux-2.4.2/fs/jffs2/comprtest.c
--- linux-2.4.2.orig/fs/jffs2/comprtest.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/comprtest.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,307 @@
+/* $Id: comprtest.c,v 1.4 2001/02/21 14:03:20 dwmw2 Exp $ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <asm/types.h>
+#if 0
+#define TESTDATA_LEN 512
+static unsigned char testdata[TESTDATA_LEN] = {
+ 0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0x83, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00,
+ 0xb0, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x06, 0x00, 0x28, 0x00,
+ 0x1e, 0x00, 0x1b, 0x00, 0x06, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x34, 0x80, 0x04, 0x08,
+ 0x34, 0x80, 0x04, 0x08, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
+ 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x00, 0xf4, 0x80, 0x04, 0x08,
+ 0xf4, 0x80, 0x04, 0x08, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+ 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x08,
+ 0x00, 0x80, 0x04, 0x08, 0x0d, 0x05, 0x00, 0x00, 0x0d, 0x05, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
+ 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x05, 0x00, 0x00, 0x10, 0x95, 0x04, 0x08,
+ 0x10, 0x95, 0x04, 0x08, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
+ 0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x58, 0x05, 0x00, 0x00, 0x58, 0x95, 0x04, 0x08,
+ 0x58, 0x95, 0x04, 0x08, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
+ 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x08, 0x81, 0x04, 0x08,
+ 0x08, 0x81, 0x04, 0x08, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+ 0x04, 0x00, 0x00, 0x00, 0x2f, 0x6c, 0x69, 0x62, 0x2f, 0x6c, 0x64, 0x2d, 0x6c, 0x69, 0x6e, 0x75,
+ 0x78, 0x2e, 0x73, 0x6f, 0x2e, 0x32, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
+ 0x01, 0x00, 0x00, 0x00, 0x47, 0x4e, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+ 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00,
+ 0x0c, 0x83, 0x04, 0x08, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+ 0x1c, 0x83, 0x04, 0x08, 0xac, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00,
+ 0x2c, 0x83, 0x04, 0x08, 0xdd, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
+ 0x3c, 0x83, 0x04, 0x08, 0x2e, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
+ 0x4c, 0x83, 0x04, 0x08, 0x7d, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
+ 0x00, 0x85, 0x04, 0x08, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x5f, 0x67,
+ 0x6d, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x5f, 0x00, 0x6c, 0x69, 0x62, 0x63,
+ 0x2e, 0x73, 0x6f, 0x2e, 0x36, 0x00, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x00, 0x5f, 0x5f, 0x63};
+#else
+#define TESTDATA_LEN 3481
+static unsigned char testdata[TESTDATA_LEN] = {
+ 0x23, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x20, 0x22, 0x64, 0x62, 0x65, 0x6e, 0x63, 0x68,
+ 0x2e, 0x68, 0x22, 0x0a, 0x0a, 0x23, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x20, 0x4d, 0x41, 0x58,
+ 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x20, 0x31, 0x30, 0x30, 0x30, 0x0a, 0x0a, 0x73, 0x74, 0x61,
+ 0x74, 0x69, 0x63, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x62, 0x75, 0x66, 0x5b, 0x37, 0x30, 0x30,
+ 0x30, 0x30, 0x5d, 0x3b, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x20, 0x69, 0x6e, 0x74, 0x20,
+ 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x3b, 0x0a, 0x0a, 0x73, 0x74, 0x61,
+ 0x74, 0x69, 0x63, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x7b, 0x0a, 0x09, 0x69, 0x6e,
+ 0x74, 0x20, 0x66, 0x64, 0x3b, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c,
+ 0x65, 0x3b, 0x0a, 0x7d, 0x20, 0x66, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x4d, 0x41, 0x58, 0x5f,
+ 0x46, 0x49, 0x4c, 0x45, 0x53, 0x5d, 0x3b, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f,
+ 0x5f, 0x75, 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x28, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e,
+ 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72,
+ 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x75,
+ 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x20, 0x21, 0x3d, 0x20,
+ 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28,
+ 0x25, 0x64, 0x29, 0x20, 0x75, 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x20, 0x25, 0x73, 0x20, 0x66, 0x61,
+ 0x69, 0x6c, 0x65, 0x64, 0x20, 0x28, 0x25, 0x73, 0x29, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09,
+ 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75,
+ 0x6e, 0x74, 0x2c, 0x20, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x65, 0x72,
+ 0x72, 0x6f, 0x72, 0x28, 0x65, 0x72, 0x72, 0x6e, 0x6f, 0x29, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a,
+ 0x7d, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6e, 0x64, 0x5f, 0x66,
+ 0x69, 0x6c, 0x65, 0x28, 0x69, 0x6e, 0x74, 0x20, 0x66, 0x64, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20,
+ 0x73, 0x69, 0x7a, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x73, 0x3b, 0x0a,
+ 0x09, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x20, 0x7b, 0x0a,
+ 0x09, 0x09, 0x73, 0x20, 0x3d, 0x20, 0x4d, 0x49, 0x4e, 0x28, 0x73, 0x69, 0x7a, 0x65, 0x6f, 0x66,
+ 0x28, 0x62, 0x75, 0x66, 0x29, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x09,
+ 0x77, 0x72, 0x69, 0x74, 0x65, 0x28, 0x66, 0x64, 0x2c, 0x20, 0x62, 0x75, 0x66, 0x2c, 0x20, 0x73,
+ 0x29, 0x3b, 0x0a, 0x09, 0x09, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x2d, 0x3d, 0x20, 0x73, 0x3b, 0x0a,
+ 0x09, 0x7d, 0x0a, 0x7d, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x6f, 0x70,
+ 0x65, 0x6e, 0x28, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20,
+ 0x69, 0x6e, 0x74, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20,
+ 0x73, 0x69, 0x7a, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x66, 0x64, 0x2c,
+ 0x20, 0x69, 0x3b, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x20, 0x3d,
+ 0x20, 0x4f, 0x5f, 0x52, 0x44, 0x57, 0x52, 0x7c, 0x4f, 0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x3b,
+ 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x20, 0x73, 0x74,
+ 0x3b, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x63, 0x6f,
+ 0x75, 0x6e, 0x74, 0x3b, 0x0a, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72, 0x28,
+ 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x73, 0x69,
+ 0x7a, 0x65, 0x20, 0x3d, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x20, 0x7c,
+ 0x3d, 0x20, 0x4f, 0x5f, 0x54, 0x52, 0x55, 0x4e, 0x43, 0x3b, 0x0a, 0x0a, 0x09, 0x66, 0x64, 0x20,
+ 0x3d, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x66, 0x6c,
+ 0x61, 0x67, 0x73, 0x2c, 0x20, 0x30, 0x36, 0x30, 0x30, 0x29, 0x3b, 0x0a, 0x09, 0x69, 0x66, 0x20,
+ 0x28, 0x66, 0x64, 0x20, 0x3d, 0x3d, 0x20, 0x2d, 0x31, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70,
+ 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28, 0x25, 0x64, 0x29, 0x20, 0x6f, 0x70, 0x65, 0x6e,
+ 0x20, 0x25, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x68,
+ 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x25, 0x64, 0x20, 0x28, 0x25, 0x73, 0x29, 0x5c, 0x6e, 0x22,
+ 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e, 0x65,
+ 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x68,
+ 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x28,
+ 0x65, 0x72, 0x72, 0x6e, 0x6f, 0x29, 0x29, 0x3b, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72,
+ 0x6e, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x66, 0x73, 0x74, 0x61, 0x74, 0x28, 0x66, 0x64, 0x2c,
+ 0x20, 0x26, 0x73, 0x74, 0x29, 0x3b, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x73, 0x69, 0x7a, 0x65,
+ 0x20, 0x3e, 0x20, 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x20, 0x7b,
+ 0x0a, 0x23, 0x69, 0x66, 0x20, 0x44, 0x45, 0x42, 0x55, 0x47, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69,
+ 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28, 0x25, 0x64, 0x29, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6e, 0x64,
+ 0x69, 0x6e, 0x67, 0x20, 0x25, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x25, 0x64, 0x20, 0x66, 0x72, 0x6f,
+ 0x6d, 0x20, 0x25, 0x64, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20,
+ 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20, 0x66,
+ 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x2c, 0x20, 0x28, 0x69, 0x6e, 0x74,
+ 0x29, 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x23, 0x65,
+ 0x6e, 0x64, 0x69, 0x66, 0x0a, 0x09, 0x09, 0x65, 0x78, 0x70, 0x61, 0x6e, 0x64, 0x5f, 0x66, 0x69,
+ 0x6c, 0x65, 0x28, 0x66, 0x64, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x74,
+ 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x20, 0x65, 0x6c,
+ 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x28, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x3c, 0x20, 0x73, 0x74,
+ 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72,
+ 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x69, 0x6e, 0x67,
+ 0x20, 0x25, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x25, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x25,
+ 0x64, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+ 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x2c, 0x20, 0x28, 0x69, 0x6e,
+ 0x74, 0x29, 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09,
+ 0x09, 0x66, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x28, 0x66, 0x64, 0x2c, 0x20, 0x73,
+ 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x28, 0x69,
+ 0x3d, 0x30, 0x3b, 0x69, 0x3c, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x3b, 0x69,
+ 0x2b, 0x2b, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x69, 0x66, 0x20, 0x28, 0x66, 0x74, 0x61, 0x62,
+ 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x3d, 0x3d, 0x20,
+ 0x30, 0x29, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69, 0x66,
+ 0x20, 0x28, 0x69, 0x20, 0x3d, 0x3d, 0x20, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53,
+ 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x66, 0x69,
+ 0x6c, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x20, 0x66, 0x6f,
+ 0x72, 0x20, 0x25, 0x73, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x3b,
+ 0x0a, 0x09, 0x09, 0x65, 0x78, 0x69, 0x74, 0x28, 0x31, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09,
+ 0x66, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
+ 0x20, 0x3d, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x3b, 0x0a, 0x09, 0x66, 0x74, 0x61, 0x62,
+ 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x66, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x64, 0x3b, 0x0a, 0x09,
+ 0x69, 0x66, 0x20, 0x28, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2b, 0x2b, 0x20, 0x25, 0x20, 0x31, 0x30,
+ 0x30, 0x20, 0x3d, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e,
+ 0x74, 0x66, 0x28, 0x22, 0x2e, 0x22, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d, 0x0a, 0x0a, 0x76,
+ 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x28, 0x69, 0x6e, 0x74,
+ 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x7a,
+ 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29, 0x0a, 0x7b,
+ 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x62,
+ 0x75, 0x66, 0x5b, 0x30, 0x5d, 0x20, 0x3d, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x6d, 0x65, 0x6d, 0x73,
+ 0x65, 0x74, 0x28, 0x62, 0x75, 0x66, 0x2c, 0x20, 0x31, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x6f,
+ 0x66, 0x28, 0x62, 0x75, 0x66, 0x29, 0x29, 0x3b, 0x0a, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x28,
+ 0x69, 0x3d, 0x30, 0x3b, 0x69, 0x3c, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x3b,
+ 0x69, 0x2b, 0x2b, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x69, 0x66, 0x20, 0x28, 0x66, 0x74, 0x61,
+ 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x3d, 0x3d,
+ 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x29, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x3b, 0x0a,
+ 0x09, 0x7d, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x69, 0x20, 0x3d, 0x3d, 0x20, 0x4d, 0x41, 0x58,
+ 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x29, 0x20, 0x7b, 0x0a, 0x23, 0x69, 0x66, 0x20, 0x31, 0x0a,
+ 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28, 0x25, 0x64, 0x29, 0x20, 0x64,
+ 0x6f, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x3a, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20,
+ 0x25, 0x64, 0x20, 0x77, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x20,
+ 0x73, 0x69, 0x7a, 0x65, 0x3d, 0x25, 0x64, 0x20, 0x6f, 0x66, 0x73, 0x3d, 0x25, 0x64, 0x5c, 0x6e,
+ 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e,
+ 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c,
+ 0x20, 0x73, 0x69, 0x7a, 0x65, 0x2c, 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29, 0x3b, 0x0a,
+ 0x23, 0x65, 0x6e, 0x64, 0x69, 0x66, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x3b,
+ 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x6c, 0x73, 0x65, 0x65, 0x6b, 0x28, 0x66, 0x74, 0x61, 0x62, 0x6c,
+ 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x66, 0x64, 0x2c, 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x2c,
+ 0x20, 0x53, 0x45, 0x45, 0x4b, 0x5f, 0x53, 0x45, 0x54, 0x29, 0x3b, 0x0a, 0x09, 0x69, 0x66, 0x20,
+ 0x28, 0x77, 0x72, 0x69, 0x74, 0x65, 0x28, 0x66, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d,
+ 0x2e, 0x66, 0x64, 0x2c, 0x20, 0x62, 0x75, 0x66, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x20,
+ 0x21, 0x3d, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69,
+ 0x6e, 0x74, 0x66, 0x28, 0x22, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65,
+ 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x25, 0x64, 0x5c, 0x6e,
+ 0x22, 0x2c, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d,
+ 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x28, 0x69,
+ 0x6e, 0x74, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x73,
+ 0x69, 0x7a, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29,
+ 0x0a, 0x7b, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x3b, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20,
+ 0x28, 0x69, 0x3d, 0x30, 0x3b, 0x69, 0x3c, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53,
+ 0x3b, 0x69, 0x2b, 0x2b, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x69, 0x66, 0x20, 0x28, 0x66, 0x74,
+ 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x3d,
+ 0x3d, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x29, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x3b,
+ 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x69, 0x20, 0x3d, 0x3d, 0x20, 0x4d, 0x41,
+ 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69,
+ 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28, 0x25, 0x64, 0x29, 0x20, 0x64, 0x6f, 0x5f, 0x72, 0x65, 0x61,
+ 0x64, 0x3a, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x25, 0x64, 0x20, 0x77, 0x61, 0x73,
+ 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x3d, 0x25,
+ 0x64, 0x20, 0x6f, 0x66, 0x73, 0x3d, 0x25, 0x64, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09,
+ 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e,
+ 0x74, 0x2c, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x2c,
+ 0x20, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29, 0x3b, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74, 0x75,
+ 0x72, 0x6e, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x6c, 0x73, 0x65, 0x65, 0x6b, 0x28, 0x66, 0x74,
+ 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x66, 0x64, 0x2c, 0x20, 0x6f, 0x66, 0x66, 0x73,
+ 0x65, 0x74, 0x2c, 0x20, 0x53, 0x45, 0x45, 0x4b, 0x5f, 0x53, 0x45, 0x54, 0x29, 0x3b, 0x0a, 0x09,
+ 0x72, 0x65, 0x61, 0x64, 0x28, 0x66, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x66,
+ 0x64, 0x2c, 0x20, 0x62, 0x75, 0x66, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x7d,
+ 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x28,
+ 0x69, 0x6e, 0x74, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x69,
+ 0x6e, 0x74, 0x20, 0x69, 0x3b, 0x0a, 0x09, 0x66, 0x6f, 0x72, 0x20, 0x28, 0x69, 0x3d, 0x30, 0x3b,
+ 0x69, 0x3c, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x3b, 0x69, 0x2b, 0x2b, 0x29,
+ 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x69, 0x66, 0x20, 0x28, 0x66, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5b,
+ 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x3d, 0x3d, 0x20, 0x68, 0x61, 0x6e,
+ 0x64, 0x6c, 0x65, 0x29, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09,
+ 0x69, 0x66, 0x20, 0x28, 0x69, 0x20, 0x3d, 0x3d, 0x20, 0x4d, 0x41, 0x58, 0x5f, 0x46, 0x49, 0x4c,
+ 0x45, 0x53, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22,
+ 0x28, 0x25, 0x64, 0x29, 0x20, 0x64, 0x6f, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x3a, 0x20, 0x68,
+ 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x25, 0x64, 0x20, 0x77, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x74,
+ 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20,
+ 0x20, 0x20, 0x20, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20,
+ 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72,
+ 0x6e, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x28, 0x66, 0x74, 0x61,
+ 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x66, 0x64, 0x29, 0x3b, 0x0a, 0x09, 0x66, 0x74, 0x61,
+ 0x62, 0x6c, 0x65, 0x5b, 0x69, 0x5d, 0x2e, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x3d, 0x20,
+ 0x30, 0x3b, 0x0a, 0x7d, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x6d, 0x6b,
+ 0x64, 0x69, 0x72, 0x28, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29,
+ 0x0a, 0x7b, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72, 0x28, 0x66, 0x6e, 0x61,
+ 0x6d, 0x65, 0x29, 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x6d, 0x6b, 0x64, 0x69, 0x72,
+ 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x30, 0x37, 0x30, 0x30, 0x29, 0x20, 0x21, 0x3d,
+ 0x20, 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x23, 0x69, 0x66, 0x20, 0x44, 0x45, 0x42, 0x55, 0x47, 0x0a,
+ 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x6d, 0x6b, 0x64, 0x69, 0x72, 0x20,
+ 0x25, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x28, 0x25, 0x73, 0x29, 0x5c, 0x6e,
+ 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6e, 0x61,
+ 0x6d, 0x65, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x28, 0x65, 0x72, 0x72,
+ 0x6e, 0x6f, 0x29, 0x29, 0x3b, 0x0a, 0x23, 0x65, 0x6e, 0x64, 0x69, 0x66, 0x0a, 0x09, 0x7d, 0x0a,
+ 0x7d, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x72, 0x6d, 0x64, 0x69, 0x72,
+ 0x28, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x7b, 0x0a,
+ 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29,
+ 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x72, 0x6d, 0x64, 0x69, 0x72, 0x28, 0x66, 0x6e,
+ 0x61, 0x6d, 0x65, 0x29, 0x20, 0x21, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70,
+ 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x72, 0x6d, 0x64, 0x69, 0x72, 0x20, 0x25, 0x73, 0x20,
+ 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x28, 0x25, 0x73, 0x29, 0x5c, 0x6e, 0x22, 0x2c, 0x20,
+ 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c,
+ 0x20, 0x73, 0x74, 0x72, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x28, 0x65, 0x72, 0x72, 0x6e, 0x6f, 0x29,
+ 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f,
+ 0x5f, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x6f, 0x6c,
+ 0x64, 0x2c, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x6e, 0x65, 0x77, 0x29, 0x0a, 0x7b, 0x0a,
+ 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72, 0x28, 0x6f, 0x6c, 0x64, 0x29, 0x3b, 0x0a,
+ 0x09, 0x73, 0x74, 0x72, 0x75, 0x70, 0x70, 0x65, 0x72, 0x28, 0x6e, 0x65, 0x77, 0x29, 0x3b, 0x0a,
+ 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x6f, 0x6c, 0x64,
+ 0x2c, 0x20, 0x6e, 0x65, 0x77, 0x29, 0x20, 0x21, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x09,
+ 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x20,
+ 0x25, 0x73, 0x20, 0x25, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x28, 0x25, 0x73,
+ 0x29, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+ 0x6f, 0x6c, 0x64, 0x2c, 0x20, 0x6e, 0x65, 0x77, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x65, 0x72, 0x72,
+ 0x6f, 0x72, 0x28, 0x65, 0x72, 0x72, 0x6e, 0x6f, 0x29, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d,
+ 0x0a, 0x0a, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x28,
+ 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74,
+ 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74,
+ 0x20, 0x73, 0x74, 0x61, 0x74, 0x20, 0x73, 0x74, 0x3b, 0x0a, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x75,
+ 0x70, 0x70, 0x65, 0x72, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x3b, 0x0a, 0x0a, 0x09, 0x69,
+ 0x66, 0x20, 0x28, 0x73, 0x74, 0x61, 0x74, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x26,
+ 0x73, 0x74, 0x29, 0x20, 0x21, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72,
+ 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22, 0x28, 0x25, 0x64, 0x29, 0x20, 0x64, 0x6f, 0x5f, 0x73, 0x74,
+ 0x61, 0x74, 0x3a, 0x20, 0x25, 0x73, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x3d, 0x25, 0x64, 0x20, 0x25,
+ 0x73, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+ 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20, 0x66, 0x6e, 0x61, 0x6d,
+ 0x65, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x65, 0x72, 0x72, 0x6f,
+ 0x72, 0x28, 0x65, 0x72, 0x72, 0x6e, 0x6f, 0x29, 0x29, 0x3b, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74,
+ 0x75, 0x72, 0x6e, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28, 0x53, 0x5f, 0x49,
+ 0x53, 0x44, 0x49, 0x52, 0x28, 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x29,
+ 0x29, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x3b, 0x0a, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x28,
+ 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x21, 0x3d, 0x20, 0x73, 0x69,
+ 0x7a, 0x65, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x28, 0x22,
+ 0x28, 0x25, 0x64, 0x29, 0x20, 0x64, 0x6f, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x3a, 0x20, 0x25, 0x73,
+ 0x20, 0x77, 0x72, 0x6f, 0x6e, 0x67, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x25, 0x64, 0x20, 0x25,
+ 0x64, 0x5c, 0x6e, 0x22, 0x2c, 0x20, 0x0a, 0x09, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+ 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x20, 0x66, 0x6e, 0x61, 0x6d,
+ 0x65, 0x2c, 0x20, 0x28, 0x69, 0x6e, 0x74, 0x29, 0x73, 0x74, 0x2e, 0x73, 0x74, 0x5f, 0x73, 0x69,
+ 0x7a, 0x65, 0x2c, 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d, 0x0a,
+ 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x6f, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x28,
+ 0x63, 0x68, 0x61, 0x72, 0x20, 0x2a, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x74,
+ 0x20, 0x73, 0x69, 0x7a, 0x65, 0x29, 0x0a, 0x7b, 0x0a, 0x09, 0x64, 0x6f, 0x5f, 0x6f, 0x70, 0x65,
+ 0x6e, 0x28, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x35, 0x30, 0x30, 0x30, 0x2c, 0x20, 0x73,
+ 0x69, 0x7a, 0x65, 0x29, 0x3b, 0x0a, 0x09, 0x64, 0x6f, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x28,
+ 0x35, 0x30, 0x30, 0x30, 0x29, 0x3b, 0x0a, 0x7d, 0x0a
+};
+#endif
+static unsigned char comprbuf[TESTDATA_LEN];
+static unsigned char decomprbuf[TESTDATA_LEN];
+
+int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen);
+unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
+			     __u32 *datalen, __u32 *cdatalen);
+
+int init_module(void ) {
+	unsigned char comprtype;
+	__u32 c, d;
+	int ret;
+
+	printk("Original data: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	       testdata[0],testdata[1],testdata[2],testdata[3], 
+	       testdata[4],testdata[5],testdata[6],testdata[7], 
+	       testdata[8],testdata[9],testdata[10],testdata[11], 
+	       testdata[12],testdata[13],testdata[14],testdata[15]); 
+	d = TESTDATA_LEN;
+	c = TESTDATA_LEN;
+	comprtype = jffs2_compress(testdata, comprbuf, &d, &c);
+
+	printk("jffs2_compress used compression type %d. Compressed size %d, uncompressed size %d\n",
+	       comprtype, c, d);
+	printk("Compressed data: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	       comprbuf[0],comprbuf[1],comprbuf[2],comprbuf[3], 
+	       comprbuf[4],comprbuf[5],comprbuf[6],comprbuf[7], 
+	       comprbuf[8],comprbuf[9],comprbuf[10],comprbuf[11], 
+	       comprbuf[12],comprbuf[13],comprbuf[14],comprbuf[15]); 
+
+	ret = jffs2_decompress(comprtype, comprbuf, decomprbuf, c, d);
+	printk("jffs2_decompress returned %d\n", ret);
+	printk("Decompressed data:  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	       decomprbuf[0],decomprbuf[1],decomprbuf[2],decomprbuf[3], 
+	       decomprbuf[4],decomprbuf[5],decomprbuf[6],decomprbuf[7], 
+	       decomprbuf[8],decomprbuf[9],decomprbuf[10],decomprbuf[11], 
+	       decomprbuf[12],decomprbuf[13],decomprbuf[14],decomprbuf[15]); 
+	if (memcmp(decomprbuf, testdata, d))
+		printk("Compression and decompression corrupted data\n");
+	else
+		printk("Compression good for %d bytes\n", d);
+	return 1;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/crc32.c linux-2.4.2/fs/jffs2/crc32.c
--- linux-2.4.2.orig/fs/jffs2/crc32.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/crc32.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,97 @@
+/*
+ *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
+ *  code or tables extracted from it, as desired without restriction.
+ *
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ */
+
+/* $Id: crc32.c,v 1.3 2001/02/07 16:45:32 dwmw2 Exp $ */
+
+#include "crc32.h"
+
+const __u32 crc32_table[256] = {
+	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+	0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+	0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+	0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+	0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+	0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+	0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+	0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+	0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+	0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+	0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+	0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+	0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+	0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+	0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+	0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+	0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+	0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+	0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+	0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+	0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+	0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+	0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+	0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+	0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+	0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+	0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+	0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+	0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+	0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+	0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+	0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+	0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+	0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+	0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+	0x2d02ef8dL
+};
diff -Naur linux-2.4.2.orig/fs/jffs2/crc32.h linux-2.4.2/fs/jffs2/crc32.h
--- linux-2.4.2.orig/fs/jffs2/crc32.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/crc32.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,21 @@
+#ifndef CRC32_H
+#define CRC32_H
+
+/* $Id: crc32.h,v 1.3 2001/02/26 14:44:37 dwmw2 Exp $ */
+
+#include <linux/types.h>
+
+extern const __u32 crc32_table[256];
+
+/* Return a 32-bit CRC of the contents of the buffer. */
+
+static inline __u32 
+crc32(__u32 val, const void *ss, int len)
+{
+	const unsigned char *s = ss;
+        while (--len >= 0)
+                val = crc32_table[(val ^ *s++) & 0xff] ^ (val >> 8);
+        return val;
+}
+
+#endif
diff -Naur linux-2.4.2.orig/fs/jffs2/dir.c linux-2.4.2/fs/jffs2/dir.c
--- linux-2.4.2.orig/fs/jffs2/dir.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/dir.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,951 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: dir.c,v 1.42 2001/05/24 22:24:39 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/jffs2.h>
+#include <linux/jffs2_fs_i.h>
+#include <linux/jffs2_fs_sb.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+static int jffs2_readdir (struct file *, void *, filldir_t);
+
+static int jffs2_create (struct inode *,struct dentry *,int);
+static struct dentry *jffs2_lookup (struct inode *,struct dentry *);
+static int jffs2_link (struct dentry *,struct inode *,struct dentry *);
+static int jffs2_unlink (struct inode *,struct dentry *);
+static int jffs2_symlink (struct inode *,struct dentry *,const char *);
+static int jffs2_mkdir (struct inode *,struct dentry *,int);
+static int jffs2_rmdir (struct inode *,struct dentry *);
+static int jffs2_mknod (struct inode *,struct dentry *,int,int);
+static int jffs2_rename (struct inode *, struct dentry *,
+                        struct inode *, struct dentry *);
+
+struct file_operations jffs2_dir_operations =
+{
+	read:		generic_read_dir,
+	readdir:	jffs2_readdir,
+	ioctl:		jffs2_ioctl,
+	fsync:		jffs2_null_fsync
+};
+
+
+struct inode_operations jffs2_dir_inode_operations =
+{
+	create:		jffs2_create,
+	lookup:		jffs2_lookup,
+	link:		jffs2_link,
+	unlink:		jffs2_unlink,
+	symlink:	jffs2_symlink,
+	mkdir:		jffs2_mkdir,
+	rmdir:		jffs2_rmdir,
+	mknod:		jffs2_mknod,
+	rename:		jffs2_rename,
+	setattr:	jffs2_setattr,
+};
+
+/***********************************************************************/
+
+
+/* We keep the dirent list sorted in increasing order of name hash,
+   and we use the same hash function as the dentries. Makes this 
+   nice and simple
+*/
+static struct dentry *jffs2_lookup(struct inode *dir_i, struct dentry *target)
+{
+	struct jffs2_inode_info *dir_f;
+	struct jffs2_sb_info *c;
+	struct jffs2_full_dirent *fd = NULL, *fd_list;
+	__u32 ino = 0;
+	struct inode *inode = NULL;
+
+	D1(printk(KERN_DEBUG "jffs2_lookup()\n"));
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	down(&dir_f->sem);
+
+	/* NB: The 2.2 backport will need to explicitly check for '.' and '..' here */
+	for (fd_list = dir_f->dents; fd_list && fd_list->nhash <= target->d_name.hash; fd_list = fd_list->next) {
+		if (fd_list->nhash == target->d_name.hash && 
+		    (!fd || fd_list->version > fd->version) &&
+		    strlen(fd_list->name) == target->d_name.len &&
+		    !strncmp(fd_list->name, target->d_name.name, target->d_name.len)) {
+			fd = fd_list;
+		}
+	}
+	if (fd)
+		ino = fd->ino;
+	up(&dir_f->sem);
+	if (ino) {
+		inode = iget(dir_i->i_sb, ino);
+		if (!inode) {
+			printk(KERN_WARNING "iget() failed for ino #%u\n", ino);
+			return (ERR_PTR(-EIO));
+		}
+	}
+
+	d_add(target, inode);
+
+	return NULL;
+}
+
+/***********************************************************************/
+
+
+static int jffs2_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct jffs2_inode_info *f;
+	struct jffs2_sb_info *c;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct jffs2_full_dirent *fd;
+	unsigned long offset, curofs;
+
+	D1(printk(KERN_DEBUG "jffs2_readdir() for dir_i #%lu\n", filp->f_dentry->d_inode->i_ino));
+
+	f = JFFS2_INODE_INFO(inode);
+	c = JFFS2_SB_INFO(inode->i_sb);
+
+	offset = filp->f_pos;
+
+	if (offset == 0) {
+		D1(printk(KERN_DEBUG "Dirent 0: \".\", ino #%lu\n", inode->i_ino));
+		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)
+			goto out;
+		offset++;
+	}
+	if (offset == 1) {
+		D1(printk(KERN_DEBUG "Dirent 1: \"..\", ino #%lu\n", filp->f_dentry->d_parent->d_inode->i_ino));
+		if (filldir(dirent, "..", 2, 1, filp->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+			goto out;
+		offset++;
+	}
+
+	curofs=1;
+	down(&f->sem);
+	for (fd = f->dents; fd; fd = fd->next) {
+
+		curofs++;
+		/* First loop: curofs = 2; offset = 2 */
+		if (curofs < offset) {
+			D2(printk(KERN_DEBUG "Skipping dirent: \"%s\", ino #%u, type %d, because curofs %ld < offset %ld\n", 
+				  fd->name, fd->ino, fd->type, curofs, offset));
+			continue;
+		}
+		if (!fd->ino) {
+			D2(printk(KERN_DEBUG "Skipping deletion dirent \"%s\"\n", fd->name));
+			offset++;
+			continue;
+		}
+		D2(printk(KERN_DEBUG "Dirent %ld: \"%s\", ino #%u, type %d\n", offset, fd->name, fd->ino, fd->type));
+		if (filldir(dirent, fd->name, strlen(fd->name), offset, fd->ino, fd->type) < 0)
+			goto out;
+		offset++;
+	}
+ out:
+	up(&f->sem);
+	filp->f_pos = offset;
+	return 0;
+}
+
+/***********************************************************************/
+
+static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode)
+{
+	struct jffs2_inode_info *f, *dir_f;
+	struct jffs2_sb_info *c;
+	struct inode *inode;
+	struct jffs2_raw_inode *ri;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_full_dirent *fd;
+	int namelen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
+	int ret;
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri)
+		return -ENOMEM;
+	
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	D1(printk(KERN_DEBUG "jffs2_create()\n"));
+
+	/* Try to reserve enough space for both node and dirent. 
+	 * Just the node will do for now, though 
+	 */
+	namelen = dentry->d_name.len;
+	ret = jffs2_reserve_space(c, sizeof(*ri), &phys_ofs, &alloclen, ALLOC_NORMAL);
+	D1(printk(KERN_DEBUG "jffs2_create(): reserved 0x%x bytes\n", alloclen));
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		return ret;
+	}
+
+	inode = jffs2_new_inode(dir_i, mode, ri);
+
+	if (IS_ERR(inode)) {
+		D1(printk(KERN_DEBUG "jffs2_new_inode() failed\n"));
+		jffs2_free_raw_inode(ri);
+		jffs2_complete_reservation(c);
+		return PTR_ERR(inode);
+	}
+
+	inode->i_op = &jffs2_file_inode_operations;
+	inode->i_fop = &jffs2_file_operations;
+	inode->i_mapping->a_ops = &jffs2_file_address_operations;
+	inode->i_mapping->nrpages = 0;
+
+	f = JFFS2_INODE_INFO(inode);
+
+	ri->data_crc = 0;
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+
+	fn = jffs2_write_dnode(inode, ri, NULL, 0, phys_ofs, &writtenlen);
+	D1(printk(KERN_DEBUG "jffs2_create created file with mode 0x%x\n", ri->mode));
+	jffs2_free_raw_inode(ri);
+
+	if (IS_ERR(fn)) {
+		D1(printk(KERN_DEBUG "jffs2_write_dnode() failed\n"));
+		/* Eeek. Wave bye bye */
+		up(&f->sem);
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fn);
+	}
+	/* No data here. Only a metadata node, which will be 
+	   obsoleted by the first data write
+	*/
+	f->metadata = fn;
+
+	/* Work out where to put the dirent node now. */
+	writtenlen = PAD(writtenlen);
+	phys_ofs += writtenlen;
+	alloclen -= writtenlen;
+	up(&f->sem);
+
+	if (alloclen < sizeof(*rd)+namelen) {
+		/* Not enough space left in this chunk. Get some more */
+		jffs2_complete_reservation(c);
+		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		
+		if (ret) {
+			/* Eep. */
+			D1(printk(KERN_DEBUG "jffs2_reserve_space() for dirent failed\n"));
+			jffs2_clear_inode(inode);
+			return ret;
+		}
+	}
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd) {
+		/* Argh. Now we treat it like a normal delete */
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return -ENOMEM;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = namelen;
+	rd->type = DT_REG;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+	
+	if (IS_ERR(fd)) {
+		/* dirent failed to write. Delete the inode normally 
+		   as if it were the final unlink() */
+		up(&dir_f->sem);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fd);
+	}
+
+	/* Link the fd into the inode's list, obsoleting an old
+	   one if necessary. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	d_instantiate(dentry, inode);
+
+	D1(printk(KERN_DEBUG "jffs2_create: Created ino #%lu with mode %o, nlink %d(%d). nrpages %ld\n",
+		  inode->i_ino, inode->i_mode, inode->i_nlink, f->inocache->nlink, inode->i_mapping->nrpages));
+	return 0;
+}
+
+/***********************************************************************/
+
+static int jffs2_do_unlink(struct inode *dir_i, struct dentry *dentry, int rename)
+{
+	struct jffs2_inode_info *dir_f, *f;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dirent *fd;
+	__u32 alloclen, phys_ofs;
+	int ret;
+
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd)
+		return -ENOMEM;
+
+	ret = jffs2_reserve_space(c, sizeof(*rd)+dentry->d_name.len, &phys_ofs, &alloclen, ALLOC_DELETION);
+	if (ret) {
+		jffs2_free_raw_dirent(rd);
+		return ret;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	/* Build a deletion node */
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + dentry->d_name.len;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = 0;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = dentry->d_name.len;
+	rd->type = DT_UNKNOWN;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, dentry->d_name.len);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, dentry->d_name.len, phys_ofs, NULL);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+
+	if (IS_ERR(fd)) {
+		up(&dir_f->sem);
+		return PTR_ERR(fd);
+	}
+
+	/* File it. This will mark the old one obsolete. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+	
+	if (!rename) {
+		f = JFFS2_INODE_INFO(dentry->d_inode);
+		down(&f->sem);
+
+		while (f->dents) {
+			/* There can be only deleted ones */
+			fd = f->dents;
+			
+			f->dents = fd->next;
+			
+			if (fd->ino) {
+				printk(KERN_WARNING "Deleting inode #%u with active dentry \"%s\"->ino #%u\n",
+				       f->inocache->ino, fd->name, fd->ino);
+			} else {
+				D1(printk(KERN_DEBUG "Removing deletion dirent for \"%s\" from dir ino #%u\n", fd->name, f->inocache->ino));
+			}
+			jffs2_mark_node_obsolete(c, fd->raw);
+			jffs2_free_full_dirent(fd);
+		}
+
+		f->inocache->nlink--;
+		dentry->d_inode->i_nlink--;
+		up(&f->sem);
+	}
+
+	return 0;
+}
+
+static int jffs2_unlink(struct inode *dir_i, struct dentry *dentry)
+{
+	return jffs2_do_unlink(dir_i, dentry, 0);
+}
+/***********************************************************************/
+
+static int jffs2_do_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry, int rename)
+{
+	struct jffs2_inode_info *dir_f, *f;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dirent *fd;
+	__u32 alloclen, phys_ofs;
+	int ret;
+
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd)
+		return -ENOMEM;
+
+	ret = jffs2_reserve_space(c, sizeof(*rd)+dentry->d_name.len, &phys_ofs, &alloclen, ALLOC_NORMAL);
+	if (ret) {
+		jffs2_free_raw_dirent(rd);
+		return ret;
+	}
+	
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	/* Build a deletion node */
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + dentry->d_name.len;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = old_dentry->d_inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = dentry->d_name.len;
+
+	/* XXX: This is ugly. */
+	rd->type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
+	if (!rd->type) rd->type = DT_REG;
+
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, dentry->d_name.len);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, dentry->d_name.len, phys_ofs, NULL);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+
+	if (IS_ERR(fd)) {
+		up(&dir_f->sem);
+		return PTR_ERR(fd);
+	}
+
+	/* File it. This will mark the old one obsolete. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	if (!rename) {
+		f = JFFS2_INODE_INFO(old_dentry->d_inode);
+		down(&f->sem);
+		old_dentry->d_inode->i_nlink = ++f->inocache->nlink;
+		up(&f->sem);
+	}
+	return 0;
+}
+
+static int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)
+{
+	int ret = jffs2_do_link(old_dentry, dir_i, dentry, 0);
+	if (!ret) {
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+	}
+	return ret;
+}
+
+/***********************************************************************/
+
+static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char *target)
+{
+	struct jffs2_inode_info *f, *dir_f;
+	struct jffs2_sb_info *c;
+	struct inode *inode;
+	struct jffs2_raw_inode *ri;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_full_dirent *fd;
+	int namelen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
+	int ret;
+
+	/* FIXME: If you care. We'd need to use frags for the target
+	   if it grows much more than this */
+	if (strlen(target) > 254)
+		return -EINVAL;
+
+	ri = jffs2_alloc_raw_inode();
+
+	if (!ri)
+		return -ENOMEM;
+	
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+	
+	/* Try to reserve enough space for both node and dirent. 
+	 * Just the node will do for now, though 
+	 */
+	namelen = dentry->d_name.len;
+	ret = jffs2_reserve_space(c, sizeof(*ri) + strlen(target), &phys_ofs, &alloclen, ALLOC_NORMAL);
+
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		return ret;
+	}
+
+	inode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri);
+
+	if (IS_ERR(inode)) {
+		jffs2_free_raw_inode(ri);
+		jffs2_complete_reservation(c);
+		return PTR_ERR(inode);
+	}
+
+	inode->i_op = &jffs2_symlink_inode_operations;
+
+	f = JFFS2_INODE_INFO(inode);
+
+	ri->dsize = ri->csize = strlen(target);
+	ri->totlen = sizeof(*ri) + ri->dsize;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri->compr = JFFS2_COMPR_NONE;
+	ri->data_crc = crc32(0, target, strlen(target));
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+	
+	fn = jffs2_write_dnode(inode, ri, target, strlen(target), phys_ofs, &writtenlen);
+
+	jffs2_free_raw_inode(ri);
+
+	if (IS_ERR(fn)) {
+		/* Eeek. Wave bye bye */
+		up(&f->sem);
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fn);
+	}
+	/* No data here. Only a metadata node, which will be 
+	   obsoleted by the first data write
+	*/
+	f->metadata = fn;
+	up(&f->sem);
+
+	/* Work out where to put the dirent node now. */
+	writtenlen = (writtenlen+3)&~3;
+	phys_ofs += writtenlen;
+	alloclen -= writtenlen;
+
+	if (alloclen < sizeof(*rd)+namelen) {
+		/* Not enough space left in this chunk. Get some more */
+		jffs2_complete_reservation(c);
+		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		if (ret) {
+			/* Eep. */
+			jffs2_clear_inode(inode);
+			return ret;
+		}
+	}
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd) {
+		/* Argh. Now we treat it like a normal delete */
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return -ENOMEM;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = namelen;
+	rd->type = DT_LNK;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+	
+	if (IS_ERR(fd)) {
+		/* dirent failed to write. Delete the inode normally 
+		   as if it were the final unlink() */
+		up(&dir_f->sem);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fd);
+	}
+
+	/* Link the fd into the inode's list, obsoleting an old
+	   one if necessary. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	d_instantiate(dentry, inode);
+	return 0;
+}
+
+
+static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)
+{
+	struct jffs2_inode_info *f, *dir_f;
+	struct jffs2_sb_info *c;
+	struct inode *inode;
+	struct jffs2_raw_inode *ri;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_full_dirent *fd;
+	int namelen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
+	int ret;
+
+	mode |= S_IFDIR;
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri)
+		return -ENOMEM;
+	
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	/* Try to reserve enough space for both node and dirent. 
+	 * Just the node will do for now, though 
+	 */
+	namelen = dentry->d_name.len;
+	ret = jffs2_reserve_space(c, sizeof(*ri), &phys_ofs, &alloclen, ALLOC_NORMAL);
+
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		return ret;
+	}
+
+	inode = jffs2_new_inode(dir_i, mode, ri);
+
+	if (IS_ERR(inode)) {
+		jffs2_free_raw_inode(ri);
+		jffs2_complete_reservation(c);
+		return PTR_ERR(inode);
+	}
+
+	inode->i_op = &jffs2_dir_inode_operations;
+	inode->i_fop = &jffs2_dir_operations;
+
+	f = JFFS2_INODE_INFO(inode);
+
+	ri->data_crc = 0;
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+	
+	fn = jffs2_write_dnode(inode, ri, NULL, 0, phys_ofs, &writtenlen);
+
+	jffs2_free_raw_inode(ri);
+
+	if (IS_ERR(fn)) {
+		/* Eeek. Wave bye bye */
+		up(&f->sem);
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fn);
+	}
+	/* No data here. Only a metadata node, which will be 
+	   obsoleted by the first data write
+	*/
+	f->metadata = fn;
+	up(&f->sem);
+
+	/* Work out where to put the dirent node now. */
+	writtenlen = PAD(writtenlen);
+	phys_ofs += writtenlen;
+	alloclen -= writtenlen;
+
+	if (alloclen < sizeof(*rd)+namelen) {
+		/* Not enough space left in this chunk. Get some more */
+		jffs2_complete_reservation(c);
+		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		if (ret) {
+			/* Eep. */
+			jffs2_clear_inode(inode);
+			return ret;
+		}
+	}
+	
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd) {
+		/* Argh. Now we treat it like a normal delete */
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return -ENOMEM;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = namelen;
+	rd->type = DT_DIR;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+	
+	if (IS_ERR(fd)) {
+		/* dirent failed to write. Delete the inode normally 
+		   as if it were the final unlink() */
+		up(&dir_f->sem);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fd);
+	}
+
+	/* Link the fd into the inode's list, obsoleting an old
+	   one if necessary. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	d_instantiate(dentry, inode);
+	return 0;
+}
+
+static int jffs2_rmdir (struct inode *dir_i, struct dentry *dentry)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_full_dirent *fd;
+
+	for (fd = f->dents ; fd; fd = fd->next) {
+		if (fd->ino)
+			return -ENOTEMPTY;
+	}
+	return jffs2_unlink(dir_i, dentry);
+}
+
+static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, int rdev)
+{
+	struct jffs2_inode_info *f, *dir_f;
+	struct jffs2_sb_info *c;
+	struct inode *inode;
+	struct jffs2_raw_inode *ri;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_full_dirent *fd;
+	int namelen;
+	unsigned short dev;
+	int devlen = 0;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
+	int ret;
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri)
+		return -ENOMEM;
+	
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+	
+	if ((mode & S_IFMT) == S_IFBLK ||
+	    (mode & S_IFMT) == S_IFCHR) {
+		dev = (MAJOR(to_kdev_t(rdev)) << 8) | MINOR(to_kdev_t(rdev));
+		devlen = sizeof(dev);
+	}
+	
+	/* Try to reserve enough space for both node and dirent. 
+	 * Just the node will do for now, though 
+	 */
+	namelen = dentry->d_name.len;
+	ret = jffs2_reserve_space(c, sizeof(*ri) + devlen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		return ret;
+	}
+
+	inode = jffs2_new_inode(dir_i, mode, ri);
+
+	if (IS_ERR(inode)) {
+		jffs2_free_raw_inode(ri);
+		jffs2_complete_reservation(c);
+		return PTR_ERR(inode);
+	}
+	inode->i_op = &jffs2_file_inode_operations;
+	init_special_inode(inode, inode->i_mode, rdev);
+
+	f = JFFS2_INODE_INFO(inode);
+
+	ri->dsize = ri->csize = devlen;
+	ri->totlen = sizeof(*ri) + ri->csize;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri->compr = JFFS2_COMPR_NONE;
+	ri->data_crc = crc32(0, &dev, devlen);
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+	
+	fn = jffs2_write_dnode(inode, ri, (char *)&dev, devlen, phys_ofs, &writtenlen);
+
+	jffs2_free_raw_inode(ri);
+
+	if (IS_ERR(fn)) {
+		/* Eeek. Wave bye bye */
+		up(&f->sem);
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fn);
+	}
+	/* No data here. Only a metadata node, which will be 
+	   obsoleted by the first data write
+	*/
+	f->metadata = fn;
+	up(&f->sem);
+
+	/* Work out where to put the dirent node now. */
+	writtenlen = (writtenlen+3)&~3;
+	phys_ofs += writtenlen;
+	alloclen -= writtenlen;
+
+	if (alloclen < sizeof(*rd)+namelen) {
+		/* Not enough space left in this chunk. Get some more */
+		jffs2_complete_reservation(c);
+		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		if (ret) {
+			/* Eep. */
+			jffs2_clear_inode(inode);
+			return ret;
+		}
+	}
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd) {
+		/* Argh. Now we treat it like a normal delete */
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return -ENOMEM;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = dir_f->highest_version++;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = namelen;
+
+	/* XXX: This is ugly. */
+	rd->type = (mode & S_IFMT) >> 12;
+
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+	
+	if (IS_ERR(fd)) {
+		/* dirent failed to write. Delete the inode normally 
+		   as if it were the final unlink() */
+		up(&dir_f->sem);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fd);
+	}
+
+	/* Link the fd into the inode's list, obsoleting an old
+	   one if necessary. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	d_instantiate(dentry, inode);
+	return 0;
+}
+
+static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
+                        struct inode *new_dir_i, struct dentry *new_dentry)
+{
+	int ret;
+	/* XXX: We probably ought to alloc enough space for
+	   both nodes at the same time. Writing the new link, 
+	   then getting -ENOSPC, is quite bad :)
+	*/
+
+	/* Make a hard link */
+	ret = jffs2_do_link(old_dentry, new_dir_i, new_dentry, 1);
+	if (ret)
+		return ret;
+
+	/* Unlink the original */
+	ret = jffs2_do_unlink(old_dir_i, old_dentry, 1);
+	
+	if (ret) {
+		/* Try to delete the _new_ link to return a clean failure */
+		int ret2 = jffs2_do_unlink(new_dir_i, new_dentry, 1);
+		if (ret2) {
+			struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
+			down(&f->sem);
+			old_dentry->d_inode->i_nlink = f->inocache->nlink++;
+			up(&f->sem);
+		       
+			printk(KERN_NOTICE "jffs2_rename(): Link succeeded, unlink failed (old err %d, new err %d). You now have a hard link\n", ret, ret2);
+			/* Might as well let the VFS know */
+			d_instantiate(new_dentry, old_dentry->d_inode);
+			atomic_inc(&old_dentry->d_inode->i_count);
+		}
+		
+	}
+	return ret;
+}
+
diff -Naur linux-2.4.2.orig/fs/jffs2/erase.c linux-2.4.2/fs/jffs2/erase.c
--- linux-2.4.2.orig/fs/jffs2/erase.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/erase.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,345 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: erase.c,v 1.19 2001/03/25 22:36:12 dwmw2 Exp $
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+struct erase_priv_struct {
+	struct jffs2_eraseblock *jeb;
+	struct jffs2_sb_info *c;
+};
+      
+static void jffs2_erase_callback(struct erase_info *);
+static void jffs2_free_all_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
+
+void jffs2_erase_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+{
+	struct erase_info *instr;
+	int ret;
+
+	instr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);
+	if (!instr) {
+		printk(KERN_WARNING "kmalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\n");
+		spin_lock_bh(&c->erase_completion_lock);
+		list_del(&jeb->list);
+		list_add(&jeb->list, &c->erase_pending_list);
+		c->erasing_size -= c->sector_size;
+		spin_unlock_bh(&c->erase_completion_lock);
+		return;
+	}
+
+	memset(instr, 0, sizeof(*instr));
+
+	instr->mtd = c->mtd;
+	instr->addr = jeb->offset;
+	instr->len = c->sector_size;
+	instr->callback = jffs2_erase_callback;
+	instr->priv = (unsigned long)(&instr[1]);
+	
+	((struct erase_priv_struct *)instr->priv)->jeb = jeb;
+	((struct erase_priv_struct *)instr->priv)->c = c;
+
+	ret = c->mtd->erase(c->mtd, instr);
+	if (!ret) {
+		return;
+	}
+	if (ret == -ENOMEM || ret == -EAGAIN) {
+		/* Erase failed immediately. Refile it on the list */
+		D1(printk(KERN_DEBUG "Erase at 0x%08x failed: %d. Refiling on erase_pending_list\n", jeb->offset, ret));
+		spin_lock_bh(&c->erase_completion_lock);
+		list_del(&jeb->list);
+		list_add(&jeb->list, &c->erase_pending_list);
+		c->erasing_size -= c->sector_size;
+		spin_unlock_bh(&c->erase_completion_lock);
+		kfree(instr);
+		return;
+	}
+
+	printk(KERN_WARNING "Erase at 0x%08x failed immediately: %d\n", jeb->offset, ret);
+	spin_lock_bh(&c->erase_completion_lock);
+	list_del(&jeb->list);
+	list_add(&jeb->list, &c->bad_list);
+	c->nr_erasing_blocks--;
+	c->bad_size += c->sector_size;
+	c->erasing_size -= c->sector_size;
+	spin_unlock_bh(&c->erase_completion_lock);
+	wake_up(&c->erase_wait);
+	kfree(instr);
+}
+
+void jffs2_erase_pending_blocks(struct jffs2_sb_info *c)
+{
+	struct jffs2_eraseblock *jeb;
+
+	spin_lock_bh(&c->erase_completion_lock);
+	while (!list_empty(&c->erase_pending_list)) {
+
+		jeb = list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list);
+
+		D1(printk(KERN_DEBUG "Starting erase of pending block 0x%08x\n", jeb->offset));
+
+		list_del(&jeb->list);
+		c->erasing_size += c->sector_size;
+		c->free_size -= jeb->free_size;
+		c->used_size -= jeb->used_size;
+		c->dirty_size -= jeb->dirty_size;
+		jeb->used_size = jeb->dirty_size = jeb->free_size = 0;
+		jffs2_free_all_node_refs(c, jeb);
+		list_add(&jeb->list, &c->erasing_list);
+		spin_unlock_bh(&c->erase_completion_lock);
+		
+		jffs2_erase_block(c, jeb);
+		/* Be nice */
+		if (current->need_resched)
+			schedule();
+		spin_lock_bh(&c->erase_completion_lock);
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	D1(printk(KERN_DEBUG "jffs2_erase_pending_blocks completed\n"));
+}
+
+
+static void jffs2_erase_callback(struct erase_info *instr)
+{
+	struct erase_priv_struct *priv = (void *)instr->priv;
+
+	if(instr->state != MTD_ERASE_DONE) {
+		printk(KERN_WARNING "Erase at 0x%08x finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\n", instr->addr, instr->state);
+		spin_lock(&priv->c->erase_completion_lock);
+		priv->c->erasing_size -= priv->c->sector_size;
+		priv->c->bad_size += priv->c->sector_size;
+		list_del(&priv->jeb->list);
+		list_add(&priv->jeb->list, &priv->c->bad_list);
+		priv->c->nr_erasing_blocks--;
+		spin_unlock(&priv->c->erase_completion_lock);
+		wake_up(&priv->c->erase_wait);
+	} else {
+		D1(printk(KERN_DEBUG "Erase completed successfully at 0x%08x\n", instr->addr));
+		spin_lock(&priv->c->erase_completion_lock);
+		list_del(&priv->jeb->list);
+		list_add_tail(&priv->jeb->list, &priv->c->erase_complete_list);
+		spin_unlock(&priv->c->erase_completion_lock);
+	}	
+	/* Make sure someone picks up the block off the erase_complete list */
+	OFNI_BS_2SFFJ(priv->c)->s_dirt = 1;
+	kfree(instr);
+}
+
+/* Hmmm. Maybe we should accept the extra space it takes and make
+   this a standard doubly-linked list? */
+static inline void jffs2_remove_node_ref_from_ino_list(struct jffs2_sb_info *sbinfo, struct jffs2_raw_node_ref *ref)
+{
+	struct jffs2_inode_cache *ic;
+	struct jffs2_raw_node_ref **prev, *this;
+	D2(int c=0);
+
+	this = ref;
+	while(this->next_in_ino)
+		 this = this->next_in_ino;
+
+	ic = (struct jffs2_inode_cache *)this;
+
+	D1(printk(KERN_DEBUG "Removing node at phys 0x%08x from ino #%u\n", ref->flash_offset &~3, ic->ino));
+
+	prev = &ic->nodes;
+	if (!*prev) {
+		printk(KERN_WARNING "Eep. ic->nodes == NULL.\n");
+		return;
+	}
+	while (*prev != ref) {
+		if (!(*prev)->next_in_ino) {
+		        printk(KERN_WARNING "Eep. node at phys 0x%08x, mem %p. next_in_ino is NULL.\n", (*prev)->flash_offset &~3, 
+			       *prev);
+			return;
+		}
+		prev = &(*prev)->next_in_ino;
+	}
+	*prev = ref->next_in_ino;
+	this = ic->nodes;
+	D2(printk(KERN_DEBUG "After remove_node_ref_from_ino_list: \n" KERN_DEBUG);
+	while(this) {
+		printk( "0x%08x(%d)->", this->flash_offset & ~3, this->flash_offset &3);
+		if (++c == 5) {
+			printk("\n" KERN_DEBUG);
+			c=0;
+		}
+		this = this->next_in_ino;
+	}
+	printk("\n"););
+	if (ic->nodes == (void *)ic) {
+		D1(printk(KERN_DEBUG "inocache for ino #%u is all gone now. Freeing\n", ic->ino));
+		jffs2_del_ino_cache(sbinfo, ic);
+		jffs2_free_inode_cache(ic);
+	}
+}
+
+static void jffs2_free_all_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+{
+	struct jffs2_raw_node_ref *ref;
+	D1(printk(KERN_DEBUG "Freeing all node refs for eraseblock offset 0x%08x\n", jeb->offset));
+	while(jeb->first_node) {
+		ref = jeb->first_node;
+		jeb->first_node = ref->next_phys;
+		
+		/* Remove from the inode-list */
+		if (ref->next_in_ino)
+			jffs2_remove_node_ref_from_ino_list(c, ref);
+		/* else it was a non-inode node so don't bother */
+
+		jffs2_free_raw_node_ref(ref);
+	}
+	jeb->last_node = NULL;
+}
+
+void jffs2_erase_pending_trigger(struct jffs2_sb_info *c)
+{
+	OFNI_BS_2SFFJ(c)->s_dirt = 1;
+}
+
+void jffs2_mark_erased_blocks(struct jffs2_sb_info *c)
+{
+	static struct jffs2_unknown_node marker = {JFFS2_MAGIC_BITMASK, JFFS2_NODETYPE_CLEANMARKER, sizeof(struct jffs2_unknown_node)};
+	struct jffs2_eraseblock *jeb;
+	struct jffs2_raw_node_ref *marker_ref;
+	unsigned char *ebuf;
+	ssize_t retlen;
+	int ret;
+
+	marker.hdr_crc = crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4);
+
+	spin_lock_bh(&c->erase_completion_lock);
+	while (!list_empty(&c->erase_complete_list)) {
+		jeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);
+		list_del(&jeb->list);
+		spin_unlock_bh(&c->erase_completion_lock);
+
+		marker_ref = jffs2_alloc_raw_node_ref();
+		if (!marker_ref) {
+			printk(KERN_WARNING "Failed to allocate raw node ref for clean marker\n");
+			/* Come back later */
+			jffs2_erase_pending_trigger(c);
+			return;
+		}
+
+		ebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!ebuf) {
+			printk(KERN_WARNING "Failed to allocate page buffer for verifying erase at 0x%08x. Assuming it worked\n", jeb->offset);
+		} else {
+			__u32 ofs = jeb->offset;
+
+			D1(printk(KERN_DEBUG "Verifying erase at 0x%08x\n", jeb->offset));
+			while(ofs < jeb->offset + c->sector_size) {
+				__u32 readlen = min(PAGE_SIZE, jeb->offset + c->sector_size - ofs);
+				int i;
+
+				ret = c->mtd->read(c->mtd, ofs, readlen, &retlen, ebuf);
+				if (ret < 0) {
+					printk(KERN_WARNING "Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\n", ofs, ret);
+					goto bad;
+				}
+				if (retlen != readlen) {
+					printk(KERN_WARNING "Short read from newly-erased block at 0x%08x. Wanted %d, got %d\n", ofs, readlen, retlen);
+					goto bad;
+				}
+				for (i=0; i<readlen; i += sizeof(unsigned long)) {
+					/* It's OK. We know it's properly aligned */
+					unsigned long datum = *(unsigned long *)(&ebuf[i]);
+					if (datum + 1) {
+						printk(KERN_WARNING "Newly-erased block contained word 0x%lx at offset 0x%08x\n", datum, ofs + i);
+					bad: 
+						jffs2_free_raw_node_ref(marker_ref);
+						kfree(ebuf);
+					bad2:
+						spin_lock_bh(&c->erase_completion_lock);
+						c->erasing_size -= c->sector_size;
+						c->bad_size += c->sector_size;
+
+						list_add_tail(&jeb->list, &c->bad_list);
+						c->nr_erasing_blocks--;
+						spin_unlock_bh(&c->erase_completion_lock);
+						wake_up(&c->erase_wait);
+						return;
+					}
+				}
+				ofs += readlen;
+			}
+			kfree(ebuf);
+		}
+					
+		/* Write the erase complete marker */	
+		D1(printk(KERN_DEBUG "Writing erased marker to block at 0x%08x\n", jeb->offset));
+		ret = c->mtd->write(c->mtd, jeb->offset, sizeof(marker), &retlen, (char *)&marker);
+		if (ret) {
+			printk(KERN_WARNING "Write clean marker to block at 0x%08x failed: %d\n",
+			       jeb->offset, ret);
+			goto bad2;
+		}
+		if (retlen != sizeof(marker)) {
+			printk(KERN_WARNING "Short write to newly-erased block at 0x%08x: Wanted %d, got %d\n",
+			       jeb->offset, sizeof(marker), retlen);
+			goto bad2;
+		}
+
+		marker_ref->next_in_ino = NULL;
+		marker_ref->next_phys = NULL;
+		marker_ref->flash_offset = jeb->offset;
+		marker_ref->totlen = PAD(sizeof(marker));
+
+		jeb->first_node = jeb->last_node = marker_ref;
+
+		jeb->free_size = c->sector_size - marker_ref->totlen;
+		jeb->used_size = marker_ref->totlen;
+		jeb->dirty_size = 0;
+
+		spin_lock_bh(&c->erase_completion_lock);
+		c->erasing_size -= c->sector_size;
+		c->free_size += jeb->free_size;
+		c->used_size += jeb->used_size;
+
+		ACCT_SANITY_CHECK(c,jeb);
+		ACCT_PARANOIA_CHECK(jeb);
+
+		list_add_tail(&jeb->list, &c->free_list);
+		c->nr_erasing_blocks--;
+		c->nr_free_blocks++;
+		wake_up(&c->erase_wait);
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/file.c linux-2.4.2/fs/jffs2/file.c
--- linux-2.4.2.orig/fs/jffs2/file.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/file.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,540 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: file.c,v 1.55 2001/05/29 09:19:24 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+extern int generic_file_open(struct inode *, struct file *) __attribute__((weak));
+
+
+int jffs2_null_fsync(struct file *filp, struct dentry *dentry, int datasync)
+{
+	/* Move along. Nothing to see here */
+	return 0;
+}
+
+struct file_operations jffs2_file_operations =
+{
+	open:		generic_file_open,
+	read:		generic_file_read,
+	write:		generic_file_write,
+	ioctl:		jffs2_ioctl,
+	mmap:		generic_file_mmap,
+	fsync:		jffs2_null_fsync
+};
+
+/* jffs2_file_inode_operations */
+
+struct inode_operations jffs2_file_inode_operations =
+{
+	setattr:	jffs2_setattr
+};
+
+struct address_space_operations jffs2_file_address_operations =
+{
+	readpage:	jffs2_readpage,
+	prepare_write:	jffs2_prepare_write,
+	commit_write:	jffs2_commit_write
+};
+
+int jffs2_setattr (struct dentry *dentry, struct iattr *iattr)
+{
+	struct jffs2_full_dnode *old_metadata, *new_metadata;
+	struct inode *inode = dentry->d_inode;
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_raw_inode *ri;
+	unsigned short dev;
+	unsigned char *mdata = NULL;
+	int mdatalen = 0;
+	unsigned int ivalid;
+	__u32 phys_ofs, alloclen;
+	int ret;
+	D1(printk(KERN_DEBUG "jffs2_setattr(): ino #%lu\n", inode->i_ino));
+	ret = inode_change_ok(inode, iattr);
+	if (ret) 
+		return ret;
+
+	/* Special cases - we don't want more than one data node
+	   for these types on the medium at any time. So setattr
+	   must read the original data associated with the node
+	   (i.e. the device numbers or the target name) and write
+	   it out again with the appropriate data attached */
+	if ((inode->i_mode & S_IFMT) == S_IFBLK ||
+	    (inode->i_mode & S_IFMT) == S_IFCHR) {
+		/* For these, we don't actually need to read the old node */
+		dev =  (MAJOR(to_kdev_t(dentry->d_inode->i_rdev)) << 8) | 
+			MINOR(to_kdev_t(dentry->d_inode->i_rdev));
+		mdata = (char *)&dev;
+		mdatalen = sizeof(dev);
+		D1(printk(KERN_DEBUG "jffs2_setattr(): Writing %d bytes of kdev_t\n", mdatalen));
+	} else if ((inode->i_mode & S_IFMT) == S_IFLNK) {
+		mdatalen = f->metadata->size;
+		mdata = kmalloc(f->metadata->size, GFP_USER);
+		if (!mdata)
+			return -ENOMEM;
+		ret = jffs2_read_dnode(c, f->metadata, mdata, 0, mdatalen);
+		if (ret) {
+			kfree(mdata);
+			return ret;
+		}
+		D1(printk(KERN_DEBUG "jffs2_setattr(): Writing %d bytes of symlink target\n", mdatalen));
+	}
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri) {
+		if ((inode->i_mode & S_IFMT) == S_IFLNK)
+			kfree(mdata);
+		return -ENOMEM;
+	}
+		
+	ret = jffs2_reserve_space(c, sizeof(*ri) + mdatalen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		if ((inode->i_mode & S_IFMT) == S_IFLNK)
+			 kfree(mdata);
+		return ret;
+	}
+	down(&f->sem);
+        ivalid = iattr->ia_valid;
+	
+	ri->magic = JFFS2_MAGIC_BITMASK;
+	ri->nodetype = JFFS2_NODETYPE_INODE;
+	ri->totlen = sizeof(*ri) + mdatalen;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri->ino = inode->i_ino;
+	ri->version = ++f->highest_version;
+
+	ri->mode = (ivalid & ATTR_MODE)?iattr->ia_mode:inode->i_mode;
+	ri->uid = (ivalid & ATTR_UID)?iattr->ia_uid:inode->i_uid;
+	ri->gid = (ivalid & ATTR_GID)?iattr->ia_gid:inode->i_gid;
+
+	if (ivalid & ATTR_MODE && ri->mode & S_ISGID &&
+	    !in_group_p(ri->gid) && !capable(CAP_FSETID))
+		ri->mode &= ~S_ISGID;
+
+	ri->isize = (ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size;
+	ri->atime = (ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime;
+	ri->mtime = (ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime;
+	ri->ctime = (ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime;
+
+	ri->offset = 0;
+	ri->csize = ri->dsize = mdatalen;
+	ri->compr = JFFS2_COMPR_NONE;
+	if (inode->i_size < ri->isize) {
+		/* It's an extension. Make it a hole node */
+		ri->compr = JFFS2_COMPR_ZERO;
+		ri->dsize = ri->isize - inode->i_size;
+		ri->offset = inode->i_size;
+	}
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+	if (mdatalen)
+		ri->data_crc = crc32(0, mdata, mdatalen);
+	else
+		ri->data_crc = 0;
+
+	new_metadata = jffs2_write_dnode(inode, ri, mdata, mdatalen, phys_ofs, NULL);
+	if ((inode->i_mode & S_IFMT) == S_IFLNK)
+		kfree(mdata);
+
+	jffs2_complete_reservation(c);
+	
+	if (IS_ERR(new_metadata)) {
+		jffs2_free_raw_inode(ri);
+		up(&f->sem);
+		return PTR_ERR(new_metadata);
+	}
+	/* It worked. Update the inode */
+	inode->i_atime = ri->atime;
+	inode->i_ctime = ri->ctime;
+	inode->i_mtime = ri->mtime;
+	inode->i_mode = ri->mode;
+	inode->i_uid = ri->uid;
+	inode->i_gid = ri->gid;
+
+
+	old_metadata = f->metadata;
+
+	if (inode->i_size > ri->isize) {
+		vmtruncate(inode, ri->isize);
+		jffs2_truncate_fraglist (c, &f->fraglist, ri->isize);
+	}
+
+	if (inode->i_size < ri->isize) {
+		jffs2_add_full_dnode_to_inode(c, f, new_metadata);
+		inode->i_size = ri->isize;
+		f->metadata = NULL;
+	} else {
+		f->metadata = new_metadata;
+	}
+	if (old_metadata) {
+		jffs2_mark_node_obsolete(c, old_metadata->raw);
+		jffs2_free_full_dnode(old_metadata);
+	}
+	jffs2_free_raw_inode(ri);
+	up(&f->sem);
+	return 0;
+}
+
+int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_node_frag *frag = f->fraglist;
+	__u32 offset = pg->index << PAGE_CACHE_SHIFT;
+	__u32 end = offset + PAGE_CACHE_SIZE;
+	unsigned char *pg_buf;
+	int ret;
+
+	D1(printk(KERN_DEBUG "jffs2_do_readpage_nolock(): ino #%lu, page at offset 0x%x\n", inode->i_ino, offset));
+
+	if (!PageLocked(pg))
+                PAGE_BUG(pg);
+
+	while(frag && frag->ofs + frag->size  <= offset) {
+		//		D1(printk(KERN_DEBUG "skipping frag %d-%d; before the region we care about\n", frag->ofs, frag->ofs + frag->size));
+		frag = frag->next;
+	}
+
+	pg_buf = kmap(pg);
+
+	/* XXX FIXME: Where a single physical node actually shows up in two
+	   frags, we read it twice. Don't do that. */
+	/* Now we're pointing at the first frag which overlaps our page */
+	while(offset < end) {
+		D2(printk(KERN_DEBUG "jffs2_readpage: offset %d, end %d\n", offset, end));
+		if (!frag || frag->ofs > offset) {
+			__u32 holesize = end - offset;
+			if (frag) {
+				D1(printk(KERN_NOTICE "Eep. Hole in ino %ld fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n", inode->i_ino, frag->ofs, offset));
+				holesize = min(holesize, frag->ofs - offset);
+				D1(jffs2_print_frag_list(f));
+			}
+			D1(printk(KERN_DEBUG "Filling non-frag hole from %d-%d\n", offset, offset+holesize));
+			memset(pg_buf, 0, holesize);
+			pg_buf += holesize;
+			offset += holesize;
+			continue;
+		} else if (frag->ofs < offset && (offset & (PAGE_CACHE_SIZE-1)) != 0) {
+			D1(printk(KERN_NOTICE "Eep. Overlap in ino #%ld fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n",
+				  inode->i_ino, frag->ofs, offset));
+			D1(jffs2_print_frag_list(f));
+			memset(pg_buf, 0, end - offset);
+			ClearPageUptodate(pg);
+			SetPageError(pg);
+			kunmap(pg);
+			return -EIO;
+		} else if (!frag->node) {
+			__u32 holeend = min(end, frag->ofs + frag->size);
+			D1(printk(KERN_DEBUG "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n", offset, holeend, frag->ofs, frag->ofs + frag->size));
+			memset(pg_buf, 0, holeend - offset);
+			pg_buf += holeend - offset;
+			offset = holeend;
+			frag = frag->next;
+			continue;
+		} else {
+			__u32 readlen;
+			readlen = min(frag->size, end - offset);
+			D1(printk(KERN_DEBUG "Reading %d-%d from node at 0x%x\n", frag->ofs, frag->ofs+readlen, frag->node->raw->flash_offset & ~3));
+			ret = jffs2_read_dnode(c, frag->node, pg_buf, frag->ofs - frag->node->ofs, readlen);
+			D2(printk(KERN_DEBUG "node read done\n"));
+			if (ret) {
+				D1(printk(KERN_DEBUG"jffs2_readpage error %d\n",ret));
+				memset(pg_buf, 0, frag->size);
+				ClearPageUptodate(pg);
+				SetPageError(pg);
+				kunmap(pg);
+				return ret;
+			}
+		}
+		pg_buf += frag->size;
+		offset += frag->size;
+		frag = frag->next;
+		D2(printk(KERN_DEBUG "node read was OK. Looping\n"));
+	}
+	D2(printk(KERN_DEBUG "readpage finishing\n"));
+	SetPageUptodate(pg);
+	ClearPageError(pg);
+
+	flush_dcache_page(pg);
+
+	kunmap(pg);
+	D1(printk(KERN_DEBUG "readpage finished\n"));
+	return 0;
+}
+
+int jffs2_do_readpage_unlock(struct inode *inode, struct page *pg)
+{
+	int ret = jffs2_do_readpage_nolock(inode, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+
+int jffs2_readpage (struct file *filp, struct page *pg)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(filp->f_dentry->d_inode);
+	int ret;
+	
+	down(&f->sem);
+	ret = jffs2_do_readpage_unlock(filp->f_dentry->d_inode, pg);
+	up(&f->sem);
+	return ret;
+}
+
+int jffs2_prepare_write (struct file *filp, struct page *pg, unsigned start, unsigned end)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	__u32 pageofs = pg->index << PAGE_CACHE_SHIFT;
+	int ret = 0;
+
+	down(&f->sem);
+	D1(printk(KERN_DEBUG "jffs2_prepare_write() nrpages %ld\n", inode->i_mapping->nrpages));
+
+	if (pageofs > inode->i_size) {
+		/* Make new hole frag from old EOF to new page */
+		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+		struct jffs2_raw_inode ri;
+		struct jffs2_full_dnode *fn;
+		__u32 phys_ofs, alloc_len;
+		
+		D1(printk(KERN_DEBUG "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
+			  (unsigned int)inode->i_size, pageofs));
+
+		ret = jffs2_reserve_space(c, sizeof(ri), &phys_ofs, &alloc_len, ALLOC_NORMAL);
+		if (ret) {
+			up(&f->sem);
+			return ret;
+		}
+		memset(&ri, 0, sizeof(ri));
+
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri);
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = f->inocache->ino;
+		ri.version = ++f->highest_version;
+		ri.mode = inode->i_mode;
+		ri.uid = inode->i_uid;
+		ri.gid = inode->i_gid;
+		ri.isize = max(inode->i_size, pageofs);
+		ri.atime = ri.ctime = ri.mtime = CURRENT_TIME;
+		ri.offset = inode->i_size;
+		ri.dsize = pageofs - inode->i_size;
+		ri.csize = 0;
+		ri.compr = JFFS2_COMPR_ZERO;
+		ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+		ri.data_crc = 0;
+		
+		fn = jffs2_write_dnode(inode, &ri, NULL, 0, phys_ofs, NULL);
+		jffs2_complete_reservation(c);
+		if (IS_ERR(fn)) {
+			ret = PTR_ERR(fn);
+			up(&f->sem);
+			return ret;
+		}
+		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
+		if (f->metadata) {
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+		}
+		if (ret) {
+			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in prepare_write, returned %d\n", ret));
+			jffs2_mark_node_obsolete(c, fn->raw);
+			jffs2_free_full_dnode(fn);
+			up(&f->sem);
+			return ret;
+		}
+		inode->i_size = pageofs;
+	}
+	
+
+	/* Read in the page if it wasn't already present */
+	if (!Page_Uptodate(pg) && (start || end < PAGE_SIZE))
+		ret = jffs2_do_readpage_nolock(inode, pg);
+	D1(printk(KERN_DEBUG "end prepare_write(). nrpages %ld\n", inode->i_mapping->nrpages));
+	up(&f->sem);
+	return ret;
+}
+
+int jffs2_commit_write (struct file *filp, struct page *pg, unsigned start, unsigned end)
+{
+	/* Actually commit the write from the page cache page we're looking at.
+	 * For now, we write the full page out each time. It sucks, but it's simple
+	 */
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	ssize_t newsize = max(filp->f_dentry->d_inode->i_size, (pg->index << PAGE_CACHE_SHIFT) + end);
+	__u32 file_ofs = (pg->index << PAGE_CACHE_SHIFT);
+	unsigned writelen = min(PAGE_CACHE_SIZE, newsize - file_ofs);
+	struct jffs2_raw_inode *ri;
+	int ret = 0;
+	ssize_t writtenlen = 0;
+
+	D1(printk(KERN_DEBUG "jffs2_commit_write(): ino #%lu, page at 0x%lx, range %d-%d, nrpages %ld\n", inode->i_ino, pg->index << PAGE_CACHE_SHIFT, start, end, filp->f_dentry->d_inode->i_mapping->nrpages));
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri)
+		return -ENOMEM;
+
+	while(writelen) {
+		struct jffs2_full_dnode *fn;
+		unsigned char *comprbuf = NULL;
+		unsigned char comprtype = JFFS2_COMPR_NONE;
+		__u32 phys_ofs, alloclen;
+		__u32 datalen, cdatalen;
+
+		D2(printk(KERN_DEBUG "jffs2_commit_write() loop: 0x%x to write to 0x%x\n", writelen, file_ofs));
+
+		ret = jffs2_reserve_space(c, sizeof(*ri) + JFFS2_MIN_DATA_LEN, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		if (ret) {
+			SetPageError(pg);
+			D1(printk(KERN_DEBUG "jffs2_reserve_space returned %d\n", ret));
+			break;
+		}
+		down(&f->sem);
+		datalen = writelen;
+		cdatalen = min(alloclen - sizeof(*ri), writelen);
+
+		comprbuf = kmalloc(cdatalen, GFP_KERNEL);
+		if (comprbuf) {
+			comprtype = jffs2_compress(page_address(pg)+ (file_ofs & (PAGE_CACHE_SIZE-1)), comprbuf, &datalen, &cdatalen);
+		}
+		if (comprtype == JFFS2_COMPR_NONE) {
+			/* Either compression failed, or the allocation of comprbuf failed */
+			if (comprbuf)
+				kfree(comprbuf);
+			comprbuf = page_address(pg) + (file_ofs & (PAGE_CACHE_SIZE -1));
+			datalen = cdatalen;
+		}
+		/* Now comprbuf points to the data to be written, be it compressed or not.
+		   comprtype holds the compression type, and comprtype == JFFS2_COMPR_NONE means
+		   that the comprbuf doesn't need to be kfree()d. 
+		*/
+
+		ri->magic = JFFS2_MAGIC_BITMASK;
+		ri->nodetype = JFFS2_NODETYPE_INODE;
+		ri->totlen = sizeof(*ri) + cdatalen;
+		ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri->ino = inode->i_ino;
+		ri->version = ++f->highest_version;
+		ri->mode = inode->i_mode;
+		ri->uid = inode->i_uid;
+		ri->gid = inode->i_gid;
+		ri->isize = max(inode->i_size, file_ofs + datalen);
+		ri->atime = ri->ctime = ri->mtime = CURRENT_TIME;
+		ri->offset = file_ofs;
+		ri->csize = cdatalen;
+		ri->dsize = datalen;
+		ri->compr = comprtype;
+		ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+		ri->data_crc = crc32(0, comprbuf, cdatalen);
+
+		fn = jffs2_write_dnode(inode, ri, comprbuf, cdatalen, phys_ofs, NULL);
+
+		jffs2_complete_reservation(c);
+
+		if (comprtype != JFFS2_COMPR_NONE)
+			kfree(comprbuf);
+
+		if (IS_ERR(fn)) {
+			ret = PTR_ERR(fn);
+			up(&f->sem);
+			SetPageError(pg);
+			break;
+		}
+		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
+		if (f->metadata) {
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+		}
+		up(&f->sem);
+		if (ret) {
+			/* Eep */
+			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\n", ret));
+			jffs2_mark_node_obsolete(c, fn->raw);
+			jffs2_free_full_dnode(fn);
+			SetPageError(pg);
+			break;
+		}
+		inode->i_size = ri->isize;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+		inode->i_ctime = inode->i_mtime = ri->ctime;
+		if (!datalen) {
+			printk(KERN_WARNING "Eep. We didn't actually write any bloody data\n");
+			ret = -EIO;
+			SetPageError(pg);
+			break;
+		}
+		D1(printk(KERN_DEBUG "increasing writtenlen by %d\n", datalen));
+		writtenlen += datalen;
+		file_ofs += datalen;
+		writelen -= datalen;
+	}
+
+	jffs2_free_raw_inode(ri);
+
+	if (writtenlen < end) {
+		/* generic_file_write has written more to the page cache than we've
+		   actually written to the medium. Mark the page !Uptodate so that 
+		   it gets reread */
+		D1(printk(KERN_DEBUG "jffs2_commit_write(): Not all bytes written. Marking page !uptodate\n"));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	}
+	if (writtenlen <= start) {
+		/* We didn't even get to the start of the affected part */
+		ret = ret?ret:-ENOSPC;
+		D1(printk(KERN_DEBUG "jffs2_commit_write(): Only %x bytes written to page. start (%x) not reached, returning %d\n", writtenlen, start, ret));
+	}
+	writtenlen = min(end-start, writtenlen-start);
+
+	D1(printk(KERN_DEBUG "jffs2_commit_write() returning %d. nrpages is %ld\n",writtenlen?writtenlen:ret, inode->i_mapping->nrpages));
+	return writtenlen?writtenlen:ret;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/gc.c linux-2.4.2/fs/jffs2/gc.c
--- linux-2.4.2.orig/fs/jffs2/gc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/gc.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,660 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: gc.c,v 1.51 2001/05/24 22:24:39 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/slab.h>
+#include <linux/jffs2.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/pagemap.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dnode *fd);
+static int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dirent *fd);
+static int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dirent *fd);
+static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+				      struct inode *indeo, struct jffs2_full_dnode *fn,
+				      __u32 start, __u32 end);
+static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+				       struct inode *inode, struct jffs2_full_dnode *fn,
+				       __u32 start, __u32 end);
+
+/* Called with erase_completion_lock held */
+static struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)
+{
+	struct jffs2_eraseblock *ret;
+	struct list_head *nextlist = NULL;
+
+	/* Pick an eraseblock to garbage collect next. This is where we'll
+	   put the clever wear-levelling algorithms. Eventually.  */
+	if (!list_empty(&c->bad_used_list) && c->nr_free_blocks > JFFS2_RESERVED_BLOCKS_GCBAD) {
+		D1(printk(KERN_DEBUG "Picking block from bad_used_list to GC next\n"));
+		nextlist = &c->bad_used_list;
+	} else if (jiffies % 100 && !list_empty(&c->dirty_list)) {
+		/* Most of the time, pick one off the dirty list */
+		D1(printk(KERN_DEBUG "Picking block from dirty_list to GC next\n"));
+		nextlist = &c->dirty_list;
+	} else if (!list_empty(&c->clean_list)) {
+		D1(printk(KERN_DEBUG "Picking block from clean_list to GC next\n"));
+		nextlist = &c->clean_list;
+	} else if (!list_empty(&c->dirty_list)) {
+		D1(printk(KERN_DEBUG "Picking block from dirty_list to GC next (clean_list was empty)\n"));
+
+		nextlist = &c->dirty_list;
+	} else {
+		/* Eep. Both were empty */
+		printk(KERN_NOTICE "jffs2: No clean _or_ dirty blocks to GC from! Where are they all?\n");
+		return NULL;
+	}
+
+	ret = list_entry(nextlist->next, struct jffs2_eraseblock, list);
+	list_del(&ret->list);
+	c->gcblock = ret;
+	ret->gc_node = ret->first_node;
+	if (!ret->gc_node) {
+		printk(KERN_WARNING "Eep. ret->gc_node for block at 0x%08x is NULL\n", ret->offset);
+		BUG();
+	}
+	return ret;
+}
+
+/* jffs2_garbage_collect_pass
+ * Make a single attempt to progress GC. Move one node, and possibly
+ * start erasing one eraseblock.
+ */
+int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
+{
+	struct jffs2_eraseblock *jeb;
+	struct jffs2_inode_info *f;
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_node_frag *frag;
+	struct jffs2_full_dnode *fn = NULL;
+	struct jffs2_full_dirent *fd;
+	__u32 start = 0, end = 0, nrfrags = 0;
+	__u32 inum;
+	struct inode *inode;
+	int ret = 0;
+
+	if (down_interruptible(&c->alloc_sem))
+		return -EINTR;
+
+	spin_lock_bh(&c->erase_completion_lock);
+
+	/* First, work out which block we're garbage-collecting */
+	jeb = c->gcblock;
+
+	if (!jeb)
+		jeb = jffs2_find_gc_block(c);
+
+	if (!jeb) {
+		printk(KERN_NOTICE "jffs2: Couldn't find erase block to garbage collect!\n");
+		spin_unlock_bh(&c->erase_completion_lock);
+		up(&c->alloc_sem);
+		return -EIO;
+	}
+
+	D1(printk(KERN_DEBUG "garbage collect from block at phys 0x%08x\n", jeb->offset));
+
+	if (!jeb->used_size)
+		goto eraseit;
+
+	raw = jeb->gc_node;
+			
+	while(raw->flash_offset & 1) {
+		D1(printk(KERN_DEBUG "Node at 0x%08x is obsolete... skipping\n", raw->flash_offset &~3));
+		jeb->gc_node = raw = raw->next_phys;
+		if (!raw) {
+			printk(KERN_WARNING "eep. End of raw list while still supposedly nodes to GC\n");
+			printk(KERN_WARNING "erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\n", 
+			       jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size);
+			spin_unlock_bh(&c->erase_completion_lock);
+			up(&c->alloc_sem);
+			BUG();
+		}
+	}
+	D1(printk(KERN_DEBUG "Going to garbage collect node at 0x%08x\n", raw->flash_offset &~3));
+	if (!raw->next_in_ino) {
+		/* Inode-less node. Clean marker, snapshot or something like that */
+		spin_unlock_bh(&c->erase_completion_lock);
+		jffs2_mark_node_obsolete(c, raw);
+		goto eraseit_lock;
+	}
+						     
+	inum = jffs2_raw_ref_to_inum(raw);
+	D1(printk(KERN_DEBUG "Inode number is #%u\n", inum));
+
+	spin_unlock_bh(&c->erase_completion_lock);
+
+	D1(printk(KERN_DEBUG "jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x, ino #%u\n", jeb->offset, raw->flash_offset&~3, inum));
+
+	inode = iget(OFNI_BS_2SFFJ(c), inum);
+	if (is_bad_inode(inode)) {
+		printk(KERN_NOTICE "Eep. read_inode() failed for ino #%u\n", inum);
+		/* NB. This will happen again. We need to do something appropriate here. */
+		iput(inode);
+		up(&c->alloc_sem);
+		return -EIO;
+	}
+
+	f = JFFS2_INODE_INFO(inode);
+	down(&f->sem);
+	/* Now we have the lock for this inode. Check that it's still the one at the head
+	   of the list. */
+
+	if (raw->flash_offset & 1) {
+		D1(printk(KERN_DEBUG "node to be GC'd was obsoleted in the meantime.\n"));
+		/* They'll call again */
+		goto upnout;
+	}
+	/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */
+	if (f->metadata && f->metadata->raw == raw) {
+		fn = f->metadata;
+		ret = jffs2_garbage_collect_metadata(c, jeb, inode, fn);
+		goto upnout;
+	}
+	
+	for (frag = f->fraglist; frag; frag = frag->next) {
+		if (frag->node && frag->node->raw == raw) {
+			fn = frag->node;
+			end = frag->ofs + frag->size;
+			if (!nrfrags++)
+				start = frag->ofs;
+			if (nrfrags == frag->node->frags)
+				break; /* We've found them all */
+		}
+	}
+	if (fn) {
+		/* We found a datanode. Do the GC */
+		if((start >> PAGE_CACHE_SHIFT) < ((end-1) >> PAGE_CACHE_SHIFT)) {
+			/* It crosses a page boundary. Therefore, it must be a hole. */
+			ret = jffs2_garbage_collect_hole(c, jeb, inode, fn, start, end);
+		} else {
+			/* It could still be a hole. But we GC the page this way anyway */
+			ret = jffs2_garbage_collect_dnode(c, jeb, inode, fn, start, end);
+		}
+		goto upnout;
+	}
+	
+	/* Wasn't a dnode. Try dirent */
+	for (fd = f->dents; fd; fd=fd->next) {
+		if (fd->raw == raw)
+			break;
+	}
+
+	if (fd && fd->ino) {
+		ret = jffs2_garbage_collect_dirent(c, jeb, inode, fd);
+	} else if (fd) {
+		ret = jffs2_garbage_collect_deletion_dirent(c, jeb, inode, fd);
+	} else {
+		printk(KERN_WARNING "Raw node at 0x%08x wasn't in node lists for ino #%lu\n", raw->flash_offset&~3, inode->i_ino);
+		if (raw->flash_offset & 1) {
+			printk(KERN_WARNING "But it's obsolete so we don't mind too much\n");
+		} else {
+			ret = -EIO;
+		}
+	}
+ upnout:
+	up(&f->sem);
+	iput(inode);
+
+ eraseit_lock:
+	/* If we've finished this block, start it erasing */
+	spin_lock_bh(&c->erase_completion_lock);
+
+ eraseit:
+	if (c->gcblock && !c->gcblock->used_size) {
+		D1(printk(KERN_DEBUG "Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\n", c->gcblock->offset));
+		/* We're GC'ing an empty block? */
+		list_add_tail(&c->gcblock->list, &c->erase_pending_list);
+		c->gcblock = NULL;
+		c->nr_erasing_blocks++;
+		jffs2_erase_pending_trigger(c);
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	up(&c->alloc_sem);
+
+	return ret;
+}
+
+static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dnode *fn)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_full_dnode *new_fn;
+	struct jffs2_raw_inode ri;
+	unsigned short dev;
+	char *mdata = NULL, mdatalen = 0;
+	__u32 alloclen, phys_ofs;
+	int ret;
+
+	if ((inode->i_mode & S_IFMT) == S_IFBLK ||
+	    (inode->i_mode & S_IFMT) == S_IFCHR) {
+		/* For these, we don't actually need to read the old node */
+		dev =  (MAJOR(to_kdev_t(inode->i_rdev)) << 8) | 
+			MINOR(to_kdev_t(inode->i_rdev));
+		mdata = (char *)&dev;
+		mdatalen = sizeof(dev);
+		D1(printk(KERN_DEBUG "jffs2_garbage_collect_metadata(): Writing %d bytes of kdev_t\n", mdatalen));
+	} else if ((inode->i_mode & S_IFMT) == S_IFLNK) {
+		mdatalen = fn->size;
+		mdata = kmalloc(fn->size, GFP_KERNEL);
+		if (!mdata) {
+			printk(KERN_WARNING "kmalloc of mdata failed in jffs2_garbage_collect_metadata()\n");
+			return -ENOMEM;
+		}
+		ret = jffs2_read_dnode(c, fn, mdata, 0, mdatalen);
+		if (ret) {
+			printk(KERN_WARNING "read of old metadata failed in jffs2_garbage_collect_metadata(): %d\n", ret);
+			kfree(mdata);
+			return ret;
+		}
+		D1(printk(KERN_DEBUG "jffs2_garbage_collect_metadata(): Writing %d bites of symlink target\n", mdatalen));
+
+	}
+	
+	ret = jffs2_reserve_space_gc(c, sizeof(ri) + mdatalen, &phys_ofs, &alloclen);
+	if (ret) {
+		printk(KERN_WARNING "jffs2_reserve_space_gc of %d bytes for garbage_collect_metadata failed: %d\n",
+		       sizeof(ri)+ mdatalen, ret);
+		goto out;
+	}
+	
+	memset(&ri, 0, sizeof(ri));
+	ri.magic = JFFS2_MAGIC_BITMASK;
+	ri.nodetype = JFFS2_NODETYPE_INODE;
+	ri.totlen = sizeof(ri) + mdatalen;
+	ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri.ino = inode->i_ino;
+	ri.version = ++f->highest_version;
+	ri.mode = inode->i_mode;
+	ri.uid = inode->i_uid;
+	ri.gid = inode->i_gid;
+	ri.isize = inode->i_size;
+	ri.atime = inode->i_atime;
+	ri.ctime = inode->i_ctime;
+	ri.mtime = inode->i_mtime;
+	ri.offset = 0;
+	ri.csize = mdatalen;
+	ri.dsize = mdatalen;
+	ri.compr = JFFS2_COMPR_NONE;
+	ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+	ri.data_crc = crc32(0, mdata, mdatalen);
+
+	new_fn = jffs2_write_dnode(inode, &ri, mdata, mdatalen, phys_ofs, NULL);
+
+	if (IS_ERR(new_fn)) {
+		printk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));
+		ret = PTR_ERR(new_fn);
+		goto out;
+	}
+	jffs2_mark_node_obsolete(c, fn->raw);
+	jffs2_free_full_dnode(fn);
+	f->metadata = new_fn;
+ out:
+	if ((inode->i_mode & S_IFMT) == S_IFLNK)
+		kfree(mdata);
+	return ret;
+}
+
+static int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dirent *fd)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_full_dirent *new_fd;
+	struct jffs2_raw_dirent rd;
+	__u32 alloclen, phys_ofs;
+	int ret;
+
+	rd.magic = JFFS2_MAGIC_BITMASK;
+	rd.nodetype = JFFS2_NODETYPE_DIRENT;
+	rd.nsize = strlen(fd->name);
+	rd.totlen = sizeof(rd) + rd.nsize;
+	rd.hdr_crc = crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd.pino = inode->i_ino;
+	rd.version = ++f->highest_version;
+	rd.ino = fd->ino;
+	rd.mctime = max(inode->i_mtime, inode->i_ctime);
+	rd.type = fd->type;
+	rd.node_crc = crc32(0, &rd, sizeof(rd)-8);
+	rd.name_crc = crc32(0, fd->name, rd.nsize);
+	
+	ret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &phys_ofs, &alloclen);
+	if (ret) {
+		printk(KERN_WARNING "jffs2_reserve_space_gc of %d bytes for garbage_collect_dirent failed: %d\n",
+		       sizeof(rd)+rd.nsize, ret);
+		return ret;
+	}
+	new_fd = jffs2_write_dirent(inode, &rd, fd->name, rd.nsize, phys_ofs, NULL);
+
+	if (IS_ERR(new_fd)) {
+		printk(KERN_WARNING "jffs2_write_dirent in garbage_collect_dirent failed: %ld\n", PTR_ERR(new_fd));
+		return PTR_ERR(new_fd);
+	}
+	jffs2_add_fd_to_list(c, new_fd, &f->dents);
+	return 0;
+}
+
+static int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
+					struct inode *inode, struct jffs2_full_dirent *fd)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_full_dirent **fdp = &f->dents;
+	int found = 0;
+
+	/* FIXME: When we run on NAND flash, we need to work out whether
+	   this deletion dirent is still needed to actively delete a
+	   'real' dirent with the same name that's still somewhere else
+	   on the flash. For now, we know that we've actually obliterated
+	   all the older dirents when they became obsolete, so we didn't
+	   really need to write the deletion to flash in the first place.
+	*/
+	while (*fdp) {
+		if ((*fdp) == fd) {
+			found = 1;
+			*fdp = fd->next;
+			break;
+		}
+		fdp = &(*fdp)->next;
+	}
+	if (!found) {
+		printk(KERN_WARNING "Deletion dirent \"%s\" not found in list for ino #%lu\n", fd->name, inode->i_ino);
+	}
+	jffs2_mark_node_obsolete(c, fd->raw);
+	jffs2_free_full_dirent(fd);
+	return 0;
+}
+
+static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+				      struct inode *inode, struct jffs2_full_dnode *fn,
+				      __u32 start, __u32 end)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_raw_inode ri;
+	struct jffs2_node_frag *frag;
+	struct jffs2_full_dnode *new_fn;
+	__u32 alloclen, phys_ofs;
+	int ret;
+
+	D1(printk(KERN_DEBUG "Writing replacement hole node for ino #%lu from offset 0x%x to 0x%x\n",
+		  inode->i_ino, start, end));
+	
+	memset(&ri, 0, sizeof(ri));
+
+	if(fn->frags > 1) {
+		size_t readlen;
+		__u32 crc;
+		/* It's partially obsoleted by a later write. So we have to 
+		   write it out again with the _same_ version as before */
+		ret = c->mtd->read(c->mtd, fn->raw->flash_offset & ~3, sizeof(ri), &readlen, (char *)&ri);
+		if (readlen != sizeof(ri) || ret) {
+			printk(KERN_WARNING "Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %d. Data will be lost by writing new hold node\n", ret, readlen);
+			goto fill;
+		}
+		if (ri.nodetype != JFFS2_NODETYPE_INODE) {
+			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\n",
+			       fn->raw->flash_offset & ~3, ri.nodetype, JFFS2_NODETYPE_INODE);
+			return -EIO;
+		}
+		if (ri.totlen != sizeof(ri)) {
+			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had totlen 0x%x instead of expected 0x%x\n",
+			       fn->raw->flash_offset & ~3, ri.totlen, sizeof(ri));
+			return -EIO;
+		}
+		crc = crc32(0, &ri, sizeof(ri)-8);
+		if (crc != ri.node_crc) {
+			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\n",
+			       fn->raw->flash_offset & ~3, ri.node_crc, crc);
+			/* FIXME: We could possibly deal with this by writing new holes for each frag */
+			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%lu will be lost\n", 
+			       start, end, inode->i_ino);
+			goto fill;
+		}
+		if (ri.compr != JFFS2_COMPR_ZERO) {
+			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node 0x%08x wasn't a hole node!\n", fn->raw->flash_offset & ~3);
+			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%lu will be lost\n", 
+			       start, end, inode->i_ino);
+			goto fill;
+		}
+	} else {
+	fill:
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri);
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = inode->i_ino;
+		ri.version = ++f->highest_version;
+		ri.offset = start;
+		ri.csize = end - start;
+		ri.dsize = 0;
+		ri.compr = JFFS2_COMPR_ZERO;
+	}
+	ri.mode = inode->i_mode;
+	ri.uid = inode->i_uid;
+	ri.gid = inode->i_gid;
+	ri.isize = inode->i_size;
+	ri.atime = inode->i_atime;
+	ri.ctime = inode->i_ctime;
+	ri.mtime = inode->i_mtime;
+	ri.data_crc = 0;
+	ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+
+	ret = jffs2_reserve_space_gc(c, sizeof(ri), &phys_ofs, &alloclen);
+	if (ret) {
+		printk(KERN_WARNING "jffs2_reserve_space_gc of %d bytes for garbage_collect_hole failed: %d\n",
+		       sizeof(ri), ret);
+		return ret;
+	}
+	new_fn = jffs2_write_dnode(inode, &ri, NULL, 0, phys_ofs, NULL);
+
+	if (IS_ERR(new_fn)) {
+		printk(KERN_WARNING "Error writing new hole node: %ld\n", PTR_ERR(new_fn));
+		return PTR_ERR(new_fn);
+	}
+	if (ri.version == f->highest_version) {
+		jffs2_add_full_dnode_to_inode(c, f, new_fn);
+		if (f->metadata) {
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+			return 0;
+		}
+	}
+	for (frag = f->fraglist; frag; frag = frag->next) {
+		if (frag->ofs > fn->size + fn->ofs)
+			break;
+		if (frag->node == fn) {
+			frag->node = new_fn;
+			new_fn->frags++;
+			fn->frags--;
+		}
+	}
+	if (fn->frags) {
+		printk(KERN_WARNING "jffs2_garbage_collect_hole: Old node still has frags!\n");
+		BUG();
+	}
+	if (!new_fn->frags) {
+		printk(KERN_WARNING "jffs2_garbage_collect_hole: New node has no frags!\n");
+		BUG();
+	}
+		
+	jffs2_mark_node_obsolete(c, fn->raw);
+	jffs2_free_full_dnode(fn);
+	
+	return 0;
+}
+
+static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+				       struct inode *inode, struct jffs2_full_dnode *fn,
+				       __u32 start, __u32 end)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_full_dnode *new_fn;
+	struct jffs2_raw_inode ri;
+	__u32 alloclen, phys_ofs, offset, orig_end;	
+	int ret = 0;
+	unsigned char *comprbuf = NULL, *writebuf;
+	struct page *pg;
+	unsigned char *pg_ptr;
+
+
+	memset(&ri, 0, sizeof(ri));
+
+	D1(printk(KERN_DEBUG "Writing replacement dnode for ino #%lu from offset 0x%x to 0x%x\n",
+		  inode->i_ino, start, end));
+
+	orig_end = end;
+
+
+	/* If we're looking at the last node in the block we're
+	   garbage-collecting, we allow ourselves to merge as if the
+	   block was already erasing. We're likely to be GC'ing a
+	   partial page, and the next block we GC is likely to have
+	   the other half of this page right at the beginning, which
+	   means we'd expand it _then_, as nr_erasing_blocks would have
+	   increased since we checked, and in doing so would obsolete 
+	   the partial node which we'd have written here. Meaning that 
+	   the GC would churn and churn, and just leave dirty blocks in
+	   it's wake.
+	*/
+	if(c->nr_free_blocks + c->nr_erasing_blocks > JFFS2_RESERVED_BLOCKS_GCMERGE - (fn->raw->next_phys?0:1)) {
+		/* Shitloads of space */
+		/* FIXME: Integrate this properly with GC calculations */
+		start &= ~(PAGE_CACHE_SIZE-1);
+		end = min(start + PAGE_CACHE_SIZE, inode->i_size);
+		D1(printk(KERN_DEBUG "Plenty of free space, so expanding to write from offset 0x%x to 0x%x\n",
+			  start, end));
+		if (end < orig_end) {
+			printk(KERN_WARNING "Eep. jffs2_garbage_collect_dnode extended node to write, but it got smaller: start 0x%x, orig_end 0x%x, end 0x%x\n", start, orig_end, end);
+			end = orig_end;
+		}
+	}
+	
+	/* First, use readpage() to read the appropriate page into the page cache */
+	/* Q: What happens if we actually try to GC the _same_ page for which commit_write()
+	 *    triggered garbage collection in the first place?
+	 * A: I _think_ it's OK. read_cache_page shouldn't deadlock, we'll write out the
+	 *    page OK. We'll actually write it out again in commit_write, which is a little
+	 *    suboptimal, but at least we're correct.
+	 */
+	pg = read_cache_page(inode->i_mapping, start >> PAGE_CACHE_SHIFT, (void *)jffs2_do_readpage_unlock, inode);
+
+	if (IS_ERR(pg)) {
+		printk(KERN_WARNING "read_cache_page() returned error: %ld\n", PTR_ERR(pg));
+		return PTR_ERR(pg);
+	}
+	pg_ptr = (char *)kmap(pg);
+	comprbuf = kmalloc(end - start, GFP_KERNEL);
+
+	offset = start;
+	while(offset < orig_end) {
+		__u32 datalen;
+		__u32 cdatalen;
+		char comprtype = JFFS2_COMPR_NONE;
+
+		ret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN, &phys_ofs, &alloclen);
+
+		if (ret) {
+			printk(KERN_WARNING "jffs2_reserve_space_gc of %d bytes for garbage_collect_dnode failed: %d\n",
+			       sizeof(ri)+ JFFS2_MIN_DATA_LEN, ret);
+			break;
+		}
+		cdatalen = min(alloclen - sizeof(ri), end - offset);
+		datalen = end - offset;
+
+		writebuf = pg_ptr + (offset & (PAGE_CACHE_SIZE -1));
+
+		if (comprbuf) {
+			comprtype = jffs2_compress(writebuf, comprbuf, &datalen, &cdatalen);
+		}
+		if (comprtype) {
+			writebuf = comprbuf;
+		} else {
+			datalen = cdatalen;
+		}
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri) + cdatalen;
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = inode->i_ino;
+		ri.version = ++f->highest_version;
+		ri.mode = inode->i_mode;
+		ri.uid = inode->i_uid;
+		ri.gid = inode->i_gid;
+		ri.isize = inode->i_size;
+		ri.atime = inode->i_atime;
+		ri.ctime = inode->i_ctime;
+		ri.mtime = inode->i_mtime;
+		ri.offset = offset;
+		ri.csize = cdatalen;
+		ri.dsize = datalen;
+		ri.compr = comprtype;
+		ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+		ri.data_crc = crc32(0, writebuf, cdatalen);
+	
+		new_fn = jffs2_write_dnode(inode, &ri, writebuf, cdatalen, phys_ofs, NULL);
+
+		if (IS_ERR(new_fn)) {
+			printk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));
+			ret = PTR_ERR(new_fn);
+			break;
+		}
+		ret = jffs2_add_full_dnode_to_inode(c, f, new_fn);
+		offset += datalen;
+		if (f->metadata) {
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+		}
+	}
+	if (comprbuf) kfree(comprbuf);
+
+	kunmap(pg);
+	/* XXX: Does the page get freed automatically? */
+	/* AAA: Judging by the unmount getting stuck in __wait_on_page, nope. */
+	page_cache_release(pg);
+	return ret;
+}
+
diff -Naur linux-2.4.2.orig/fs/jffs2/histo.h linux-2.4.2/fs/jffs2/histo.h
--- linux-2.4.2.orig/fs/jffs2/histo.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/histo.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,3 @@
+/* This file provides the bit-probabilities for the input file */
+#define BIT_DIVIDER 629 
+static int bits[9] = { 179,167,183,165,159,198,178,119,}; /* ia32 .so files */
diff -Naur linux-2.4.2.orig/fs/jffs2/histo_mips.h linux-2.4.2/fs/jffs2/histo_mips.h
--- linux-2.4.2.orig/fs/jffs2/histo_mips.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/histo_mips.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER_MIPS 1043 
+static int bits_mips[8] = { 277,249,290,267,229,341,212,241}; /* mips32 */
diff -Naur linux-2.4.2.orig/fs/jffs2/ioctl.c linux-2.4.2/fs/jffs2/ioctl.c
--- linux-2.4.2.orig/fs/jffs2/ioctl.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/ioctl.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,47 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: ioctl.c,v 1.5 2001/03/15 15:38:24 dwmw2 Exp $
+ *
+ */
+
+#include <linux/fs.h>
+
+int jffs2_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
+		unsigned long arg)
+{
+	/* Later, this will provide for lsattr.jffs2 and chattr.jffs2, which
+	   will include compression support etc. */
+	return -EINVAL;
+}
+	
diff -Naur linux-2.4.2.orig/fs/jffs2/malloc.c linux-2.4.2/fs/jffs2/malloc.c
--- linux-2.4.2.orig/fs/jffs2/malloc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/malloc.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,220 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: malloc.c,v 1.16 2001/03/15 15:38:24 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+
+#if 0
+#define JFFS2_SLAB_POISON SLAB_POISON
+#else
+#define JFFS2_SLAB_POISON 0
+#endif
+
+/* These are initialised to NULL in the kernel startup code.
+   If you're porting to other operating systems, beware */
+static kmem_cache_t *full_dnode_slab;
+static kmem_cache_t *raw_dirent_slab;
+static kmem_cache_t *raw_inode_slab;
+static kmem_cache_t *tmp_dnode_info_slab;
+static kmem_cache_t *raw_node_ref_slab;
+static kmem_cache_t *node_frag_slab;
+static kmem_cache_t *inode_cache_slab;
+
+void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_tmp_dnode_info *next;
+
+	while (tn) {
+		next = tn;
+		tn = tn->next;
+		jffs2_free_full_dnode(next->fn);
+		jffs2_free_tmp_dnode_info(next);
+	}
+}
+
+void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
+{
+	struct jffs2_full_dirent *next;
+
+	while (fd) {
+		next = fd->next;
+		jffs2_free_full_dirent(fd);
+		fd = next;
+	}
+}
+
+int __init jffs2_create_slab_caches(void)
+{
+	full_dnode_slab = kmem_cache_create("jffs2_full_dnode", sizeof(struct jffs2_full_dnode), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!full_dnode_slab)
+		goto err;
+
+	raw_dirent_slab = kmem_cache_create("jffs2_raw_dirent", sizeof(struct jffs2_raw_dirent), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!raw_dirent_slab)
+		goto err;
+
+	raw_inode_slab = kmem_cache_create("jffs2_raw_inode", sizeof(struct jffs2_raw_inode), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!raw_inode_slab)
+		goto err;
+
+	tmp_dnode_info_slab = kmem_cache_create("jffs2_tmp_dnode", sizeof(struct jffs2_tmp_dnode_info), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!tmp_dnode_info_slab)
+		goto err;
+
+	raw_node_ref_slab = kmem_cache_create("jffs2_raw_node_ref", sizeof(struct jffs2_raw_node_ref), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!raw_node_ref_slab)
+		goto err;
+
+	node_frag_slab = kmem_cache_create("jffs2_node_frag", sizeof(struct jffs2_node_frag), 0, JFFS2_SLAB_POISON, NULL, NULL);
+	if (!node_frag_slab)
+		goto err;
+
+	inode_cache_slab = kmem_cache_create("jffs2_inode_cache", sizeof(struct jffs2_inode_cache), 0, JFFS2_SLAB_POISON, NULL, NULL);
+
+	if (inode_cache_slab)
+		return 0;
+ err:
+	jffs2_destroy_slab_caches();
+	return -ENOMEM;
+}
+
+void jffs2_destroy_slab_caches(void)
+{
+	if(full_dnode_slab)
+		kmem_cache_destroy(full_dnode_slab);
+	if(raw_dirent_slab)
+		kmem_cache_destroy(raw_dirent_slab);
+	if(raw_inode_slab)
+		kmem_cache_destroy(raw_inode_slab);
+	if(tmp_dnode_info_slab)
+		kmem_cache_destroy(tmp_dnode_info_slab);
+	if(raw_node_ref_slab)
+		kmem_cache_destroy(raw_node_ref_slab);
+	if(node_frag_slab)
+		kmem_cache_destroy(node_frag_slab);
+	if(inode_cache_slab)
+		kmem_cache_destroy(inode_cache_slab);
+
+}
+
+struct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)
+{
+	return kmalloc(sizeof(struct jffs2_full_dirent) + namesize, GFP_KERNEL);
+}
+
+void jffs2_free_full_dirent(struct jffs2_full_dirent *x)
+{
+	kfree(x);
+}
+
+struct jffs2_full_dnode *jffs2_alloc_full_dnode(void)
+{
+	void *ret = kmem_cache_alloc(full_dnode_slab, GFP_KERNEL);
+	return ret;
+}
+
+void jffs2_free_full_dnode(struct jffs2_full_dnode *x)
+{
+	kmem_cache_free(full_dnode_slab, x);
+}
+
+struct jffs2_raw_dirent *jffs2_alloc_raw_dirent(void)
+{
+	return kmem_cache_alloc(raw_dirent_slab, GFP_KERNEL);
+}
+
+void jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)
+{
+	kmem_cache_free(raw_dirent_slab, x);
+}
+
+struct jffs2_raw_inode *jffs2_alloc_raw_inode(void)
+{
+	return kmem_cache_alloc(raw_inode_slab, GFP_KERNEL);
+}
+
+void jffs2_free_raw_inode(struct jffs2_raw_inode *x)
+{
+	kmem_cache_free(raw_inode_slab, x);
+}
+
+struct jffs2_tmp_dnode_info *jffs2_alloc_tmp_dnode_info(void)
+{
+	return kmem_cache_alloc(tmp_dnode_info_slab, GFP_KERNEL);
+}
+
+void jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *x)
+{
+	kmem_cache_free(tmp_dnode_info_slab, x);
+}
+
+struct jffs2_raw_node_ref *jffs2_alloc_raw_node_ref(void)
+{
+	return kmem_cache_alloc(raw_node_ref_slab, GFP_KERNEL);
+}
+
+void jffs2_free_raw_node_ref(struct jffs2_raw_node_ref *x)
+{
+	kmem_cache_free(raw_node_ref_slab, x);
+}
+
+struct jffs2_node_frag *jffs2_alloc_node_frag(void)
+{
+	return kmem_cache_alloc(node_frag_slab, GFP_KERNEL);
+}
+
+void jffs2_free_node_frag(struct jffs2_node_frag *x)
+{
+	kmem_cache_free(node_frag_slab, x);
+}
+
+struct jffs2_inode_cache *jffs2_alloc_inode_cache(void)
+{
+	struct jffs2_inode_cache *ret = kmem_cache_alloc(inode_cache_slab, GFP_KERNEL);
+	D1(printk(KERN_DEBUG "Allocated inocache at %p\n", ret));
+	return ret;
+}
+
+void jffs2_free_inode_cache(struct jffs2_inode_cache *x)
+{
+	D1(printk(KERN_DEBUG "Freeing inocache at %p\n", x));
+	kmem_cache_free(inode_cache_slab, x);
+}
+
diff -Naur linux-2.4.2.orig/fs/jffs2/nodelist.c linux-2.4.2/fs/jffs2/nodelist.c
--- linux-2.4.2.orig/fs/jffs2/nodelist.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/nodelist.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,358 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: nodelist.c,v 1.28 2001/03/27 06:20:04 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/jffs2.h>
+#include <linux/fs.h>
+#include <linux/mtd/mtd.h>
+#include "nodelist.h"
+
+#if 0
+/**
+ *	jffs2_add_raw_node_ref - Add a jffs2_raw_node_ref to the cached
+ *				node list for the filesystem
+ *	@sb: Pointer to filesystem information structure
+ *	@ref: New node to add
+ *
+ *	Adds a new node reference to the filesystem\'s node cache, which
+ *	is the only permanent storage required for the filesystem.
+ */
+void jffs2_add_raw_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)
+{
+	/* Sort the list, hash it or do _something_ useful with it */
+	spin_lock(&c->nodelist_lock);
+	ref->next = c->nodelist;
+	c->nodelist = ref;
+	spin_unlock(&c->nodelist_lock);
+	return 0;
+}
+#endif
+void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
+{
+	struct jffs2_full_dirent **prev = list;
+	D1(printk(KERN_DEBUG "jffs2_add_fd_to_list( %p, %p (->%p))\n", new, list, *list));
+
+	while ((*prev) && (*prev)->nhash <= new->nhash) {
+		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
+			/* Duplicate. Free one */
+			if (new->version < (*prev)->version) {
+				D1(printk(KERN_DEBUG "Eep! Marking new dirent node obsolete\n"));
+				D1(printk(KERN_DEBUG "New dirent is \"%s\"->ino #%u. Old is \"%s\"->ino #%u\n", new->name, new->ino, (*prev)->name, (*prev)->ino));
+				jffs2_mark_node_obsolete(c, new->raw);
+				jffs2_free_full_dirent(new);
+			} else {
+				D1(printk(KERN_DEBUG "Marking old dirent node (ino #%u) obsolete\n", (*prev)->ino));
+				new->next = (*prev)->next;
+				jffs2_mark_node_obsolete(c, ((*prev)->raw));
+				jffs2_free_full_dirent(*prev);
+				*prev = new;
+			}
+			goto out;
+		}
+		prev = &((*prev)->next);
+	}
+	new->next = *prev;
+	*prev = new;
+
+ out:
+	D1(while(*list) {
+		printk(KERN_DEBUG "Dirent \"%s\" (hash 0x%08x, ino #%u\n", (*list)->name, (*list)->nhash, (*list)->ino);
+		list = &(*list)->next;
+	})
+}
+
+/* Put a new tmp_dnode_info into the list, keeping the list in 
+   order of increasing version
+*/
+void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct jffs2_tmp_dnode_info **list)
+{
+	struct jffs2_tmp_dnode_info **prev = list;
+	
+	while ((*prev) && (*prev)->version < tn->version) {
+		prev = &((*prev)->next);
+	}
+	tn->next = (*prev);
+        *prev = tn;
+}
+
+/* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
+   with this ino, returning the former in order of version */
+
+int jffs2_get_inode_nodes(struct jffs2_sb_info *c, ino_t ino, struct jffs2_inode_info *f,
+			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
+			  __u32 *highest_version)
+{
+	struct jffs2_raw_node_ref *ref = f->inocache->nodes;
+	struct jffs2_tmp_dnode_info *tn, *ret_tn = NULL;
+	struct jffs2_full_dirent *fd, *ret_fd = NULL;
+
+	union jffs2_node_union node;
+	size_t retlen;
+	int err;
+
+	D1(printk(KERN_DEBUG "jffs2_get_inode_nodes(): ino #%lu\n", ino));
+	if (!f->inocache->nodes) {
+		printk(KERN_WARNING "Eep. no nodes for ino #%lu\n", ino);
+	}
+	for (ref = f->inocache->nodes; ref && ref->next_in_ino; ref = ref->next_in_ino) {
+		/* Work out whether it's a data node or a dirent node */
+		if (ref->flash_offset & 1) {
+			/* FIXME: On NAND flash we may need to read these */
+			D1(printk(KERN_DEBUG "node at 0x%08x is obsoleted. Ignoring.\n", ref->flash_offset &~3));
+			continue;
+		}
+		err = c->mtd->read(c->mtd, (ref->flash_offset & ~3), sizeof(node), &retlen, (void *)&node);
+		if (err) {
+			printk(KERN_WARNING "error %d reading node at 0x%08x in get_inode_nodes()\n", err, (ref->flash_offset) & ~3);
+			goto free_out;
+		}
+			
+
+			/* Check we've managed to read at least the common node header */
+		if (retlen < sizeof(node.u)) {
+			printk(KERN_WARNING "short read in get_inode_nodes()\n");
+			err = -EIO;
+			goto free_out;
+		}
+			
+		switch (node.u.nodetype) {
+		case JFFS2_NODETYPE_DIRENT:
+			D1(printk(KERN_DEBUG "Node at %08x is a dirent node\n", ref->flash_offset &~3));
+			if (retlen < sizeof(node.d)) {
+				printk(KERN_WARNING "short read in get_inode_nodes()\n");
+				err = -EIO;
+				goto free_out;
+			}
+			if (node.d.version > *highest_version)
+				*highest_version = node.d.version;
+			if (ref->flash_offset & 1) {
+				/* Obsoleted */
+				continue;
+			}
+			fd = jffs2_alloc_full_dirent(node.d.nsize+1);
+			if (!fd) {
+				err = -ENOMEM;
+				goto free_out;
+			}
+			memset(fd,0,sizeof(struct jffs2_full_dirent) + node.d.nsize+1);
+			fd->raw = ref;
+			fd->version = node.d.version;
+			fd->ino = node.d.ino;
+			fd->type = node.d.type;
+				/* memcpy as much of the name as possible from the raw
+				   dirent we've already read from the flash
+				*/
+			if (retlen > sizeof(struct jffs2_raw_dirent))
+				memcpy(&fd->name[0], &node.d.name[0], min(node.d.nsize, retlen-sizeof(struct jffs2_raw_dirent)));
+				
+				/* Do we need to copy any more of the name directly
+				   from the flash?
+				*/
+			if (node.d.nsize + sizeof(struct jffs2_raw_dirent) > retlen) {
+				int already = retlen - sizeof(struct jffs2_raw_dirent);
+					
+				err = c->mtd->read(c->mtd, (ref->flash_offset & ~3) + retlen, 
+						   node.d.nsize - already, &retlen, &fd->name[already]);
+				if (!err && retlen != node.d.nsize - already)
+					err = -EIO;
+					
+				if (err) {
+					printk(KERN_WARNING "Read remainder of name in jffs2_get_inode_nodes(): error %d\n", err);
+					jffs2_free_full_dirent(fd);
+					goto free_out;
+				}
+			}
+			fd->nhash = full_name_hash(fd->name, node.d.nsize);
+			fd->next = NULL;
+				/* Wheee. We now have a complete jffs2_full_dirent structure, with
+				   the name in it and everything. Link it into the list 
+				*/
+			D1(printk(KERN_DEBUG "Adding fd \"%s\", ino #%u\n", fd->name, fd->ino));
+			jffs2_add_fd_to_list(c, fd, &ret_fd);
+			break;
+
+		case JFFS2_NODETYPE_INODE:
+			D1(printk(KERN_DEBUG "Node at %08x is a data node\n", ref->flash_offset &~3));
+			if (retlen < sizeof(node.i)) {
+				printk(KERN_WARNING "read too short for dnode\n");
+				err = -EIO;
+				goto free_out;
+			}
+			if (node.d.version > *highest_version)
+				*highest_version = node.i.version;
+			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n", node.d.version, *highest_version));
+
+			if (ref->flash_offset & 1) {
+				D1(printk(KERN_DEBUG "obsoleted\n"));
+				/* Obsoleted */
+				continue;
+			}
+			tn = jffs2_alloc_tmp_dnode_info();
+			if (!tn) {
+				D1(printk(KERN_DEBUG "alloc tn failed\n"));
+				err = -ENOMEM;
+				goto free_out;
+			}
+
+			tn->fn = jffs2_alloc_full_dnode();
+			if (!tn->fn) {
+				D1(printk(KERN_DEBUG "alloc fn failed\n"));
+				err = -ENOMEM;
+				jffs2_free_tmp_dnode_info(tn);
+				goto free_out;
+			}
+			tn->version = node.i.version;
+			tn->fn->ofs = node.i.offset;
+			tn->fn->size = node.i.dsize;
+			tn->fn->raw = ref;
+			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n", ref->flash_offset &~3, node.i.version, node.i.offset, node.i.dsize));
+			jffs2_add_tn_to_list(tn, &ret_tn);
+			break;
+
+		default:
+			switch(node.u.nodetype & JFFS2_COMPAT_MASK) {
+			case JFFS2_FEATURE_INCOMPAT:
+				printk(KERN_NOTICE "Unknown INCOMPAT nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
+				break;
+			case JFFS2_FEATURE_ROCOMPAT:
+				printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
+				break;
+			case JFFS2_FEATURE_RWCOMPAT_COPY:
+				printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
+				break;
+			case JFFS2_FEATURE_RWCOMPAT_DELETE:
+				printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
+				break;
+			}
+		}
+	}
+	*tnp = ret_tn;
+	*fdp = ret_fd;
+	return 0;
+
+ free_out:
+	jffs2_free_tmp_dnode_info_list(ret_tn);
+	jffs2_free_full_dirent_list(ret_fd);
+	return err;
+}
+
+struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, int ino)
+{
+	struct jffs2_inode_cache *ret;
+
+	D2(printk(KERN_DEBUG "jffs2_get_ino_cache(): ino %u\n", ino));
+	spin_lock (&c->inocache_lock);
+	ret = c->inocache_list[ino % INOCACHE_HASHSIZE];
+	while (ret && ret->ino < ino) {
+		ret = ret->next;
+	}
+
+	spin_unlock(&c->inocache_lock);
+
+	if (ret && ret->ino != ino)
+		ret = NULL;
+
+	D2(printk(KERN_DEBUG "jffs2_get_ino_cache found %p for ino %u\n", ret, ino));
+	return ret;
+}
+
+void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)
+{
+	struct jffs2_inode_cache **prev;
+	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
+	spin_lock(&c->inocache_lock);
+	
+	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
+
+	while ((*prev) && (*prev)->ino < new->ino) {
+		prev = &(*prev)->next;
+	}
+	new->next = *prev;
+	*prev = new;
+	spin_unlock(&c->inocache_lock);
+}
+
+void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
+{
+	struct jffs2_inode_cache **prev;
+	D2(printk(KERN_DEBUG "jffs2_del_ino_cache: Del %p (ino #%u)\n", old, old->ino));
+	spin_lock(&c->inocache_lock);
+	
+	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
+	
+	while ((*prev) && (*prev)->ino < old->ino) {
+		prev = &(*prev)->next;
+	}
+	if ((*prev) == old) {
+		*prev = old->next;
+	}
+	spin_unlock(&c->inocache_lock);
+}
+
+void jffs2_free_ino_caches(struct jffs2_sb_info *c)
+{
+	int i;
+	struct jffs2_inode_cache *this, *next;
+	
+	for (i=0; i<INOCACHE_HASHSIZE; i++) {
+		this = c->inocache_list[i];
+		while (this) {
+			next = this->next;
+			D2(printk(KERN_DEBUG "jffs2_free_ino_caches: Freeing ino #%u at %p\n", this->ino, this));
+			jffs2_free_inode_cache(this);
+			this = next;
+		}
+		c->inocache_list[i] = NULL;
+	}
+}
+
+void jffs2_free_raw_node_refs(struct jffs2_sb_info *c)
+{
+	int i;
+	struct jffs2_raw_node_ref *this, *next;
+
+	for (i=0; i<c->nr_blocks; i++) {
+		this = c->blocks[i].first_node;
+		while(this) {
+			next = this->next_phys;
+			jffs2_free_raw_node_ref(this);
+			this = next;
+		}
+		c->blocks[i].first_node = c->blocks[i].last_node = NULL;
+	}
+}
+	
diff -Naur linux-2.4.2.orig/fs/jffs2/nodelist.h linux-2.4.2/fs/jffs2/nodelist.h
--- linux-2.4.2.orig/fs/jffs2/nodelist.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/nodelist.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,354 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: nodelist.h,v 1.45 2001/03/20 17:43:57 dwmw2 Exp $
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/fs.h>
+
+#include <linux/jffs2_fs_sb.h>
+#include <linux/jffs2_fs_i.h>
+
+#ifndef CONFIG_JFFS2_FS_DEBUG
+#define CONFIG_JFFS2_FS_DEBUG 2
+#endif
+
+#if CONFIG_JFFS2_FS_DEBUG > 0
+#define D1(x) x
+#else
+#define D1(x)
+#endif
+
+#if CONFIG_JFFS2_FS_DEBUG > 1
+#define D2(x) x
+#else
+#define D2(x)
+#endif
+
+/*
+  This is all we need to keep in-core for each raw node during normal
+  operation. As and when we do read_inode on a particular inode, we can
+  scan the nodes which are listed for it and build up a proper map of 
+  which nodes are currently valid. JFFSv1 always used to keep that whole
+  map in core for each inode.
+*/
+struct jffs2_raw_node_ref
+{
+	struct jffs2_raw_node_ref *next_in_ino; /* Points to the next raw_node_ref
+		for this inode. If this is the last, it points to the inode_cache
+		for this inode instead. The inode_cache will have NULL in the first
+		word so you know when you've got there :) */
+	struct jffs2_raw_node_ref *next_phys;
+	//	__u32 ino;
+	__u32 flash_offset;
+	__u32 totlen;
+//	__u16 nodetype;
+	
+        /* flash_offset & 3 always has to be zero, because nodes are
+	   always aligned at 4 bytes. So we have a couple of extra bits
+	   to play with. So we set the least significant bit to 1 to
+	   signify that the node is obsoleted by later nodes.
+	*/
+};
+
+/* 
+   Used for keeping track of deletion nodes &c, which can only be marked
+   as obsolete when the node which they mark as deleted has actually been 
+   removed from the flash.
+*/
+struct jffs2_raw_node_ref_list {
+	struct jffs2_raw_node_ref *rew;
+	struct jffs2_raw_node_ref_list *next;
+};
+
+/* For each inode in the filesystem, we need to keep a record of
+   nlink, because it would be a PITA to scan the whole directory tree
+   at read_inode() time to calculate it, and to keep sufficient information
+   in the raw_node_ref (basically both parent and child inode number for 
+   dirent nodes) would take more space than this does. We also keep
+   a pointer to the first physical node which is part of this inode, too.
+*/
+struct jffs2_inode_cache {
+	struct jffs2_scan_info *scan; /* Used during scan to hold
+		temporary lists of nodes, and later must be set to
+		NULL to mark the end of the raw_node_ref->next_in_ino
+		chain. */
+	struct jffs2_inode_cache *next;
+	struct jffs2_raw_node_ref *nodes;
+	__u32 ino;
+	int nlink;
+};
+
+struct jffs2_scan_info {
+	struct jffs2_full_dirent *dents;
+	struct jffs2_tmp_dnode_info *tmpnodes;
+};
+/*
+  Larger representation of a raw node, kept in-core only when the 
+  struct inode for this particular ino is instantiated.
+*/
+
+struct jffs2_full_dnode
+{
+	struct jffs2_raw_node_ref *raw;
+	__u32 ofs; /* Don't really need this, but optimisation */
+	__u32 size;
+	__u32 frags; /* Number of fragments which currently refer
+			to this node. When this reaches zero, 
+			the node is obsolete.
+		     */
+};
+
+/* 
+   Even larger representation of a raw node, kept in-core only while
+   we're actually building up the original map of which nodes go where,
+   in read_inode()
+*/
+struct jffs2_tmp_dnode_info
+{
+	struct jffs2_tmp_dnode_info *next;
+	struct jffs2_full_dnode *fn;
+	__u32 version;
+};       
+
+struct jffs2_full_dirent
+{
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dirent *next;
+	__u32 version;
+	__u32 ino; /* == zero for unlink */
+	unsigned int nhash;
+	unsigned char type;
+	unsigned char name[0];
+};
+/*
+  Fragments - used to build a map of which raw node to obtain 
+  data from for each part of the ino
+*/
+struct jffs2_node_frag
+{
+	struct jffs2_node_frag *next;
+	struct jffs2_full_dnode *node; /* NULL for holes */
+	__u32 size;
+	__u32 ofs; /* Don't really need this, but optimisation */
+	__u32 node_ofs; /* offset within the physical node */
+};
+
+struct jffs2_eraseblock
+{
+	struct list_head list;
+	int bad_count;
+	__u32 offset;		/* of this block in the MTD */
+
+	__u32 used_size;
+	__u32 dirty_size;
+	__u32 free_size;	/* Note that sector_size - free_size
+				   is the address of the first free space */
+	struct jffs2_raw_node_ref *first_node;
+	struct jffs2_raw_node_ref *last_node;
+
+	struct jffs2_raw_node_ref *gc_node;	/* Next node to be garbage collected */
+
+	/* For deletia. When a dirent node in this eraseblock is
+	   deleted by a node elsewhere, that other node can only 
+	   be marked as obsolete when this block is actually erased.
+	   So we keep a list of the nodes to mark as obsolete when
+	   the erase is completed.
+	*/
+	// MAYBE	struct jffs2_raw_node_ref_list *deletia;
+};
+
+#define ACCT_SANITY_CHECK(c, jeb) do { \
+	if (jeb->used_size + jeb->dirty_size + jeb->free_size != c->sector_size) { \
+		printk(KERN_NOTICE "Eeep. Space accounting for block at 0x%08x is screwed\n", jeb->offset); \
+		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x != total %08x\n", \
+		jeb->free_size, jeb->dirty_size, jeb->used_size, c->sector_size); \
+		BUG(); \
+	} \
+	if (c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size != c->flash_size) { \
+		printk(KERN_NOTICE "Eeep. Space accounting superblock info is screwed\n"); \
+		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x + erasing %08x + bad %08x != total %08x\n", \
+		c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size, c->flash_size); \
+		BUG(); \
+	} \
+} while(0)
+
+#define ACCT_PARANOIA_CHECK(jeb) do { \
+		__u32 my_used_size = 0; \
+		struct jffs2_raw_node_ref *ref2 = jeb->first_node; \
+		while (ref2) { \
+			if (!(ref2->flash_offset & 1)) \
+				my_used_size += ref2->totlen; \
+			ref2 = ref2->next_phys; \
+		} \
+		if (my_used_size != jeb->used_size) { \
+			printk(KERN_NOTICE "Calculated used size %08x != stored used size %08x\n", my_used_size, jeb->used_size); \
+			BUG(); \
+		} \
+	} while(0)
+
+#define ALLOC_NORMAL	0	/* Normal allocation */
+#define ALLOC_DELETION	1	/* Deletion node. Best to allow it */
+#define ALLOC_GC	2	/* Space requested for GC. Give it or die */
+
+#define JFFS2_RESERVED_BLOCKS_BASE 0						/* Number of free blocks there must be before we... */
+#define JFFS2_RESERVED_BLOCKS_WRITE (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem write */
+#define JFFS2_RESERVED_BLOCKS_DELETION 0 //(JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem deletion */
+#define JFFS2_RESERVED_BLOCKS_GCTRIGGER (JFFS2_RESERVED_BLOCKS_BASE + 2)	/* ... wake up the GC thread */
+#define JFFS2_RESERVED_BLOCKS_GCBAD (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... pick a block from the bad_list to GC */
+#define JFFS2_RESERVED_BLOCKS_GCMERGE (JFFS2_RESERVED_BLOCKS_BASE)		/* ... merge pages when garbage collecting */
+
+
+#define PAD(x) (((x)+3)&~3)
+
+/* These probably ought to be somewhere central. */
+#define min(x,y) ({ typeof((x)) _x = (x); typeof((y)) _y = (y); (_x>_y)?_y:_x; })
+#define max(x,y) ({ typeof((x)) _x = (x); typeof((y)) _y = (y); (_x>_y)?_x:_y; })
+
+static inline int jffs2_raw_ref_to_inum(struct jffs2_raw_node_ref *raw)
+{
+	while(raw->next_in_ino) {
+		raw = raw->next_in_ino;
+	}
+
+	return ((struct jffs2_inode_cache *)raw)->ino;
+}
+
+/* nodelist.c */
+D1(void jffs2_print_frag_list(struct jffs2_inode_info *f));
+void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list);
+void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct jffs2_tmp_dnode_info **list);
+int jffs2_get_inode_nodes(struct jffs2_sb_info *c, ino_t ino, struct jffs2_inode_info *f,
+			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
+			  __u32 *highest_version);
+struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, int ino);
+void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new);
+void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old);
+void jffs2_free_ino_caches(struct jffs2_sb_info *c);
+void jffs2_free_raw_node_refs(struct jffs2_sb_info *c);
+
+/* nodemgmt.c */
+int jffs2_reserve_space(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len, int prio);
+int jffs2_reserve_space_gc(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len);
+int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new, __u32 len, int dirty);
+void jffs2_complete_reservation(struct jffs2_sb_info *c);
+void jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *raw);
+
+/* write.c */
+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri);
+struct jffs2_full_dnode *jffs2_write_dnode(struct inode *inode, struct jffs2_raw_inode *ri, const unsigned char *data, __u32 datalen, __u32 flash_ofs,  __u32 *writelen);
+struct jffs2_full_dirent *jffs2_write_dirent(struct inode *inode, struct jffs2_raw_dirent *rd, const unsigned char *name, __u32 namelen, __u32 flash_ofs,  __u32 *writelen);
+
+/* readinode.c */
+void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_node_frag **list, __u32 size);
+int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, struct jffs2_node_frag **list, struct jffs2_full_dnode *fn);
+int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn);
+void jffs2_read_inode (struct inode *);
+void jffs2_clear_inode (struct inode *);
+
+/* malloc.c */
+void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn);
+void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd);
+
+int jffs2_create_slab_caches(void);
+void jffs2_destroy_slab_caches(void);
+
+struct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize);
+void jffs2_free_full_dirent(struct jffs2_full_dirent *);
+struct jffs2_full_dnode *jffs2_alloc_full_dnode(void);
+void jffs2_free_full_dnode(struct jffs2_full_dnode *);
+struct jffs2_raw_dirent *jffs2_alloc_raw_dirent(void);
+void jffs2_free_raw_dirent(struct jffs2_raw_dirent *);
+struct jffs2_raw_inode *jffs2_alloc_raw_inode(void);
+void jffs2_free_raw_inode(struct jffs2_raw_inode *);
+struct jffs2_tmp_dnode_info *jffs2_alloc_tmp_dnode_info(void);
+void jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *);
+struct jffs2_raw_node_ref *jffs2_alloc_raw_node_ref(void);
+void jffs2_free_raw_node_ref(struct jffs2_raw_node_ref *);
+struct jffs2_node_frag *jffs2_alloc_node_frag(void);
+void jffs2_free_node_frag(struct jffs2_node_frag *);
+struct jffs2_inode_cache *jffs2_alloc_inode_cache(void);
+void jffs2_free_inode_cache(struct jffs2_inode_cache *);
+
+/* gc.c */
+int jffs2_garbage_collect_pass(struct jffs2_sb_info *c);
+
+/* background.c */
+int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);
+
+/* dir.c */
+extern struct file_operations jffs2_dir_operations;
+extern struct inode_operations jffs2_dir_inode_operations;
+
+/* file.c */
+extern struct file_operations jffs2_file_operations;
+extern struct inode_operations jffs2_file_inode_operations;
+extern struct address_space_operations jffs2_file_address_operations;
+int jffs2_null_fsync(struct file *, struct dentry *, int);
+int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
+int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
+int jffs2_do_readpage_unlock (struct inode *inode, struct page *pg);
+int jffs2_readpage (struct file *, struct page *);
+int jffs2_prepare_write (struct file *, struct page *, unsigned, unsigned);
+int jffs2_commit_write (struct file *, struct page *, unsigned, unsigned);
+
+/* ioctl.c */
+int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+
+/* read.c */
+int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_full_dnode *fd, unsigned char *buf, int ofs, int len);
+
+/* compr.c */
+unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
+			     __u32 *datalen, __u32 *cdatalen);
+int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen);
+
+/* scan.c */
+int jffs2_scan_medium(struct jffs2_sb_info *c);
+
+/* build.c */
+int jffs2_build_filesystem(struct jffs2_sb_info *c);
+
+/* symlink.c */
+extern struct inode_operations jffs2_symlink_inode_operations;
+
+/* erase.c */
+void jffs2_erase_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
+void jffs2_erase_pending_blocks(struct jffs2_sb_info *c);
+void jffs2_mark_erased_blocks(struct jffs2_sb_info *c);
+void jffs2_erase_pending_trigger(struct jffs2_sb_info *c);
diff -Naur linux-2.4.2.orig/fs/jffs2/nodemgmt.c linux-2.4.2/fs/jffs2/nodemgmt.c
--- linux-2.4.2.orig/fs/jffs2/nodemgmt.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/nodemgmt.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,380 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: nodemgmt.c,v 1.39 2001/04/11 22:20:26 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include "nodelist.h"
+
+/**
+ *	jffs2_reserve_space - request physical space to write nodes to flash
+ *	@c: superblock info
+ *	@minsize: Minimum acceptable size of allocation
+ *	@ofs: Returned value of node offset
+ *	@len: Returned value of allocation length
+ *	@prio: Allocation type - ALLOC_{NORMAL,DELETION}
+ *
+ *	Requests a block of physical space on the flash. Returns zero for success
+ *	and puts 'ofs' and 'len' into the appriopriate place, or returns -ENOSPC
+ *	or other error if appropriate.
+ *
+ *	If it returns zero, jffs2_reserve_space() also downs the per-filesystem
+ *	allocation semaphore, to prevent more than one allocation from being
+ *	active at any time. The semaphore is later released by jffs2_commit_allocation()
+ *
+ *	jffs2_reserve_space() may trigger garbage collection in order to make room
+ *	for the requested allocation.
+ */
+
+static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  __u32 minsize, __u32 *ofs, __u32 *len);
+
+int jffs2_reserve_space(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len, int prio)
+{
+	int ret = -EAGAIN;
+	int blocksneeded = JFFS2_RESERVED_BLOCKS_WRITE;
+	/* align it */
+	minsize = PAD(minsize);
+
+	if (prio == ALLOC_DELETION)
+		blocksneeded = JFFS2_RESERVED_BLOCKS_DELETION;
+
+	D1(printk(KERN_DEBUG "jffs2_reserve_space(): Requested 0x%x bytes\n", minsize));
+	down(&c->alloc_sem);
+
+	D1(printk(KERN_DEBUG "jffs2_reserve_space(): alloc sem got\n"));
+
+	spin_lock_bh(&c->erase_completion_lock);
+
+	/* this needs a little more thought */
+	while(ret == -EAGAIN) {
+		while(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {
+			int ret;
+
+			up(&c->alloc_sem);
+			if (c->dirty_size < c->sector_size) {
+				D1(printk(KERN_DEBUG "Short on space, but total dirty size 0x%08x < sector size 0x%08x, so -ENOSPC\n", c->dirty_size, c->sector_size));
+				spin_unlock_bh(&c->erase_completion_lock);
+				return -ENOSPC;
+			}
+			D1(printk(KERN_DEBUG "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",
+				  c->nr_free_blocks, c->nr_erasing_blocks, c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,
+				  c->free_size + c->dirty_size + c->used_size + c->erasing_size + c->bad_size, c->flash_size));
+			spin_unlock_bh(&c->erase_completion_lock);
+			
+			ret = jffs2_garbage_collect_pass(c);
+			if (ret)
+				return ret;
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+			if(current->need_resched) {
+				schedule();
+			}
+			down(&c->alloc_sem);
+			spin_lock_bh(&c->erase_completion_lock);
+		}
+
+		ret = jffs2_do_reserve_space(c, minsize, ofs, len);
+		if (ret) {
+			D1(printk(KERN_DEBUG "jffs2_reserve_space: ret is %d\n", ret));
+		}
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	if (ret)
+		up(&c->alloc_sem);
+	return ret;
+}
+
+int jffs2_reserve_space_gc(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len)
+{
+	int ret = -EAGAIN;
+	minsize = PAD(minsize);
+
+	D1(printk(KERN_DEBUG "jffs2_reserve_space_gc(): Requested 0x%x bytes\n", minsize));
+
+	spin_lock_bh(&c->erase_completion_lock);
+	while(ret == -EAGAIN) {
+		ret = jffs2_do_reserve_space(c, minsize, ofs, len);
+		if (ret) {
+		        D1(printk(KERN_DEBUG "jffs2_reserve_space_gc: looping, ret is %d\n", ret));
+		}
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	return ret;
+}
+
+/* Called with alloc sem _and_ erase_completion_lock */
+static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  __u32 minsize, __u32 *ofs, __u32 *len)
+{
+	struct jffs2_eraseblock *jeb = c->nextblock;
+	
+ restart:
+	if (jeb && minsize > jeb->free_size) {
+		/* Skip the end of this block and file it as having some dirty space */
+		c->dirty_size += jeb->free_size;
+		c->free_size -= jeb->free_size;
+		jeb->dirty_size += jeb->free_size;
+		jeb->free_size = 0;
+		D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
+			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
+		list_add_tail(&jeb->list, &c->dirty_list);
+		c->nextblock = jeb = NULL;
+	}
+	
+	if (!jeb) {
+		struct list_head *next;
+		/* Take the next block off the 'free' list */
+
+		if (list_empty(&c->free_list)) {
+
+			DECLARE_WAITQUEUE(wait, current);
+			
+			if (!c->nr_erasing_blocks) {
+//			if (list_empty(&c->erasing_list) && list_empty(&c->erase_pending_list) && list_empty(c->erase_complete_list)) {
+				/* Ouch. We're in GC, or we wouldn't have got here.
+				   And there's no space left. At all. */
+				printk(KERN_CRIT "Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasingempty: %s, erasependingempty: %s)\n", 
+				       c->nr_erasing_blocks, c->nr_free_blocks, list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no");
+				return -ENOSPC;
+			}
+			/* Make sure this can't deadlock. Someone has to start the erases
+			   of erase_pending blocks */
+			set_current_state(TASK_INTERRUPTIBLE);
+			add_wait_queue(&c->erase_wait, &wait);
+			D1(printk(KERN_DEBUG "Waiting for erases to complete. erasing_blocks is %d. (erasingempty: %s, erasependingempty: %s)\n", 
+				  c->nr_erasing_blocks, list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no"));
+			if (!list_empty(&c->erase_pending_list)) {
+				D1(printk(KERN_DEBUG "Triggering pending erases\n"));
+				jffs2_erase_pending_trigger(c);
+			}
+			spin_unlock_bh(&c->erase_completion_lock);
+			schedule();
+			remove_wait_queue(&c->erase_wait, &wait);
+			spin_lock_bh(&c->erase_completion_lock);
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+			/* An erase may have failed, decreasing the
+			   amount of free space available. So we must
+			   restart from the beginning */
+			return -EAGAIN;
+		}
+
+		next = c->free_list.next;
+		list_del(next);
+		c->nextblock = jeb = list_entry(next, struct jffs2_eraseblock, list);
+		c->nr_free_blocks--;
+		if (jeb->free_size != c->sector_size - sizeof(struct jffs2_unknown_node)) {
+			printk(KERN_WARNING "Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\n", jeb->offset, jeb->free_size);
+			goto restart;
+		}
+	}
+	/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has
+	   enough space */
+	*ofs = jeb->offset + (c->sector_size - jeb->free_size);
+	*len = jeb->free_size;
+	D1(printk(KERN_DEBUG "jffs2_do_reserve_space(): Giving 0x%x bytes at 0x%x\n", *len, *ofs));
+	return 0;
+}
+
+/**
+ *	jffs2_add_physical_node_ref - add a physical node reference to the list
+ *	@c: superblock info
+ *	@ofs: physical location of this physical node
+ *	@len: length of this physical node
+ *	@ino: inode number with which this physical node is associated
+ *
+ *	Should only be used to report nodes for which space has been allocated 
+ *	by jffs2_reserve_space.
+ *
+ *	Must be called with the alloc_sem held.
+ */
+ 
+int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new, __u32 len, int dirty)
+{
+	struct jffs2_eraseblock *jeb;
+
+	len = PAD(len);
+	jeb = &c->blocks[(new->flash_offset & ~3) / c->sector_size];
+	D1(printk(KERN_DEBUG "jffs2_add_physical_node_ref(): Node at 0x%x, size 0x%x\n", new->flash_offset & ~3, len));
+#if 1
+	if (jeb != c->nextblock || (new->flash_offset & ~3) != jeb->offset + (c->sector_size - jeb->free_size)) {
+		printk(KERN_WARNING "argh. node added in wrong place\n");
+		jffs2_free_raw_node_ref(new);
+		return -EINVAL;
+	}
+#endif
+	if (!jeb->first_node)
+		jeb->first_node = new;
+	if (jeb->last_node)
+		jeb->last_node->next_phys = new;
+	jeb->last_node = new;
+
+	spin_lock_bh(&c->erase_completion_lock);
+	jeb->free_size -= len;
+	c->free_size -= len;
+	if (dirty) {
+		new->flash_offset |= 1;
+		jeb->dirty_size += len;
+		c->dirty_size += len;
+	} else {
+		jeb->used_size += len;
+		c->used_size += len;
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+	if (!jeb->free_size && !jeb->dirty_size) {
+		/* If it lives on the dirty_list, jffs2_reserve_space will put it there */
+		D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
+			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
+		list_add_tail(&jeb->list, &c->clean_list);
+		c->nextblock = NULL;
+	}
+	ACCT_SANITY_CHECK(c,jeb);
+	ACCT_PARANOIA_CHECK(jeb);
+
+	return 0;
+}
+
+
+void jffs2_complete_reservation(struct jffs2_sb_info *c)
+{
+	D1(printk(KERN_DEBUG "jffs2_complete_reservation()\n"));
+	jffs2_garbage_collect_trigger(c);
+	up(&c->alloc_sem);
+}
+
+void jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)
+{
+	struct jffs2_eraseblock *jeb;
+	int blocknr;
+	struct jffs2_unknown_node n;
+	int ret;
+	ssize_t retlen;
+
+	if(!ref) {
+		printk(KERN_NOTICE "EEEEEK. jffs2_mark_node_obsolete called with NULL node\n");
+		return;
+	}
+	if (ref->flash_offset & 1) {
+		D1(printk(KERN_DEBUG "jffs2_mark_node_obsolete called with already obsolete node at 0x%08x\n", ref->flash_offset &~3));
+		return;
+	}
+	blocknr = ref->flash_offset / c->sector_size;
+	if (blocknr >= c->nr_blocks) {
+		printk(KERN_NOTICE "raw node at 0x%08x is off the end of device!\n", ref->flash_offset);
+		BUG();
+	}
+	jeb = &c->blocks[blocknr];
+	if (jeb->used_size < ref->totlen) {
+		printk(KERN_NOTICE "raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\n",
+		       ref->totlen, blocknr, ref->flash_offset, jeb->used_size);
+		BUG();
+	}
+
+	spin_lock_bh(&c->erase_completion_lock);
+	jeb->used_size -= ref->totlen;
+	jeb->dirty_size += ref->totlen;
+	c->used_size -= ref->totlen;
+	c->dirty_size += ref->totlen;
+	ref->flash_offset |= 1;
+	
+	ACCT_SANITY_CHECK(c, jeb);
+
+	ACCT_PARANOIA_CHECK(jeb);
+
+	if (jeb == c->nextblock) {
+		D2(printk(KERN_DEBUG "Not moving nextblock 0x%08x to dirty/erase_pending list\n", jeb->offset));
+	} else if (jeb == c->gcblock) {
+		D2(printk(KERN_DEBUG "Not moving gcblock 0x%08x to dirty/erase_pending list\n", jeb->offset));
+#if 0 /* We no longer do this here. It can screw the wear levelling. If you have a lot of static
+	 data and a few blocks free, and you just create new files and keep deleting/overwriting
+	 them, then you'd keep erasing and reusing those blocks without ever moving stuff around.
+	 So we leave completely obsoleted blocks on the dirty_list and let the GC delete them 
+	 when it finds them there. That way, we still get the 'once in a while, take a clean block'
+	 to spread out the flash usage */
+	} else if (!jeb->used_size) {
+		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\n", jeb->offset));
+		list_del(&jeb->list);
+		D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
+		list_add_tail(&jeb->list, &c->erase_pending_list);
+		c->nr_erasing_blocks++;
+		jffs2_erase_pending_trigger(c);
+		//		OFNI_BS_2SFFJ(c)->s_dirt = 1;
+		D1(printk(KERN_DEBUG "Done OK\n"));
+#endif
+	} else if (jeb->dirty_size == ref->totlen) {
+		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\n", jeb->offset));
+		list_del(&jeb->list);
+		D1(printk(KERN_DEBUG "...and adding to dirty_list\n"));
+		list_add_tail(&jeb->list, &c->dirty_list);
+	}
+	spin_unlock_bh(&c->erase_completion_lock);
+
+	if (c->mtd->type != MTD_NORFLASH && c->mtd->type != MTD_RAM)
+		return;
+
+	D1(printk(KERN_DEBUG "obliterating obsoleted node at 0x%08x\n", ref->flash_offset &~3));
+	ret = c->mtd->read(c->mtd, ref->flash_offset &~3, sizeof(n), &retlen, (char *)&n);
+	if (ret) {
+		printk(KERN_WARNING "Read error reading from obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, ret);
+		return;
+	}
+	if (retlen != sizeof(n)) {
+		printk(KERN_WARNING "Short read from obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, retlen);
+		return;
+	}
+	if (PAD(n.totlen) != PAD(ref->totlen)) {
+		printk(KERN_WARNING "Node totlen on flash (0x%08x) != totlen in node ref (0x%08x)\n", n.totlen, ref->totlen);
+		return;
+	}
+	if (!(n.nodetype & JFFS2_NODE_ACCURATE)) {
+		D1(printk(KERN_DEBUG "Node at 0x%08x was already marked obsolete (nodetype 0x%04x\n", ref->flash_offset &~3, n.nodetype));
+		return;
+	}
+	n.nodetype &= ~JFFS2_NODE_ACCURATE;
+	ret = c->mtd->write(c->mtd, ref->flash_offset&~3, sizeof(n), &retlen, (char *)&n);
+	if (ret) {
+		printk(KERN_WARNING "Write error in obliterating obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, ret);
+		return;
+	}
+	if (retlen != sizeof(n)) {
+		printk(KERN_WARNING "Short write in obliterating obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, retlen);
+		return;
+	}
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/os-linux.h linux-2.4.2/fs/jffs2/os-linux.h
--- linux-2.4.2.orig/fs/jffs2/os-linux.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/os-linux.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,104 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2002 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: os-linux.h,v 1.5 2002/01/20 16:55:52 dwmw2 Exp $
+ *
+ */
+
+#ifndef __JFFS2_OS_LINUX_H__
+#define __JFFS2_OS_LINUX_H__
+
+#ifdef JFFS2_OUT_OF_KERNEL
+#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
+#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
+#else
+#define JFFS2_INODE_INFO(i) (&i->u.jffs2_i)
+#define JFFS2_SB_INFO(sb) (&sb->u.jffs2_sb)
+#endif
+
+#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
+#define OFNI_EDONI_2SFFJ(f)  ((struct inode *) ( ((char *)f) - ((char *)(&((struct inode *)NULL)->u)) ) )
+
+#define JFFS2_F_I_SIZE(f) (OFNI_EDONI_2SFFJ(f)->i_size)
+#define JFFS2_F_I_MODE(f) (OFNI_EDONI_2SFFJ(f)->i_mode)
+#define JFFS2_F_I_UID(f) (OFNI_EDONI_2SFFJ(f)->i_uid)
+#define JFFS2_F_I_GID(f) (OFNI_EDONI_2SFFJ(f)->i_gid)
+#define JFFS2_F_I_CTIME(f) (OFNI_EDONI_2SFFJ(f)->i_ctime)
+#define JFFS2_F_I_MTIME(f) (OFNI_EDONI_2SFFJ(f)->i_mtime)
+#define JFFS2_F_I_ATIME(f) (OFNI_EDONI_2SFFJ(f)->i_atime)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,1)
+#define JFFS2_F_I_RDEV_MIN(f) (minor(OFNI_EDONI_2SFFJ(f)->i_rdev))
+#define JFFS2_F_I_RDEV_MAJ(f) (major(OFNI_EDONI_2SFFJ(f)->i_rdev))
+#else
+#define JFFS2_F_I_RDEV_MIN(f) (MINOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
+#define JFFS2_F_I_RDEV_MAJ(f) (MAJOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
+#endif
+
+#define jffs2_is_readonly(c) (OFNI_BS_2SFFJ(c)->s_flags & MS_RDONLY)
+#define jffs2_can_mark_obsolete(c) (c->mtd->type == MTD_NORFLASH || c->mtd->type == MTD_RAM)
+
+#define jffs2_flash_write(c, ofs, len, retlen, buf) ((c)->mtd->write((c)->mtd, ofs, len, retlen, buf))
+#define jffs2_flash_read(c, ofs, len, retlen, buf) ((c)->mtd->read((c)->mtd, ofs, len, retlen, buf))
+
+/* background.c */
+int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);
+
+/* dir.c */
+extern struct file_operations jffs2_dir_operations;
+extern struct inode_operations jffs2_dir_inode_operations;
+
+/* file.c */
+extern struct file_operations jffs2_file_operations;
+extern struct inode_operations jffs2_file_inode_operations;
+extern struct address_space_operations jffs2_file_address_operations;
+int jffs2_null_fsync(struct file *, struct dentry *, int);
+int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
+int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
+int jffs2_do_readpage_unlock (struct inode *inode, struct page *pg);
+int jffs2_readpage (struct file *, struct page *);
+int jffs2_prepare_write (struct file *, struct page *, unsigned, unsigned);
+int jffs2_commit_write (struct file *, struct page *, unsigned, unsigned);
+
+/* ioctl.c */
+int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+
+/* symlink.c */
+extern struct inode_operations jffs2_symlink_inode_operations;
+
+/* super.c */
+
+
+#endif /* __JFFS2_OS_LINUX_H__ */
diff -Naur linux-2.4.2.orig/fs/jffs2/pushpull.c linux-2.4.2/fs/jffs2/pushpull.c
--- linux-2.4.2.orig/fs/jffs2/pushpull.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/pushpull.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,88 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: pushpull.c,v 1.6 2001/03/15 15:38:24 dwmw2 Exp $
+ *
+ */
+
+#include <linux/string.h>
+#include "pushpull.h"
+#include <linux/errno.h>
+
+void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
+{
+	pp->buf = buf;
+	pp->buflen = buflen;
+	pp->ofs = ofs;
+	pp->reserve = reserve;
+}
+     
+
+int pushbit(struct pushpull *pp, int bit, int use_reserved)
+{
+	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
+		return -ENOSPC;
+	}
+
+	if (bit) {
+		pp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs &7)));
+	}
+	else {
+		pp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs &7)));
+	}
+	pp->ofs++;
+
+	return 0;
+}
+
+int pushedbits(struct pushpull *pp)
+{
+	return pp->ofs;
+}
+	
+
+int pullbit(struct pushpull *pp)
+{
+	int bit;
+
+	bit = (pp->buf[pp->ofs >> 3] >> (7-(pp->ofs & 7))) & 1;
+
+	pp->ofs++;
+	return bit;
+}
+
+int pulledbits (struct pushpull *pp)
+{
+	return pp->ofs;
+}
+     
diff -Naur linux-2.4.2.orig/fs/jffs2/pushpull.h linux-2.4.2/fs/jffs2/pushpull.h
--- linux-2.4.2.orig/fs/jffs2/pushpull.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/pushpull.h	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,53 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: pushpull.h,v 1.4 2001/03/15 15:38:24 dwmw2 Exp $
+ *
+ */
+
+#ifndef __PUSHPULL_H__
+#define __PUSHPULL_H__
+struct pushpull {
+	unsigned char *buf;
+	unsigned int buflen;
+	unsigned int ofs;
+	unsigned int reserve;
+};
+
+void init_pushpull(struct pushpull *, char *, unsigned, unsigned, unsigned);
+int pushbit(struct pushpull *pp, int bit, int use_reserved);
+int pushedbits(struct pushpull *pp);
+int pullbit(struct pushpull *pp);
+int pulledbits(struct pushpull *);
+
+#endif /* __PUSHPULL_H__ */
diff -Naur linux-2.4.2.orig/fs/jffs2/read.c linux-2.4.2/fs/jffs2/read.c
--- linux-2.4.2.orig/fs/jffs2/read.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/read.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,157 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: read.c,v 1.13 2001/05/01 16:24:44 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_full_dnode *fd, unsigned char *buf, int ofs, int len)
+{
+	struct jffs2_raw_inode *ri;
+	size_t readlen;
+	__u32 crc;
+	unsigned char *decomprbuf = NULL;
+	unsigned char *readbuf = NULL;
+	int ret = 0;
+
+	ri = jffs2_alloc_raw_inode();
+	if (!ri)
+		return -ENOMEM;
+
+	ret = c->mtd->read(c->mtd, fd->raw->flash_offset & ~3, sizeof(*ri), &readlen, (char *)ri);
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		printk(KERN_WARNING "Error reading node from 0x%08x: %d\n", fd->raw->flash_offset & ~3, ret);
+		return ret;
+	}
+	if (readlen != sizeof(*ri)) {
+		jffs2_free_raw_inode(ri);
+		printk(KERN_WARNING "Short read from 0x%08x: wanted 0x%x bytes, got 0x%x\n", 
+		       fd->raw->flash_offset & ~3, sizeof(*ri), readlen);
+		return -EIO;
+	}
+	crc = crc32(0, ri, sizeof(*ri)-8);
+
+	D1(printk(KERN_DEBUG "Node read from %08x: node_crc %08x, calculated CRC %08x. dsize %x, csize %x, offset %x, buf %p\n", fd->raw->flash_offset & ~3, ri->node_crc, crc, ri->dsize, ri->csize, ri->offset, buf));
+	if (crc != ri->node_crc) {
+		printk(KERN_WARNING "Node CRC %08x != calculated CRC %08x for node at %08x\n", ri->node_crc, crc, fd->raw->flash_offset & ~3);
+		ret = -EIO;
+		goto out_ri;
+	}
+
+	D1(if(ofs + len > ri->dsize) {
+		printk(KERN_WARNING "jffs2_read_dnode() asked for %d bytes at %d from %d-byte node\n", len, ofs, ri->dsize);
+		ret = -EINVAL;
+		goto out_ri;
+	});
+
+	
+	if (ri->compr == JFFS2_COMPR_ZERO) {
+		memset(buf, 0, len);
+		goto out_ri;
+	}
+
+	/* Cases:
+	   Reading whole node and it's uncompressed - read directly to buffer provided, check CRC.
+	   Reading whole node and it's compressed - read into comprbuf, check CRC and decompress to buffer provided 
+	   Reading partial node and it's uncompressed - read into readbuf, check CRC, and copy 
+	   Reading partial node and it's compressed - read into readbuf, check checksum, decompress to decomprbuf and copy
+	*/
+	if (ri->compr == JFFS2_COMPR_NONE && len == ri->dsize) {
+		readbuf = buf;
+	} else {
+		readbuf = kmalloc(ri->csize, GFP_KERNEL);
+		if (!readbuf) {
+			ret = -ENOMEM;
+			goto out_ri;
+		}
+	}
+	if (ri->compr != JFFS2_COMPR_NONE) {
+		if (len < ri->dsize) {
+			decomprbuf = kmalloc(ri->dsize, GFP_KERNEL);
+			if (!decomprbuf) {
+				ret = -ENOMEM;
+				goto out_readbuf;
+			}
+		} else {
+			decomprbuf = buf;
+		}
+	} else {
+		decomprbuf = readbuf;
+	}
+
+	D2(printk(KERN_DEBUG "Read %d bytes to %p\n", ri->csize, readbuf));
+	ret = c->mtd->read(c->mtd, (fd->raw->flash_offset &~3) + sizeof(*ri), ri->csize, &readlen, readbuf);
+
+	if (!ret && readlen != ri->csize)
+		ret = -EIO;
+	if (ret)
+		goto out_decomprbuf;
+
+	crc = crc32(0, readbuf, ri->csize);
+	if (crc != ri->data_crc) {
+		printk(KERN_WARNING "Data CRC %08x != calculated CRC %08x for node at %08x\n", ri->data_crc, crc, fd->raw->flash_offset & ~3);
+		ret = -EIO;
+		goto out_decomprbuf;
+	}
+	D2(printk(KERN_DEBUG "Data CRC matches calculated CRC %08x\n", crc));
+	if (ri->compr != JFFS2_COMPR_NONE) {
+		D2(printk(KERN_DEBUG "Decompress %d bytes from %p to %d bytes at %p\n", ri->csize, readbuf, ri->dsize, decomprbuf)); 
+		ret = jffs2_decompress(ri->compr, readbuf, decomprbuf, ri->csize, ri->dsize);
+		if (ret) {
+			printk(KERN_WARNING "Error: jffs2_decompress returned %d\n", ret);
+			goto out_decomprbuf;
+		}
+	}
+
+	if (len < ri->dsize) {
+		memcpy(buf, decomprbuf+ofs, len);
+	}
+ out_decomprbuf:
+	if(decomprbuf != buf && decomprbuf != readbuf)
+		kfree(decomprbuf);
+ out_readbuf:
+	if(readbuf != buf)
+		kfree(readbuf);
+ out_ri:
+	jffs2_free_raw_inode(ri);
+
+	return ret;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/readinode.c linux-2.4.2/fs/jffs2/readinode.c
--- linux-2.4.2.orig/fs/jffs2/readinode.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/readinode.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,494 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: readinode.c,v 1.56 2001/07/26 20:32:39 dwmw2 Exp $
+ *
+ */
+
+/* Given an inode, probably with existing list of fragments, add the new node
+ * to the fragment list.
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mtd/mtd.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+
+D1(void jffs2_print_frag_list(struct jffs2_inode_info *f)
+{
+	struct jffs2_node_frag *this = f->fraglist;
+
+	while(this) {
+		if (this->node)
+			printk(KERN_DEBUG "frag %04x-%04x: 0x%08x on flash (*%p->%p)\n", this->ofs, this->ofs+this->size, this->node->raw->flash_offset &~3, this, this->next);
+		else 
+			printk(KERN_DEBUG "frag %04x-%04x: hole (*%p->%p)\n", this->ofs, this->ofs+this->size, this, this->next);
+		this = this->next;
+	}
+	if (f->metadata) {
+		printk(KERN_DEBUG "metadata at 0x%08x\n", f->metadata->raw->flash_offset &~3);
+	}
+})
+
+
+int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)
+{
+	int ret;
+	D1(printk(KERN_DEBUG "jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)\n", f->inocache->ino, f, fn));
+
+	ret = jffs2_add_full_dnode_to_fraglist(c, &f->fraglist, fn);
+
+	D2(jffs2_print_frag_list(f));
+	return ret;
+}
+
+static void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
+{
+	if (this->node) {
+		this->node->frags--;
+		if (!this->node->frags) {
+			/* The node has no valid frags left. It's totally obsoleted */
+			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
+				  this->node->raw->flash_offset &~3, this->node->ofs, this->node->ofs+this->node->size));
+			jffs2_mark_node_obsolete(c, this->node->raw);
+			jffs2_free_full_dnode(this->node);
+		} else {
+			D2(printk(KERN_DEBUG "Not marking old node @0x%08x (0x%04x-0x%04x) obsolete. frags is %d\n",
+				  this->node->raw->flash_offset &~3, this->node->ofs, this->node->ofs+this->node->size,
+				  this->node->frags));
+		}
+		
+	}
+	jffs2_free_node_frag(this);
+}
+
+/* Doesn't set inode->i_size */
+int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, struct jffs2_node_frag **list, struct jffs2_full_dnode *fn)
+{
+	
+	struct jffs2_node_frag *this, **prev, *old;
+	struct jffs2_node_frag *newfrag, *newfrag2;
+	__u32 lastend = 0;
+
+
+	newfrag = jffs2_alloc_node_frag();
+	if (!newfrag) {
+		return -ENOMEM;
+	}
+
+	D2(if (fn->raw)
+		printk(KERN_DEBUG "adding node %04x-%04x @0x%08x on flash, newfrag *%p\n", fn->ofs, fn->ofs+fn->size, fn->raw->flash_offset &~3, newfrag);
+	else
+		printk(KERN_DEBUG "adding hole node %04x-%04x on flash, newfrag *%p\n", fn->ofs, fn->ofs+fn->size, newfrag));
+	
+	prev = list;
+	this = *list;
+
+	if (!fn->size) {
+		jffs2_free_node_frag(newfrag);
+		return 0;
+	}
+
+	newfrag->ofs = fn->ofs;
+	newfrag->size = fn->size;
+	newfrag->node = fn;
+	newfrag->node->frags = 1;
+	newfrag->next = (void *)0xdeadbeef;
+
+	/* Skip all the nodes which are completed before this one starts */
+	while(this && fn->ofs >= this->ofs+this->size) {
+		lastend = this->ofs + this->size;
+
+		D2(printk(KERN_DEBUG "j_a_f_d_t_f: skipping frag 0x%04x-0x%04x; phys 0x%08x (*%p->%p)\n", 
+			  this->ofs, this->ofs+this->size, this->node?(this->node->raw->flash_offset &~3):0xffffffff, this, this->next));
+		prev = &this->next;
+		this = this->next;
+	}
+
+	/* See if we ran off the end of the list */
+	if (!this) {
+		/* We did */
+		if (lastend < fn->ofs) {
+			/* ... and we need to put a hole in before the new node */
+			struct jffs2_node_frag *holefrag = jffs2_alloc_node_frag();
+			if (!holefrag)
+				return -ENOMEM;
+			holefrag->ofs = lastend;
+			holefrag->size = fn->ofs - lastend;
+			holefrag->next = NULL;
+			holefrag->node = NULL;
+			*prev = holefrag;
+			prev = &holefrag->next;
+		}
+		newfrag->next = NULL;
+		*prev = newfrag;
+		return 0;
+	}
+
+	D2(printk(KERN_DEBUG "j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p->%p)\n", 
+		  this->ofs, this->ofs+this->size, this->node?(this->node->raw->flash_offset &~3):0xffffffff, this, this->next));
+
+	/* OK. 'this' is pointing at the first frag that fn->ofs at least partially obsoletes,
+	 * - i.e. fn->ofs < this->ofs+this->size && fn->ofs >= this->ofs  
+	 */
+	if (fn->ofs > this->ofs) {
+		/* This node isn't completely obsoleted. The start of it remains valid */
+		if (this->ofs + this->size > fn->ofs + fn->size) {
+			/* The new node splits 'this' frag into two */
+			newfrag2 = jffs2_alloc_node_frag();
+			if (!newfrag2) {
+				jffs2_free_node_frag(newfrag);
+				return -ENOMEM;
+			}
+			printk(KERN_DEBUG "split old frag 0x%04x-0x%04x -->", this->ofs, this->ofs+this->size);
+			if (this->node)
+				printk("phys 0x%08x\n", this->node->raw->flash_offset &~3);
+			else 
+				printk("hole\n");
+
+			newfrag2->ofs = fn->ofs + fn->size;
+			newfrag2->size = (this->ofs+this->size) - newfrag2->ofs;
+			newfrag2->next = this->next;
+			newfrag2->node = this->node;
+			if (this->node)
+				this->node->frags++;
+			newfrag->next = newfrag2;
+			this->next = newfrag;
+			this->size = newfrag->ofs - this->ofs;
+			return 0;
+		}
+		/* New node just reduces 'this' frag in size, doesn't split it */
+		this->size = fn->ofs - this->ofs;
+		newfrag->next = this->next;
+		this->next = newfrag;
+		this = newfrag->next;
+	} else {
+		D2(printk(KERN_DEBUG "Inserting newfrag (*%p) in before 'this' (*%p)\n", newfrag, this));
+		*prev = newfrag;
+	        newfrag->next = this;
+	}
+	/* OK, now we have newfrag added in the correct place in the list, but
+	   newfrag->next points to a fragment which may be overlapping it
+	*/
+	while (this && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
+		/* 'this' frag is obsoleted. */
+		old = this;
+		this = old->next;
+		jffs2_obsolete_node_frag(c, old);
+	}
+	/* Now we're pointing at the first frag which isn't totally obsoleted by 
+	   the new frag */
+	newfrag->next = this;
+
+	if (!this || newfrag->ofs + newfrag->size == this->ofs) {
+		return 0;
+	}
+	/* Still some overlap */
+	this->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);
+	this->ofs = newfrag->ofs + newfrag->size;
+	return 0;
+}
+
+void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_node_frag **list, __u32 size)
+{
+	D1(printk(KERN_DEBUG "Truncating fraglist to 0x%08x bytes\n", size));
+
+	while (*list) {
+		if ((*list)->ofs >= size) {
+			struct jffs2_node_frag *this = *list;
+			*list = this->next;
+			D1(printk(KERN_DEBUG "Removing frag 0x%08x-0x%08x\n", this->ofs, this->ofs+this->size));
+			jffs2_obsolete_node_frag(c, this);
+			continue;
+		} else if ((*list)->ofs + (*list)->size > size) {
+			D1(printk(KERN_DEBUG "Truncating frag 0x%08x-0x%08x\n", (*list)->ofs, (*list)->ofs + (*list)->size));
+			(*list)->size = size - (*list)->ofs;
+		}
+		list = &(*list)->next;
+	}
+}
+
+/* Scan the list of all nodes present for this ino, build map of versions, etc. */
+
+void jffs2_read_inode (struct inode *inode)
+{
+	struct jffs2_tmp_dnode_info *tn_list, *tn;
+	struct jffs2_full_dirent *fd_list;
+	struct jffs2_inode_info *f;
+	struct jffs2_full_dnode *fn = NULL;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_inode latest_node;
+	int ret;
+	ssize_t retlen;
+
+	D1(printk(KERN_DEBUG "jffs2_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
+
+	f = JFFS2_INODE_INFO(inode);
+	c = JFFS2_SB_INFO(inode->i_sb);
+
+	memset(f, 0, sizeof(*f));
+	D2(printk(KERN_DEBUG "getting inocache\n"));
+	init_MUTEX(&f->sem);
+	f->inocache = jffs2_get_ino_cache(c, inode->i_ino);
+	D2(printk(KERN_DEBUG "jffs2_read_inode(): Got inocache at %p\n", f->inocache));
+
+	if (!f->inocache && inode->i_ino == 1) {
+		/* Special case - no root inode on medium */
+		f->inocache = jffs2_alloc_inode_cache();
+		if (!f->inocache) {
+			printk(KERN_CRIT "jffs2_read_inode(): Cannot allocate inocache for root inode\n");
+			make_bad_inode(inode);
+			return;
+		}
+		D1(printk(KERN_DEBUG "jffs2_read_inode(): Creating inocache for root inode\n"));
+		memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
+		f->inocache->ino = f->inocache->nlink = 1;
+		f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
+		jffs2_add_ino_cache(c, f->inocache);
+	}
+	if (!f->inocache) {
+		printk(KERN_WARNING "jffs2_read_inode() on nonexistent ino %lu\n", (unsigned long)inode->i_ino);
+		make_bad_inode(inode);
+		return;
+	}
+	D1(printk(KERN_DEBUG "jffs2_read_inode(): ino #%lu nlink is %d\n", (unsigned long)inode->i_ino, f->inocache->nlink));
+	inode->i_nlink = f->inocache->nlink;
+
+	/* Grab all nodes relevant to this ino */
+	ret = jffs2_get_inode_nodes(c, inode->i_ino, f, &tn_list, &fd_list, &f->highest_version);
+
+	if (ret) {
+		printk(KERN_CRIT "jffs2_get_inode_nodes() for ino %lu returned %d\n", inode->i_ino, ret);
+		make_bad_inode(inode);
+		return;
+	}
+	f->dents = fd_list;
+
+	while (tn_list) {
+		static __u32 mdata_ver = 0;
+
+		tn = tn_list;
+
+		fn = tn->fn;
+
+		if (f->metadata && tn->version > mdata_ver) {
+			D1(printk(KERN_DEBUG "Obsoleting old metadata at 0x%08x\n", f->metadata->raw->flash_offset &~3));
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+			
+			mdata_ver = 0;
+		}
+
+		if (fn->size) {
+			jffs2_add_full_dnode_to_inode(c, f, fn);
+		} else {
+			/* Zero-sized node at end of version list. Just a metadata update */
+			D1(printk(KERN_DEBUG "metadata @%08x: ver %d\n", fn->raw->flash_offset &~3, tn->version));
+			f->metadata = fn;
+			mdata_ver = tn->version;
+		}
+		tn_list = tn->next;
+		jffs2_free_tmp_dnode_info(tn);
+	}
+	if (!fn) {
+		/* No data nodes for this inode. */
+		if (inode->i_ino != 1) {
+			printk(KERN_WARNING "jffs2_read_inode(): No data nodes found for ino #%lu\n", inode->i_ino);
+			if (!fd_list) {
+				make_bad_inode(inode);
+				return;
+			}
+			printk(KERN_WARNING "jffs2_read_inode(): But it has children so we fake some modes for it\n");
+		}
+		inode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;
+		inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+		inode->i_nlink = f->inocache->nlink;
+		inode->i_size = 0;
+	} else {
+		__u32 crc;
+
+		ret = c->mtd->read(c->mtd, fn->raw->flash_offset & ~3, sizeof(latest_node), &retlen, (void *)&latest_node);
+		if (ret || retlen != sizeof(latest_node)) {
+			printk(KERN_NOTICE "MTD read in jffs2_read_inode() failed: Returned %d, %ld of %d bytes read\n",
+			       ret, (long)retlen, sizeof(latest_node));
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+
+		crc = crc32(0, &latest_node, sizeof(latest_node)-8);
+		if (crc != latest_node.node_crc) {
+			printk(KERN_NOTICE "CRC failed for read_inode of inode %ld at physical location 0x%x\n", inode->i_ino, fn->raw->flash_offset & ~3);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+
+		inode->i_mode = latest_node.mode;
+		inode->i_uid = latest_node.uid;
+		inode->i_gid = latest_node.gid;
+		inode->i_size = latest_node.isize;
+		if ((inode->i_mode & S_IFMT) == S_IFREG)
+			jffs2_truncate_fraglist(c, &f->fraglist, latest_node.isize);
+		inode->i_atime = latest_node.atime;
+		inode->i_mtime = latest_node.mtime;
+		inode->i_ctime = latest_node.ctime;
+	}
+
+	/* OK, now the special cases. Certain inode types should
+	   have only one data node, and it's kept as the metadata
+	   node */
+	if ((inode->i_mode & S_IFMT) == S_IFBLK ||
+	    (inode->i_mode & S_IFMT) == S_IFCHR ||
+	    (inode->i_mode & S_IFMT) == S_IFLNK) {
+		if (f->metadata) {
+			printk(KERN_WARNING "Argh. Special inode #%lu with mode 0%o had metadata node\n", inode->i_ino, inode->i_mode);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		if (!f->fraglist) {
+			printk(KERN_WARNING "Argh. Special inode #%lu with mode 0%o has no fragments\n", inode->i_ino, inode->i_mode);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		/* ASSERT: f->fraglist != NULL */
+		if (f->fraglist->next) {
+			printk(KERN_WARNING "Argh. Special inode #%lu had more than one node\n", inode->i_ino);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		/* OK. We're happy */
+		f->metadata = f->fraglist->node;
+		jffs2_free_node_frag(f->fraglist);
+		f->fraglist = NULL;
+	}			
+	    
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	
+	switch (inode->i_mode & S_IFMT) {
+		unsigned short rdev;
+
+	case S_IFLNK:
+		inode->i_op = &jffs2_symlink_inode_operations;
+		break;
+		
+	case S_IFDIR:
+		inode->i_op = &jffs2_dir_inode_operations;
+		inode->i_fop = &jffs2_dir_operations;
+		break;
+
+	case S_IFREG:
+		inode->i_op = &jffs2_file_inode_operations;
+		inode->i_fop = &jffs2_file_operations;
+		inode->i_mapping->a_ops = &jffs2_file_address_operations;
+		inode->i_mapping->nrpages = 0;
+		break;
+
+	case S_IFBLK:
+	case S_IFCHR:
+		/* Read the device numbers from the media */
+		D1(printk(KERN_DEBUG "Reading device numbers from flash\n"));
+		if (jffs2_read_dnode(c, f->metadata, (char *)&rdev, 0, sizeof(rdev)) < 0) {
+			/* Eep */
+			printk(KERN_NOTICE "Read device numbers for inode %lu failed\n", (unsigned long)inode->i_ino);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}			
+
+	case S_IFSOCK:
+	case S_IFIFO:
+		inode->i_op = &jffs2_file_inode_operations;
+		init_special_inode(inode, inode->i_mode, kdev_t_to_nr(MKDEV(rdev>>8, rdev&0xff)));
+		break;
+
+	default:
+		printk(KERN_WARNING "jffs2_read_inode(): Bogus imode %o for ino %lu", inode->i_mode, (unsigned long)inode->i_ino);
+	}
+	D1(printk(KERN_DEBUG "jffs2_read_inode() returning\n"));
+}
+
+void jffs2_clear_inode (struct inode *inode)
+{
+	/* We can forget about this inode for now - drop all 
+	 *  the nodelists associated with it, etc.
+	 */
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_node_frag *frag, *frags;
+	struct jffs2_full_dirent *fd, *fds;
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+
+	D1(printk(KERN_DEBUG "jffs2_clear_inode(): ino #%lu mode %o\n", inode->i_ino, inode->i_mode));
+
+	frags = f->fraglist;
+	fds = f->dents;
+	if (f->metadata) {
+		if (!f->inocache->nlink)
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+		jffs2_free_full_dnode(f->metadata);
+	}
+
+	while (frags) {
+		frag = frags;
+		frags = frag->next;
+		D2(printk(KERN_DEBUG "jffs2_clear_inode: frag at 0x%x-0x%x: node %p, frags %d--\n", frag->ofs, frag->ofs+frag->size, frag->node, frag->node?frag->node->frags:0));
+
+		if (frag->node && !(--frag->node->frags)) {
+			/* Not a hole, and it's the final remaining frag of this node. Free the node */
+			if (!f->inocache->nlink)
+				jffs2_mark_node_obsolete(c, frag->node->raw);
+
+			jffs2_free_full_dnode(frag->node);
+		}
+		jffs2_free_node_frag(frag);
+	}
+	while(fds) {
+		fd = fds;
+		fds = fd->next;
+		jffs2_free_full_dirent(fd);
+	}
+	//	if (!f->inocache->nlink) {
+		//		D1(printk(KERN_DEBUG "jffs2_clear_inode() deleting inode #%lu\n", inode->i_ino));
+		//		jffs2_del_ino_cache(JFFS2_SB_INFO(inode->i_sb), f->inocache);
+		//		jffs2_free_inode_cache(f->inocache);
+	//	}
+};
+
diff -Naur linux-2.4.2.orig/fs/jffs2/scan.c linux-2.4.2/fs/jffs2/scan.c
--- linux-2.4.2.orig/fs/jffs2/scan.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/scan.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,686 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: scan.c,v 1.49 2001/07/02 16:40:01 nico Exp $
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
+#include <linux/pagemap.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+
+#define DIRTY_SPACE(x) do { typeof(x) _x = (x); \
+		c->free_size -= _x; c->dirty_size += _x; \
+		jeb->free_size -= _x ; jeb->dirty_size += _x; \
+		}while(0)
+#define USED_SPACE(x) do { typeof(x) _x = (x); \
+		c->free_size -= _x; c->used_size += _x; \
+		jeb->free_size -= _x ; jeb->used_size += _x; \
+		}while(0)
+
+#define noisy_printk(noise, args...) do { \
+	if (*(noise)) { \
+		printk(KERN_NOTICE args); \
+		 (*(noise))--; \
+		 if (!(*(noise))) { \
+			 printk(KERN_NOTICE "Further such events for this erase block will not be printed\n"); \
+		 } \
+	} \
+} while(0)
+
+static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
+
+/* These helper functions _must_ increase ofs and also do the dirty/used space accounting. 
+ * Returning an error will abort the mount - bad checksums etc. should just mark the space
+ * as dirty.
+ */
+static int jffs2_scan_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs, int *noise);
+static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs);
+static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs);
+
+
+int jffs2_scan_medium(struct jffs2_sb_info *c)
+{
+	int i, ret;
+	__u32 empty_blocks = 0;
+
+	if (!c->blocks) {
+		printk(KERN_WARNING "EEEK! c->blocks is NULL!\n");
+		return -EINVAL;
+	}
+	for (i=0; i<c->nr_blocks; i++) {
+		struct jffs2_eraseblock *jeb = &c->blocks[i];
+
+		ret = jffs2_scan_eraseblock(c, jeb);
+		if (ret < 0)
+			return ret;
+
+		ACCT_PARANOIA_CHECK(jeb);
+
+		/* Now decide which list to put it on */
+		if (ret == 1) {
+			/* 
+			 * Empty block.   Since we can't be sure it 
+			 * was entirely erased, we just queue it for erase
+			 * again.  It will be marked as such when the erase
+			 * is complete.  Meanwhile we still count it as empty
+			 * for later checks.
+			 */
+			list_add(&jeb->list, &c->erase_pending_list);
+			empty_blocks++;
+			c->nr_erasing_blocks++;
+		} else if (jeb->used_size == PAD(sizeof(struct jffs2_unknown_node)) && !jeb->first_node->next_in_ino) {
+			/* Only a CLEANMARKER node is valid */
+			if (!jeb->dirty_size) {
+				/* It's actually free */
+				list_add(&jeb->list, &c->free_list);
+				c->nr_free_blocks++;
+			} else {
+				/* Dirt */
+				D1(printk(KERN_DEBUG "Adding all-dirty block at 0x%08x to erase_pending_list\n", jeb->offset));
+				list_add(&jeb->list, &c->erase_pending_list);
+				c->nr_erasing_blocks++;
+			}
+		} else if (jeb->used_size > c->sector_size - (2*sizeof(struct jffs2_raw_inode))) {
+                        /* Full (or almost full) of clean data. Clean list */
+                        list_add(&jeb->list, &c->clean_list);
+                } else if (jeb->used_size) {
+                        /* Some data, but not full. Dirty list. */
+                        /* Except that we want to remember the block with most free space,
+                           and stick it in the 'nextblock' position to start writing to it.
+                           Later when we do snapshots, this must be the most recent block,
+                           not the one with most free space.
+                        */
+                        if (jeb->free_size > 2*sizeof(struct jffs2_raw_inode) && 
+                                (!c->nextblock || c->nextblock->free_size < jeb->free_size)) {
+                                /* Better candidate for the next writes to go to */
+                                if (c->nextblock)
+                                        list_add(&c->nextblock->list, &c->dirty_list);
+                                c->nextblock = jeb;
+                        } else {
+                                list_add(&jeb->list, &c->dirty_list);
+                        }
+		} else {
+			/* Nothing valid - not even a clean marker. Needs erasing. */
+                        /* For now we just put it on the erasing list. We'll start the erases later */
+			printk(KERN_NOTICE "JFFS2: Erase block at 0x%08x is not formatted. It will be erased\n", jeb->offset);
+                        list_add(&jeb->list, &c->erase_pending_list);
+			c->nr_erasing_blocks++;
+		}
+	}
+	if (c->nr_erasing_blocks) {
+		if (!c->used_size && empty_blocks != c->nr_blocks) {
+			printk(KERN_NOTICE "Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\n");
+			return -EIO;
+		}
+		jffs2_erase_pending_trigger(c);
+	}
+	return 0;
+}
+
+static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb) {
+	struct jffs2_unknown_node node;
+	__u32 ofs, prevofs;
+	__u32 hdr_crc, nodetype;
+	int err;
+	int noise = 0;
+
+	ofs = jeb->offset;
+	prevofs = jeb->offset - 1;
+
+	D1(printk(KERN_DEBUG "jffs2_scan_eraseblock(): Scanning block at 0x%x\n", ofs));
+
+	err = jffs2_scan_empty(c, jeb, &ofs, &noise);
+	if (err) return err;
+	if (ofs == jeb->offset + c->sector_size) {
+		D1(printk(KERN_DEBUG "Block at 0x%08x is empty (erased)\n", jeb->offset));
+		return 1;	/* special return code */
+	}
+	
+	noise = 10;
+
+	while(ofs < jeb->offset + c->sector_size) {
+		ssize_t retlen;
+		ACCT_PARANOIA_CHECK(jeb);
+		
+		if (ofs & 3) {
+			printk(KERN_WARNING "Eep. ofs 0x%08x not word-aligned!\n", ofs);
+			ofs = (ofs+3)&~3;
+			continue;
+		}
+		if (ofs == prevofs) {
+			printk(KERN_WARNING "ofs 0x%08x has already been seen. Skipping\n", ofs);
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+		prevofs = ofs;
+		
+		if (jeb->offset + c->sector_size < ofs + sizeof(node)) {
+			D1(printk(KERN_DEBUG "Fewer than %d bytes left to end of block. Not reading\n", sizeof(struct jffs2_unknown_node)));
+			DIRTY_SPACE((jeb->offset + c->sector_size)-ofs);
+			break;
+		}
+
+		err = c->mtd->read(c->mtd, ofs, sizeof(node), &retlen, (char *)&node);
+		
+		if (err) {
+			D1(printk(KERN_WARNING "mtd->read(0x%x bytes from 0x%x) returned %d\n", sizeof(node), ofs, err));
+			return err;
+		}
+		if (retlen < sizeof(node)) {
+			D1(printk(KERN_WARNING "Read at 0x%x gave only 0x%x bytes\n", ofs, retlen));
+			DIRTY_SPACE(retlen);
+			ofs += retlen;
+			continue;
+		}
+
+		if (node.magic == JFFS2_EMPTY_BITMASK && node.nodetype == JFFS2_EMPTY_BITMASK) {
+			D1(printk(KERN_DEBUG "Found empty flash at 0x%x\n", ofs));
+			err = jffs2_scan_empty(c, jeb, &ofs, &noise);
+			if (err) return err;
+			continue;
+		}
+
+		if (ofs == jeb->offset && node.magic == KSAMTIB_CIGAM_2SFFJ) {
+			printk(KERN_WARNING "Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\n", ofs);
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+		if (node.magic == JFFS2_DIRTY_BITMASK) {
+			D1(printk(KERN_DEBUG "Empty bitmask at 0x%08x\n", ofs));
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+		if (node.magic == JFFS2_OLD_MAGIC_BITMASK) {
+			printk(KERN_WARNING "Old JFFS2 bitmask found at 0x%08x\n", ofs);
+			printk(KERN_WARNING "You cannot use older JFFS2 filesystems with newer kernels\n");
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+		if (node.magic != JFFS2_MAGIC_BITMASK) {
+			/* OK. We're out of possibilities. Whinge and move on */
+			noisy_printk(&noise, "jffs2_scan_eraseblock(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\n", JFFS2_MAGIC_BITMASK, ofs, node.magic);
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+		/* We seem to have a node of sorts. Check the CRC */
+		nodetype = node.nodetype;
+		node.nodetype |= JFFS2_NODE_ACCURATE;
+		hdr_crc = crc32(0, &node, sizeof(node)-4);
+		node.nodetype = nodetype;
+		if (hdr_crc != node.hdr_crc) {
+			noisy_printk(&noise, "jffs2_scan_eraseblock(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\n",
+				     ofs, node.magic, node.nodetype, node.totlen, node.hdr_crc, hdr_crc);
+			DIRTY_SPACE(4);
+			ofs += 4;
+			continue;
+		}
+
+		switch(node.nodetype | JFFS2_NODE_ACCURATE) {
+		case JFFS2_NODETYPE_INODE:
+			err = jffs2_scan_inode_node(c, jeb, &ofs);
+			if (err) return err;
+			break;
+			
+		case JFFS2_NODETYPE_DIRENT:
+			err = jffs2_scan_dirent_node(c, jeb, &ofs);
+			if (err) return err;
+			break;
+
+		case JFFS2_NODETYPE_CLEANMARKER:
+			if (node.totlen != sizeof(struct jffs2_unknown_node)) {
+				printk(KERN_NOTICE "CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\n", 
+				       ofs, node.totlen, sizeof(struct jffs2_unknown_node));
+				DIRTY_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
+			} else if (jeb->first_node) {
+				printk(KERN_NOTICE "CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\n", ofs, jeb->offset);
+				DIRTY_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
+				ofs += PAD(sizeof(struct jffs2_unknown_node));
+				continue;
+			} else {
+				struct jffs2_raw_node_ref *marker_ref = jffs2_alloc_raw_node_ref();
+				if (!marker_ref) {
+					printk(KERN_NOTICE "Failed to allocate node ref for clean marker\n");
+					return -ENOMEM;
+				}
+				marker_ref->next_in_ino = NULL;
+				marker_ref->next_phys = NULL;
+				marker_ref->flash_offset = ofs;
+				marker_ref->totlen = sizeof(struct jffs2_unknown_node);
+				jeb->first_node = jeb->last_node = marker_ref;
+			     
+				USED_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
+			}
+			ofs += PAD(sizeof(struct jffs2_unknown_node));
+			break;
+
+		default:
+			switch (node.nodetype & JFFS2_COMPAT_MASK) {
+			case JFFS2_FEATURE_ROCOMPAT:
+				printk(KERN_NOTICE "Read-only compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+			        c->flags |= JFFS2_SB_FLAG_RO;
+				DIRTY_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
+				continue;
+
+			case JFFS2_FEATURE_INCOMPAT:
+				printk(KERN_NOTICE "Incompatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+				return -EINVAL;
+
+			case JFFS2_FEATURE_RWCOMPAT_DELETE:
+				printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+				DIRTY_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
+				break;
+
+			case JFFS2_FEATURE_RWCOMPAT_COPY:
+				printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+				USED_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
+				break;
+			}
+		}
+	}
+	D1(printk(KERN_DEBUG "Block at 0x%08x: free 0x%08x, dirty 0x%08x, used 0x%08x\n", jeb->offset, 
+		  jeb->free_size, jeb->dirty_size, jeb->used_size));
+	return 0;
+}
+
+/* We're pointing at the first empty word on the flash. Scan and account for the whole dirty region */
+static int jffs2_scan_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *startofs, int *noise)
+{
+	__u32 *buf;
+	__u32 scanlen = (jeb->offset + c->sector_size) - *startofs;
+	__u32 curofs = *startofs;
+	
+	buf = kmalloc(min(PAGE_SIZE, scanlen), GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_WARNING "Scan buffer allocation failed\n");
+		return -ENOMEM;
+	}
+	while(scanlen) {
+		ssize_t retlen;
+		int ret, i;
+		
+		ret = c->mtd->read(c->mtd, curofs, min(PAGE_SIZE, scanlen), &retlen, (char *)buf);
+		if(ret) {
+			D1(printk(KERN_WARNING "jffs2_scan_empty(): Read 0x%lx bytes at 0x%08x returned %d\n", min(PAGE_SIZE, scanlen), curofs, ret));
+			kfree(buf);
+			return ret;
+		}
+		if (retlen < 4) {
+			D1(printk(KERN_WARNING "Eep. too few bytes read in scan_empty()\n"));
+			kfree(buf);
+			return -EIO;
+		}
+		for (i=0; i<(retlen / 4); i++) {
+			if (buf[i] != 0xffffffff) {
+				curofs += i*4;
+
+				noisy_printk(noise, "jffs2_scan_empty(): Empty block at 0x%08x ends at 0x%08x (with 0x%08x)! Marking dirty\n", *startofs, curofs, buf[i]);
+				DIRTY_SPACE(curofs - (*startofs));
+				*startofs = curofs;
+				kfree(buf);
+				return 0;
+			}
+		}
+		scanlen -= retlen&~3;
+		curofs += retlen&~3;
+	}
+
+	D1(printk(KERN_DEBUG "Empty flash detected from 0x%08x to 0x%08x\n", *startofs, curofs));
+	kfree(buf);
+	*startofs = curofs;
+	return 0;
+}
+
+static struct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, __u32 ino)
+{
+	struct jffs2_inode_cache *ic;
+
+	ic = jffs2_get_ino_cache(c, ino);
+	if (ic)
+		return ic;
+
+	ic = jffs2_alloc_inode_cache();
+	if (!ic) {
+		printk(KERN_NOTICE "jffs2_scan_make_inode_cache(): allocation of inode cache failed\n");
+		return NULL;
+	}
+	memset(ic, 0, sizeof(*ic));
+	ic->scan = kmalloc(sizeof(struct jffs2_scan_info), GFP_KERNEL);
+	if (!ic->scan) {
+		printk(KERN_NOTICE "jffs2_scan_make_inode_cache(): allocation of scan info for inode cache failed\n");
+		jffs2_free_inode_cache(ic);
+		return NULL;
+	}
+	memset(ic->scan, 0, sizeof(*ic->scan));
+	ic->ino = ino;
+	ic->nodes = (void *)ic;
+	jffs2_add_ino_cache(c, ic);
+	if (ino == 1)
+		ic->nlink=1;
+	return ic;
+}
+
+static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs)
+{
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_tmp_dnode_info *tn, **tn_list;
+	struct jffs2_inode_cache *ic;
+	struct jffs2_raw_inode ri;
+	__u32 crc;
+	__u16 oldnodetype;
+	int ret;
+	ssize_t retlen;
+
+	D1(printk(KERN_DEBUG "jffs2_scan_inode_node(): Node at 0x%08x\n", *ofs));
+
+	ret = c->mtd->read(c->mtd, *ofs, sizeof(ri), &retlen, (char *)&ri);
+	if (ret) {
+		printk(KERN_NOTICE "jffs2_scan_inode_node(): Read error at 0x%08x: %d\n", *ofs, ret);
+		return ret;
+	}
+	if (retlen != sizeof(ri)) {
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs, sizeof(ri));
+		return -EIO;
+	}
+
+	/* We sort of assume that the node was accurate when it was 
+	   first written to the medium :) */
+	oldnodetype = ri.nodetype;
+	ri.nodetype |= JFFS2_NODE_ACCURATE;
+	crc = crc32(0, &ri, sizeof(ri)-8);
+	ri.nodetype = oldnodetype;
+
+	if(crc != ri.node_crc) {
+		printk(KERN_NOTICE "jffs2_scan_inode_node(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+		       *ofs, ri.node_crc, crc);
+		/* FIXME: Why do we believe totlen? */
+		DIRTY_SPACE(4);
+		*ofs += 4;
+		return 0;
+	}
+
+	if (ri.csize) {
+		/* Check data CRC too */
+		unsigned char *dbuf;
+		__u32 crc;
+
+		dbuf = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);
+		if (!dbuf) {
+			printk(KERN_NOTICE "jffs2_scan_inode_node(): allocation of temporary data buffer for CRC check failed\n");
+			return -ENOMEM;
+		}
+		ret = c->mtd->read(c->mtd, *ofs+sizeof(ri), ri.csize, &retlen, dbuf);
+		if (ret) {
+			printk(KERN_NOTICE "jffs2_scan_inode_node(): Read error at 0x%08x: %d\n", *ofs+sizeof(ri), ret);
+			kfree(dbuf);
+			return ret;
+		}
+		if (retlen != ri.csize) {
+			printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+			       retlen, *ofs+ sizeof(ri), ri.csize);
+			kfree(dbuf);
+			return -EIO;
+		}
+		crc = crc32(0, dbuf, ri.csize);
+		kfree(dbuf);
+		if (crc != ri.data_crc) {
+			printk(KERN_NOTICE "jffs2_scan_inode_node(): Data CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+			       *ofs, ri.data_crc, crc);
+			DIRTY_SPACE(PAD(ri.totlen));
+			*ofs += PAD(ri.totlen);
+			return -0;
+		}
+	}
+
+	/* Wheee. It worked */
+	raw = jffs2_alloc_raw_node_ref();
+	if (!raw) {
+		printk(KERN_NOTICE "jffs2_scan_inode_node(): allocation of node reference failed\n");
+		return -ENOMEM;
+	}
+	tn = jffs2_alloc_tmp_dnode_info();
+	if (!tn) {
+		jffs2_free_raw_node_ref(raw);
+		return -ENOMEM;
+	}
+	fn = jffs2_alloc_full_dnode();
+	if (!fn) {
+		jffs2_free_tmp_dnode_info(tn);
+		jffs2_free_raw_node_ref(raw);
+		return -ENOMEM;
+	}
+	ic = jffs2_scan_make_ino_cache(c, ri.ino);
+	if (!ic) {
+		jffs2_free_full_dnode(fn);
+		jffs2_free_tmp_dnode_info(tn);
+		jffs2_free_raw_node_ref(raw);
+		return -ENOMEM;
+	}
+
+	/* Build the data structures and file them for later */
+	raw->flash_offset = *ofs;
+	raw->totlen = PAD(ri.totlen);
+	raw->next_phys = NULL;
+	raw->next_in_ino = ic->nodes;
+	ic->nodes = raw;
+	if (!jeb->first_node)
+		jeb->first_node = raw;
+	if (jeb->last_node)
+		jeb->last_node->next_phys = raw;
+	jeb->last_node = raw;
+
+	D1(printk(KERN_DEBUG "Node is ino #%u, version %d. Range 0x%x-0x%x\n", 
+		  ri.ino, ri.version, ri.offset, ri.offset+ri.dsize));
+
+	for (tn_list = &ic->scan->tmpnodes; *tn_list; tn_list = &((*tn_list)->next)) {
+		if ((*tn_list)->version < ri.version)
+			continue;
+		if ((*tn_list)->version > ri.version) 
+			break;
+		/* Wheee. We've found another instance of the same version number.
+		   We should obsolete one of them. 
+		*/
+		D1(printk(KERN_DEBUG "Duplicate version %d found in ino #%u. Previous one is at 0x%08x\n", ri.version, ic->ino, (*tn_list)->fn->raw->flash_offset &~3));
+		if (!jeb->used_size) {
+			D1(printk(KERN_DEBUG "No valid nodes yet found in this eraseblock 0x%08x, so obsoleting the new instance at 0x%08x\n", 
+				  jeb->offset, raw->flash_offset & ~3));
+			ri.nodetype &= ~JFFS2_NODE_ACCURATE;
+			/* Perhaps we could also mark it as such on the medium. Maybe later */
+		}
+		break;
+	}
+
+	if (ri.nodetype & JFFS2_NODE_ACCURATE) {
+		memset(fn,0,sizeof(*fn));
+
+		fn->ofs = ri.offset;
+		fn->size = ri.dsize;
+		fn->frags = 0;
+		fn->raw = raw;
+
+		tn->next = NULL;
+		tn->fn = fn;
+		tn->version = ri.version;
+
+		USED_SPACE(PAD(ri.totlen));
+		jffs2_add_tn_to_list(tn, &ic->scan->tmpnodes);
+		/* Make sure the one we just added is the _last_ in the list
+		   with this version number, so the older ones get obsoleted */
+		while (tn->next && tn->next->version == tn->version) {
+
+			D1(printk(KERN_DEBUG "Shifting new node at 0x%08x after other node at 0x%08x for version %d in list\n",
+				  fn->raw->flash_offset&~3, tn->next->fn->raw->flash_offset &~3, ri.version));
+
+			if(tn->fn != fn)
+				BUG();
+			tn->fn = tn->next->fn;
+			tn->next->fn = fn;
+			tn = tn->next;
+		}
+	} else {
+		jffs2_free_full_dnode(fn);
+		jffs2_free_tmp_dnode_info(tn);
+		raw->flash_offset |= 1;
+		DIRTY_SPACE(PAD(ri.totlen));
+	}		
+	*ofs += PAD(ri.totlen);
+	return 0;
+}
+
+static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs)
+{
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dirent *fd;
+	struct jffs2_inode_cache *ic;
+	struct jffs2_raw_dirent rd;
+	__u16 oldnodetype;
+	int ret;
+	__u32 crc;
+	ssize_t retlen;
+
+	D1(printk(KERN_DEBUG "jffs2_scan_dirent_node(): Node at 0x%08x\n", *ofs));
+
+	ret = c->mtd->read(c->mtd, *ofs, sizeof(rd), &retlen, (char *)&rd);
+	if (ret) {
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Read error at 0x%08x: %d\n", *ofs, ret);
+		return ret;
+	}
+	if (retlen != sizeof(rd)) {
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs, sizeof(rd));
+		return -EIO;
+	}
+
+	/* We sort of assume that the node was accurate when it was 
+	   first written to the medium :) */
+	oldnodetype = rd.nodetype;
+	rd.nodetype |= JFFS2_NODE_ACCURATE;
+	crc = crc32(0, &rd, sizeof(rd)-8);
+	rd.nodetype = oldnodetype;
+
+	if (crc != rd.node_crc) {
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+		       *ofs, rd.node_crc, crc);
+		/* FIXME: Why do we believe totlen? */
+		DIRTY_SPACE(4);
+		*ofs += 4;
+		return 0;
+	}
+
+	fd = jffs2_alloc_full_dirent(rd.nsize+1);
+	if (!fd) {
+		return -ENOMEM;
+}
+	ret = c->mtd->read(c->mtd, *ofs + sizeof(rd), rd.nsize, &retlen, &fd->name[0]);
+	if (ret) {
+		jffs2_free_full_dirent(fd);
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Read error at 0x%08x: %d\n", 
+		       *ofs + sizeof(rd), ret);
+		return ret;
+	}
+	if (retlen != rd.nsize) {
+		jffs2_free_full_dirent(fd);
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs + sizeof(rd), rd.nsize);
+		return -EIO;
+	}
+	crc = crc32(0, fd->name, rd.nsize);
+	if (crc != rd.name_crc) {
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+		       *ofs, rd.name_crc, crc);	
+		fd->name[rd.nsize]=0;
+		D1(printk(KERN_NOTICE "Name for which CRC failed is (now) '%s', ino #%d\n", fd->name, rd.ino));
+		jffs2_free_full_dirent(fd);
+		/* FIXME: Why do we believe totlen? */
+		DIRTY_SPACE(PAD(rd.totlen));
+		*ofs += PAD(rd.totlen);
+		return 0;
+	}
+	raw = jffs2_alloc_raw_node_ref();
+	if (!raw) {
+		jffs2_free_full_dirent(fd);
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): allocation of node reference failed\n");
+		return -ENOMEM;
+	}
+	ic = jffs2_scan_make_ino_cache(c, rd.pino);
+	if (!ic) {
+		jffs2_free_full_dirent(fd);
+		jffs2_free_raw_node_ref(raw);
+		return -ENOMEM;
+	}
+	
+	raw->totlen = PAD(rd.totlen);
+	raw->flash_offset = *ofs;
+	raw->next_phys = NULL;
+	raw->next_in_ino = ic->nodes;
+	ic->nodes = raw;
+	if (!jeb->first_node)
+		jeb->first_node = raw;
+	if (jeb->last_node)
+		jeb->last_node->next_phys = raw;
+	jeb->last_node = raw;
+
+	if (rd.nodetype & JFFS2_NODE_ACCURATE) {
+		fd->raw = raw;
+		fd->next = NULL;
+		fd->version = rd.version;
+		fd->ino = rd.ino;
+		fd->name[rd.nsize]=0;
+		fd->nhash = full_name_hash(fd->name, rd.nsize);
+		fd->type = rd.type;
+
+		USED_SPACE(PAD(rd.totlen));
+		jffs2_add_fd_to_list(c, fd, &ic->scan->dents);
+	} else {
+		raw->flash_offset |= 1;
+		jffs2_free_full_dirent(fd);
+
+		DIRTY_SPACE(PAD(rd.totlen));
+	} 
+	*ofs += PAD(rd.totlen);
+	return 0;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/super.c linux-2.4.2/fs/jffs2/super.c
--- linux-2.4.2.orig/fs/jffs2/super.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/super.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,355 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: super.c,v 1.44 2001/05/31 20:47:48 dwmw2 Exp $
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/jffs2.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include "nodelist.h"
+
+#ifndef MTD_BLOCK_MAJOR
+#define MTD_BLOCK_MAJOR 31
+#endif
+
+extern void jffs2_read_inode (struct inode *);
+void jffs2_put_super (struct super_block *);
+void jffs2_write_super (struct super_block *);
+static int jffs2_statfs (struct super_block *, struct statfs *);
+int jffs2_remount_fs (struct super_block *, int *, char *);
+extern void jffs2_clear_inode (struct inode *);
+
+static struct super_operations jffs2_super_operations =
+{
+	read_inode:	jffs2_read_inode,
+//	delete_inode:	jffs2_delete_inode,
+	put_super:	jffs2_put_super,
+	write_super:	jffs2_write_super,
+	statfs:		jffs2_statfs,
+//	remount_fs:	jffs2_remount_fs,
+	clear_inode:	jffs2_clear_inode
+};
+
+static int jffs2_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	unsigned long avail;
+
+	buf->f_type = JFFS2_SUPER_MAGIC;
+	buf->f_bsize = 1 << PAGE_SHIFT;
+	buf->f_blocks = c->flash_size >> PAGE_SHIFT;
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_namelen = JFFS2_MAX_NAME_LEN;
+
+	spin_lock_bh(&c->erase_completion_lock);
+
+	avail = c->dirty_size + c->free_size;
+	if (avail > c->sector_size * JFFS2_RESERVED_BLOCKS_WRITE)
+		avail -= c->sector_size * JFFS2_RESERVED_BLOCKS_WRITE;
+	else
+		avail = 0;
+
+	buf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;
+
+#if CONFIG_JFFS2_FS_DEBUG > 0
+	printk(KERN_DEBUG "STATFS:\n");
+	printk(KERN_DEBUG "flash_size: %08x\n", c->flash_size);
+	printk(KERN_DEBUG "used_size: %08x\n", c->used_size);
+	printk(KERN_DEBUG "dirty_size: %08x\n", c->dirty_size);
+	printk(KERN_DEBUG "free_size: %08x\n", c->free_size);
+	printk(KERN_DEBUG "erasing_size: %08x\n", c->erasing_size);
+	printk(KERN_DEBUG "bad_size: %08x\n", c->bad_size);
+	printk(KERN_DEBUG "sector_size: %08x\n", c->sector_size);
+
+	if (c->nextblock) {
+		printk(KERN_DEBUG "nextblock: 0x%08x\n", c->nextblock->offset);
+	} else {
+		printk(KERN_DEBUG "nextblock: NULL\n");
+	}
+	if (c->gcblock) {
+		printk(KERN_DEBUG "gcblock: 0x%08x\n", c->gcblock->offset);
+	} else {
+		printk(KERN_DEBUG "gcblock: NULL\n");
+	}
+	if (list_empty(&c->clean_list)) {
+		printk(KERN_DEBUG "clean_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->clean_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "clean_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->dirty_list)) {
+		printk(KERN_DEBUG "dirty_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->dirty_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "dirty_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->erasing_list)) {
+		printk(KERN_DEBUG "erasing_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erasing_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "erasing_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->erase_pending_list)) {
+		printk(KERN_DEBUG "erase_pending_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erase_pending_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "erase_pending_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->free_list)) {
+		printk(KERN_DEBUG "free_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->free_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "free_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->bad_list)) {
+		printk(KERN_DEBUG "bad_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->bad_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "bad_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->bad_used_list)) {
+		printk(KERN_DEBUG "bad_used_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->bad_used_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "bad_used_list: %08x\n", jeb->offset);
+		}
+	}
+#endif /* CONFIG_JFFS2_FS_DEBUG */
+
+	spin_unlock_bh(&c->erase_completion_lock);
+
+
+	return 0;
+}
+
+static struct super_block *jffs2_read_super(struct super_block *sb, void *data, int silent)
+{
+	struct jffs2_sb_info *c;
+	struct inode *root_i;
+	int i;
+
+	D1(printk(KERN_DEBUG "jffs2: read_super for device %s\n", kdevname(sb->s_dev)));
+
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR) {
+		if (!silent)
+			printk(KERN_DEBUG "jffs2: attempt to mount non-MTD device %s\n", kdevname(sb->s_dev));
+		return NULL;
+	}
+
+	c = JFFS2_SB_INFO(sb);
+	memset(c, 0, sizeof(*c));
+	
+	c->mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!c->mtd) {
+		D1(printk(KERN_DEBUG "jffs2: MTD device #%u doesn't appear to exist\n", MINOR(sb->s_dev)));
+		return NULL;
+	}
+	c->sector_size = c->mtd->erasesize;
+	c->free_size = c->flash_size = c->mtd->size;
+	c->nr_blocks = c->mtd->size / c->mtd->erasesize;
+	c->blocks = kmalloc(sizeof(struct jffs2_eraseblock) * c->nr_blocks, GFP_KERNEL);
+	if (!c->blocks)
+		goto out_mtd;
+	for (i=0; i<c->nr_blocks; i++) {
+		INIT_LIST_HEAD(&c->blocks[i].list);
+		c->blocks[i].offset = i * c->sector_size;
+		c->blocks[i].free_size = c->sector_size;
+		c->blocks[i].dirty_size = 0;
+		c->blocks[i].used_size = 0;
+		c->blocks[i].first_node = NULL;
+		c->blocks[i].last_node = NULL;
+	}
+		
+	spin_lock_init(&c->nodelist_lock);
+	init_MUTEX(&c->alloc_sem);
+	init_waitqueue_head(&c->erase_wait);
+	spin_lock_init(&c->erase_completion_lock);
+	spin_lock_init(&c->inocache_lock);
+
+	INIT_LIST_HEAD(&c->clean_list);
+	INIT_LIST_HEAD(&c->dirty_list);
+	INIT_LIST_HEAD(&c->erasing_list);
+	INIT_LIST_HEAD(&c->erase_pending_list);
+	INIT_LIST_HEAD(&c->erase_complete_list);
+	INIT_LIST_HEAD(&c->free_list);
+	INIT_LIST_HEAD(&c->bad_list);
+	INIT_LIST_HEAD(&c->bad_used_list);
+	c->highest_ino = 1;
+
+	if (jffs2_build_filesystem(c)) {
+		D1(printk(KERN_DEBUG "build_fs failed\n"));
+		goto out_nodes;
+	}
+	sb->s_op = &jffs2_super_operations;
+
+	D1(printk(KERN_DEBUG "jffs2_read_super(): Getting root inode\n"));
+	root_i = iget(sb, 1);
+	if (is_bad_inode(root_i)) {
+		D1(printk(KERN_WARNING "get root inode failed\n"));
+		goto out_nodes;
+	}
+
+	D1(printk(KERN_DEBUG "jffs2_read_super(): d_alloc_root()\n"));
+	sb->s_root = d_alloc_root(root_i);
+	if (!sb->s_root)
+		goto out_root_i;
+
+#if LINUX_VERSION_CODE >= 0x20403
+	sb->s_maxbytes = 0xFFFFFFFF;
+#endif
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = JFFS2_SUPER_MAGIC;
+	jffs2_start_garbage_collect_thread(c);
+	return sb;
+
+ out_root_i:
+	iput(root_i);
+ out_nodes:
+	jffs2_free_ino_caches(c);
+	jffs2_free_raw_node_refs(c);
+	kfree(c->blocks);
+ out_mtd:
+	put_mtd_device(c->mtd);
+	return NULL;
+}
+
+void jffs2_put_super (struct super_block *sb)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+
+	D2(printk(KERN_DEBUG "jffs2: jffs2_put_super()\n"));
+
+	jffs2_stop_garbage_collect_thread(c);
+	jffs2_free_ino_caches(c);
+	jffs2_free_raw_node_refs(c);
+	kfree(c->blocks);
+	if (c->mtd->sync)
+		c->mtd->sync(c->mtd);
+	put_mtd_device(c->mtd);
+	
+	D1(printk(KERN_DEBUG "jffs2_put_super returning\n"));
+}
+
+void jffs2_write_super (struct super_block *sb)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	sb->s_dirt = 0;
+	jffs2_garbage_collect_trigger(c);
+	jffs2_erase_pending_blocks(c);
+	jffs2_mark_erased_blocks(c);
+}
+
+
+static DECLARE_FSTYPE_DEV(jffs2_fs_type, "jffs2", jffs2_read_super);
+
+static int __init init_jffs2_fs(void)
+{
+	int ret;
+
+	printk(KERN_NOTICE "JFFS2 version 2.1. (C) 2001 Red Hat, Inc., designed by Axis Communications AB.\n");
+
+#ifdef JFFS2_OUT_OF_KERNEL
+	/* sanity checks. Could we do these at compile time? */
+	if (sizeof(struct jffs2_sb_info) > sizeof (((struct super_block *)NULL)->u)) {
+		printk(KERN_ERR "JFFS2 error: struct jffs2_sb_info (%d bytes) doesn't fit in the super_block union (%d bytes)\n", 
+		       sizeof(struct jffs2_sb_info), sizeof (((struct super_block *)NULL)->u));
+		return -EIO;
+	}
+
+	if (sizeof(struct jffs2_inode_info) > sizeof (((struct inode *)NULL)->u)) {
+		printk(KERN_ERR "JFFS2 error: struct jffs2_inode_info (%d bytes) doesn't fit in the inode union (%d bytes)\n", 
+		       sizeof(struct jffs2_inode_info), sizeof (((struct inode *)NULL)->u));
+		return -EIO;
+	}
+#endif
+
+	ret = jffs2_create_slab_caches();
+	if (ret) {
+		printk(KERN_ERR "JFFS2 error: Failed to initialise slab caches\n");
+		return ret;
+	}
+	ret = register_filesystem(&jffs2_fs_type);
+	if (ret) {
+		printk(KERN_ERR "JFFS2 error: Failed to register filesystem\n");
+		jffs2_destroy_slab_caches();
+	}
+	return ret;
+}
+
+static void __exit exit_jffs2_fs(void)
+{
+	jffs2_destroy_slab_caches();
+	unregister_filesystem(&jffs2_fs_type);
+}
+
+module_init(init_jffs2_fs);
+module_exit(exit_jffs2_fs);
diff -Naur linux-2.4.2.orig/fs/jffs2/symlink.c linux-2.4.2/fs/jffs2/symlink.c
--- linux-2.4.2.orig/fs/jffs2/symlink.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/symlink.c	Fri Feb 15 14:41:16 2002
@@ -0,0 +1,105 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: symlink.c,v 1.5 2001/03/15 15:38:24 dwmw2 Exp $
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/jffs2.h>
+#include "nodelist.h"
+
+int jffs2_readlink(struct dentry *dentry, char *buffer, int buflen);
+int jffs2_follow_link(struct dentry *dentry, struct nameidata *nd);
+
+struct inode_operations jffs2_symlink_inode_operations =
+{	
+	readlink:	jffs2_readlink,
+	follow_link:	jffs2_follow_link,
+	setattr:	jffs2_setattr
+};
+
+static char *jffs2_getlink(struct dentry *dentry)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	char *buf;
+	int ret;
+
+	if (!f->metadata) {
+		printk(KERN_NOTICE "No metadata for symlink inode #%lu\n", dentry->d_inode->i_ino);
+		return ERR_PTR(-EINVAL);
+	}
+	buf = kmalloc(f->metadata->size+1, GFP_USER);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+	buf[f->metadata->size]=0;
+
+	ret = jffs2_read_dnode(JFFS2_SB_INFO(dentry->d_inode->i_sb), f->metadata, buf, 0, f->metadata->size);
+	if (ret) {
+		kfree(buf);
+		return ERR_PTR(ret);
+	}
+	return buf;
+
+}
+int jffs2_readlink(struct dentry *dentry, char *buffer, int buflen)
+{
+	unsigned char *kbuf;
+	int ret;
+
+	kbuf = jffs2_getlink(dentry);
+	if (IS_ERR(kbuf))
+		return PTR_ERR(kbuf);
+
+	ret = vfs_readlink(dentry, buffer, buflen, kbuf);
+	kfree(kbuf);
+	return ret;
+}
+
+int jffs2_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	unsigned char *buf;
+	int ret;
+
+	buf = jffs2_getlink(dentry);
+
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	ret = vfs_follow_link(nd, buf);
+	kfree(buf);
+	return ret;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/test/CVS/Entries linux-2.4.2/fs/jffs2/test/CVS/Entries
--- linux-2.4.2.orig/fs/jffs2/test/CVS/Entries	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/CVS/Entries	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,11 @@
+/compr_rubin.h/1.1/Mon Feb 19 10:21:30 2001//
+/histo.cc/1.1/Mon Feb 26 11:57:30 2001//
+/histo.h/1.1/Mon Feb 19 10:21:30 2001//
+/histo1.h/1.1/Mon Feb 19 10:21:30 2001//
+/histo2.h/1.1/Mon Feb 19 10:21:30 2001//
+/histo_html.h/1.1/Mon Feb 19 10:21:30 2001//
+/histo_text.h/1.1/Mon Feb 19 10:21:30 2001//
+/main.c/1.2/Mon Feb 19 12:01:59 2001//
+/pushpull.h/1.2/Mon Feb 19 11:20:43 2001//
+/rtime.h/1.1/Mon Feb 19 10:21:30 2001//
+D
diff -Naur linux-2.4.2.orig/fs/jffs2/test/CVS/Repository linux-2.4.2/fs/jffs2/test/CVS/Repository
--- linux-2.4.2.orig/fs/jffs2/test/CVS/Repository	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/CVS/Repository	Fri Feb 15 14:41:17 2002
@@ -0,0 +1 @@
+mtd/fs/jffs2/test
diff -Naur linux-2.4.2.orig/fs/jffs2/test/CVS/Root linux-2.4.2/fs/jffs2/test/CVS/Root
--- linux-2.4.2.orig/fs/jffs2/test/CVS/Root	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/CVS/Root	Fri Feb 15 14:41:17 2002
@@ -0,0 +1 @@
+:pserver:anoncvs@cvs.infradead.org:/home/cvs
diff -Naur linux-2.4.2.orig/fs/jffs2/test/compr_rubin.h linux-2.4.2/fs/jffs2/test/compr_rubin.h
--- linux-2.4.2.orig/fs/jffs2/test/compr_rubin.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/compr_rubin.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,13 @@
+/* Rubin encoder/decoder header       */
+/* work started at   : aug   3, 1994  */
+/* last modification : aug  15, 1994  */
+
+#define RUBIN_REG_SIZE   16
+#define UPPER_BIT_RUBIN    (((long) 1)<<RUBIN_REG_SIZE-1)
+#define LOWER_BITS_RUBIN   ((((long) 1)<<RUBIN_REG_SIZE-1)-1)
+
+void init_rubin (void);
+void encode (long, long, int);
+void end_rubin (void);
+void init_decod (void);
+int decode (long, long);
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo.cc linux-2.4.2/fs/jffs2/test/histo.cc
--- linux-2.4.2.orig/fs/jffs2/test/histo.cc	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo.cc	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,80 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+
+int histo[256];
+int histo2[256];
+int bits[8];
+int total;
+void main() 
+{
+	FILE *file;
+	int i,i2;
+
+	int max=0; 
+	
+/*	file = fopen("/lib/libc-2.2.so","r"); */
+	file = fopen("bigsymb2","r");
+	assert(file!=NULL);
+	while (!feof(file)) {
+		unsigned char cr;
+		fread(&cr,1,1,file);
+		histo[cr]++;		
+		if (histo[cr]>max)
+			max = histo[cr];
+	}	
+	fclose(file);
+
+	i2 = 0;
+
+#if 0
+	printf("static int xlate[257] = { ");
+
+
+	
+	/* Ugh slow */
+	while (max>=0) {	
+		for (i=0;i<256;i++) {	
+			if (histo[i]==max) {
+				printf("\t%i,\n",i);
+				histo2[i2++]=histo[i];
+			}
+		}
+		max--;
+	}	
+
+	printf(" };\n");
+
+	if (i2!=256)
+		printf("/* Uh oh: %i != 256 */ \n");
+#endif
+	
+	for (i=0;i<256;i++) {
+		if (i&128)
+			bits[7]+=histo[i];
+		if (i&64)
+			bits[6]+=histo[i];
+		if (i&32)
+			bits[5]+=histo[i];
+		if (i&16)
+			bits[4]+=histo[i];
+		if (i&8)
+			bits[3]+=histo[i];
+		if (i&4)
+			bits[2]+=histo[i];
+		if (i&2)
+			bits[1]+=histo[i];
+		if (i&1)
+			bits[0]+=histo[i];
+		total+=histo[i];
+	}
+	
+	printf("#define BIT_DIVIDER %i \n",total>>12);
+	printf("static int bits[9] = { ");
+	for (i=0;i<8;i++)
+		if ((bits[i]>>12)>0)
+			printf("%i,",bits[i]>>12);
+		else 
+			printf("1, ");
+	printf("};\n");
+}
\ No newline at end of file
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo.h linux-2.4.2/fs/jffs2/test/histo.h
--- linux-2.4.2.orig/fs/jffs2/test/histo.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER 1043 
+static int bits[9] = { 277,249,290,267,229,341,212,241,};
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo1.h linux-2.4.2/fs/jffs2/test/histo1.h
--- linux-2.4.2.orig/fs/jffs2/test/histo1.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo1.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER 755 
+static int bits[9] = { 108,125,128,93,84,89,119,94,};
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo2.h linux-2.4.2/fs/jffs2/test/histo2.h
--- linux-2.4.2.orig/fs/jffs2/test/histo2.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo2.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER 504 
+static int bits[9] = { 250,210,239,238,233,307,237,144,};
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo_html.h linux-2.4.2/fs/jffs2/test/histo_html.h
--- linux-2.4.2.orig/fs/jffs2/test/histo_html.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo_html.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER 631 
+static int bits[9] = { 268,247,324,252,199,529,436,1, };
diff -Naur linux-2.4.2.orig/fs/jffs2/test/histo_text.h linux-2.4.2/fs/jffs2/test/histo_text.h
--- linux-2.4.2.orig/fs/jffs2/test/histo_text.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/histo_text.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,2 @@
+#define BIT_DIVIDER 1187 
+static int bits[9] = { 518,418,533,414,310,1069,822,1, };
diff -Naur linux-2.4.2.orig/fs/jffs2/test/main.c linux-2.4.2/fs/jffs2/test/main.c
--- linux-2.4.2.orig/fs/jffs2/test/main.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/main.c	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,56 @@
+#include <stdio.h>
+
+#include "compr_rubin.h"
+
+#define __u32 int
+
+/* _compress returns the compressed size, -1 if bigger */
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen);
+
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen);
+
+void main()
+{
+	unsigned char source[4096];
+	unsigned char compr[40960];
+	unsigned char dest[4096];
+
+	int result;
+	int i;
+	int len,maxlen;
+	FILE *file;
+	
+	memset(dest,0xA5,sizeof(dest));
+	
+	for (i=0;i<4096;i++)
+		source[i] = i;
+		
+	file=fopen("asd","r");
+	while (!feof(file)) {
+		fread(source,1,4096,file);
+	
+		len = 4096;
+		maxlen = 40960;
+		result = rubin_compress(source,compr,&len, &maxlen);
+		if (result) {
+			printf("result is %d, exiting\n",result);
+			exit(0);
+		}
+		printf("Compressed to %i bytes \n",maxlen);
+		
+		if (maxlen>4096)
+			continue;
+	
+		rubin_decompress(compr,dest,4096,4096);
+		for (i=0;i<4096;i++)
+			if (source[i]!=dest[i]) {
+				printf("Mismatch at position %i: %i -> %i \n",i,source[i],dest[i]);
+			
+			}
+		
+	}
+	fclose(file);
+}
+
diff -Naur linux-2.4.2.orig/fs/jffs2/test/pushpull.h linux-2.4.2/fs/jffs2/test/pushpull.h
--- linux-2.4.2.orig/fs/jffs2/test/pushpull.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/pushpull.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,11 @@
+#define  PPBUFSIZ   2048
+void pushinit(unsigned char *buffer, unsigned int max);
+void pushbit(int bit);
+void pushblk(int blk, int bitsinblk);
+void pushexit(void);
+int pushedbits(void);
+void pullinit(unsigned char *buffer);
+int pullbit(void);
+int pullblk(int bitsinblk);
+void pullexit(void);
+int pulledbits(void);
diff -Naur linux-2.4.2.orig/fs/jffs2/test/rtime.h linux-2.4.2/fs/jffs2/test/rtime.h
--- linux-2.4.2.orig/fs/jffs2/test/rtime.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/test/rtime.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,8 @@
+#define __u32 int
+
+/* _compress returns the compressed size, -1 if bigger */
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen);
+
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen);
diff -Naur linux-2.4.2.orig/fs/jffs2/write.c linux-2.4.2/fs/jffs2/write.c
--- linux-2.4.2.orig/fs/jffs2/write.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/write.c	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,322 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: write.c,v 1.28 2001/05/01 16:25:25 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
+#include "nodelist.h"
+#include "crc32.h"
+
+/* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
+   fill in the raw_inode while you're at it. */
+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)
+{
+	struct inode *inode;
+	struct super_block *sb = dir_i->i_sb;
+	struct jffs2_inode_cache *ic;
+	struct jffs2_sb_info *c;
+	struct jffs2_inode_info *f;
+
+	D1(printk(KERN_DEBUG "jffs2_new_inode(): dir_i %ld, mode 0x%x\n", dir_i->i_ino, mode));
+
+	c = JFFS2_SB_INFO(sb);
+	memset(ri, 0, sizeof(*ri));
+
+	ic = jffs2_alloc_inode_cache();
+	if (!ic) {
+		return ERR_PTR(-ENOMEM);
+	}
+	memset(ic, 0, sizeof(*ic));
+	
+	inode = new_inode(sb);
+	
+	if (!inode) {
+		jffs2_free_inode_cache(ic);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Alloc jffs2_inode_info when that's split in 2.5 */
+
+	f = JFFS2_INODE_INFO(inode);
+	memset(f, 0, sizeof(*f));
+	init_MUTEX_LOCKED(&f->sem);
+	f->inocache = ic;
+	inode->i_nlink = f->inocache->nlink = 1;
+	f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
+	f->inocache->ino = ri->ino = inode->i_ino = ++c->highest_ino;
+	D1(printk(KERN_DEBUG "jffs2_new_inode(): Assigned ino# %d\n", ri->ino));
+	jffs2_add_ino_cache(c, f->inocache);
+
+	ri->magic = JFFS2_MAGIC_BITMASK;
+	ri->nodetype = JFFS2_NODETYPE_INODE;
+	ri->totlen = PAD(sizeof(*ri));
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+	ri->mode = mode;
+	f->highest_version = ri->version = 1;
+	ri->uid = current->fsuid;
+	if (dir_i->i_mode & S_ISGID) {
+		ri->gid = dir_i->i_gid;
+		if (S_ISDIR(mode))
+			ri->mode |= S_ISGID;
+	} else {
+		ri->gid = current->fsgid;
+	}
+	inode->i_mode = ri->mode;
+	inode->i_gid = ri->gid;
+	inode->i_uid = ri->uid;
+	inode->i_atime = inode->i_ctime = inode->i_mtime = 
+		ri->atime = ri->mtime = ri->ctime = CURRENT_TIME;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = 0;
+	inode->i_size = 0;
+
+	insert_inode_hash(inode);
+
+	return inode;
+}
+
+/* This ought to be in core MTD code. All registered MTD devices without writev should have
+   this put in place. Bug the MTD maintainer */
+static int mtd_fake_writev(struct mtd_info *mtd, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen)
+{
+	unsigned long i;
+	size_t totlen = 0, thislen;
+	int ret = 0;
+
+	for (i=0; i<count; i++) {
+		mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);
+		totlen += thislen;
+		if (ret || thislen != vecs[i].iov_len)
+			break;
+		to += vecs[i].iov_len;
+	}
+	if (retlen)
+		*retlen = totlen;
+	return ret;
+}
+
+
+static inline int mtd_writev(struct mtd_info *mtd, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen)
+{
+	if (mtd->writev)
+		return mtd->writev(mtd,vecs,count,to,retlen);
+	else
+		return mtd_fake_writev(mtd, vecs, count, to, retlen);
+}
+
+static void writecheck(struct mtd_info *mtd, __u32 ofs)
+{
+	unsigned char buf[16];
+	ssize_t retlen;
+	int ret, i;
+
+	ret = mtd->read(mtd, ofs, 16, &retlen, buf);
+	if (ret && retlen != 16) {
+		D1(printk(KERN_DEBUG "read failed or short in writecheck(). ret %d, retlen %d\n", ret, retlen));
+		return;
+	}
+	ret = 0;
+	for (i=0; i<16; i++) {
+		if (buf[i] != 0xff)
+			ret = 1;
+	}
+	if (ret) {
+		printk(KERN_WARNING "ARGH. About to write node to 0x%08x on flash, but there's data already there:\n", ofs);
+		printk(KERN_WARNING "0x%08x: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", 
+		       ofs,
+		       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
+		       buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);
+	}
+}
+
+	
+	
+
+/* jffs2_write_dnode - given a raw_inode, allocate a full_dnode for it, 
+   write it to the flash, link it into the existing inode/fragment list */
+
+struct jffs2_full_dnode *jffs2_write_dnode(struct inode *inode, struct jffs2_raw_inode *ri, const unsigned char *data, __u32 datalen, __u32 flash_ofs,  __u32 *writelen)
+
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dnode *fn;
+	ssize_t retlen;
+	struct iovec vecs[2];
+	int ret;
+
+	D1(if(ri->hdr_crc != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {
+		printk(KERN_CRIT "Eep. CRC not correct in jffs2_write_dnode()\n");
+		BUG();
+	}
+	   );
+	vecs[0].iov_base = ri;
+	vecs[0].iov_len = sizeof(*ri);
+	vecs[1].iov_base = (unsigned char *)data;
+	vecs[1].iov_len = datalen;
+
+	writecheck(c->mtd, flash_ofs);
+
+	if (ri->totlen != sizeof(*ri) + datalen) {
+		printk(KERN_WARNING "jffs2_write_dnode: ri->totlen (0x%08x) != sizeof(*ri) (0x%08x) + datalen (0x%08x)\n", ri->totlen, sizeof(*ri), datalen);
+	}
+	raw = jffs2_alloc_raw_node_ref();
+	if (!raw)
+		return ERR_PTR(-ENOMEM);
+	
+	fn = jffs2_alloc_full_dnode();
+	if (!fn) {
+		jffs2_free_raw_node_ref(raw);
+		return ERR_PTR(-ENOMEM);
+	}
+	raw->flash_offset = flash_ofs;
+	raw->totlen = PAD(ri->totlen);
+	raw->next_in_ino = f->inocache->nodes;
+	f->inocache->nodes = raw;
+	raw->next_phys = NULL;
+
+	fn->ofs = ri->offset;
+	fn->size = ri->dsize;
+	fn->frags = 0;
+	fn->raw = raw;
+
+	ret = mtd_writev(c->mtd, vecs, 2, flash_ofs, &retlen);
+	if (ret || (retlen != sizeof(*ri) + datalen)) {
+		printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %d\n", 
+		       sizeof(*ri)+datalen, flash_ofs, ret, retlen);
+		/* Mark the space as dirtied */
+		if (retlen) {
+			jffs2_add_physical_node_ref(c, raw, sizeof(*ri)+datalen, 1);
+			jffs2_mark_node_obsolete(c, raw);
+		} else {
+			printk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", raw->flash_offset);
+			jffs2_free_raw_node_ref(raw);
+		}
+
+		/* Release the full_dnode which is now useless, and return */
+		jffs2_free_full_dnode(fn);
+		if (writelen)
+			*writelen = retlen;
+		return ERR_PTR(ret?ret:-EIO);
+	}
+	/* Mark the space used */
+	jffs2_add_physical_node_ref(c, raw, retlen, 0);
+	D1(printk(KERN_DEBUG "jffs2_write_dnode wrote node at 0x%08x with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\n", flash_ofs, ri->dsize, ri->csize, ri->node_crc, ri->data_crc, ri->totlen));
+	if (writelen)
+		*writelen = retlen;
+
+	f->inocache->nodes = raw;
+	return fn;
+}
+
+struct jffs2_full_dirent *jffs2_write_dirent(struct inode *inode, struct jffs2_raw_dirent *rd, const unsigned char *name, __u32 namelen, __u32 flash_ofs,  __u32 *writelen)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
+	struct jffs2_raw_node_ref *raw;
+	struct jffs2_full_dirent *fd;
+	ssize_t retlen;
+	struct iovec vecs[2];
+	int ret;
+
+	D1(printk(KERN_DEBUG "jffs2_write_dirent(ino #%u, name at *0x%p \"%s\"->ino #%u, name_crc 0x%08x)\n", rd->pino, name, name, rd->ino, rd->name_crc));
+	writecheck(c->mtd, flash_ofs);
+
+	D1(if(rd->hdr_crc != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {
+		printk(KERN_CRIT "Eep. CRC not correct in jffs2_write_dirent()\n");
+		BUG();
+	}
+	   );
+
+	vecs[0].iov_base = rd;
+	vecs[0].iov_len = sizeof(*rd);
+	vecs[1].iov_base = (unsigned char *)name;
+	vecs[1].iov_len = namelen;
+	
+	raw = jffs2_alloc_raw_node_ref();
+
+	if (!raw)
+		return ERR_PTR(-ENOMEM);
+
+	fd = jffs2_alloc_full_dirent(namelen+1);
+	if (!fd) {
+		jffs2_free_raw_node_ref(raw);
+		return ERR_PTR(-ENOMEM);
+	}
+	raw->flash_offset = flash_ofs;
+	raw->totlen = PAD(rd->totlen);
+	raw->next_in_ino = f->inocache->nodes;
+	f->inocache->nodes = raw;
+	raw->next_phys = NULL;
+
+	fd->version = rd->version;
+	fd->ino = rd->ino;
+	fd->nhash = full_name_hash(name, strlen(name));
+	fd->type = rd->type;
+	memcpy(fd->name, name, namelen);
+	fd->name[namelen]=0;
+	fd->raw = raw;
+
+	ret = mtd_writev(c->mtd, vecs, 2, flash_ofs, &retlen);
+		if (ret || (retlen != sizeof(*rd) + namelen)) {
+			printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %d\n", 
+			       sizeof(*rd)+namelen, flash_ofs, ret, retlen);
+		/* Mark the space as dirtied */
+			if (retlen) {
+				jffs2_add_physical_node_ref(c, raw, sizeof(*rd)+namelen, 1);
+				jffs2_mark_node_obsolete(c, raw);
+			} else {
+				printk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", raw->flash_offset);
+				jffs2_free_raw_node_ref(raw);
+			}
+
+		/* Release the full_dnode which is now useless, and return */
+		jffs2_free_full_dirent(fd);
+		if (writelen)
+			*writelen = retlen;
+		return ERR_PTR(ret?ret:-EIO);
+	}
+	/* Mark the space used */
+	jffs2_add_physical_node_ref(c, raw, retlen, 0);
+	if (writelen)
+		*writelen = retlen;
+
+	f->inocache->nodes = raw;
+	return fd;
+}
diff -Naur linux-2.4.2.orig/fs/jffs2/zlib.c linux-2.4.2/fs/jffs2/zlib.c
--- linux-2.4.2.orig/fs/jffs2/zlib.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/zlib.c	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,5371 @@
+/*
+ * This file is derived from various .h and .c files from the zlib-1.0.4
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.  See zlib.h for conditions of
+ * distribution and use.
+ *
+ * Changes that have been made include:
+ * - added Z_PACKET_FLUSH (see zlib.h for details)
+ * - added inflateIncomp and deflateOutputPending
+ * - allow strm->next_out to be NULL, meaning discard the output
+ *
+ * $Id: zlib.c,v 1.3 1997/12/23 10:47:42 paulus Exp $
+ */
+
+/* 
+ *  ==FILEVERSION 971210==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+#define NO_DUMMY_DECL
+#define NO_ZCFUNCS
+#define MY_ZCALLOC
+
+#if defined(__FreeBSD__) && (defined(KERNEL) || defined(_KERNEL))
+#define inflate	inflate_ppp	/* FreeBSD already has an inflate :-( */
+#endif
+
+
+/* +++ zutil.h */
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* From: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */
+
+#ifndef _Z_UTIL_H
+#define _Z_UTIL_H
+
+#include "zlib.h"
+
+#if defined(KERNEL) || defined(_KERNEL)
+/* Assume this is a *BSD or SVR4 kernel */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/systm.h>
+#  define HAVE_MEMCPY
+#  define memcpy(d, s, n)	bcopy((s), (d), (n))
+#  define memset(d, v, n)	bzero((d), (n))
+#  define memcmp		bcmp
+
+#else
+#if defined(__KERNEL__)
+/* Assume this is a Linux kernel */
+#include <linux/string.h>
+#define HAVE_MEMCPY
+
+#else /* not kernel */
+
+#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
+#   include <stddef.h>
+#   include <errno.h>
+#else
+    extern int errno;
+#endif
+#ifdef STDC
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#endif /* __KERNEL__ */
+#endif /* _KERNEL || KERNEL */
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = (char*)ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#ifdef MSDOS
+#  define OS_CODE  0x00
+#  ifdef __TURBOC__
+#    include <alloc.h>
+#  else /* MSC or DJGPP */
+#    include <malloc.h>
+#  endif
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#endif
+
+#ifdef WIN32 /* Window 95 & Windows NT */
+#  define OS_CODE  0x0b
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define FOPEN(name, mode) \
+     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#ifdef MACOS
+#  define OS_CODE  0x07
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0F
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+        /* Common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef FOPEN
+#  define FOPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#ifdef HAVE_STRERROR
+   extern char *strerror OF((int));
+#  define zstrerror(errnum) strerror(errnum)
+#else
+#  define zstrerror(errnum) ""
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(_MSC_VER)
+ /* Use our own functions for small and medium model with MSC <= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
+   extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
+   extern void zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG_ZLIB
+#  include <stdio.h>
+#  ifndef verbose
+#    define verbose 0
+#  endif
+   extern void z_error    OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));
+
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void   zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* _Z_UTIL_H */
+/* --- zutil.h */
+
+/* +++ deflate.h */
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-1996 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* From: deflate.h,v 1.10 1996/07/02 12:41:00 me Exp $ */
+
+#ifndef _DEFLATE_H
+#define _DEFLATE_H
+
+/* #include "zutil.h" */
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct deflate_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    int   pending;       /* nb of bytes in the pending buffer */
+    int   noheader;      /* suppress zlib header and adler32 */
+    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH >= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels >= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels <= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    ulg compressed_len; /* total bit length of compressed file */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG_ZLIB
+    ulg bits_sent;      /* bit length of the compressed data */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+        /* in trees.c */
+void _tr_init         OF((deflate_state *s));
+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
+ulg  _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+			  int eof));
+void _tr_align        OF((deflate_state *s));
+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+void _tr_stored_type_only OF((deflate_state *));
+
+#endif
+/* --- deflate.h */
+
+/* +++ deflate.c */
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin & Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
+ *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* From: deflate.c,v 1.15 1996/07/24 13:40:58 me Exp $ */
+
+/* #include "deflate.h" */
+
+char deflate_copyright[] = " deflate 1.0.4 Copyright 1995-1996 Jean-loup Gailly ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, charf *buf, unsigned size));
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+
+#ifdef DEBUG_ZLIB
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+local config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
+
+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+#ifndef NO_DUMMY_DECL
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+#endif
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s->head[s->hash_size-1] = NIL; \
+    zmemzero((charf *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+
+/* ========================================================================= */
+int deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+			 Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm->next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+		  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int noheader = 0;
+    static char* my_version = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is <= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+	return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+#ifndef NO_ZCFUNCS
+    if (strm->zalloc == Z_NULL) {
+	strm->zalloc = zcalloc;
+	strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == Z_NULL) strm->zfree = zcfree;
+#endif
+
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+
+    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
+        noheader = 1;
+        windowBits = -windowBits;
+    }
+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
+	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm->state = (struct internal_state FAR *)s;
+    s->strm = strm;
+
+    s->noheader = noheader;
+    s->w_bits = windowBits;
+    s->w_size = 1 << s->w_bits;
+    s->w_mask = s->w_size - 1;
+
+    s->hash_bits = memLevel + 7;
+    s->hash_size = 1 << s->hash_bits;
+    s->hash_mask = s->hash_size - 1;
+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+
+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+    s->pending_buf = (uchf *) overlay;
+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+
+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
+        s->pending_buf == Z_NULL) {
+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+
+    s->level = level;
+    s->strategy = strategy;
+    s->method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
+	return Z_STREAM_ERROR;
+
+    s = (deflate_state *) strm->state;
+    if (s->status != INIT_STATE) return Z_STREAM_ERROR;
+
+    strm->adler = adler32(strm->adler, dictionary, dictLength);
+
+    if (length < MIN_MATCH) return Z_OK;
+    if (length > MAX_DIST(s)) {
+	length = MAX_DIST(s);
+#ifndef USE_DICT_HEAD
+	dictionary += dictLength - length; /* use the tail of the dictionary */
+#endif
+    }
+    zmemcpy((charf *)s->window, dictionary, length);
+    s->strstart = length;
+    s->block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s->lookahead stays null, so s->ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s->ins_h = s->window[0];
+    UPDATE_HASH(s, s->ins_h, s->window[1]);
+    for (n = 0; n <= length - MIN_MATCH; n++) {
+	INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+    
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->pending = 0;
+    s->pending_out = s->pending_buf;
+
+    if (s->noheader < 0) {
+        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
+    }
+    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
+    strm->adler = 1;
+    s->last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = (deflate_state *) strm->state;
+
+    if (level == Z_DEFAULT_COMPRESSION) {
+	level = 6;
+    }
+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+	return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s->level].func;
+
+    if (func != configuration_table[level].func && strm->total_in != 0) {
+	/* Flush the last buffer: */
+	err = deflate(strm, Z_PARTIAL_FLUSH);
+    }
+    if (s->level != level) {
+	s->level = level;
+	s->max_lazy_match   = configuration_table[level].max_lazy;
+	s->good_match       = configuration_table[level].good_length;
+	s->nice_match       = configuration_table[level].nice_length;
+	s->max_chain_length = configuration_table[level].max_chain;
+    }
+    s->strategy = strategy;
+    return err;
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b >> 8));
+    put_byte(s, (Byte)(b & 0xff));
+}   
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    deflate_state *s = (deflate_state *) strm->state;
+    unsigned len = s->pending;
+
+    if (len > strm->avail_out) len = strm->avail_out;
+    if (len == 0) return;
+
+    if (strm->next_out != Z_NULL) {
+	zmemcpy(strm->next_out, s->pending_out, len);
+	strm->next_out += len;
+    }
+    s->pending_out += len;
+    strm->total_out += len;
+    strm->avail_out  -= len;
+    s->pending -= len;
+    if (s->pending == 0) {
+        s->pending_out = s->pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+	flush > Z_FINISH || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) strm->state;
+
+    if ((strm->next_in == Z_NULL && strm->avail_in != 0) ||
+	(s->status == FINISH_STATE && flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s->strm = strm; /* just in case */
+    old_flush = s->last_flush;
+    s->last_flush = flush;
+
+    /* Write the zlib header */
+    if (s->status == INIT_STATE) {
+
+        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+        uInt level_flags = (s->level-1) >> 1;
+
+        if (level_flags > 3) level_flags = 3;
+        header |= (level_flags << 6);
+	if (s->strstart != 0) header |= PRESET_DICT;
+        header += 31 - (header % 31);
+
+        s->status = BUSY_STATE;
+        putShortMSB(s, header);
+
+	/* Save the adler32 of the preset dictionary: */
+	if (s->strstart != 0) {
+	    putShortMSB(s, (uInt)(strm->adler >> 16));
+	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+	}
+	strm->adler = 1L;
+    }
+
+    /* Flush as much pending output as possible */
+    if (s->pending != 0) {
+        flush_pending(strm);
+        if (strm->avail_out == 0) {
+	    /* Since avail_out is 0, deflate will be called again with
+	     * more output space, but possibly with both pending and
+	     * avail_in equal to zero. There won't be anything to do,
+	     * but this is not an error situation so make sure we
+	     * return OK instead of BUF_ERROR at next call of deflate:
+             */
+	    s->last_flush = -1;
+	    return Z_OK;
+	}
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
+     */
+    } else if (strm->avail_in == 0 && flush <= old_flush &&
+	       flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s->status == FINISH_STATE && strm->avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm->avail_in != 0 || s->lookahead != 0 ||
+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
+        block_state bstate;
+
+	bstate = (*(configuration_table[s->level].func))(s, flush);
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s->status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+	    if (strm->avail_out == 0) {
+	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
+	    }
+	    return Z_OK;
+	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+	     * of deflate should use the same flush parameter to make sure
+	     * that the flush is complete. So we don't have to output an
+	     * empty block here, this will be done at next call. This also
+	     * ensures that for a very small output buffer, we emit at most
+	     * one empty block.
+	     */
+	}
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+	    } else if (flush == Z_PACKET_FLUSH) {
+		/* Output just the 3-bit `stored' block type value,
+		   but not a zero length. */
+		_tr_stored_type_only(s);
+            } else { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                }
+            }
+            flush_pending(strm);
+	    if (strm->avail_out == 0) {
+	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+	      return Z_OK;
+	    }
+        }
+    }
+    Assert(strm->avail_out > 0, "bug2");
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s->noheader) return Z_STREAM_END;
+
+    /* Write the zlib trailer (adler32) */
+    putShortMSB(s, (uInt)(strm->adler >> 16));
+    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    s->noheader = -1; /* write the trailer only once! */
+    return s->pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = (deflate_state *) strm->state;
+
+    status = s->status;
+    if (status != INIT_STATE && status != BUSY_STATE &&
+	status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, s->pending_buf);
+    TRY_FREE(strm, s->head);
+    TRY_FREE(strm, s->prev);
+    TRY_FREE(strm, s->window);
+
+    ZFREE(strm, s);
+    strm->state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ */
+int deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL)
+        return Z_STREAM_ERROR;
+    ss = (deflate_state *) source->state;
+
+    *dest = *source;
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest->state = (struct internal_state FAR *) ds;
+    *ds = *ss;
+    ds->strm = dest;
+
+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+    ds->pending_buf = (uchf *) overlay;
+
+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
+        ds->pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* ??? following zmemcpy doesn't work for 16-bit MSDOS */
+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+
+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+
+    ds->l_desc.dyn_tree = ds->dyn_ltree;
+    ds->d_desc.dyn_tree = ds->dyn_dtree;
+    ds->bl_desc.dyn_tree = ds->bl_tree;
+
+    return Z_OK;
+}
+
+/* ===========================================================================
+ * Return the number of bytes of output which are immediately available
+ * for output from the decompressor.
+ */
+int deflateOutputPending (strm)
+    z_streamp strm;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL) return 0;
+    
+    return ((deflate_state *)(strm->state))->pending;
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    charf *buf;
+    unsigned size;
+{
+    unsigned len = strm->avail_in;
+
+    if (len > size) len = size;
+    if (len == 0) return 0;
+
+    strm->avail_in  -= len;
+
+    if (!((deflate_state *)(strm->state))->noheader) {
+        strm->adler = adler32(strm->adler, strm->next_in, len);
+    }
+    zmemcpy(buf, strm->next_in, len);
+    strm->next_in  += len;
+    strm->total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s->window_size = (ulg)2L*s->w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s->max_lazy_match   = configuration_table[s->level].max_lazy;
+    s->good_match       = configuration_table[s->level].good_length;
+    s->nice_match       = configuration_table[s->level].nice_length;
+    s->max_chain_length = configuration_table[s->level].max_chain;
+
+    s->strstart = 0;
+    s->block_start = 0L;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    s->ins_h = 0;
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+}
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s->prev_length;              /* best match length so far */
+    int nice_match = s->nice_match;             /* stop if match long enough */
+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
+        s->strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes <= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s->prev;
+    uInt wmask = s->w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s->prev_length >= s->good_match) {
+        chain_length >>= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    do {
+        Assert(cur_match < s->strstart, "no future");
+        match = s->window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2:
+         */
+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], "scan[2]?");
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 scan < strend);
+        /* The funny "do {}" generates better code on most compilers */
+
+        /* Here, scan <= window+strstart+257 */
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS >= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, "match[2]?");
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 scan < strend);
+
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len > best_len) {
+            s->match_start = cur_match;
+            best_len = len;
+            if (len >= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match & wmask]) > limit
+             && --chain_length != 0);
+
+    if ((uInt)best_len <= s->lookahead) return best_len;
+    return s->lookahead;
+}
+#endif /* ASMV */
+
+#ifdef DEBUG_ZLIB
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp((charf *)s->window + match,
+                (charf *)s->window + start, length) != EQUAL) {
+        fprintf(stderr, " start %u, match %u, length %d\n",
+		start, match, length);
+        do {
+	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+	} while (--length != 0);
+        z_error("invalid match");
+    }
+    if (z_verbose > 1) {
+        fprintf(stderr,"\\[%d,%d]", start-match, length);
+        do { putc(s->window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s->w_size;
+
+    do {
+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+            more = wsize;
+
+        } else if (more == (unsigned)(-1)) {
+            /* Very unlikely, but possible on 16 bit machine if strstart == 0
+             * and lookahead == 1 (input done one byte at time)
+             */
+            more--;
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        } else if (s->strstart >= wsize+MAX_DIST(s)) {
+
+            zmemcpy((charf *)s->window, (charf *)s->window+wsize,
+                   (unsigned)wsize);
+            s->match_start -= wsize;
+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            s->block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level > 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+            n = s->hash_size;
+            p = &s->head[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+            } while (--n);
+
+            n = wsize;
+            p = &s->prev[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+                /* If n is not on any hash chain, prev[n] is garbage but
+                 * its value will never be used.
+                 */
+            } while (--n);
+            more += wsize;
+        }
+        if (s->strm->avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+         *    more == window_size - lookahead - strstart
+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * => more >= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &&
+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more >= 2.
+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+         */
+        Assert(more >= 2, "more < 2");
+
+        n = read_buf(s->strm, (charf *)s->window + s->strstart + s->lookahead,
+                     more);
+        s->lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s->lookahead >= MIN_MATCH) {
+            s->ins_h = s->window[s->strstart];
+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, eof) { \
+   _tr_flush_block(s, (s->block_start >= 0L ? \
+                   (charf *)&s->window[(unsigned)s->block_start] : \
+                   (charf *)Z_NULL), \
+		(ulg)((long)s->strstart - s->block_start), \
+		(eof)); \
+   s->block_start = s->strstart; \
+   flush_pending(s->strm); \
+   Tracev((stderr,"[FLUSH]")); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, eof) { \
+   FLUSH_BLOCK_ONLY(s, eof); \
+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size > s->pending_buf_size - 5) {
+        max_block_size = s->pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s->lookahead <= 1) {
+
+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+		   s->block_start >= (long)s->w_size, "slide too late");
+
+            fill_window(s);
+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+	Assert(s->block_start >= 0L, "block gone");
+
+	s->strstart += s->lookahead;
+	s->lookahead = 0;
+
+	/* Emit a stored block if pending_buf will be full: */
+ 	max_start = s->block_start + max_block_size;
+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+	    /* strstart == 0 is possible when wraparound on 16-bit machine */
+	    s->lookahead = (uInt)(s->strstart - max_start);
+	    s->strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+	}
+	/* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+	}
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL; /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         * At this point we have always match_length < MIN_MATCH
+         */
+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+        }
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->match_start, s->match_length);
+
+            bflush = _tr_tally(s, s->strstart - s->match_start,
+                               s->match_length - MIN_MATCH);
+
+            s->lookahead -= s->match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+            if (s->match_length <= s->max_insert_length &&
+                s->lookahead >= MIN_MATCH) {
+                s->match_length--; /* string at strstart already in hash table */
+                do {
+                    s->strstart++;
+                    INSERT_STRING(s, s->strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s->match_length != 0);
+                s->strstart++; 
+            } else {
+                s->strstart += s->match_length;
+                s->match_length = 0;
+                s->ins_h = s->window[s->strstart];
+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            bflush = _tr_tally (s, 0, s->window[s->strstart]);
+            s->lookahead--;
+            s->strstart++; 
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL;    /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         */
+        s->prev_length = s->match_length, s->prev_match = s->match_start;
+        s->match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
+            s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+
+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
+                 (s->match_length == MIN_MATCH &&
+                  s->strstart - s->match_start > TOO_FAR))) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s->match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+
+            bflush = _tr_tally(s, s->strstart -1 - s->prev_match,
+                               s->prev_length - MIN_MATCH);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s->lookahead -= s->prev_length-1;
+            s->prev_length -= 2;
+            do {
+                if (++s->strstart <= max_insert) {
+                    INSERT_STRING(s, s->strstart, hash_head);
+                }
+            } while (--s->prev_length != 0);
+            s->match_available = 0;
+            s->match_length = MIN_MATCH-1;
+            s->strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s->match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,"%c", s->window[s->strstart-1]));
+            if (_tr_tally (s, 0, s->window[s->strstart-1])) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s->strstart++;
+            s->lookahead--;
+            if (s->strm->avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s->match_available = 1;
+            s->strstart++;
+            s->lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, "no flush?");
+    if (s->match_available) {
+        Tracevv((stderr,"%c", s->window[s->strstart-1]));
+        _tr_tally (s, 0, s->window[s->strstart-1]);
+        s->match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+/* --- deflate.c */
+
+/* +++ trees.c */
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-1996 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */
+
+/* #include "deflate.h" */
+
+#ifdef DEBUG_ZLIB
+#  include <ctype.h>
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+local uch dist_code[512];
+/* distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+local uch length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+struct static_tree_desc_s {
+    ct_data *static_tree;        /* static tree or NULL */
+    intf    *extra_bits;         /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(ct_data *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
+local void set_data_type  OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifndef DEBUG_ZLIB
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG_ZLIB */
+#  define send_code(s, c, tree) \
+     { if (verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+#define d_code(dist) \
+   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. dist_code[256] and dist_code[257] are never
+ * used.
+ */
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) & 0xff)); \
+    put_byte(s, (uch)((ush)(w) >> 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+#ifdef DEBUG_ZLIB
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr," l %2d v %4x ", length, value));
+    Assert(length > 0 && length <= 15, "invalid length");
+    s->bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s->bi_valid > (int)Buf_size - length) {
+        s->bi_buf |= (value << s->bi_valid);
+        put_short(s, s->bi_buf);
+        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_valid += length - Buf_size;
+    } else {
+        s->bi_buf |= value << s->bi_valid;
+        s->bi_valid += length;
+    }
+}
+#else /* !DEBUG_ZLIB */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s->bi_valid > (int)Buf_size - len) {\
+    int val = value;\
+    s->bi_buf |= (val << s->bi_valid);\
+    put_short(s, s->bi_buf);\
+    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_valid += len - Buf_size;\
+  } else {\
+    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_valid += len;\
+  }\
+}
+#endif /* DEBUG_ZLIB */
+
+
+#define MAX(a,b) (a >= b ? a : b)
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables. In a multi-threaded environment,
+ * this function may be called by two threads concurrently, but this is
+ * harmless since both invocations do exactly the same thing.
+ */
+local void tr_static_init()
+{
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* Initialize the mapping length (0..255) -> length code (0..28) */
+    length = 0;
+    for (code = 0; code < LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n < (1<<extra_lbits[code]); n++) {
+            length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, "tr_static_init: length != 256");
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code < 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n < (1<<extra_dbits[code]); n++) {
+            dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: dist != 256");
+    dist >>= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code < D_CODES; code++) {
+        base_dist[code] = dist << 7;
+        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
+            dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n < D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+}
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s->compressed_len = 0L;
+
+    s->l_desc.dyn_tree = s->dyn_ltree;
+    s->l_desc.stat_desc = &static_l_desc;
+
+    s->d_desc.dyn_tree = s->dyn_dtree;
+    s->d_desc.stat_desc = &static_d_desc;
+
+    s->bl_desc.dyn_tree = s->bl_tree;
+    s->bl_desc.stat_desc = &static_bl_desc;
+
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG_ZLIB
+    s->bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+
+    s->dyn_ltree[END_BLOCK].Freq = 1;
+    s->opt_len = s->static_len = 0L;
+    s->last_lit = s->matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s->heap[SMALLEST]; \
+    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq < tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s->heap[k];
+    int j = k << 1;  /* left son of k */
+    while (j <= s->heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j < s->heap_len &&
+            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s->heap[j], s->depth)) break;
+
+        /* Exchange v with the smallest son */
+        s->heap[k] = s->heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j <<= 1;
+    }
+    s->heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree  = desc->dyn_tree;
+    int max_code   = desc->max_code;
+    ct_data *stree = desc->stat_desc->static_tree;
+    intf *extra    = desc->stat_desc->extra_bits;
+    int base       = desc->stat_desc->extra_base;
+    int max_length = desc->stat_desc->max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+        n = s->heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits > max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n > max_code) continue; /* not a leaf node */
+
+        s->bl_count[bits]++;
+        xbits = 0;
+        if (n >= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s->opt_len += (ulg)f * (bits + xbits);
+        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,"\nbit length overflow\n"));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s->bl_count[bits] == 0) bits--;
+        s->bl_count[bits]--;      /* move one leaf down the tree */
+        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s->bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow > 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s->bl_count[bits];
+        while (n != 0) {
+            m = s->heap[--h];
+            if (m > max_code) continue;
+            if (tree[m].Len != (unsigned) bits) {
+                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+                s->opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits <= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+            "inconsistent bit counts");
+    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+    for (n = 0;  n <= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree   = desc->dyn_tree;
+    ct_data *stree  = desc->stat_desc->static_tree;
+    int elems       = desc->stat_desc->elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s->heap_len = 0, s->heap_max = HEAP_SIZE;
+
+    for (n = 0; n < elems; n++) {
+        if (tree[n].Freq != 0) {
+            s->heap[++(s->heap_len)] = max_code = n;
+            s->depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s->heap_len < 2) {
+        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s->depth[node] = 0;
+        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc->max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s->heap[SMALLEST]; /* m = node of next least frequency */
+
+        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
+        s->heap[--(s->heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s->bl_tree) {
+            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s->heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s->heap_len >= 2);
+
+    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            s->bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+            s->bl_tree[REP_3_6].Freq++;
+        } else if (count <= 10) {
+            s->bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s->bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s->bl_tree); count--;
+            }
+            Assert(count >= 3 && count <= 6, " 3_6?");
+            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count <= 10) {
+            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
+    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
+        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+            s->opt_len, s->static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+            "too many codes");
+    Tracev((stderr, "\nbl counts: "));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank < blcodes; rank++) {
+        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void _tr_stored_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len += (stored_len + 4) << 3;
+
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* Send just the `stored block' type code without any length bytes or data.
+ */
+void _tr_stored_type_only(s)
+    deflate_state *s;
+{
+    send_bits(s, (STORED_BLOCK << 1), 3);
+    bi_windup(s);
+    s->compressed_len = (s->compressed_len + 3) & ~7L;
+}
+
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES<<1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
+        send_bits(s, STATIC_TREES<<1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+        s->compressed_len += 10L;
+        bi_flush(s);
+    }
+    s->last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file. This function
+ * returns the total compressed length for the file so far.
+ */
+ulg _tr_flush_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s->level > 0) {
+
+	 /* Check if the file is ascii or binary */
+	if (s->data_type == Z_UNKNOWN) set_data_type(s);
+
+	/* Construct the literal and distance trees */
+	build_tree(s, (tree_desc *)(&(s->l_desc)));
+	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+
+	build_tree(s, (tree_desc *)(&(s->d_desc)));
+	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+	/* At this point, opt_len and static_len are the total bit lengths of
+	 * the compressed block data, excluding the tree representations.
+	 */
+
+	/* Build the bit length tree for the above two trees, and get the index
+	 * in bl_order of the last bit length code to send.
+	 */
+	max_blindex = build_bl_tree(s);
+
+	/* Determine the best encoding. Compute first the block length in bytes*/
+	opt_lenb = (s->opt_len+3+7)>>3;
+	static_lenb = (s->static_len+3+7)>>3;
+
+	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+		s->last_lit));
+
+	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, "lost buf");
+	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+    /* If compression failed and this is the first and last block,
+     * and if the .zip file can be seeked (to rewrite the local header),
+     * the whole file is transformed into a stored file:
+     */
+#ifdef STORED_FILE_OK
+#  ifdef FORCE_STORED_FILE
+    if (eof && s->compressed_len == 0L) { /* force stored file */
+#  else
+    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {
+#  endif
+        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
+        if (buf == (charf*)0) error ("block vanished");
+
+        copy_block(s, buf, (unsigned)stored_len, 0); /* without header */
+        s->compressed_len = stored_len << 3;
+        s->method = STORED;
+    } else
+#endif /* STORED_FILE_OK */
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, eof);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb >= 0) { /* force static trees */
+#else
+    } else if (static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES<<1)+eof, 3);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+        s->compressed_len += 3 + s->static_len;
+    } else {
+        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+        s->compressed_len += 3 + s->opt_len;
+    }
+    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+    init_block(s);
+
+    if (eof) {
+        bi_windup(s);
+        s->compressed_len += 7;  /* align on byte boundary */
+    }
+    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+           s->compressed_len-7*eof));
+
+    return s->compressed_len >> 3;
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s->d_buf[s->last_lit] = (ush)dist;
+    s->l_buf[s->last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s->dyn_ltree[lc].Freq++;
+    } else {
+        s->matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist < (ush)MAX_DIST(s) &&
+               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
+        s->dyn_dtree[d_code(dist)].Freq++;
+    }
+
+    /* Try to guess if it is profitable to stop the current block here */
+    if (s->level > 2 && (s->last_lit & 0xfff) == 0) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s->last_lit*8L;
+        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        int dcode;
+        for (dcode = 0; dcode < D_CODES; dcode++) {
+            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length >>= 3;
+        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+               s->last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+    }
+    return (s->last_lit == s->lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s->last_lit != 0) do {
+        dist = s->d_buf[lx];
+        lc = s->l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code < D_CODES, "bad d_code");
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
+
+    } while (lx < s->last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s->last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Set the data type to ASCII or BINARY, using a crude approximation:
+ * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
+ * IN assertion: the fields freq of dyn_ltree are set and the total of all
+ * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
+ */
+local void set_data_type(s)
+    deflate_state *s;
+{
+    int n = 0;
+    unsigned ascii_freq = 0;
+    unsigned bin_freq = 0;
+    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
+    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
+    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
+    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code & 1;
+        code >>= 1, res <<= 1;
+    } while (--len > 0);
+    return res >> 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s->bi_valid == 16) {
+        put_short(s, s->bi_buf);
+        s->bi_buf = 0;
+        s->bi_valid = 0;
+    } else if (s->bi_valid >= 8) {
+        put_byte(s, (Byte)s->bi_buf);
+        s->bi_buf >>= 8;
+        s->bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s->bi_valid > 8) {
+        put_short(s, s->bi_buf);
+    } else if (s->bi_valid > 0) {
+        put_byte(s, (Byte)s->bi_buf);
+    }
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+#ifdef DEBUG_ZLIB
+    s->bits_sent = (s->bits_sent+7) & ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);   
+        put_short(s, (ush)~len);
+#ifdef DEBUG_ZLIB
+        s->bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG_ZLIB
+    s->bits_sent += (ulg)len<<3;
+#endif
+    /* bundle up the put_byte(s, *buf++) calls */
+    zmemcpy(&s->pending_buf[s->pending], buf, len);
+    s->pending += len;
+}
+/* --- trees.c */
+
+/* +++ inflate.c */
+/* inflate.c -- zlib interface to inflate modules
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+
+/* +++ infblock.h */
+/* infblock.h -- header to use infblock.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state FAR inflate_blocks_statef;
+
+extern inflate_blocks_statef * inflate_blocks_new OF((
+    z_streamp z,
+    check_func c,               /* check function */
+    uInt w));                   /* window size */
+
+extern int inflate_blocks OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));                      /* initial return code */
+
+extern void inflate_blocks_reset OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern int inflate_blocks_free OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern void inflate_set_dictionary OF((
+    inflate_blocks_statef *s,
+    const Bytef *d,  /* dictionary */
+    uInt  n));       /* dictionary length */
+
+extern int inflate_addhistory OF((
+    inflate_blocks_statef *,
+    z_streamp));
+
+extern int inflate_packet_flush OF((
+    inflate_blocks_statef *));
+/* --- infblock.h */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* inflate private state */
+struct internal_state {
+
+  /* mode */
+  enum {
+      METHOD,   /* waiting for method byte */
+      FLAG,     /* waiting for flag byte */
+      DICT4,    /* four dictionary check bytes to go */
+      DICT3,    /* three dictionary check bytes to go */
+      DICT2,    /* two dictionary check bytes to go */
+      DICT1,    /* one dictionary check byte to go */
+      DICT0,    /* waiting for inflateSetDictionary */
+      BLOCKS,   /* decompressing blocks */
+      CHECK4,   /* four check bytes to go */
+      CHECK3,   /* three check bytes to go */
+      CHECK2,   /* two check bytes to go */
+      CHECK1,   /* one check byte to go */
+      DONE,     /* finished check, done */
+      BAD}      /* got an error--stay here */
+    mode;               /* current inflate mode */
+
+  /* mode dependent information */
+  union {
+    uInt method;        /* if FLAGS, method byte */
+    struct {
+      uLong was;                /* computed check value */
+      uLong need;               /* stream check value */
+    } check;            /* if CHECK, check values to compare */
+    uInt marker;        /* if BAD, inflateSync's marker bytes count */
+  } sub;        /* submode */
+
+  /* mode independent information */
+  int  nowrap;          /* flag for no wrapper */
+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
+  inflate_blocks_statef 
+    *blocks;            /* current inflate_blocks state */
+
+};
+
+
+int inflateReset(z)
+z_streamp z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
+  inflate_blocks_reset(z->state->blocks, z, &c);
+  Trace((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+
+int inflateEnd(z)
+z_streamp z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z, &c);
+  ZFREE(z, z->state);
+  z->state = Z_NULL;
+  Trace((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int inflateInit2_(z, w, version, stream_size)
+z_streamp z;
+int w;
+const char *version;
+int stream_size;
+{
+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+      stream_size != sizeof(z_stream))
+      return Z_VERSION_ERROR;
+
+  /* initialize state */
+  if (z == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->msg = Z_NULL;
+#ifndef NO_ZCFUNCS
+  if (z->zalloc == Z_NULL)
+  {
+    z->zalloc = zcalloc;
+    z->opaque = (voidpf)0;
+  }
+  if (z->zfree == Z_NULL) z->zfree = zcfree;
+#endif
+  if ((z->state = (struct internal_state FAR *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  /* handle undocumented nowrap option (no zlib header or check) */
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  /* set window size */
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  /* create inflate_blocks state */
+  if ((z->state->blocks =
+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Trace((stderr, "inflate: allocated\n"));
+
+  /* reset state */
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+int inflateInit_(z, version, stream_size)
+z_streamp z;
+const char *version;
+int stream_size;
+{
+  return inflateInit2_(z, DEF_WBITS, version, stream_size);
+}
+
+
+#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int inflate(z, f)
+z_streamp z;
+int f;
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL || f < 0)
+    return Z_STREAM_ERROR;
+  r = Z_BUF_ERROR;
+  while (1) switch (z->state->mode)
+  {
+    case METHOD:
+      NEEDBYTE
+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"unknown compression method";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"invalid window size";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      z->state->mode = FLAG;
+    case FLAG:
+      NEEDBYTE
+      b = NEXTBYTE;
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect header check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Trace((stderr, "inflate: zlib header ok\n"));
+      if (!(b & PRESET_DICT))
+      {
+        z->state->mode = BLOCKS;
+	break;
+      }
+      z->state->mode = DICT4;
+    case DICT4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = DICT3;
+    case DICT3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = DICT2;
+    case DICT2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = DICT1;
+    case DICT1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+      z->adler = z->state->sub.check.need;
+      z->state->mode = DICT0;
+      return Z_NEED_DICT;
+    case DICT0:
+      z->state->mode = BAD;
+      z->msg = (char*)"need dictionary";
+      z->state->sub.marker = 0;       /* can try inflateSync */
+      return Z_STREAM_ERROR;
+    case BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
+	  r = inflate_packet_flush(z->state->blocks);
+      if (r == Z_DATA_ERROR)
+      {
+        z->state->mode = BAD;
+        z->state->sub.marker = 0;       /* can try inflateSync */
+        break;
+      }
+      if (r != Z_STREAM_END)
+        return r;
+      r = Z_OK;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+        z->state->mode = DONE;
+        break;
+      }
+      z->state->mode = CHECK4;
+    case CHECK4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = CHECK3;
+    case CHECK3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = CHECK2;
+    case CHECK2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = CHECK1;
+    case CHECK1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect data check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Trace((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = DONE;
+    case DONE:
+      return Z_STREAM_END;
+    case BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+
+ empty:
+  if (f != Z_PACKET_FLUSH)
+    return r;
+  z->state->mode = BAD;
+  z->msg = (char *)"need more for packet flush";
+  z->state->sub.marker = 0;       /* can try inflateSync */
+  return Z_DATA_ERROR;
+}
+
+
+int inflateSetDictionary(z, dictionary, dictLength)
+z_streamp z;
+const Bytef *dictionary;
+uInt  dictLength;
+{
+  uInt length = dictLength;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
+    return Z_STREAM_ERROR;
+
+  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
+  z->adler = 1L;
+
+  if (length >= ((uInt)1<<z->state->wbits))
+  {
+    length = (1<<z->state->wbits)-1;
+    dictionary += dictLength - length;
+  }
+  inflate_set_dictionary(z->state->blocks, dictionary, length);
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+
+int inflateIncomp(z)
+z_stream *z;
+{
+    if (z->state->mode != BLOCKS)
+	return Z_DATA_ERROR;
+    return inflate_addhistory(z->state->blocks, z);
+}
+
+
+int inflateSync(z)
+z_streamp z;
+{
+  uInt n;       /* number of bytes to look at */
+  Bytef *p;     /* pointer to bytes */
+  uInt m;       /* number of marker bytes found in a row */
+  uLong r, w;   /* temporaries to save total_in and total_out */
+
+  /* set up */
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->mode != BAD)
+  {
+    z->state->mode = BAD;
+    z->state->sub.marker = 0;
+  }
+  if ((n = z->avail_in) == 0)
+    return Z_BUF_ERROR;
+  p = z->next_in;
+  m = z->state->sub.marker;
+
+  /* search */
+  while (n && m < 4)
+  {
+    if (*p == (Byte)(m < 2 ? 0 : 0xff))
+      m++;
+    else if (*p)
+      m = 0;
+    else
+      m = 4 - m;
+    p++, n--;
+  }
+
+  /* restore */
+  z->total_in += p - z->next_in;
+  z->next_in = p;
+  z->avail_in = n;
+  z->state->sub.marker = m;
+
+  /* return no joy or set up to restart on a new block */
+  if (m != 4)
+    return Z_DATA_ERROR;
+  r = z->total_in;  w = z->total_out;
+  inflateReset(z);
+  z->total_in = r;  z->total_out = w;
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+#undef NEEDBYTE
+#undef NEXTBYTE
+/* --- inflate.c */
+
+/* +++ infblock.c */
+/* infblock.c -- interpret and process block types to last block
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "infblock.h" */
+
+/* +++ inftrees.h */
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Huffman code lookup table entry--this entry is four bytes for machines
+   that have 16-bit pointers (e.g. PC's in the small or medium model). */
+
+typedef struct inflate_huft_s FAR inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        /* number of extra bits or operation */
+      Byte Bits;        /* number of bits in this code or subcode */
+    } what;
+    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
+  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
+  union {
+    uInt Base;          /* literal, length base, or distance base */
+    inflate_huft *Next; /* pointer to next level of table */
+  } more;
+};
+
+#ifdef DEBUG_ZLIB
+  extern uInt inflate_hufts;
+#endif
+
+extern int inflate_trees_bits OF((
+    uIntf *,                    /* 19 code lengths */
+    uIntf *,                    /* bits tree desired/actual depth */
+    inflate_huft * FAR *,       /* bits tree result */
+    z_streamp ));               /* for zalloc, zfree functions */
+
+extern int inflate_trees_dynamic OF((
+    uInt,                       /* number of literal/length codes */
+    uInt,                       /* number of distance codes */
+    uIntf *,                    /* that many (total) code lengths */
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    z_streamp ));               /* for zalloc, zfree functions */
+
+extern int inflate_trees_fixed OF((
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *));     /* distance tree result */
+
+extern int inflate_trees_free OF((
+    inflate_huft *,             /* tables to free */
+    z_streamp ));               /* for zfree function */
+
+/* --- inftrees.h */
+
+/* +++ infcodes.h */
+/* infcodes.h -- header to use infcodes.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state FAR inflate_codes_statef;
+
+extern inflate_codes_statef *inflate_codes_new OF((
+    uInt, uInt,
+    inflate_huft *, inflate_huft *,
+    z_streamp ));
+
+extern int inflate_codes OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+extern void inflate_codes_free OF((
+    inflate_codes_statef *,
+    z_streamp ));
+
+/* --- infcodes.h */
+
+/* +++ infutil.h */
+/* infutil.h -- types and macros common to blocks and codes
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFUTIL_H
+#define _INFUTIL_H
+
+typedef enum {
+      TYPE,     /* get type bits (3, including end bit) */
+      LENS,     /* get lengths for stored */
+      STORED,   /* processing stored block */
+      TABLE,    /* get table lengths */
+      BTREE,    /* get bit lengths tree for a dynamic block */
+      DTREE,    /* get length, distance trees for a dynamic block */
+      CODES,    /* processing fixed or dynamic block */
+      DRY,      /* output remaining window bytes */
+      DONEB,    /* finished last block, done */
+      BADB}     /* got a data error--stuck here */
+inflate_block_mode;
+
+/* inflate blocks semi-private state */
+struct inflate_blocks_state {
+
+  /* mode */
+  inflate_block_mode  mode;     /* current inflate_block mode */
+
+  /* mode dependent information */
+  union {
+    uInt left;          /* if STORED, bytes left to copy */
+    struct {
+      uInt table;               /* table lengths (14 bits) */
+      uInt index;               /* index into blens (or border) */
+      uIntf *blens;             /* bit lengths of codes */
+      uInt bb;                  /* bit length tree depth */
+      inflate_huft *tb;         /* bit length decoding tree */
+    } trees;            /* if DTREE, decoding info for trees */
+    struct {
+      inflate_huft *tl;
+      inflate_huft *td;         /* trees to free */
+      inflate_codes_statef 
+         *codes;
+    } decode;           /* if CODES, current state */
+  } sub;                /* submode */
+  uInt last;            /* true if this block is the last block */
+
+  /* mode independent information */
+  uInt bitk;            /* bits in bit buffer */
+  uLong bitb;           /* bit buffer */
+  Bytef *window;        /* sliding window */
+  Bytef *end;           /* one byte after sliding window */
+  Bytef *read;          /* window read pointer */
+  Bytef *write;         /* window write pointer */
+  check_func checkfn;   /* check function */
+  uLong check;          /* check on output */
+
+};
+
+
+/* defines for inflate input/output */
+/*   update pointers and return */
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+/*   get bytes and bits */
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+/*   output bytes */
+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
+#define WWRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WWRAP if(m==0){FLUSH WWRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+/*   load local pointers */
+#define LOAD {LOADIN LOADOUT}
+
+/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
+extern uInt inflate_mask[17];
+
+/* copy as much as possible from the sliding window to the output area */
+extern int inflate_flush OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+#endif
+/* --- infutil.h */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* Table for deflate from PKZIP's appnote.txt. */
+local const uInt border[] = { /* Order of the bit length code lengths */
+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+/*
+   Notes beyond the 1.93a appnote.txt:
+
+   1. Distance pointers never point before the beginning of the output
+      stream.
+   2. Distance pointers can point back across blocks, up to 32k away.
+   3. There is an implied maximum of 7 bits for the bit length table and
+      15 bits for the actual data.
+   4. If only one code exists, then it is encoded using one bit.  (Zero
+      would be more efficient, but perhaps a little confusing.)  If two
+      codes exist, they are coded using one bit each (0 and 1).
+   5. There is no way of sending zero distance codes--a dummy must be
+      sent if there are none.  (History: a pre 2.0 version of PKZIP would
+      store blocks with no distance codes, but this was discovered to be
+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+      zero distance codes, which is sent as one code of zero bits in
+      length.
+   6. There are up to 286 literal/length codes.  Code 256 represents the
+      end-of-block.  Note however that the static length tree defines
+      288 codes just to fill out the Huffman codes.  Codes 286 and 287
+      cannot be used though, since there is no length base or extra bits
+      defined for them.  Similarily, there are up to 30 distance codes.
+      However, static trees define 32 codes (all 5 bits) to fill out the
+      Huffman codes, but the last two had better not show up in the data.
+   7. Unzip can check dynamic Huffman blocks for complete code sets.
+      The exception is that a single code would not be complete (see #4).
+   8. The five bits following the block type is really the number of
+      literal codes sent minus 257.
+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+      (1+6+6).  Therefore, to output three times the length, you output
+      three codes (1+1+1), whereas to output four times the same length,
+      you only need two codes (1+3).  Hmm.
+  10. In the tree reconstruction algorithm, Code = Code + Increment
+      only if BitLength(i) is not zero.  (Pretty obvious.)
+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+  12. Note: length code 284 can represent 227-258, but length code 285
+      really is 258.  The last length deserves its own, short code
+      since it gets used a lot in very redundant files.  The length
+      258 is special since 258 - 3 (the min match length) is 255.
+  13. The literal/length and distance code bit lengths are read as a
+      single stream of lengths.  It is possible (and advantageous) for
+      a repeat code (16, 17, or 18) to go across the boundary between
+      the two sets of lengths.
+ */
+
+
+void inflate_blocks_reset(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  if (s->checkfn != Z_NULL)
+    *c = s->check;
+  if (s->mode == BTREE || s->mode == DTREE)
+    ZFREE(z, s->sub.trees.blens);
+  if (s->mode == CODES)
+  {
+    inflate_codes_free(s->sub.decode.codes, z);
+    inflate_trees_free(s->sub.decode.td, z);
+    inflate_trees_free(s->sub.decode.tl, z);
+  }
+  s->mode = TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(0L, Z_NULL, 0);
+  Trace((stderr, "inflate:   blocks reset\n"));
+}
+
+
+inflate_blocks_statef *inflate_blocks_new(z, c, w)
+z_streamp z;
+check_func c;
+uInt w;
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = TYPE;
+  Trace((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, &s->check);
+  return s;
+}
+
+
+#ifdef DEBUG_ZLIB
+  extern uInt inflate_hufts;
+#endif
+int inflate_blocks(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt t;               /* temporary storage */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input based on current state */
+  while (1) switch (s->mode)
+  {
+    case TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+        case 0:                         /* stored */
+          Trace((stderr, "inflate:     stored block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          t = k & 7;                    /* go to byte boundary */
+          DUMPBITS(t)
+          s->mode = LENS;               /* get length of stored block */
+          break;
+        case 1:                         /* fixed */
+          Trace((stderr, "inflate:     fixed codes block%s\n",
+                 s->last ? " (last)" : ""));
+          {
+            uInt bl, bd;
+            inflate_huft *tl, *td;
+
+            inflate_trees_fixed(&bl, &bd, &tl, &td);
+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+            if (s->sub.decode.codes == Z_NULL)
+            {
+              r = Z_MEM_ERROR;
+              LEAVE
+            }
+            s->sub.decode.tl = Z_NULL;  /* don't try to free these */
+            s->sub.decode.td = Z_NULL;
+          }
+          DUMPBITS(3)
+          s->mode = CODES;
+          break;
+        case 2:                         /* dynamic */
+          Trace((stderr, "inflate:     dynamic codes block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          s->mode = TABLE;
+          break;
+        case 3:                         /* illegal */
+          DUMPBITS(3)
+          s->mode = BADB;
+          z->msg = (char*)"invalid block type";
+          r = Z_DATA_ERROR;
+          LEAVE
+      }
+      break;
+    case LENS:
+      NEEDBITS(32)
+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
+      {
+        s->mode = BADB;
+        z->msg = (char*)"invalid stored block lengths";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      /* dump bits */
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
+      break;
+    case STORED:
+      if (n == 0)
+        LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      zmemcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+        break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? DRY : TYPE;
+      break;
+    case TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+#ifndef PKZIP_BUG_WORKAROUND
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+        s->mode = BADB;
+        z->msg = (char*)"too many length or distance symbols";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+#endif
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if (t < 19)
+        t = 19;
+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+        r = Z_MEM_ERROR;
+        LEAVE
+      }
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = BTREE;
+    case BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+        NEEDBITS(3)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+        DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+                             &s->sub.trees.tb, z);
+      if (t != Z_OK)
+      {
+        ZFREE(z, s->sub.trees.blens);
+        r = t;
+        if (r == Z_DATA_ERROR)
+          s->mode = BADB;
+        LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = DTREE;
+    case DTREE:
+      while (t = s->sub.trees.table,
+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+        inflate_huft *h;
+        uInt i, j, c;
+
+        t = s->sub.trees.bb;
+        NEEDBITS(t)
+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+        t = h->word.what.Bits;
+        c = h->more.Base;
+        if (c < 16)
+        {
+          DUMPBITS(t)
+          s->sub.trees.blens[s->sub.trees.index++] = c;
+        }
+        else /* c == 16..18 */
+        {
+          i = c == 18 ? 7 : c - 14;
+          j = c == 18 ? 11 : 3;
+          NEEDBITS(t + i)
+          DUMPBITS(t)
+          j += (uInt)b & inflate_mask[i];
+          DUMPBITS(i)
+          i = s->sub.trees.index;
+          t = s->sub.trees.table;
+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+              (c == 16 && i < 1))
+          {
+            inflate_trees_free(s->sub.trees.tb, z);
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = BADB;
+            z->msg = (char*)"invalid bit length repeat";
+            r = Z_DATA_ERROR;
+            LEAVE
+          }
+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+          do {
+            s->sub.trees.blens[i++] = c;
+          } while (--j);
+          s->sub.trees.index = i;
+        }
+      }
+      inflate_trees_free(s->sub.trees.tb, z);
+      s->sub.trees.tb = Z_NULL;
+      {
+        uInt bl, bd;
+        inflate_huft *tl, *td;
+        inflate_codes_statef *c;
+
+        bl = 9;         /* must be <= 9 for lookahead assumptions */
+        bd = 6;         /* must be <= 9 for lookahead assumptions */
+        t = s->sub.trees.table;
+#ifdef DEBUG_ZLIB
+      inflate_hufts = 0;
+#endif
+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+                                  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
+        ZFREE(z, s->sub.trees.blens);
+        if (t != Z_OK)
+        {
+          if (t == (uInt)Z_DATA_ERROR)
+            s->mode = BADB;
+          r = t;
+          LEAVE
+        }
+        Tracev((stderr, "inflate:       trees ok, %d * %d bytes used\n",
+              inflate_hufts, sizeof(inflate_huft)));
+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+        {
+          inflate_trees_free(td, z);
+          inflate_trees_free(tl, z);
+          r = Z_MEM_ERROR;
+          LEAVE
+        }
+        s->sub.decode.codes = c;
+        s->sub.decode.tl = tl;
+        s->sub.decode.td = td;
+      }
+      s->mode = CODES;
+    case CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+        return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      inflate_trees_free(s->sub.decode.td, z);
+      inflate_trees_free(s->sub.decode.tl, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+        s->mode = TYPE;
+        break;
+      }
+      if (k > 7)              /* return unused byte, if any */
+      {
+        Assert(k < 16, "inflate_codes grabbed too many bytes")
+        k -= 8;
+        n++;
+        p--;                    /* can always return one */
+      }
+      s->mode = DRY;
+    case DRY:
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      s->mode = DONEB;
+    case DONEB:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADB:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+int inflate_blocks_free(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  inflate_blocks_reset(s, z, c);
+  ZFREE(z, s->window);
+  ZFREE(z, s);
+  Trace((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+
+void inflate_set_dictionary(s, d, n)
+inflate_blocks_statef *s;
+const Bytef *d;
+uInt  n;
+{
+  zmemcpy((charf *)s->window, d, n);
+  s->read = s->write = s->window + n;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+int inflate_addhistory(s, z)
+inflate_blocks_statef *s;
+z_stream *z;
+{
+    uLong b;              /* bit buffer */  /* NOT USED HERE */
+    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
+    uInt t;               /* temporary storage */
+    Bytef *p;             /* input data pointer */
+    uInt n;               /* bytes available there */
+    Bytef *q;             /* output window write pointer */
+    uInt m;               /* bytes to end of window or read pointer */
+
+    if (s->read != s->write)
+	return Z_STREAM_ERROR;
+    if (s->mode != TYPE)
+	return Z_DATA_ERROR;
+
+    /* we're ready to rock */
+    LOAD
+    /* while there is input ready, copy to output buffer, moving
+     * pointers as needed.
+     */
+    while (n) {
+	t = n;  /* how many to do */
+	/* is there room until end of buffer? */
+	if (t > m) t = m;
+	/* update check information */
+	if (s->checkfn != Z_NULL)
+	    s->check = (*s->checkfn)(s->check, q, t);
+	zmemcpy(q, p, t);
+	q += t;
+	p += t;
+	n -= t;
+	z->total_out += t;
+	s->read = q;    /* drag read pointer forward */
+/*      WWRAP  */ 	/* expand WWRAP macro by hand to handle s->read */
+	if (q == s->end) {
+	    s->read = q = s->window;
+	    m = WAVAIL;
+	}
+    }
+    UPDATE
+    return Z_OK;
+}
+
+
+/*
+ * At the end of a Deflate-compressed PPP packet, we expect to have seen
+ * a `stored' block type value but not the (zero) length bytes.
+ */
+int inflate_packet_flush(s)
+    inflate_blocks_statef *s;
+{
+    if (s->mode != LENS)
+	return Z_DATA_ERROR;
+    s->mode = TYPE;
+    return Z_OK;
+}
+/* --- infblock.c */
+
+/* +++ inftrees.c */
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+
+char inflate_copyright[] = " inflate 1.0.4 Copyright 1995-1996 Mark Adler ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+#ifndef NO_DUMMY_DECL
+struct internal_state  {int dummy;}; /* for buggy compilers */
+#endif
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+
+local int huft_build OF((
+    uIntf *,            /* code lengths in bits */
+    uInt,               /* number of codes */
+    uInt,               /* number of "simple" codes */
+    const uIntf *,      /* list of base values for non-simple codes */
+    const uIntf *,      /* list of extra bits for non-simple codes */
+    inflate_huft * FAR*,/* result: starting table */
+    uIntf *,            /* maximum lookup bits (returns actual) */
+    z_streamp ));       /* for zalloc function */
+
+local voidpf falloc OF((
+    voidpf,             /* opaque pointer (not used) */
+    uInt,               /* number of items */
+    uInt));             /* size of item */
+
+/* Tables for deflate from PKZIP's appnote.txt. */
+local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+        /* see note #13 above about 258 */
+local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
+local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577};
+local const uInt cpdext[30] = { /* Extra bits for distance codes */
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+        12, 12, 13, 13};
+
+/*
+   Huffman code decoding is performed using a multi-level table lookup.
+   The fastest way to decode is to simply build a lookup table whose
+   size is determined by the longest code.  However, the time it takes
+   to build this table can also be a factor if the data being decoded
+   is not very long.  The most common codes are necessarily the
+   shortest codes, so those codes dominate the decoding time, and hence
+   the speed.  The idea is you can have a shorter table that decodes the
+   shorter, more probable codes, and then point to subsidiary tables for
+   the longer codes.  The time it costs to decode the longer codes is
+   then traded against the time it takes to make longer tables.
+
+   This results of this trade are in the variables lbits and dbits
+   below.  lbits is the number of bits the first level table for literal/
+   length codes can decode in one step, and dbits is the same thing for
+   the distance codes.  Subsequent tables are also less than or equal to
+   those sizes.  These values may be adjusted either when all of the
+   codes are shorter than that, in which case the longest code length in
+   bits is used, or when the shortest code is *longer* than the requested
+   table size, in which case the length of the shortest code in bits is
+   used.
+
+   There are two different values for the two tables, since they code a
+   different number of possibilities each.  The literal/length table
+   codes 286 possible values, or in a flat code, a little over eight
+   bits.  The distance table codes 30 possible values, or a little less
+   than five bits, flat.  The optimum values for speed end up being
+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+   The optimum values may differ though from machine to machine, and
+   possibly even between compilers.  Your mileage may vary.
+ */
+
+
+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
+#define BMAX 15         /* maximum bit length of any code */
+#define N_MAX 288       /* maximum number of codes in any set */
+
+#ifdef DEBUG_ZLIB
+  uInt inflate_hufts;
+#endif
+
+local int huft_build(b, n, s, d, e, t, m, zs)
+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
+uInt n;                 /* number of codes (assumed <= N_MAX) */
+uInt s;                 /* number of simple-valued codes (0..s-1) */
+const uIntf *d;         /* list of base values for non-simple codes */
+const uIntf *e;         /* list of extra bits for non-simple codes */
+inflate_huft * FAR *t;  /* result: starting table */
+uIntf *m;               /* maximum lookup bits, returns actual */
+z_streamp zs;           /* for zalloc function */
+/* Given a list of code lengths and a maximum table size, make a set of
+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+   if the given code set is incomplete (the tables are still built in this
+   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
+   lengths), or Z_MEM_ERROR if not enough memory. */
+{
+
+  uInt a;                       /* counter for codes of length k */
+  uInt c[BMAX+1];               /* bit length count table */
+  uInt f;                       /* i repeats in table every f entries */
+  int g;                        /* maximum code length */
+  int h;                        /* table level */
+  register uInt i;              /* counter, current code */
+  register uInt j;              /* counter */
+  register int k;               /* number of bits in current code */
+  int l;                        /* bits per table (returned in m) */
+  register uIntf *p;            /* pointer into c[], b[], or v[] */
+  inflate_huft *q;              /* points to current table */
+  struct inflate_huft_s r;      /* table entry for structure assignment */
+  inflate_huft *u[BMAX];        /* table stack */
+  uInt v[N_MAX];                /* values in order of bit length */
+  register int w;               /* bits before this table == (l * h) */
+  uInt x[BMAX+1];               /* bit offsets, then code stack */
+  uIntf *xp;                    /* pointer into x */
+  int y;                        /* number of dummy codes added */
+  uInt z;                       /* number of entries in current table */
+
+
+  /* Generate counts for each bit length */
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4                            /* clear c[]--assume BMAX+1 is 16 */
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  /* assume all entries <= BMAX */
+  } while (--i);
+  if (c[0] == n)                /* null input--all zero length codes */
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  /* Find minimum and maximum length, bound *m by those */
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        /* minimum code length */
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        /* maximum code length */
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  /* Adjust last length count to fill out codes, if needed */
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  /* Generate starting offsets into the value table for each length */
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 /* note that i == g from above */
+    *xp++ = (j += *p++);
+  }
+
+
+  /* Make a table of values in order of bit lengths */
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+  n = x[g];                   /* set n to length of v */
+
+
+  /* Generate the Huffman codes and for each, make the table entries */
+  x[0] = i = 0;                 /* first Huffman code is zero */
+  p = v;                        /* grab values in bit order */
+  h = -1;                       /* no tables yet--level -1 */
+  w = -l;                       /* bits decoded == (l * h) */
+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
+  q = (inflate_huft *)Z_NULL;   /* ditto */
+  z = 0;                        /* ditto */
+
+  /* go through the bit lengths (k already is bits in shortest code) */
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      /* here i is the Huffman code of length k bits for value *p */
+      /* make tables up to required level */
+      while (k > w + l)
+      {
+        h++;
+        w += l;                 /* previous table always l bits */
+
+        /* compute minimum size table less than or equal to l bits */
+        z = g - w;
+        z = z > (uInt)l ? l : z;        /* table size upper limit */
+        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
+        {                       /* too few codes for k-w bit table */
+          f -= a + 1;           /* deduct codes from patterns left */
+          xp = c + k;
+          if (j < z)
+            while (++j < z)     /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;          /* enough codes to use up j bits */
+              f -= *xp;         /* else deduct codes from patterns */
+            }
+        }
+        z = 1 << j;             /* table entries for j-bit table */
+
+        /* allocate and link in new table */
+        if ((q = (inflate_huft *)ZALLOC
+             (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
+        {
+          if (h)
+            inflate_trees_free(u[0], zs);
+          return Z_MEM_ERROR;   /* not enough memory */
+        }
+#ifdef DEBUG_ZLIB
+        inflate_hufts += z + 1;
+#endif
+        *t = q + 1;             /* link to list for huft_free() */
+        *(t = &(q->next)) = Z_NULL;
+        u[h] = ++q;             /* table starts after link */
+
+        /* connect to last table, if there is one */
+        if (h)
+        {
+          x[h] = i;             /* save pattern for backing up */
+          r.bits = (Byte)l;     /* bits to dump before this table */
+          r.exop = (Byte)j;     /* bits in this table */
+          r.next = q;           /* pointer to this table */
+          j = i >> (w - l);     /* (get around Turbo C bug) */
+          u[h-1][j] = r;        /* connect to last table */
+        }
+      }
+
+      /* set up table entry in r */
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+        r.exop = 128 + 64;      /* out of values--invalid code */
+      else if (*p < s)
+      {
+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+        r.base = *p++;          /* simple code is just the value */
+      }
+      else
+      {
+        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
+        r.base = d[*p++ - s];
+      }
+
+      /* fill code-like entries with r */
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+        q[j] = r;
+
+      /* backwards increment the k-bit code i */
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+        i ^= j;
+      i ^= j;
+
+      /* backup over finished tables */
+      while ((i & ((1 << w) - 1)) != x[h])
+      {
+        h--;                    /* don't need to update q */
+        w -= l;
+      }
+    }
+  }
+
+
+  /* Return Z_BUF_ERROR if we were given an incomplete table */
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+int inflate_trees_bits(c, bb, tb, z)
+uIntf *c;               /* 19 code lengths */
+uIntf *bb;              /* bits tree desired/actual depth */
+inflate_huft * FAR *tb; /* bits tree result */
+z_streamp z;            /* for zfree function */
+{
+  int r;
+
+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
+  if (r == Z_DATA_ERROR)
+    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR || *bb == 0)
+  {
+    inflate_trees_free(*tb, z);
+    z->msg = (char*)"incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  return r;
+}
+
+
+int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
+uInt nl;                /* number of literal/length codes */
+uInt nd;                /* number of distance codes */
+uIntf *c;               /* that many (total) code lengths */
+uIntf *bl;              /* literal desired/actual bit depth */
+uIntf *bd;              /* distance desired/actual bit depth */
+inflate_huft * FAR *tl; /* literal/length tree result */
+inflate_huft * FAR *td; /* distance tree result */
+z_streamp z;            /* for zfree function */
+{
+  int r;
+
+  /* build literal/length tree */
+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z);
+  if (r != Z_OK || *bl == 0)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed literal/length tree";
+    else if (r != Z_MEM_ERROR)
+    {
+      inflate_trees_free(*tl, z);
+      z->msg = (char*)"incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    return r;
+  }
+
+  /* build distance tree */
+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z);
+  if (r != Z_OK || (*bd == 0 && nl > 257))
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed distance tree";
+    else if (r == Z_BUF_ERROR) {
+#ifdef PKZIP_BUG_WORKAROUND
+      r = Z_OK;
+    }
+#else
+      inflate_trees_free(*td, z);
+      z->msg = (char*)"incomplete distance tree";
+      r = Z_DATA_ERROR;
+    }
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"empty distance tree with lengths";
+      r = Z_DATA_ERROR;
+    }
+    inflate_trees_free(*tl, z);
+    return r;
+#endif
+  }
+
+  /* done */
+  return Z_OK;
+}
+
+
+/* build fixed tables only once--keep them here */
+local int fixed_built = 0;
+#define FIXEDH 530      /* number of hufts used by fixed tables */
+local inflate_huft fixed_mem[FIXEDH];
+local uInt fixed_bl;
+local uInt fixed_bd;
+local inflate_huft *fixed_tl;
+local inflate_huft *fixed_td;
+
+
+local voidpf falloc(q, n, s)
+voidpf q;       /* opaque pointer */
+uInt n;         /* number of items */
+uInt s;         /* size of item */
+{
+  Assert(s == sizeof(inflate_huft) && n <= *(intf *)q,
+         "inflate_trees falloc overflow");
+  *(intf *)q -= n+s-s; /* s-s to avoid warning */
+  return (voidpf)(fixed_mem + *(intf *)q);
+}
+
+
+int inflate_trees_fixed(bl, bd, tl, td)
+uIntf *bl;               /* literal desired/actual bit depth */
+uIntf *bd;               /* distance desired/actual bit depth */
+inflate_huft * FAR *tl;  /* literal/length tree result */
+inflate_huft * FAR *td;  /* distance tree result */
+{
+  /* build fixed tables if not already (multiple overlapped executions ok) */
+  if (!fixed_built)
+  {
+    int k;              /* temporary variable */
+    unsigned c[288];    /* length list for huft_build */
+    z_stream z;         /* for falloc function */
+    int f = FIXEDH;     /* number of hufts left in fixed_mem */
+
+    /* set up fake z_stream for memory routines */
+    z.zalloc = falloc;
+    z.zfree = Z_NULL;
+    z.opaque = (voidpf)&f;
+
+    /* literal table */
+    for (k = 0; k < 144; k++)
+      c[k] = 8;
+    for (; k < 256; k++)
+      c[k] = 9;
+    for (; k < 280; k++)
+      c[k] = 7;
+    for (; k < 288; k++)
+      c[k] = 8;
+    fixed_bl = 7;
+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
+
+    /* distance table */
+    for (k = 0; k < 30; k++)
+      c[k] = 5;
+    fixed_bd = 5;
+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
+
+    /* done */
+    Assert(f == 0, "invalid build of fixed tables");
+    fixed_built = 1;
+  }
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
+
+
+int inflate_trees_free(t, z)
+inflate_huft *t;        /* table to free */
+z_streamp z;            /* for zfree function */
+/* Free the malloc'ed tables built by huft_build(), which makes a linked
+   list of the tables it made, with the links in a dummy first entry of
+   each table. */
+{
+  register inflate_huft *p, *q, *r;
+
+  /* Reverse linked list */
+  p = Z_NULL;
+  q = t;
+  while (q != Z_NULL)
+  {
+    r = (q - 1)->next;
+    (q - 1)->next = p;
+    p = q;
+    q = r;
+  }
+  /* Go through linked list, freeing from the malloced (t[-1]) address. */
+  while (p != Z_NULL)
+  {
+    q = (--p)->next;
+    ZFREE(z,p);
+    p = q;
+  } 
+  return Z_OK;
+}
+/* --- inftrees.c */
+
+/* +++ infcodes.c */
+/* infcodes.c -- process literals and length/distance pairs
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+/* #include "infblock.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+
+/* +++ inffast.h */
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+extern int inflate_fast OF((
+    uInt,
+    uInt,
+    inflate_huft *,
+    inflate_huft *,
+    inflate_blocks_statef *,
+    z_streamp ));
+/* --- inffast.h */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* inflate codes private state */
+struct inflate_codes_state {
+
+  /* mode */
+  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+      START,    /* x: set up for LEN */
+      LEN,      /* i: get length/literal/eob next */
+      LENEXT,   /* i: getting length extra (have base) */
+      DIST,     /* i: get distance next */
+      DISTEXT,  /* i: getting distance extra */
+      COPY,     /* o: copying bytes in window, waiting for space */
+      LIT,      /* o: got literal, waiting for output space */
+      WASH,     /* o: got eob, possibly still output waiting */
+      END,      /* x: got eob and all data flushed */
+      BADCODE}  /* x: got error */
+    mode;               /* current inflate_codes mode */
+
+  /* mode dependent information */
+  uInt len;
+  union {
+    struct {
+      inflate_huft *tree;       /* pointer into tree */
+      uInt need;                /* bits needed */
+    } code;             /* if LEN or DIST, where in tree */
+    uInt lit;           /* if LIT, literal */
+    struct {
+      uInt get;                 /* bits to get for extra */
+      uInt dist;                /* distance back to copy from */
+    } copy;             /* if EXT or COPY, where and how much */
+  } sub;                /* submode */
+
+  /* mode independent information */
+  Byte lbits;           /* ltree bits decoded per branch */
+  Byte dbits;           /* dtree bits decoder per branch */
+  inflate_huft *ltree;          /* literal/length/eob tree */
+  inflate_huft *dtree;          /* distance tree */
+
+};
+
+
+inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+z_streamp z;
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+int inflate_codes(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt j;               /* temporary storage */
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  Bytef *f;             /* pointer to copy strings from */
+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input and output based on current state */
+  while (1) switch (c->mode)
+  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+    case START:         /* x: set up for LEN */
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+        UPDATE
+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+        LOAD
+        if (r != Z_OK)
+        {
+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+          break;
+        }
+      }
+#endif /* !SLOW */
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           /* i: get length/literal/eob next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               /* literal */
+      {
+        c->sub.lit = t->base;
+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                 "inflate:         literal '%c'\n" :
+                 "inflate:         literal 0x%02x\n", t->base));
+        c->mode = LIT;
+        break;
+      }
+      if (e & 16)               /* length */
+      {
+        c->sub.copy.get = e & 15;
+        c->len = t->base;
+        c->mode = LENEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t->next;
+        break;
+      }
+      if (e & 32)               /* end of block */
+      {
+        Tracevv((stderr, "inflate:         end of block\n"));
+        c->mode = WASH;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        /* i: getting length extra (have base) */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          /* i: get distance next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               /* distance */
+      {
+        c->sub.copy.get = e & 15;
+        c->sub.copy.dist = t->base;
+        c->mode = DISTEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t->next;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       /* i: getting distance extra */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          /* o: copying bytes in window, waiting for space */
+#ifndef __TURBOC__ /* Turbo C bug for following expression */
+      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+          s->end - (c->sub.copy.dist - (q - s->window)) :
+          q - c->sub.copy.dist;
+#else
+      f = q - c->sub.copy.dist;
+      if ((uInt)(q - s->window) < c->sub.copy.dist)
+        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
+#endif
+      while (c->len)
+      {
+        NEEDOUT
+        OUTBYTE(*f++)
+        if (f == s->end)
+          f = s->window;
+        c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           /* o: got literal, waiting for output space */
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          /* o: got eob, possibly more output */
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       /* x: got error */
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+void inflate_codes_free(c, z)
+inflate_codes_statef *c;
+z_streamp z;
+{
+  ZFREE(z, c);
+  Tracev((stderr, "inflate:       codes free\n"));
+}
+/* --- infcodes.c */
+
+/* +++ infutil.c */
+/* inflate_util.c -- data and routines common to blocks and codes
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "infblock.h" */
+/* #include "inftrees.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* And'ing with mask[n] masks the lower n bits */
+uInt inflate_mask[17] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+
+/* copy as much as possible from the sliding window to the output area */
+int inflate_flush(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt n;
+  Bytef *p;
+  Bytef *q;
+
+  /* local copies of source and destination pointers */
+  p = z->next_out;
+  q = s->read;
+
+  /* compute number of bytes to copy as far as end of window */
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  /* update counters */
+  z->avail_out -= n;
+  z->total_out += n;
+
+  /* update check information */
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+  /* copy as far as end of window */
+  if (p != Z_NULL) {
+    zmemcpy(p, q, n);
+    p += n;
+  }
+  q += n;
+
+  /* see if more to copy at beginning of window */
+  if (q == s->end)
+  {
+    /* wrap pointers */
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    /* compute bytes to copy */
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    /* update counters */
+    z->avail_out -= n;
+    z->total_out += n;
+
+    /* update check information */
+    if (s->checkfn != Z_NULL)
+      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+    /* copy */
+    if (p != Z_NULL) {
+      zmemcpy(p, q, n);
+      p += n;
+    }
+    q += n;
+  }
+
+  /* update pointers */
+  z->next_out = p;
+  s->read = q;
+
+  /* done */
+  return r;
+}
+/* --- infutil.c */
+
+/* +++ inffast.c */
+/* inffast.c -- process literals and length/distance pairs fast
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+/* #include "infblock.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+/* #include "inffast.h" */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* macros for bit input with no checking and for returning unused bytes */
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}
+
+/* Called with number of bytes left to write in window at least 258
+   (the maximum string length) and number of input bytes available
+   at least ten.  The ten bytes are six bytes for the longest length/
+   distance pair plus four bytes for overloading the bit buffer. */
+
+int inflate_fast(bl, bd, tl, td, s, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  uInt ml;              /* mask for literal/length tree */
+  uInt md;              /* mask for distance tree */
+  uInt c;               /* bytes to copy */
+  uInt d;               /* distance back to copy from */
+  Bytef *r;             /* copy source pointer */
+
+  /* load input, output, bit values */
+  LOAD
+
+  /* initialize masks */
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  /* do until not enough input or output space for fast loop */
+  do {                          /* assume called with m >= 258 && n >= 10 */
+    /* get literal/length code */
+    GRABBITS(20)                /* max bits for literal/length code */
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                "inflate:         * literal '%c'\n" :
+                "inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    do {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+        /* get extra bits for length */
+        e &= 15;
+        c = t->base + ((uInt)b & inflate_mask[e]);
+        DUMPBITS(e)
+        Tracevv((stderr, "inflate:         * length %u\n", c));
+
+        /* decode distance base of block to copy */
+        GRABBITS(15);           /* max bits for distance code */
+        e = (t = td + ((uInt)b & md))->exop;
+        do {
+          DUMPBITS(t->bits)
+          if (e & 16)
+          {
+            /* get extra bits to add to distance base */
+            e &= 15;
+            GRABBITS(e)         /* get extra bits (up to 13) */
+            d = t->base + ((uInt)b & inflate_mask[e]);
+            DUMPBITS(e)
+            Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+            /* do the copy */
+            m -= c;
+            if ((uInt)(q - s->window) >= d)     /* offset before dest */
+            {                                   /*  just copy */
+              r = q - d;
+              *q++ = *r++;  c--;        /* minimum count is three, */
+              *q++ = *r++;  c--;        /*  so unroll loop a little */
+            }
+            else                        /* else offset after destination */
+            {
+              e = d - (uInt)(q - s->window); /* bytes from offset to end */
+              r = s->end - e;           /* pointer to offset */
+              if (c > e)                /* if source crosses, */
+              {
+                c -= e;                 /* copy to end of window */
+                do {
+                  *q++ = *r++;
+                } while (--e);
+                r = s->window;          /* copy rest from start of window */
+              }
+            }
+            do {                        /* copy all or what's left */
+              *q++ = *r++;
+            } while (--c);
+            break;
+          }
+          else if ((e & 64) == 0)
+            e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
+          else
+          {
+            z->msg = (char*)"invalid distance code";
+            UNGRAB
+            UPDATE
+            return Z_DATA_ERROR;
+          }
+        } while (1);
+        break;
+      }
+      if ((e & 64) == 0)
+      {
+        if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
+        {
+          DUMPBITS(t->bits)
+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                    "inflate:         * literal '%c'\n" :
+                    "inflate:         * literal 0x%02x\n", t->base));
+          *q++ = (Byte)t->base;
+          m--;
+          break;
+        }
+      }
+      else if (e & 32)
+      {
+        Tracevv((stderr, "inflate:         * end of block\n"));
+        UNGRAB
+        UPDATE
+        return Z_STREAM_END;
+      }
+      else
+      {
+        z->msg = (char*)"invalid literal/length code";
+        UNGRAB
+        UPDATE
+        return Z_DATA_ERROR;
+      }
+    } while (1);
+  } while (m >= 258 && n >= 10);
+
+  /* not enough input or output--restore pointers and return */
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
+/* --- inffast.c */
+
+/* +++ zutil.c */
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: zutil.c,v 1.17 1996/07/24 13:41:12 me Exp $ */
+
+/* #include "zutil.h" */
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+#ifndef STDC
+extern void exit OF((int));
+#endif
+
+const char *z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
+
+
+const char *zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+#ifdef DEBUG_ZLIB
+void z_error (m)
+    char *m;
+{
+    fprintf(stderr, "%s\n", m);
+    exit(1);
+}
+#endif
+
+#ifndef HAVE_MEMCPY
+
+void zmemcpy(dest, source, len)
+    Bytef* dest;
+    Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int zmemcmp(s1, s2, len)
+    Bytef* s1;
+    Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j < len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+    }
+    return 0;
+}
+
+void zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+#ifdef __TURBOC__
+#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
+/* Small and medium model in Turbo C are for now limited to near allocation
+ * with reduced MAX_WBITS and MAX_MEM_LEVEL
+ */
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize < 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
+    *(ush*)&buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&ptr != 0) { /* object < 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n < next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n < next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, "zcfree: ptr not found");
+}
+#endif
+#endif /* __TURBOC__ */
+
+
+#if defined(M_I86) && !defined(__32BIT__)
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER < 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* MSC */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return (voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
+/* --- zutil.c */
+
+/* +++ adler32.c */
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */
+
+/* #include "zlib.h" */
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* ========================================================================= */
+uLong adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+        k = len < NMAX ? len : NMAX;
+        len -= k;
+        while (k >= 16) {
+            DO16(buf);
+	    buf += 16;
+            k -= 16;
+        }
+        if (k != 0) do {
+            s1 += *buf++;
+	    s2 += s1;
+        } while (--k);
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
+/* --- adler32.c */
diff -Naur linux-2.4.2.orig/fs/jffs2/zlib.h linux-2.4.2/fs/jffs2/zlib.h
--- linux-2.4.2.orig/fs/jffs2/zlib.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs2/zlib.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,1010 @@
+/*	$Id: zlib.h,v 1.2 1997/12/23 10:47:44 paulus Exp $	*/
+
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-1.0.4
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+/*
+ *  ==FILEVERSION 971127==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+
+/* +++ zlib.h */
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.0.4, Jul 24th, 1996.
+
+  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* +++ zconf.h */
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: zconf.h,v 1.20 1996/07/02 15:09:28 me Exp $ */
+
+#ifndef _ZCONF_H
+#define _ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_	z_deflateInit_
+#  define deflate	z_deflate
+#  define deflateEnd	z_deflateEnd
+#  define inflateInit_ 	z_inflateInit_
+#  define inflate	z_inflate
+#  define inflateEnd	z_inflateEnd
+#  define deflateInit2_	z_deflateInit2_
+#  define deflateSetDictionary z_deflateSetDictionary
+#  define deflateCopy	z_deflateCopy
+#  define deflateReset	z_deflateReset
+#  define deflateParams	z_deflateParams
+#  define inflateInit2_	z_inflateInit2_
+#  define inflateSetDictionary z_inflateSetDictionary
+#  define inflateSync	z_inflateSync
+#  define inflateReset	z_inflateReset
+#  define compress	z_compress
+#  define uncompress	z_uncompress
+#  define adler32	z_adler32
+#  define crc32		z_crc32
+#  define get_crc_table z_get_crc_table
+
+#  define Byte		z_Byte
+#  define uInt		z_uInt
+#  define uLong		z_uLong
+#  define Bytef	        z_Bytef
+#  define charf		z_charf
+#  define intf		z_intf
+#  define uIntf		z_uIntf
+#  define uLongf	z_uLongf
+#  define voidpf	z_voidpf
+#  define voidp		z_voidp
+#endif
+
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
+#  ifndef __32BIT__
+#    define __32BIT__
+#  endif
+#endif
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#if defined(MSDOS) && !defined(__32BIT__)
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
+#  define STDC
+#endif
+#if (defined(__STDC__) || defined(__cplusplus)) && !defined(STDC)
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            1 << (windowBits+2)   +  1 << (memLevel+9)
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
+   /* MSC small or medium model */
+#  define SMALL_MEDIUM
+#  ifdef _MSC_VER
+#    define FAR __far
+#  else
+#    define FAR far
+#  endif
+#endif
+#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
+#  ifndef __32BIT__
+#    define SMALL_MEDIUM
+#    define FAR __far
+#  endif
+#endif
+#ifndef FAR
+#   define FAR
+#endif
+
+typedef unsigned char  Byte;  /* 8 bits */
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#if defined(__BORLANDC__) && defined(SMALL_MEDIUM)
+   /* Borland C/C++ ignores FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+
+/* Compile with -DZLIB_DLL for Windows DLL support */
+#if (defined(_WINDOWS) || defined(WINDOWS)) && defined(ZLIB_DLL)
+#  include <windows.h>
+#  define EXPORT  WINAPI
+#else
+#  define EXPORT
+#endif
+
+#endif /* _ZCONF_H */
+/* --- zconf.h */
+
+#define ZLIB_VERSION "1.0.4P"
+
+/* 
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms may be added later and will have the same
+  stream interface.
+
+     For compression the application must provide the output buffer and
+  may optionally provide the input buffer for optimization. For decompression,
+  the application must provide the input buffer and may optionally provide
+  the output buffer for optimization.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The library does not install any signal handler. It is recommended to
+  add at least a handler for SIGSEGV when decompressing; the library checks
+  the consistency of the input data whenever possible but may go nuts
+  for some forms of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1
+#define Z_PACKET_FLUSH	2
+#define Z_SYNC_FLUSH    3
+#define Z_FULL_FLUSH    4
+#define Z_FINISH        5
+/* Allowed flush values; see deflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+extern const char * EXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/* 
+extern int EXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+extern int EXPORT deflate OF((z_streamp strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
+  block is terminated and flushed to the output buffer so that the
+  decompressor can get all input data available so far. For method 9, a future
+  variant on method 8, the current block will be flushed but not terminated.
+  Z_SYNC_FLUSH has the same effect as partial flush except that the compressed
+  output is byte aligned (the compressor can clear its internal bit buffer)
+  and the current block is always terminated; this can be useful if the
+  compressor has to be restarted from scratch after an interruption (in which
+  case the internal state of the compressor may be lost).
+    If flush is set to Z_FULL_FLUSH, the compression block is terminated, a
+  special marker is output and the compression dictionary is discarded; this
+  is useful to allow the decompressor to synchronize if one compressed block
+  has been damaged (see inflateSync below).  Flushing degrades compression and
+  so should be used only when necessary.  Using Z_FULL_FLUSH too often can
+  seriously degrade the compression. If deflate returns with avail_out == 0,
+  this function must be called again with the same value of the flush
+  parameter and more output space (updated avail_out), until the flush is
+  complete (deflate returns with non-zero avail_out).
+
+    If the parameter flush is set to Z_PACKET_FLUSH, the compression
+  block is terminated, and a zero-length stored block is output,
+  omitting the length bytes (the effect of this is that the 3-bit type
+  code 000 for a stored block is output, and the output is then
+  byte-aligned).  This is designed for use at the end of a PPP packet.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+  
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible.
+*/
+
+
+extern int EXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/* 
+extern int EXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.  If
+   zalloc and zfree are set to Z_NULL, inflateInit updates them to use default
+   allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_VERSION_ERROR if the zlib library version is incompatible
+   with the version assumed by the caller.  msg is set to null if there is no
+   error message. inflateInit does not perform any decompression: this will be
+   done by inflate().
+*/
+
+
+extern int EXPORT inflate OF((z_streamp strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
+  inflate flushes as much output as possible to the output buffer. The
+  flushing behavior of inflate is not specified for values of the flush
+  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
+  current implementation actually flushes as much output as possible
+  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
+  has been consumed, it is expecting to see the length field of a stored
+  block; if not, it returns Z_DATA_ERROR.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+    inflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if the end of the
+  compressed data has been reached and all uncompressed output has been
+  produced, Z_NEED_DICT if a preset dictionary is needed at this point (see
+  inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,
+  Z_STREAM_ERROR if the stream structure was inconsistent (for example if
+  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in
+  the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the
+  application may then call inflateSync to look for a good compression block.
+  In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the
+  dictionary chosen by the compressor.
+*/
+
+
+extern int EXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*   
+extern int EXPORT deflateInit2 OF((z_streamp strm,
+                                   int  level,
+                                   int  method,
+                                   int  windowBits,
+                                   int  memLevel,
+                                   int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library. (Method 9 will allow a 64K history buffer and
+   partial block flushes.)
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library (the value 16 will be allowed for method 9). Larger
+   values of this parameter result in better compression at the expense of
+   memory usage. The default value is 15 if deflateInit is used instead.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match).  Filtered data consists mostly of small values with a
+   somewhat random distribution. In this case, the compression algorithm is
+   tuned to compress them better. The effect of Z_FILTERED is to force more
+   Huffman coding and less string matching; it is somewhat intermediate
+   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
+   the compression ratio but not the correctness of the compressed output even
+   if it is not set appropriately.
+
+     If next_in is not null, the library will use this buffer to hold also
+   some history information; the buffer must either hold the entire input
+   data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in
+   is null, the library will allocate its own history buffer (and leave next_in
+   null). next_out need not be provided here but must be provided by the
+   application for the next call of deflate().
+
+     If the history buffer is provided by the application, next_in must
+   must never be changed by the application since the compressor maintains
+   information inside this buffer from call to call; the application
+   must provide more input only by increasing avail_in. next_in is always
+   reset by the library in this case.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   an invalid method). msg is set to null if there is no error message.
+   deflateInit2 does not perform any compression: this will be done by
+   deflate(). 
+*/
+                            
+extern int EXPORT deflateSetDictionary OF((z_streamp strm,
+                                           const Bytef *dictionary,
+				           uInt  dictLength));
+/*
+     Initializes the compression dictionary (history buffer) from the given
+   byte sequence without producing any compressed output. This function must
+   be called immediately after deflateInit or deflateInit2, before any call
+   of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and
+   can be predicted with good accuracy; the data can then be compressed better
+   than with the default empty dictionary. In this version of the library,
+   only the last 32K bytes of the dictionary are used.
+     Upon return of this function, strm->adler is set to the Adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The Adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.)
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state
+   is inconsistent (for example if deflate has already been called for this
+   stream). deflateSetDictionary does not perform any compression: this will
+   be done by deflate(). 
+*/
+
+extern int EXPORT deflateCopy OF((z_streamp dest,
+                                  z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.  If
+   the source stream is using an application-supplied history buffer, a new
+   buffer is allocated for the destination stream.  The compressed output
+   buffer is always application-supplied. It's the responsibility of the
+   application to provide the correct values of next_out and avail_out for the
+   next call of deflate.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+extern int EXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int EXPORT deflateParams OF((z_streamp strm, int level, int strategy));
+/*
+     Dynamically update the compression level and compression strategy.
+   This can be used to switch between compression and straight copy of
+   the input data, or to switch to a different kind of input data requiring
+   a different strategy. If the compression level is changed, the input
+   available so far is compressed with the old level (and may be flushed);
+   the new level will take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+extern int EXPORT deflateOutputPending OF((z_streamp strm));
+/*
+     Returns the number of bytes of output which are immediately
+   available from the compressor (i.e. without any further input
+   or flush).
+*/
+
+/*   
+extern int EXPORT inflateInit2 OF((z_streamp strm,
+                                   int  windowBits));
+
+     This is another version of inflateInit with more compression options. The
+   fields next_out, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library (the value 16 will be allowed soon). The
+   default value is 15 if inflateInit is used instead. If a compressed stream
+   with a larger window size is given as input, inflate() will return with
+   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     If next_out is not null, the library will use this buffer for the history
+   buffer; the buffer must either be large enough to hold the entire output
+   data, or have at least 1<<windowBits bytes.  If next_out is null, the
+   library will allocate its own buffer (and leave next_out null). next_in
+   need not be provided here but must be provided by the application for the
+   next call of inflate().
+
+     If the history buffer is provided by the application, next_out must
+   never be changed by the application since the decompressor maintains
+   history information inside this buffer from call to call; the application
+   can only reset next_out to the beginning of the history buffer when
+   avail_out is zero and all output has been consumed.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   windowBits < 8). msg is set to null if there is no error message.
+   inflateInit2 does not perform any decompression: this will be done by
+   inflate().
+*/
+
+extern int EXPORT inflateSetDictionary OF((z_streamp strm,
+				           const Bytef *dictionary,
+					   uInt  dictLength));
+/*
+     Initializes the decompression dictionary (history buffer) from the given
+   uncompressed byte sequence. This function must be called immediately after
+   a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen
+   by the compressor can be determined from the Adler32 value returned by this
+   call of inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect Adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+extern int EXPORT inflateSync OF((z_streamp strm));
+/* 
+    Skips invalid compressed data until the special marker (see deflate()
+  above) can be found, or until all available input is skipped. No output
+  is provided.
+
+    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no marker has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+extern int EXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int inflateIncomp OF((z_stream *strm));
+/*
+     This function adds the data at next_in (avail_in bytes) to the output
+   history without performing any output.  There must be no pending output,
+   and the decompressor must be expecting to see the start of a block.
+   Calling this function is equivalent to decompressing a stored block
+   containing the data at next_in (except that the data is not output).
+*/
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level, window size,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+extern int EXPORT compress OF((Bytef *dest,   uLongf *destLen,
+			       const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least 0.1% larger than
+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+extern int EXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+				 const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+
+
+typedef voidp gzFile;
+
+extern gzFile EXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9").  gzopen can be used to read a file which is not in gzip format;
+   in this case gzread will directly read from the file without decompression.
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).
+*/
+
+extern gzFile EXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+extern int EXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+extern int EXPORT    gzwrite OF((gzFile file, const voidp buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+extern int EXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+extern int EXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+extern const char * EXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+extern uLong EXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+extern int EXPORT deflateInit_ OF((z_streamp strm, int level,
+			           const char *version, int stream_size));
+extern int EXPORT inflateInit_ OF((z_streamp strm,
+				   const char *version, int stream_size));
+extern int EXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+				    int windowBits, int memLevel, int strategy,
+				    const char *version, int stream_size));
+extern int EXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+				    const char *version, int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+uLongf *get_crc_table OF((void)); /* can be used by asm versions of crc32() */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZLIB_H */
+/* --- zlib.h */
diff -Naur linux-2.4.2.orig/include/asm-ppc/8xx_rtc.h linux-2.4.2/include/asm-ppc/8xx_rtc.h
--- linux-2.4.2.orig/include/asm-ppc/8xx_rtc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/asm-ppc/8xx_rtc.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,30 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifdef __KERNEL__
+#ifndef __ASM_PPC_8XX_RTC_H
+#define __ASM_PPC_8XX_RTC_H
+
+#include <asm/io.h>
+
+#ifndef RTC_ALWAYS_BCD
+#define RTC_ALWAYS_BCD	0	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#define RTC_IRQ 9
+
+#endif /* __ASM_PPC_8XXRTC_H */
+#endif /* __KERNEL__ */
diff -Naur linux-2.4.2.orig/include/asm-ppc/bitops.h linux-2.4.2/include/asm-ppc/bitops.h
--- linux-2.4.2.orig/include/asm-ppc/bitops.h	Sun Nov 12 03:23:10 2000
+++ linux-2.4.2/include/asm-ppc/bitops.h	Fri Feb 15 14:41:17 2002
@@ -35,10 +35,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 	
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	or	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	or	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -68,10 +68,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	andc	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	andc	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -84,10 +84,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	xor	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	xor	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -104,9 +104,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	or	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	or	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
@@ -136,9 +136,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	andc	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	andc	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
@@ -168,9 +168,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	xor	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	xor	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
diff -Naur linux-2.4.2.orig/include/asm-ppc/checksum.h linux-2.4.2/include/asm-ppc/checksum.h
--- linux-2.4.2.orig/include/asm-ppc/checksum.h	Sun Nov 12 03:23:10 2000
+++ linux-2.4.2/include/asm-ppc/checksum.h	Fri Feb 15 14:41:17 2002
@@ -83,11 +83,11 @@
 						   unsigned short proto,
 						   unsigned int sum) 
 {
-    __asm__("
-	addc %0,%0,%1
-	adde %0,%0,%2
-	adde %0,%0,%3
-	addze %0,%0
+    __asm__("\n\
+	addc %0,%0,%1\n\
+	adde %0,%0,%2\n\
+	adde %0,%0,%3\n\
+	addze %0,%0\n\
 	"
 	: "=r" (sum)
 	: "r" (daddr), "r"(saddr), "r"((proto<<16)+len), "0"(sum));
diff -Naur linux-2.4.2.orig/include/asm-ppc/pgtable.h linux-2.4.2/include/asm-ppc/pgtable.h
--- linux-2.4.2.orig/include/asm-ppc/pgtable.h	Tue Jan 23 00:41:15 2001
+++ linux-2.4.2/include/asm-ppc/pgtable.h	Fri Feb 15 14:41:17 2002
@@ -418,11 +418,11 @@
 {
 	unsigned long old, tmp;
 	
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	andc	%1,%0,%4
-	or	%1,%1,%5
-	stwcx.	%1,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	andc	%1,%0,%4\n\
+	or	%1,%1,%5\n\
+	stwcx.	%1,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=&r" (tmp), "=m" (*p)
 	: "r" (p), "r" (clr), "r" (set), "m" (*p)
diff -Naur linux-2.4.2.orig/include/asm-ppc/system.h linux-2.4.2/include/asm-ppc/system.h
--- linux-2.4.2.orig/include/asm-ppc/system.h	Sun Nov 12 03:23:11 2000
+++ linux-2.4.2/include/asm-ppc/system.h	Fri Feb 15 14:41:17 2002
@@ -131,9 +131,9 @@
 {
 	unsigned long prev;
 
-	__asm__ __volatile__ ("
-1:	lwarx	%0,0,%2
-	stwcx.	%3,0,%2
+	__asm__ __volatile__ ("\n\
+1:	lwarx	%0,0,%2\n\
+	stwcx.	%3,0,%2\n\
 	bne-	1b"
 	: "=&r" (prev), "=m" (*(volatile unsigned long *)p)
 	: "r" (p), "r" (val), "m" (*(volatile unsigned long *)p)
@@ -180,11 +180,11 @@
 {
 	int prev;
 
-	__asm__ __volatile__ ("
-1:	lwarx	%0,0,%2
-	cmpw	0,%0,%3
-	bne	2f
-	stwcx.	%4,0,%2
+	__asm__ __volatile__ ("\n\
+1:	lwarx	%0,0,%2\n\
+	cmpw	0,%0,%3\n\
+	bne	2f\n\
+	stwcx.	%4,0,%2\n\
 	bne-	1b\n"
 #ifdef CONFIG_SMP
 "	sync\n"
diff -Naur linux-2.4.2.orig/include/asm-ppc/tqm8xxL.h linux-2.4.2/include/asm-ppc/tqm8xxL.h
--- linux-2.4.2.orig/include/asm-ppc/tqm8xxL.h	Sun Nov 12 03:23:11 2000
+++ linux-2.4.2/include/asm-ppc/tqm8xxL.h	Fri Feb 15 14:41:17 2002
@@ -39,9 +39,17 @@
 /* Configuration options for TQ Systems TQM850L mini module
  */
 
+#ifdef CONFIG_DBOX2 
+#define	TQM_RESET_ADDR	0x00000100	/* Monitor Reset Entry */
+#else
 #define	TQM_RESET_ADDR	0x40000100	/* Monitor Reset Entry */
+#endif
 
+#ifdef CONFIG_DBOX2
+#define	TQM_IMMR_BASE	0xFF000000	/* phys. addr of IMMR */
+#else
 #define	TQM_IMMR_BASE	0xFFF00000	/* phys. addr of IMMR */
+#endif
 #define	TQM_IMAP_SIZE	(64 * 1024)	/* size of mapped area */
 
 #define	TQM_CLOCKRATE	50		/* 50 MHz Clock */
diff -Naur linux-2.4.2.orig/include/linux/8xx_rtc.h linux-2.4.2/include/linux/8xx_rtc.h
--- linux-2.4.2.orig/include/linux/8xx_rtc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/8xx_rtc.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,90 @@
+#ifndef _PPC_8XX_RTC_H
+#define _PPC_8XX_RTC_H
+
+#include <asm/io.h>
+#include <linux/rtc.h>			/* get the user-level API */
+#include <asm/8xx_rtc.h>		/* register access macros */
+
+extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
+
+/**********************************************************************
+ * register summary
+ **********************************************************************/
+#define RTC_SECONDS		0
+#define RTC_SECONDS_ALARM	1
+#define RTC_MINUTES		2
+#define RTC_MINUTES_ALARM	3
+#define RTC_HOURS		4
+#define RTC_HOURS_ALARM		5
+/* RTC_*_alarm is always true if 2 MSBs are set */
+# define RTC_ALARM_DONT_CARE 	0xC0
+
+#define RTC_DAY_OF_WEEK		6
+#define RTC_DAY_OF_MONTH	7
+#define RTC_MONTH		8
+#define RTC_YEAR		9
+
+/* control registers - Moto names
+ */
+#define RTC_REG_A		10
+#define RTC_REG_B		11
+#define RTC_REG_C		12
+#define RTC_REG_D		13
+
+/**********************************************************************
+ * register details
+ **********************************************************************/
+#define RTC_FREQ_SELECT	RTC_REG_A
+
+/* update-in-progress  - set to "1" 244 microsecs before RTC goes off the bus,
+ * reset after update (may take 1.984ms @ 32768Hz RefClock) is complete,
+ * totalling to a max high interval of 2.228 ms.
+ */
+# define RTC_UIP		0x80
+# define RTC_DIV_CTL		0x70
+   /* divider control: refclock values 4.194 / 1.049 MHz / 32.768 kHz */
+#  define RTC_REF_CLCK_4MHZ	0x00
+#  define RTC_REF_CLCK_1MHZ	0x10
+#  define RTC_REF_CLCK_32KHZ	0x20
+   /* 2 values for divider stage reset, others for "testing purposes only" */
+#  define RTC_DIV_RESET1	0x60
+#  define RTC_DIV_RESET2	0x70
+  /* Periodic intr. / Square wave rate select. 0=none, 1=32.8kHz,... 15=2Hz */
+# define RTC_RATE_SELECT 	0x0F
+
+/**********************************************************************/
+#define RTC_CONTROL	RTC_REG_B
+# define RTC_SET 0x80		/* disable updates for clock setting */
+# define RTC_PIE 0x40		/* periodic interrupt enable */
+# define RTC_AIE 0x20		/* alarm interrupt enable */
+# define RTC_UIE 0x10		/* update-finished interrupt enable */
+# define RTC_SQWE 0x08		/* enable square-wave output */
+# define RTC_DM_BINARY 0x04	/* all time/date values are BCD if clear */
+# define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
+# define RTC_DST_EN 0x01	/* auto switch DST - works f. USA only */
+
+/**********************************************************************/
+#define RTC_INTR_FLAGS	RTC_REG_C
+/* caution - cleared by read */
+# define RTC_IRQF 0x80		/* any of the following 3 is active */
+# define RTC_PF 0x40
+# define RTC_AF 0x20
+# define RTC_UF 0x10
+
+/**********************************************************************/
+#define RTC_VALID	RTC_REG_D
+# define RTC_VRT 0x80		/* valid RAM and time */
+/**********************************************************************/
+
+/* example: !(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) 
+ * determines if the following two #defines are needed
+ */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#endif /* _MC146818RTC_H */
diff -Naur linux-2.4.2.orig/include/linux/jffs.h linux-2.4.2/include/linux/jffs.h
--- linux-2.4.2.orig/include/linux/jffs.h	Wed Aug  9 23:06:12 2000
+++ linux-2.4.2/include/linux/jffs.h	Fri Feb 15 14:41:17 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs.h,v 1.11 2000/08/04 12:46:34 dwmw2 Exp $
+ * $Id: jffs.h,v 1.20 2001/09/18 21:33:37 dwmw2 Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -20,6 +20,9 @@
 #ifndef __LINUX_JFFS_H__
 #define __LINUX_JFFS_H__
 
+#include <linux/types.h>
+#include <linux/completion.h>
+
 #define JFFS_VERSION_STRING "1.0"
 
 /* This is a magic number that is used as an identification number for
@@ -185,7 +188,7 @@
 	struct jffs_delete_list *delete_list; /* Track deleted files.  */
 	pid_t thread_pid;		/* GC thread's PID */
 	struct task_struct *gc_task;	/* GC task struct */
-	struct semaphore gc_thread_sem; /* GC thread exit mutex */
+	struct completion gc_thread_comp; /* GC thread exit mutex */
 	__u32 gc_minfree_threshold;	/* GC trigger thresholds */
 	__u32 gc_maxdirty_threshold;
 };
@@ -204,9 +207,9 @@
 /* This stuff could be used for finding memory leaks.  */
 #define JFFS_MEMORY_DEBUG 0
 
-#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
-extern long no_jffs_file;
 extern long no_jffs_node;
+extern long no_jffs_file;
+#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
 extern long no_jffs_control;
 extern long no_jffs_raw_inode;
 extern long no_jffs_node_ref;
diff -Naur linux-2.4.2.orig/include/linux/jffs2.h linux-2.4.2/include/linux/jffs2.h
--- linux-2.4.2.orig/include/linux/jffs2.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,164 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: jffs2.h,v 1.18 2001/03/25 22:36:12 dwmw2 Exp $
+ *
+ */
+
+#ifndef __LINUX_JFFS2_H__
+#define __LINUX_JFFS2_H__
+
+#include <asm/types.h>
+#define JFFS2_SUPER_MAGIC 0x72b6
+
+/* Values we may expect to find in the 'magic' field */
+#define JFFS2_OLD_MAGIC_BITMASK 0x1984
+#define JFFS2_MAGIC_BITMASK 0x1985
+#define KSAMTIB_CIGAM_2SFFJ 0x5981 /* For detecting wrong-endian fs */
+#define JFFS2_EMPTY_BITMASK 0xffff
+#define JFFS2_DIRTY_BITMASK 0x0000
+
+/* We only allow a single char for length, and 0xFF is empty flash so
+   we don't want it confused with a real length. Hence max 254.
+*/
+#define JFFS2_MAX_NAME_LEN 254
+
+/* How small can we sensibly write nodes? */
+#define JFFS2_MIN_DATA_LEN 128
+
+#define JFFS2_COMPR_NONE	0x00
+#define JFFS2_COMPR_ZERO	0x01
+#define JFFS2_COMPR_RTIME	0x02
+#define JFFS2_COMPR_RUBINMIPS	0x03
+#define JFFS2_COMPR_COPY	0x04
+#define JFFS2_COMPR_DYNRUBIN	0x05
+#define JFFS2_COMPR_ZLIB	0x06
+/* Compatibility flags. */
+#define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+#define JFFS2_NODE_ACCURATE 0x2000
+/* INCOMPAT: Fail to mount the filesystem */
+#define JFFS2_FEATURE_INCOMPAT 0xc000
+/* ROCOMPAT: Mount read-only */
+#define JFFS2_FEATURE_ROCOMPAT 0x8000
+/* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_COPY 0x4000
+/* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_DELETE 0x0000
+
+#define JFFS2_NODETYPE_DIRENT (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1)
+#define JFFS2_NODETYPE_INODE (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2)
+#define JFFS2_NODETYPE_CLEANMARKER (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+
+// Maybe later...
+//#define JFFS2_NODETYPE_CHECKPOINT (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+//#define JFFS2_NODETYPE_OPTIONS (JFFS2_FEATURE_RWCOMPAT_COPY | JFFS2_NODE_ACCURATE | 4)
+
+/* Same as the non_ECC versions, but with extra space for real 
+ * ECC instead of just the checksum. For use on NAND flash 
+ */
+//#define JFFS2_NODETYPE_DIRENT_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 5)
+//#define JFFS2_NODETYPE_INODE_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 6)
+
+#define JFFS2_INO_FLAG_PREREAD	  1	/* Do read_inode() for this one at 
+					   mount time, don't wait for it to 
+					   happen later */
+#define JFFS2_INO_FLAG_USERCOMPR  2	/* User has requested a specific 
+					   compression type */
+
+
+struct jffs2_unknown_node
+{
+	/* All start like this */
+	__u16 magic;
+	__u16 nodetype;
+	__u32 totlen; /* So we can skip over nodes we don't grok */
+	__u32 hdr_crc;
+};
+
+struct jffs2_raw_dirent
+{
+	__u16 magic;
+	__u16 nodetype;	/* == JFFS_NODETYPE_DIRENT */
+	__u32 totlen;
+	__u32 hdr_crc;
+	__u32 pino;
+	__u32 version;
+	__u32 ino; /* == zero for unlink */
+	__u32 mctime;
+	__u8 nsize;
+	__u8 type;
+	__u8 unused[2];
+	__u32 node_crc;
+	__u32 name_crc;
+	__u8 name[0];
+};
+
+/* The JFFS2 raw inode structure: Used for storage on physical media.  */
+/* The uid, gid, atime, mtime and ctime members could be longer, but 
+   are left like this for space efficiency. If and when people decide
+   they really need them extended, it's simple enough to add support for
+   a new type of raw node.
+*/
+struct jffs2_raw_inode
+{
+	__u16 magic;      /* A constant magic number.  */
+	__u16 nodetype;   /* == JFFS_NODETYPE_INODE */
+	__u32 totlen;     /* Total length of this node (inc data, etc.) */
+	__u32 hdr_crc;
+	__u32 ino;        /* Inode number.  */
+	__u32 version;    /* Version number.  */
+	__u32 mode;       /* The file's type or mode.  */
+	__u16 uid;        /* The file's owner.  */
+	__u16 gid;        /* The file's group.  */
+	__u32 isize;      /* Total resultant size of this inode (used for truncations)  */
+	__u32 atime;      /* Last access time.  */
+	__u32 mtime;      /* Last modification time.  */
+	__u32 ctime;      /* Change time.  */
+	__u32 offset;     /* Where to begin to write.  */
+	__u32 csize;      /* (Compressed) data size */
+	__u32 dsize;	  /* Size of the node's data. (after decompression) */
+	__u8 compr;       /* Compression algorithm used */
+	__u8 usercompr;	  /* Compression algorithm requested by the user */
+	__u16 flags;	  /* See JFFS2_INO_FLAG_* */
+	__u32 data_crc;   /* CRC for the (compressed) data.  */
+	__u32 node_crc;   /* CRC for the raw inode (excluding data)  */
+//	__u8 data[dsize];
+};
+
+union jffs2_node_union {
+	struct jffs2_raw_inode i;
+	struct jffs2_raw_dirent d;
+	struct jffs2_unknown_node u;
+};
+
+#endif /* __LINUX_JFFS2_H__ */
diff -Naur linux-2.4.2.orig/include/linux/jffs2_fs_i.h linux-2.4.2/include/linux/jffs2_fs_i.h
--- linux-2.4.2.orig/include/linux/jffs2_fs_i.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2_fs_i.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,58 @@
+/* $Id: jffs2_fs_i.h,v 1.7 2001/03/25 22:36:12 dwmw2 Exp $ */
+
+#ifndef _JFFS2_FS_I
+#define _JFFS2_FS_I
+
+/* Include the pipe_inode_info at the beginning so that we can still
+   use the storage space in the inode when we have a pipe inode.
+   This sucks.
+*/
+
+#undef THISSUCKS /* Only for 2.2 */
+#ifdef THISSUCKS
+#include <linux/pipe_fs_i.h>
+#endif
+
+struct jffs2_inode_info {
+#ifdef THISSUCKS
+        struct pipe_inode_info pipecrap;
+#endif
+	/* We need an internal semaphore similar to inode->i_sem.
+	   Unfortunately, we can't used the existing one, because
+	   either the GC would deadlock, or we'd have to release it
+	   before letting GC proceed. Or we'd have to put ugliness
+	   into the GC code so it didn't attempt to obtain the i_sem
+	   for the inode(s) which are already locked */
+	struct semaphore sem;
+
+	/* The highest (datanode) version number used for this ino */
+	__u32 highest_version;
+
+	/* List of data fragments which make up the file */
+	struct jffs2_node_frag *fraglist;
+
+	/* There may be one datanode which isn't referenced by any of the
+	   above fragments, if it contains a metadata update but no actual
+	   data - or if this is a directory inode */
+	/* This also holds the _only_ dnode for symlinks/device nodes, 
+	   etc. */
+	struct jffs2_full_dnode *metadata;
+
+	/* Directory entries */
+	struct jffs2_full_dirent *dents;
+
+	/* Some stuff we just have to keep in-core at all times, for each inode. */
+	struct jffs2_inode_cache *inocache;
+
+	/* Keep a pointer to the last physical node in the list. We don't 
+	   use the doubly-linked lists because we don't want to increase
+	   the memory usage that much. This is simpler */
+	//	struct jffs2_raw_node_ref *lastnode;
+	__u16 flags;
+	__u8 usercompr;
+};
+
+#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
+
+#endif /* _JFFS2_FS_I */
+
diff -Naur linux-2.4.2.orig/include/linux/jffs2_fs_sb.h linux-2.4.2/include/linux/jffs2_fs_sb.h
--- linux-2.4.2.orig/include/linux/jffs2_fs_sb.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2_fs_sb.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,75 @@
+/* $Id: jffs2_fs_sb.h,v 1.13 2001/03/20 17:43:56 dwmw2 Exp $ */
+
+#ifndef _JFFS2_FS_SB
+#define _JFFS2_FS_SB
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <asm/semaphore.h>
+#include <linux/list.h>
+
+#define INOCACHE_HASHSIZE 1
+
+#define JFFS2_SB_FLAG_RO 1
+
+/* A struct for the overall file system control.  Pointers to
+   jffs2_sb_info structs are named `c' in the source code.  
+   Nee jffs_control
+*/
+struct jffs2_sb_info {
+	struct mtd_info *mtd;
+
+	__u32 highest_ino;
+	unsigned int flags;
+	spinlock_t nodelist_lock;
+
+	//	pid_t thread_pid;		/* GC thread's PID */
+	struct task_struct *gc_task;	/* GC task struct */
+	struct semaphore gc_thread_sem; /* GC thread exit mutex */
+
+	//	__u32 gc_minfree_threshold;	/* GC trigger thresholds */
+	//	__u32 gc_maxdirty_threshold;
+
+	struct semaphore alloc_sem;	/* Used to protect all the following 
+					   fields, and also to protect against
+					   out-of-order writing of nodes */
+	struct semaphore gc_sem;
+	__u32 flash_size;
+	__u32 used_size;
+	__u32 dirty_size;
+	__u32 free_size;
+	__u32 erasing_size;
+	__u32 bad_size;
+	__u32 sector_size;
+	//	__u32 min_free_size;
+	//	__u32 max_chunk_size;
+
+	__u32 nr_free_blocks;
+	__u32 nr_erasing_blocks;
+
+	__u32 nr_blocks;
+	struct jffs2_eraseblock *blocks;	/* The whole array of blocks. Used for getting blocks 
+						 * from the offset (blocks[ofs / sector_size]) */
+	struct jffs2_eraseblock *nextblock;	/* The block we're currently filling */
+
+	struct jffs2_eraseblock *gcblock;	/* The block we're currently garbage-collecting */
+
+	struct list_head clean_list;		/* Blocks 100% full of clean data */
+	struct list_head dirty_list;		/* Blocks with some dirty space */
+	struct list_head erasing_list;		/* Blocks which are currently erasing */
+	struct list_head erase_pending_list;	/* Blocks which need erasing */
+	struct list_head erase_complete_list;	/* Blocks which are erased and need the clean marker written to them */
+	struct list_head free_list;		/* Blocks which are free and ready to be used */
+	struct list_head bad_list;		/* Bad blocks. */
+	struct list_head bad_used_list;		/* Bad blocks with valid data in. */
+
+	spinlock_t erase_completion_lock;	/* Protect free_list and erasing_list 
+						   against erase completion handler */
+	wait_queue_head_t erase_wait;		/* For waiting for erases to complete */
+	struct jffs2_inode_cache *inocache_list[INOCACHE_HASHSIZE];
+	spinlock_t inocache_lock;
+};
+
+#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
+#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
+#endif /* _JFFS2_FB_SB */
diff -Naur linux-2.4.2.orig/include/linux/mtd/cfi.h linux-2.4.2/include/linux/mtd/cfi.h
--- linux-2.4.2.orig/include/linux/mtd/cfi.h	Mon Dec 11 22:16:46 2000
+++ linux-2.4.2/include/linux/mtd/cfi.h	Fri Feb 15 14:41:17 2002
@@ -1,14 +1,161 @@
 
 /* Common Flash Interface structures 
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id: cfi.h,v 1.6 2000/07/03 13:29:16 dwmw2 Exp $
+ * $Id: cfi.h,v 1.27 2002/01/10 20:27:41 eric Exp $
  */
 
 #ifndef __MTD_CFI_H__
 #define __MTD_CFI_H__
 
+#include <linux/config.h>
+#include <linux/delay.h>
 #include <linux/types.h>
+#include <linux/interrupt.h>
 #include <linux/mtd/flashchip.h>
+#include <linux/mtd/cfi_endian.h>
+
+/*
+ * You can optimize the code size and performance by defining only 
+ * the geometry(ies) available on your hardware.
+ * CFIDEV_INTERLEAVE_n, where  represents the interleave (number of chips to fill the bus width)
+ * CFIDEV_BUSWIDTH_n, where n is the bus width in bytes (1, 2 or 4 bytes)
+ *
+ * By default, all (known) geometries are supported.
+ */
+
+#ifndef CONFIG_MTD_CFI_GEOMETRY
+
+#define CFIDEV_INTERLEAVE_1 (1)
+#define CFIDEV_INTERLEAVE_2 (2)
+#define CFIDEV_INTERLEAVE_4 (4)
+
+#define CFIDEV_BUSWIDTH_1 (1)
+#define CFIDEV_BUSWIDTH_2 (2)
+#define CFIDEV_BUSWIDTH_4 (4)
+
+#else
+
+#ifdef CONFIG_MTD_CFI_I1
+#define CFIDEV_INTERLEAVE_1 (1)
+#endif
+#ifdef CONFIG_MTD_CFI_I2
+#define CFIDEV_INTERLEAVE_2 (2)
+#endif
+#ifdef CONFIG_MTD_CFI_I4
+#define CFIDEV_INTERLEAVE_4 (4)
+#endif
+
+#ifdef CONFIG_MTD_CFI_B1
+#define CFIDEV_BUSWIDTH_1 (1)
+#endif
+#ifdef CONFIG_MTD_CFI_B2
+#define CFIDEV_BUSWIDTH_2 (2)
+#endif
+#ifdef CONFIG_MTD_CFI_B4
+#define CFIDEV_BUSWIDTH_4 (4)
+#endif
+
+#endif
+
+/*
+ * The following macros are used to select the code to execute:
+ *   cfi_buswidth_is_*()
+ *   cfi_interleave_is_*()
+ *   [where * is either 1, 2 or 4]
+ * Those macros should be used with 'if' statements.  If only one of few
+ * geometry arrangements are selected, they expand to constants thus allowing
+ * the compiler (most of them being 0) to optimize away all the unneeded code,
+ * while still validating the syntax (which is not possible with embedded 
+ * #if ... #endif constructs).
+ */
+
+#ifdef CFIDEV_INTERLEAVE_1
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE (cfi->interleave)
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_1
+# endif
+# define cfi_interleave_is_1() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_1)
+#else
+# define cfi_interleave_is_1() (0)
+#endif
+
+#ifdef CFIDEV_INTERLEAVE_2
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE (cfi->interleave)
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_2
+# endif
+# define cfi_interleave_is_2() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_2)
+#else
+# define cfi_interleave_is_2() (0)
+#endif
+
+#ifdef CFIDEV_INTERLEAVE_4
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE (cfi->interleave)
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_4
+# endif
+# define cfi_interleave_is_4() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_4)
+#else
+# define cfi_interleave_is_4() (0)
+#endif
+
+#ifndef CFIDEV_INTERLEAVE
+#error You must define at least one interleave to support!
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_1
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_1
+# endif
+# define cfi_buswidth_is_1() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_1)
+#else
+# define cfi_buswidth_is_1() (0)
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_2
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_2
+# endif
+# define cfi_buswidth_is_2() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_2)
+#else
+# define cfi_buswidth_is_2() (0)
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_4
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_4
+# endif
+# define cfi_buswidth_is_4() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_4)
+#else
+# define cfi_buswidth_is_4() (0)
+#endif
+
+#ifndef CFIDEV_BUSWIDTH
+#error You must define at least one bus width to support!
+#endif
+
+/* NB: these values must represents the number of bytes needed to meet the 
+ *     device type (x8, x16, x32).  Eg. a 32 bit device is 4 x 8 bytes. 
+ *     These numbers are used in calculations.
+ */
+#define CFI_DEVICETYPE_X8  (8 / 8)
+#define CFI_DEVICETYPE_X16 (16 / 8)
+#define CFI_DEVICETYPE_X32 (32 / 8)
 
 /* NB: We keep these structures in memory in HOST byteorder, except
  * where individually noted.
@@ -37,7 +184,7 @@
   __u16 InterfaceDesc;
   __u16 MaxBufWriteSize;
   __u8  NumEraseRegions;
-  __u32 EraseRegionInfo[1]; /* Not host ordered */
+  __u32 EraseRegionInfo[0]; /* Not host ordered */
 } __attribute__((packed));
 
 /* Extended Query Structure for both PRI and ALT */
@@ -59,6 +206,10 @@
   __u16 BlkStatusRegMask;
   __u8  VccOptimal;
   __u8  VppOptimal;
+  __u8  NumProtectionFields;
+  __u16 ProtRegAddr;
+  __u8  FactProtRegSize;
+  __u8  UserProtRegSize;
 } __attribute__((packed));
 
 struct cfi_pri_query {
@@ -82,20 +233,165 @@
 #define P_ID_RESERVED 65535
 
 
+#define CFI_MODE_CFI	1
+#define CFI_MODE_JEDEC	0
+
 struct cfi_private {
 	__u16 cmdset;
 	void *cmdset_priv;
 	int interleave;
+	int device_type;
+	int cfi_mode;		/* Are we a JEDEC device pretending to be CFI? */
+	int addr_unlock1;
+	int addr_unlock2;
+	int fast_prog;
 	struct mtd_info *(*cmdset_setup)(struct map_info *);
-	struct cfi_ident cfiq; /* For now only one. We insist that all devs
+	struct cfi_ident *cfiq; /* For now only one. We insist that all devs
 				  must be of the same type. */
+	int mfr, id;
 	int numchips;
 	unsigned long chipshift; /* Because they're of the same type */
 	const char *im_name;	 /* inter_module name for cmdset_setup */
 	struct flchip chips[0];  /* per-chip data structure for each chip */
-	/* do not add extra fields after "chips" */
 };
 
 #define MAX_CFI_CHIPS 8 /* Entirely arbitrary to avoid realloc() */
+
+/*
+ * Returns the command address according to the given geometry.
+ */
+static inline __u32 cfi_build_cmd_addr(__u32 cmd_ofs, int interleave, int type)
+{
+	return (cmd_ofs * type) * interleave;
+}
+
+/*
+ * Transforms the CFI command for the given geometry (bus width & interleave.
+ */
+static inline __u32 cfi_build_cmd(u_char cmd, struct map_info *map, struct cfi_private *cfi)
+{
+	__u32 val = 0;
+
+	if (cfi_buswidth_is_1()) {
+		/* 1 x8 device */
+		val = cmd;
+	} else if (cfi_buswidth_is_2()) {
+		if (cfi_interleave_is_1()) {
+			/* 1 x16 device in x16 mode */
+			val = cpu_to_cfi16(cmd);
+		} else if (cfi_interleave_is_2()) {
+			/* 2 (x8, x16 or x32) devices in x8 mode */
+			val = cpu_to_cfi16((cmd << 8) | cmd);
+		}
+	} else if (cfi_buswidth_is_4()) {
+		if (cfi_interleave_is_1()) {
+			/* 1 x32 device in x32 mode */
+			val = cpu_to_cfi32(cmd);
+		} else if (cfi_interleave_is_2()) {
+			/* 2 x16 device in x16 mode */
+			val = cpu_to_cfi32((cmd << 16) | cmd);
+		} else if (cfi_interleave_is_4()) {
+			/* 4 (x8, x16 or x32) devices in x8 mode */
+			val = (cmd << 16) | cmd;
+			val = cpu_to_cfi32((val << 8) | val);
+		}
+	}
+	return val;
+}
+#define CMD(x)  cfi_build_cmd((x), map, cfi)
+
+/*
+ * Read a value according to the bus width.
+ */
+
+static inline __u32 cfi_read(struct map_info *map, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		return map->read8(map, addr);
+	} else if (cfi_buswidth_is_2()) {
+		return map->read16(map, addr);
+	} else if (cfi_buswidth_is_4()) {
+		return map->read32(map, addr);
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * Write a value according to the bus width.
+ */
+
+static inline void cfi_write(struct map_info *map, __u32 val, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		map->write8(map, val, addr);
+	} else if (cfi_buswidth_is_2()) {
+		map->write16(map, val, addr);
+	} else if (cfi_buswidth_is_4()) {
+		map->write32(map, val, addr);
+	}
+}
+
+/*
+ * Sends a CFI command to a bank of flash for the given geometry.
+ *
+ * Returns the offset in flash where the command was written.
+ * If prev_val is non-null, it will be set to the value at the command address,
+ * before the command was written.
+ */
+static inline __u32 cfi_send_gen_cmd(u_char cmd, __u32 cmd_addr, __u32 base,
+				struct map_info *map, struct cfi_private *cfi,
+				int type, __u32 *prev_val)
+{
+	__u32 val;
+	__u32 addr = base + cfi_build_cmd_addr(cmd_addr, CFIDEV_INTERLEAVE, type);
+
+	val = cfi_build_cmd(cmd, map, cfi);
+
+	if (prev_val)
+		*prev_val = cfi_read(map, addr);
+
+	cfi_write(map, val, addr);
+
+	return addr - base;
+}
+
+static inline __u8 cfi_read_query(struct map_info *map, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		return map->read8(map, addr);
+	} else if (cfi_buswidth_is_2()) {
+		return cfi16_to_cpu(map->read16(map, addr));
+	} else if (cfi_buswidth_is_4()) {
+		return cfi32_to_cpu(map->read32(map, addr));
+	} else {
+		return 0;
+	}
+}
+
+static inline void cfi_udelay(int us)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	if (current->need_resched) {
+		unsigned long t = us * HZ / 1000000;
+		if (t < 1)
+			t = 1;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(t);
+	}
+	else
+#endif
+		udelay(us);
+}
+static inline void cfi_spin_lock(spinlock_t *mutex)
+{
+	spin_lock_bh(mutex);
+}
+
+static inline void cfi_spin_unlock(spinlock_t *mutex)
+{
+	spin_unlock_bh(mutex);
+}
+
 
 #endif /* __MTD_CFI_H__ */
diff -Naur linux-2.4.2.orig/include/linux/mtd/cfi_endian.h linux-2.4.2/include/linux/mtd/cfi_endian.h
--- linux-2.4.2.orig/include/linux/mtd/cfi_endian.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/cfi_endian.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,51 @@
+/*
+ * $Id: cfi_endian.h,v 1.10 2001/06/18 11:00:46 abz Exp $
+ *
+ */
+
+#include <asm/byteorder.h>
+
+#ifndef CONFIG_MTD_CFI_ADV_OPTIONS
+
+#define CFI_HOST_ENDIAN
+
+#else
+
+#ifdef CONFIG_MTD_CFI_NOSWAP
+#define CFI_HOST_ENDIAN
+#endif
+
+#ifdef CONFIG_MTD_CFI_LE_BYTE_SWAP
+#define CFI_LITTLE_ENDIAN
+#endif
+
+#ifdef CONFIG_MTD_CFI_BE_BYTE_SWAP
+#define CFI_BIG_ENDIAN
+#endif
+
+#endif
+
+#if defined(CFI_LITTLE_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) cpu_to_le16(x)
+#define cpu_to_cfi32(x) cpu_to_le32(x)
+#define cfi16_to_cpu(x) le16_to_cpu(x)
+#define cfi32_to_cpu(x) le32_to_cpu(x)
+#elif defined (CFI_BIG_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) cpu_to_be16(x)
+#define cpu_to_cfi32(x) cpu_to_be32(x)
+#define cfi16_to_cpu(x) be16_to_cpu(x)
+#define cfi32_to_cpu(x) be32_to_cpu(x)
+#elif defined (CFI_HOST_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) (x)
+#define cpu_to_cfi32(x) (x)
+#define cfi16_to_cpu(x) (x)
+#define cfi32_to_cpu(x) (x)
+#else
+#error No CFI endianness defined
+#endif
diff -Naur linux-2.4.2.orig/include/linux/mtd/compatmac.h linux-2.4.2/include/linux/mtd/compatmac.h
--- linux-2.4.2.orig/include/linux/mtd/compatmac.h	Mon Dec 11 22:16:42 2000
+++ linux-2.4.2/include/linux/mtd/compatmac.h	Fri Feb 15 14:41:17 2002
@@ -2,7 +2,7 @@
 /*
  * mtd/include/compatmac.h
  *
- * $Id: compatmac.h,v 1.4 2000/07/03 10:01:38 dwmw2 Exp $
+ * $Id: compatmac.h,v 1.26 2001/11/20 11:05:42 dwmw2 Exp $
  *
  * Extensions and omissions from the normal 'linux/compatmac.h'
  * files. hopefully this will end up empty as the 'real' one 
@@ -17,21 +17,158 @@
 #ifndef __LINUX_MTD_COMPATMAC_H__
 #define __LINUX_MTD_COMPATMAC_H__
 
-#include <linux/compatmac.h>
-#include <linux/types.h> /* used later in this header */
+#include <linux/config.h>
 #include <linux/module.h>
 #ifndef LINUX_VERSION_CODE
 #include <linux/version.h>
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
-#include <linux/vmalloc.h>
+#ifndef VERSION_CODE
+#  define VERSION_CODE(vers,rel,seq) ( ((vers)<<16) | ((rel)<<8) | (seq) )
+#endif
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(a,b,c) VERSION_CODE(a,b,c)
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,0,0)
 #  error "This kernel is too old: not supported by this file"
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+#include <linux/types.h> /* used later in this header */
+
+#define memcpy_fromio(a,b,c)    memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)      memcpy((void *)(a),(b),(c))
+
+typedef struct wait_queue * wait_queue_head_t;
+
+#define DECLARE_WAITQUEUE(x,y) struct wait_queue x = {y,NULL}
+#define DECLARE_WAIT_QUEUE_HEAD(x) struct wait_queue *x = NULL
+#define init_waitqueue_head init_waitqueue
+#define DECLARE_MUTEX(x) struct semaphore x = MUTEX
+#define DECLARE_MUTEX_LOCKED(x) struct semaphore x = MUTEX_LOCKED
+
+/* from sysdep-2.1.h */
+#  include <asm/segment.h>
+#  define access_ok(t,a,sz)           (verify_area((t),(a),(sz)) ? 0 : 1)
+#  define verify_area_20              verify_area
+#  define copy_to_user(t,f,n)         (memcpy_tofs(t,f,n), 0)
+#  define __copy_to_user(t,f,n)       copy_to_user((t),(f),(n))
+#  define copy_to_user_ret(t,f,n,r)   copy_to_user((t),(f),(n))
+#  define copy_from_user(t,f,n)       (memcpy_fromfs((t),(f),(n)), 0)
+#  define __copy_from_user(t,f,n)     copy_from_user((t),(f),(n))
+#  define copy_from_user_ret(t,f,n,r) copy_from_user((t),(f),(n))
+//xxx #  define PUT_USER(val,add)           (put_user((val),(add)), 0)
+#  define Put_user(val,add)           (put_user((val),(add)), 0)
+#  define __PUT_USER(val,add)         PUT_USER((val),(add))
+#  define PUT_USER_RET(val,add,ret)   PUT_USER((val),(add))
+#  define GET_USER(dest,add)          ((dest)=get_user((add)), 0)
+#  define __GET_USER(dest,add)        GET_USER((dest),(add))
+#  define GET_USER_RET(dest,add,ret)  GET_USER((dest),(add))
+
+#define ioremap(offset,size) vremap(offset,size)
+#define iounmap(adr)	/* */
+
+#define EXPORT_SYMBOL(s) /* */
+#define EXPORT_SYMBOL_NOVERS(s) /* */
+
+/* 2.1.10 and 2.1.43 introduced new functions. They are worth using */
+
+#if LINUX_VERSION_CODE < VERSION_CODE(2,1,10)
+
+#  include <asm/byteorder.h>
+#  ifdef __LITTLE_ENDIAN
+#    define cpu_to_le16(x) (x)
+#    define cpu_to_le32(x) (x)
+#    define cpu_to_be16(x) htons((x))
+#    define cpu_to_be32(x) htonl((x))
+#  else
+#    define cpu_to_be16(x) (x)
+#    define cpu_to_be32(x) (x)
+     extern inline __u16 cpu_to_le16(__u16 x) { return (x<<8) | (x>>8);}
+     extern inline __u32 cpu_to_le32(__u32 x) { return((x>>24) |
+             ((x>>8)&0xff00) | ((x<<8)&0xff0000) | (x<<24));}
+#  endif
+
+#  define le16_to_cpu(x)  cpu_to_le16(x)
+#  define le32_to_cpu(x)  cpu_to_le32(x)
+#  define be16_to_cpu(x)  cpu_to_be16(x)
+#  define be32_to_cpu(x)  cpu_to_be32(x)
+
+#endif
+
+#if LINUX_VERSION_CODE < VERSION_CODE(2,1,43)
+#  define cpu_to_le16p(addr) (cpu_to_le16(*(addr)))
+#  define cpu_to_le32p(addr) (cpu_to_le32(*(addr)))
+#  define cpu_to_be16p(addr) (cpu_to_be16(*(addr)))
+#  define cpu_to_be32p(addr) (cpu_to_be32(*(addr)))
+
+   extern inline void cpu_to_le16s(__u16 *a) {*a = cpu_to_le16(*a);}
+   extern inline void cpu_to_le32s(__u16 *a) {*a = cpu_to_le32(*a);}
+   extern inline void cpu_to_be16s(__u16 *a) {*a = cpu_to_be16(*a);}
+   extern inline void cpu_to_be32s(__u16 *a) {*a = cpu_to_be32(*a);}
+
+#  define le16_to_cpup(x) cpu_to_le16p(x)
+#  define le32_to_cpup(x) cpu_to_le32p(x)
+#  define be16_to_cpup(x) cpu_to_be16p(x)
+#  define be32_to_cpup(x) cpu_to_be32p(x)
+
+#  define le16_to_cpus(x) cpu_to_le16s(x)
+#  define le32_to_cpus(x) cpu_to_le32s(x)
+#  define be16_to_cpus(x) cpu_to_be16s(x)
+#  define be32_to_cpus(x) cpu_to_be32s(x)
+#endif
+
+// from 2.2, linux/types.h
+#ifndef __BIT_TYPES_DEFINED__
+#define __BIT_TYPES_DEFINED__
+
+typedef         __u8            u_int8_t;
+typedef         __s8            int8_t;
+typedef         __u16           u_int16_t;
+typedef         __s16           int16_t;
+typedef         __u32           u_int32_t;
+typedef         __s32           int32_t;
+
+#endif /* !(__BIT_TYPES_DEFINED__) */
+
+#if (__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)
+  typedef struct { } spinlock_t;
+  #define SPIN_LOCK_UNLOCKED (spinlock_t) { }
+#else
+  typedef struct { int gcc_is_buggy; } spinlock_t;
+  #define SPIN_LOCK_UNLOCKED (spinlock_t) { 0 }
+#endif
+
+#define spin_lock_init(lock)    do { } while(0)
+#define spin_lock(lock)         (void)(lock) /* Not "unused variable". */
+#define spin_trylock(lock)      (1)
+#define spin_unlock_wait(lock)  do { } while(0)
+#define spin_unlock(lock)       do { } while(0)
+#define spin_lock_irq(lock)     cli()
+#define spin_unlock_irq(lock)   sti()
+
+#define spin_lock_irqsave(lock, flags) \
+        do { save_flags(flags); cli(); } while (0)
+#define spin_unlock_irqrestore(lock, flags) \
+        restore_flags(flags)
+
+// Doesn't work when tqueue.h is included. 
+// #define queue_task                   queue_task_irq_off
+#define tty_flip_buffer_push(tty)    queue_task_irq_off(&tty->flip.tqueue, &tq_timer)
+#define signal_pending(current)      (current->signal & ~current->blocked)
+#define schedule_timeout(to)         do {current->timeout = jiffies + (to);schedule ();} while (0)
+#define time_after(t1,t2)            (((long)t1-t2) > 0)
+
+#else
+  #include <linux/compatmac.h>
+#endif  // LINUX_VERSION_CODE < 0x020100
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#include <linux/vmalloc.h>
+#endif
+
 /* Modularization issues */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,18)
 #  define __USE_OLD_SYMTAB__
@@ -97,32 +234,60 @@
 #include <linux/init.h>
 #endif
 
-#if LINUX_VERSION_CODE < 0x20300
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 #define init_MUTEX(x) do {*(x) = MUTEX;} while (0)
+#define init_MUTEX_LOCKED(x) do {*(x) = MUTEX_LOCKED;} while (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #define RQFUNC_ARG void
 #define blkdev_dequeue_request(req) do {CURRENT = req->next;} while (0)
 #else
 #define RQFUNC_ARG request_queue_t *q
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,32)
+#define blk_cleanup_queue(nr) do {blk_dev[nr].request_fn = 0;} while(0)
+#define BLK_DEFAULT_QUEUE(nr) (blk_dev[nr].request_fn)
+#define blk_init_queue(q, rq) do {q = rq;} while(0)
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,0)
+#ifdef CONFIG_MODULES
 #define __MOD_INC_USE_COUNT(mod)                                        \
         (atomic_inc(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED|MOD_USED_ONCE)
 #define __MOD_DEC_USE_COUNT(mod)                                        \
         (atomic_dec(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED)
+#else
+#define __MOD_INC_USE_COUNT(mod)
+#define __MOD_DEC_USE_COUNT(mod)
+#endif
 #endif
 
 
+#ifndef HAVE_INTER_MODULE
+static inline void *inter_module_get(char *x) {return NULL;}
+static inline void *inter_module_get_request(char *x, char *y) {return NULL;}
+static inline void inter_module_put(const char *x) {}
+static inline void inter_module_register(const char *x, struct module *y, const void *z) {}
+static inline void inter_module_unregister(const char *x) {}
+#endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 
 #define DECLARE_WAIT_QUEUE_HEAD(x) struct wait_queue *x = NULL
 #define init_waitqueue_head init_waitqueue
 
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+
 static inline int try_inc_mod_count(struct module *mod)
 {
+#ifdef CONFIG_MODULES
 	if (mod)
 		__MOD_INC_USE_COUNT(mod);
+#endif
 	return 1;
 }
 #endif
@@ -197,6 +362,123 @@
 #include <linux/spinlock.h>
 #endif
 
-#endif /* __LINUX_MTD_COMPATMAC_H__ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
+#define set_current_state(state_value)                        \
+        do { current->state = (state_value); } while (0)
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,0) 
+static inline int invalidate_device(kdev_t dev, int do_sync) {
+
+	if (do_sync)
+		fsync_dev(dev);
+	
+	invalidate_buffers(dev);
+	return 0;
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5)
+static inline int invalidate_device(kdev_t dev, int do_sync) {
+	struct super_block *sb = get_super(dev);
+	int res = 0;
+
+	if (do_sync)
+		fsync_dev(dev);
+	
+	if (sb)
+		res = invalidate_inodes(sb);
 
+	invalidate_buffers(dev);
+	return res;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+#undef min
+#undef max
+#undef min_t
+#undef max_t
+/*
+ * min()/max() macros that also do
+ * strict type-checking.. See the
+ * "unnecessary" pointer comparison.
+ */
+#define min(x,y) ({ \
+        const typeof(x) _x = (x);       \
+        const typeof(y) _y = (y);       \
+        (void) (&_x == &_y);            \
+        _x < _y ? _x : _y; })
+
+#define max(x,y) ({ \
+        const typeof(x) _x = (x);       \
+        const typeof(y) _y = (y);       \
+        (void) (&_x == &_y);            \
+        _x > _y ? _x : _y; })
+
+/*
+ * ..and if you can't take the strict
+ * types, you can specify one yourself.
+ *
+ * Or not use min/max at all, of course.
+ */
+#define min_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#define max_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,7)
+struct completion {
+	struct semaphore s;
+};
+
+#define complete(c) up(&(c)->s)
+#define wait_for_completion(c) down(&(c)->s)
+#define init_completion(c) init_MUTEX_LOCKED(&(c)->s);
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9)
+/* This came later */
+#define complete_and_exit(c, r) do { complete(c); do_exit(r); } while(0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+
+#include <linux/genhd.h>
+
+static inline void add_gendisk(struct gendisk *gp)
+{
+	gp->next = gendisk_head;
+	gendisk_head = gp;
+}
+
+static inline void del_gendisk(struct gendisk *gp)
+{
+	struct gendisk *gd, **gdp;
+
+	for (gdp = &gendisk_head; *gdp; gdp = &((*gdp)->next))
+		if (*gdp == gp) {
+			gd = *gdp; *gdp = gd->next;
+			break;
+		}
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18) && defined(MODULE)
+
+#define module_init(func)		\
+mod_init_t init_module(void) {		\
+	return func();			\
+}
+
+#define module_exit(func)		\
+mod_exit_t cleanup_module(void) {	\
+	return func();			\
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+#define MODULE_LICENSE(x) /* */
+#endif
+
+#endif /* __LINUX_MTD_COMPATMAC_H__ */
diff -Naur linux-2.4.2.orig/include/linux/mtd/doc2000.h linux-2.4.2/include/linux/mtd/doc2000.h
--- linux-2.4.2.orig/include/linux/mtd/doc2000.h	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/include/linux/mtd/doc2000.h	Fri Feb 15 14:41:17 2002
@@ -2,7 +2,7 @@
 /* Linux driver for Disk-On-Chip 2000       */
 /* (c) 1999 Machine Vision Holdings, Inc.   */
 /* Author: David Woodhouse <dwmw2@mvhi.com> */
-/* $Id: doc2000.h,v 1.12 2000/11/03 12:43:43 dwmw2 Exp $ */
+/* $Id: doc2000.h,v 1.15 2001/09/19 00:22:15 dwmw2 Exp $ */
 
 #ifndef __MTD_DOC2000_H__
 #define __MTD_DOC2000_H__
@@ -43,18 +43,22 @@
  * On PPC, it's mmap'd and 16-bit wide.
  * Others use readb/writeb 
  */
-#if defined(__arm__) 
-#define ReadDOC_(adr, reg)      ((unsigned char)(*(__u32 *)(((unsigned long)adr)+(reg<<2))))
-#define WriteDOC_(d, adr, reg)  do{ *(__u32 *)(((unsigned long)adr)+(reg<<2)) = (__u32)d} while(0)
+#if defined(__arm__)
+#define ReadDOC_(adr, reg)      ((unsigned char)(*(__u32 *)(((unsigned long)adr)+((reg)<<2))))
+#define WriteDOC_(d, adr, reg)  do{ *(__u32 *)(((unsigned long)adr)+((reg)<<2)) = (__u32)d; wmb();} while(0)
+#define DOC_IOREMAP_LEN 0x8000
 #elif defined(__ppc__)
-#define ReadDOC_(adr, reg)      ((unsigned char)(*(__u16 *)(((unsigned long)adr)+(reg<<1))))
-#define WriteDOC_(d, adr, reg)  do{ *(__u16 *)(((unsigned long)adr)+(reg<<1)) = (__u16)d} while(0)
+#define ReadDOC_(adr, reg)      ((unsigned char)(*(__u16 *)(((unsigned long)adr)+((reg)<<1))))
+#define WriteDOC_(d, adr, reg)  do{ *(__u16 *)(((unsigned long)adr)+((reg)<<1)) = (__u16)d; wmb();} while(0)
+#define DOC_IOREMAP_LEN 0x4000
 #else
-#define ReadDOC_(adr, reg)      readb(((unsigned long)adr) + reg)
-#define WriteDOC_(d, adr, reg)  writeb(d, ((unsigned long)adr) + reg)
+#define ReadDOC_(adr, reg)      readb(((unsigned long)adr) + (reg))
+#define WriteDOC_(d, adr, reg)  writeb(d, ((unsigned long)adr) + (reg))
+#define DOC_IOREMAP_LEN 0x2000
+
 #endif
 
-#if defined(__i386__)
+#if defined(__i386__) || defined(__x86_64__)
 #define USE_MEMCPY
 #endif
 
@@ -130,6 +134,7 @@
 	int numchips;
 	struct Nand *chips;
 	struct mtd_info *nextdoc;
+	struct semaphore lock;
 };
 
 int doc_decode_ecc(unsigned char sector[512], unsigned char ecc1[6]);
diff -Naur linux-2.4.2.orig/include/linux/mtd/flashchip.h linux-2.4.2/include/linux/mtd/flashchip.h
--- linux-2.4.2.orig/include/linux/mtd/flashchip.h	Mon Dec 11 22:16:46 2000
+++ linux-2.4.2/include/linux/mtd/flashchip.h	Fri Feb 15 14:41:17 2002
@@ -6,7 +6,7 @@
  *
  * (C) 2000 Red Hat. GPLd.
  *
- * $Id: flashchip.h,v 1.4 2000/07/03 12:58:41 dwmw2 Exp $
+ * $Id: flashchip.h,v 1.7 2001/01/18 03:52:36 nico Exp $
  *
  */
 
@@ -25,12 +25,17 @@
 	FL_CFI_QUERY,
 	FL_JEDEC_QUERY,
 	FL_ERASING,
+	FL_ERASE_SUSPENDING,
 	FL_ERASE_SUSPENDED,
 	FL_WRITING,
+	FL_WRITING_TO_BUFFER,
+	FL_WRITE_SUSPENDING,
 	FL_WRITE_SUSPENDED,
 	FL_PM_SUSPENDED,
 	FL_SYNCING,
 	FL_UNLOADING,
+	FL_LOCKING,
+	FL_UNLOCKING,
 	FL_UNKNOWN
 } flstate_t;
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/ftl.h linux-2.4.2/include/linux/mtd/ftl.h
--- linux-2.4.2.orig/include/linux/mtd/ftl.h	Sun Feb  4 19:05:30 2001
+++ linux-2.4.2/include/linux/mtd/ftl.h	Fri Feb 15 14:41:17 2002
@@ -1,4 +1,7 @@
 /*
+ * $Id: ftl.h,v 1.5 2001/06/02 20:35:51 dwmw2 Exp $
+ * 
+ * Derived from (and probably identical to):
  * ftl.h 1.7 1999/10/25 20:23:17
  *
  * The contents of this file are subject to the Mozilla Public License
@@ -16,8 +19,8 @@
  * are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
  *
  * Alternatively, the contents of this file may be used under the
- * terms of the GNU General Public License version 2 (the "GPL"), in which
- * case the provisions of the GPL are applicable instead of the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
  * above.  If you wish to allow the use of your version of this file
  * only under the terms of the GPL and not to allow others to use
  * your version of this file under the MPL, indicate your decision by
diff -Naur linux-2.4.2.orig/include/linux/mtd/gen_probe.h linux-2.4.2/include/linux/mtd/gen_probe.h
--- linux-2.4.2.orig/include/linux/mtd/gen_probe.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/gen_probe.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,23 @@
+/*
+ * (C) 2001, 2001 Red Hat, Inc.
+ * GPL'd
+ * $Id: gen_probe.h,v 1.1 2001/09/02 18:50:13 dwmw2 Exp $
+ */
+
+#ifndef __LINUX_MTD_GEN_PROBE_H__
+#define __LINUX_MTD_GEN_PROBE_H__
+
+#include <linux/mtd/flashchip.h>
+#include <linux/mtd/map.h> 
+#include <linux/mtd/cfi.h>
+
+struct chip_probe {
+	char *name;
+	int (*probe_chip)(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi);
+
+};
+
+struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp);
+
+#endif /* __LINUX_MTD_GEN_PROBE_H__ */
diff -Naur linux-2.4.2.orig/include/linux/mtd/iflash.h linux-2.4.2/include/linux/mtd/iflash.h
--- linux-2.4.2.orig/include/linux/mtd/iflash.h	Tue Jul  4 19:10:52 2000
+++ linux-2.4.2/include/linux/mtd/iflash.h	Fri Feb 15 14:41:17 2002
@@ -1,4 +1,4 @@
-/* iflash.h $revision$ $date$ (David Hinds) */
+/* $Id: iflash.h,v 1.2 2000/11/13 18:01:54 dwmw2 Exp $ */
 
 #ifndef __MTD_IFLASH_H__
 #define __MTD_IFLASH_H__
diff -Naur linux-2.4.2.orig/include/linux/mtd/jedec.h linux-2.4.2/include/linux/mtd/jedec.h
--- linux-2.4.2.orig/include/linux/mtd/jedec.h	Tue Jul  4 19:10:52 2000
+++ linux-2.4.2/include/linux/mtd/jedec.h	Fri Feb 15 14:41:17 2002
@@ -7,7 +7,7 @@
  *
  * See the AMD flash databook for information on how to operate the interface.
  *
- * $Id: jedec.h,v 1.1 2000/07/04 07:21:51 jgg Exp $
+ * $Id: jedec.h,v 1.2 2001/11/06 14:37:36 dwmw2 Exp $
  */
 
 #ifndef __LINUX_MTD_JEDEC_H__
@@ -63,7 +63,5 @@
    
    struct jedec_flash_chip chips[MAX_JEDEC_CHIPS];  
 };
-
-extern const struct JEDECTable *jedec_idtoinf(__u8 mfr,__u8 id);
 
 #endif
diff -Naur linux-2.4.2.orig/include/linux/mtd/list.h linux-2.4.2/include/linux/mtd/list.h
--- linux-2.4.2.orig/include/linux/mtd/list.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/list.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,154 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#ifdef __KERNEL__
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_add(struct list_head * new,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static __inline__ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static __inline__ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static __inline__ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static __inline__ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Naur linux-2.4.2.orig/include/linux/mtd/map.h linux-2.4.2/include/linux/mtd/map.h
--- linux-2.4.2.orig/include/linux/mtd/map.h	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/include/linux/mtd/map.h	Fri Feb 15 14:41:17 2002
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.10.2.2 2001/01/09 00:44:51 dwmw2 Exp $ */
+/* $Id: map.h,v 1.25 2001/09/09 15:04:17 dwmw2 Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -53,47 +53,23 @@
 	unsigned long map_priv_1;
 	unsigned long map_priv_2;
 	void *fldrv_priv;
-	void (*fldrv_destroy)(struct mtd_info *);
-	const char *im_name;
+	struct mtd_chip_driver *fldrv;
 };
 
-#ifdef CONFIG_MODULES
-/* 
- * Probe for the contents of a map device and make an MTD structure
- * if anything is recognised. Doesn't register it because the calling
- * map driver needs to set the 'module' field first.
- */
-static inline struct mtd_info *do_map_probe(struct map_info *map, const char *funcname, const char *modname)
-{
-	struct mtd_info *(*probe_p)(struct map_info *);
-	struct mtd_info *mtd = NULL;
 
-	if ((probe_p = inter_module_get_request(modname, funcname)))
-		mtd = (*probe_p)(map);	/* map->im_name is set by probe */
+struct mtd_chip_driver {
+	struct mtd_info *(*probe)(struct map_info *map);
+	void (*destroy)(struct mtd_info *);
+	struct module *module;
+	char *name;
+	struct list_head list;
+};
 
-	return mtd;
-}
+void register_mtd_chip_driver(struct mtd_chip_driver *);
+void unregister_mtd_chip_driver(struct mtd_chip_driver *);
 
+struct mtd_info *do_map_probe(char *name, struct map_info *map);
 
-/* 
- * Commonly-used probe functions for different types of chip.
- */
-#define do_cfi_probe(x) do_map_probe(x, "cfi_probe", "cfi_probe")
-#define do_jedec_probe(x) do_map_probe(x, "jedec_probe", "jedec_probe")
-#define do_ram_probe(x) do_map_probe(x, "map_ram_probe", "map_ram")
-#define do_rom_probe(x) do_map_probe(x, "map_rom_probe", "map_rom")
-#else
-	/* without module support, call probe function directly */
-extern struct mtd_info *cfi_probe(struct map_info *);
-extern struct mtd_info *jedec_probe(struct map_info *);
-extern struct mtd_info *map_ram_probe(struct map_info *);
-extern struct mtd_info *map_rom_probe(struct map_info *);
-
-#define do_cfi_probe(x) cfi_probe(x)
-#define do_jedec_probe(x) jedec_probe(x)
-#define do_ram_probe(x) map_ram_probe(x)
-#define do_rom_probe(x) map_rom_probe(x)
-#endif
 
 /*
  * Destroy an MTD device which was created for a map device.
@@ -103,8 +79,12 @@
 {
 	struct map_info *map = mtd->priv;
 
-	map->fldrv_destroy(mtd);
-	inter_module_put(map->im_name);
+	if (map->fldrv->destroy)
+		map->fldrv->destroy(mtd);
+#ifdef CONFIG_MODULES
+	if (map->fldrv->module)
+		__MOD_DEC_USE_COUNT(map->fldrv->module);
+#endif
 	kfree(mtd);
 }
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/mtd.h linux-2.4.2/include/linux/mtd/mtd.h
--- linux-2.4.2.orig/include/linux/mtd/mtd.h	Fri Dec 29 23:07:24 2000
+++ linux-2.4.2/include/linux/mtd/mtd.h	Fri Feb 15 14:41:17 2002
@@ -1,5 +1,5 @@
 
-/* $Id: mtd.h,v 1.26 2000/10/30 17:18:04 sjhill Exp $ */
+/* $Id: mtd.h,v 1.34 2001/11/27 14:55:12 cdavies Exp $ */
 
 #ifndef __MTD_MTD_H__
 #define __MTD_MTD_H__
@@ -16,13 +16,13 @@
 #endif /* __KERNEL__ */
 
 struct erase_info_user {
-	unsigned long start;
-	unsigned long length;
+	u_int32_t start;
+	u_int32_t length;
 };
 
 struct mtd_oob_buf {
-	loff_t start;
-	ssize_t length;
+	u_int32_t start;
+	u_int32_t length;
 	unsigned char *ptr;
 };
 
@@ -68,13 +68,21 @@
 
 struct mtd_info_user {
 	u_char type;
-	u_long flags;
-	u_long size;	 // Total size of the MTD
-	u_long erasesize;
-	u_long oobblock;  // Size of OOB blocks (e.g. 512)
-	u_long oobsize;   // Amount of OOB data per block (e.g. 16)
-        u_long ecctype;
-        u_long eccsize;
+	u_int32_t flags;
+	u_int32_t size;	 // Total size of the MTD
+	u_int32_t erasesize;
+	u_int32_t oobblock;  // Size of OOB blocks (e.g. 512)
+	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+	u_int32_t ecctype;
+	u_int32_t eccsize;
+};
+
+struct region_info_user {
+	u_int32_t offset;		/* At which this region starts, 
+					 * from the beginning of the MTD */
+	u_int32_t erasesize;		/* For this region */
+	u_int32_t numblocks;		/* Number of blocks in this region */
+	u_int32_t regionindex;
 };
 
 #define MEMGETINFO              _IOR('M', 1, struct mtd_info_user)
@@ -83,11 +91,14 @@
 #define MEMREADOOB              _IOWR('M', 4, struct mtd_oob_buf)
 #define MEMLOCK                 _IOW('M', 5, struct erase_info_user)
 #define MEMUNLOCK               _IOW('M', 6, struct erase_info_user)
+#define MEMGETREGIONCOUNT	_IOR('M', 7, int)
+#define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
 
 #ifndef __KERNEL__
 
 typedef struct mtd_info_user mtd_info_t;
 typedef struct erase_info_user erase_info_t;
+typedef struct region_info_user region_info_t;
 
 	/* User-space ioctl definitions */
 
@@ -103,8 +114,8 @@
 
 struct erase_info {
 	struct mtd_info *mtd;
-	u_long addr;
-	u_long len;
+	u_int32_t addr;
+	u_int32_t len;
 	u_long time;
 	u_long retries;
 	u_int dev;
@@ -115,22 +126,40 @@
 	struct erase_info *next;
 };
 
+struct mtd_erase_region_info {
+	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
+	u_int32_t erasesize;		/* For this region */
+	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
+};
 
 struct mtd_info {
 	u_char type;
-	u_long flags;
-	u_long size;	 // Total size of the MTD
-	u_long erasesize;
-	u_long oobblock;  // Size of OOB blocks (e.g. 512)
-	u_long oobsize;   // Amount of OOB data per block (e.g. 16)
-        u_long ecctype;
-        u_long eccsize;
+	u_int32_t flags;
+	u_int32_t size;	 // Total size of the MTD
+
+	/* "Major" erase size for the device. Nave users may take this
+	 * to be the only erase size available, or may use the more detailed
+	 * information below if they desire
+	 */
+	u_int32_t erasesize;
+
+	u_int32_t oobblock;  // Size of OOB blocks (e.g. 512)
+	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+	u_int32_t ecctype;
+	u_int32_t eccsize;
 
 	// Kernel-only stuff starts here.
 	char *name;
 	int index;
 
-	u_long bank_size;
+	/* Data for variable erase regions. If numeraseregions is zero,
+	 * it means that the whole device has erasesize as given above. 
+	 */
+	int numeraseregions;
+	struct mtd_erase_region_info *eraseregions; 
+
+	/* This really shouldn't be here. It can go away in 2.5 */
+	u_int32_t bank_size;
 
 	struct module *module;
 	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
@@ -150,6 +179,18 @@
 
 	int (*read_oob) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 	int (*write_oob) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+
+	/* 
+	 * Methods to access the protection register area, present in some 
+	 * flash devices. The user data is one time programmable but the
+	 * factory data is read only. 
+	 */
+	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+
+	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+
+	/* This function is not yet implemented */
+	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 
 	/* iovec-based read/write methods. We need these especially for NAND flash,
 	   with its limited number of write cycles per erase.
diff -Naur linux-2.4.2.orig/include/linux/mtd/nand_ecc.h linux-2.4.2/include/linux/mtd/nand_ecc.h
--- linux-2.4.2.orig/include/linux/mtd/nand_ecc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/nand_ecc.h	Fri Feb 15 14:41:17 2002
@@ -0,0 +1,28 @@
+/*
+ *  drivers/mtd/nand_ecc.h
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: nand_ecc.h,v 1.1 2000/10/12 00:57:15 sjhill Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file is the header for the ECC algorithm.
+ */
+
+/*
+ * Creates non-inverted ECC code from line parity
+ */
+void nand_trans_result(u_char reg2, u_char reg3, u_char *ecc_code);
+
+/*
+ * Calculate 3 byte ECC code for 256 byte block
+ */
+void nand_calculate_ecc (const u_char *dat, u_char *ecc_code);
+
+/*
+ * Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc);
diff -Naur linux-2.4.2.orig/include/linux/mtd/nftl.h linux-2.4.2/include/linux/mtd/nftl.h
--- linux-2.4.2.orig/include/linux/mtd/nftl.h	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/include/linux/mtd/nftl.h	Fri Feb 15 14:41:17 2002
@@ -2,7 +2,7 @@
 /* Defines for NAND Flash Translation Layer  */
 /* (c) 1999 Machine Vision Holdings, Inc.    */
 /* Author: David Woodhouse <dwmw2@mvhi.com>  */
-/* $Id: nftl.h,v 1.9 2000/11/07 05:48:49 ollie Exp $ */
+/* $Id: nftl.h,v 1.10 2000/12/29 00:25:38 dwmw2 Exp $ */
 
 #ifndef __MTD_NFTL_H__
 #define __MTD_NFTL_H__
@@ -115,6 +115,7 @@
 
 #define MAX_NFTLS 16
 #define MAX_SECTORS_PER_UNIT 32
+#define NFTL_PARTN_BITS 4
 
 #endif /* __KERNEL__ */
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/partitions.h linux-2.4.2/include/linux/mtd/partitions.h
--- linux-2.4.2.orig/include/linux/mtd/partitions.h	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/include/linux/mtd/partitions.h	Fri Feb 15 14:41:17 2002
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: partitions.h,v 1.3 2000/11/10 23:35:12 nico Exp $
+ * $Id: partitions.h,v 1.7 2001/11/07 01:20:59 jsiegel Exp $
  */
 
 #ifndef MTD_PARTITIONS_H
@@ -22,25 +22,30 @@
  *
  * For each partition, these fields are available:
  * name: string that will be used to label the partition's MTD device.
- * size: the partition size; if 0, the partition will extend to the end of the 
- * 	master MTD device.
- * offset: absolute starting position within the master MTD device; if 0,
- * 	partition will start where the previous one ended.
+ * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition 
+ * 	will extend to the end of the master MTD device.
+ * offset: absolute starting position within the master MTD device; if 
+ * 	defined as MTDPART_OFS_APPEND, the partition will start where the 
+ * 	previous one ended; if MTDPART_OFS_NXTBLK, at the next erase block.
  * mask_flags: contains flags that have to be masked (removed) from the 
  * 	master MTD flag set for the corresponding MTD partition.
  * 	For example, to force a read-only partition, simply adding 
  * 	MTD_WRITEABLE to the mask_flags will do the trick.
  *
  * Note: writeable partitions require their size and offset be 
- * erasesize aligned.
+ * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
  */ 
 
 struct mtd_partition {
 	char *name;		/* identifier string */
-	u_long size;		/* partition size */
-	u_long offset;		/* offset within the master MTD space */
-	u_long mask_flags;	/* master MTD flags to mask out for this partition */
+	u_int32_t size;		/* partition size */
+	u_int32_t offset;		/* offset within the master MTD space */
+	u_int32_t mask_flags;	/* master MTD flags to mask out for this partition */
 };
+
+#define MTDPART_OFS_NXTBLK	(-2)
+#define MTDPART_OFS_APPEND	(-1)
+#define MTDPART_SIZ_FULL	(0)
 
 
 int add_mtd_partitions(struct mtd_info *, struct mtd_partition *, int);
diff -Naur linux-2.4.2.orig/include/linux/mtd/pmc551.h linux-2.4.2/include/linux/mtd/pmc551.h
--- linux-2.4.2.orig/include/linux/mtd/pmc551.h	Mon Dec 11 22:16:45 2000
+++ linux-2.4.2/include/linux/mtd/pmc551.h	Fri Feb 15 14:41:17 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.h,v 1.3 2000/10/30 20:03:23 major Exp $
+ * $Id: pmc551.h,v 1.4 2001/06/12 16:19:38 major Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -17,7 +17,7 @@
 
 #include <linux/mtd/mtd.h>
 
-#define PMC551_VERSION "$Id: pmc551.h,v 1.3 2000/10/30 20:03:23 major Exp $\n"\
+#define PMC551_VERSION "$Id: pmc551.h,v 1.4 2001/06/12 16:19:38 major Exp $\n"\
        "Ramix PMC551 PCI Mezzanine Ram Driver. (C) 1999,2000 Nortel Networks.\n"
 
 /*
@@ -26,9 +26,9 @@
 struct mypriv {
         struct pci_dev *dev;
         u_char *start;
-        u32    mem_map0_base_val;
-        u32    curr_mem_map0_val;
-        u32    aperture_size;
+        u32    base_map0;
+        u32    curr_map0;
+        u32    asize;
 	struct mtd_info *nextpmc551;
 };                       
 
@@ -37,9 +37,10 @@
  */
 static int pmc551_erase(struct mtd_info *, struct erase_info *);
 static void pmc551_unpoint(struct mtd_info *, u_char *);
+static int pmc551_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf);
 static int pmc551_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-static int pmc551_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char
-*);        
+static int pmc551_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);        
+
 
 /*
  * Define the PCI ID's if the kernel doesn't define them for us
@@ -73,9 +74,6 @@
 #define PMC551_DRAM_BLK_SET_COL_MUX(x,v) (((x) & ~0x00007000) | (((v) & 0x7) << 12))
 #define PMC551_DRAM_BLK_SET_ROW_MUX(x,v) (((x) & ~0x00000f00) | (((v) & 0xf) << 8))
 
-
-#define PMC551_ADDR_HIGH_MASK	0x3ff00000
-#define PMC551_ADDR_LOW_MASK	0x000fffff
 
 #endif /* __MTD_PMC551_H__ */
 
diff -Naur linux-2.4.2.orig/include/linux/sched.h linux-2.4.2/include/linux/sched.h
--- linux-2.4.2.orig/include/linux/sched.h	Thu Feb 22 01:09:58 2001
+++ linux-2.4.2/include/linux/sched.h	Fri Feb 15 14:41:17 2002
@@ -534,7 +534,8 @@
 extern unsigned long volatile jiffies;
 extern unsigned long itimer_ticks;
 extern unsigned long itimer_next;
-extern struct timeval xtime;
+/* extern struct timeval xtime; */
+extern volatile struct timeval xtime __attribute__ ((aligned (16)));
 extern void do_timer(struct pt_regs *);
 
 extern unsigned int * prof_buffer;
