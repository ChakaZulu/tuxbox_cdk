diff -Naur linux-2.4.2.orig/Documentation/Configure.help linux-2.4.2/Documentation/Configure.help
--- linux-2.4.2.orig/Documentation/Configure.help	Mon Feb 19 19:18:18 2001
+++ linux-2.4.2/Documentation/Configure.help	Thu Jan 10 18:34:26 2002
@@ -15834,6 +15834,11 @@
   only supports one type or the other. However, there is very early
   work on support for CHRP, PReP and PowerMac's from a single binary.
 
+Nokia dbox2 Mainboard
+CONFIG_DBOX2
+  Enables various fixes and changes for the Nokia dbox2. The Nokia
+  dbox2 is a satellite receiver for DVB + Pay-TV in Germany and Austria.
+
 Power management support for PowerBooks
 CONFIG_PMAC_PBOOK
   This provides support for putting a PowerBook to sleep; it also
diff -Naur linux-2.4.2.orig/Makefile linux-2.4.2/Makefile
--- linux-2.4.2.orig/Makefile	Thu Feb 22 01:54:15 2001
+++ linux-2.4.2/Makefile	Thu Jan 10 18:30:47 2002
@@ -5,7 +5,8 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+#ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH  := ppc
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 	  else if [ -x /bin/bash ]; then echo /bin/bash; \
@@ -18,7 +19,7 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+CROSS_COMPILE 	= powerpc-linux-
 
 #
 # Include the make variables (CC, etc...)
@@ -87,7 +88,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Os -fomit-frame-pointer -fno-strict-aliasing
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
 #
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/commproc.h linux-2.4.2/arch/ppc/8xx_io/commproc.h
--- linux-2.4.2.orig/arch/ppc/8xx_io/commproc.h	Sat Feb 17 01:02:34 2001
+++ linux-2.4.2/arch/ppc/8xx_io/commproc.h	Thu Jan 10 18:34:49 2002
@@ -513,8 +513,13 @@
 
 #define PA_ENET_RXD	((ushort)0x0004)	/* PA 13 */
 #define PA_ENET_TXD	((ushort)0x0008)	/* PA 12 */
+#ifdef CONFIG_DBOX2
+#define PA_ENET_RCLK	((ushort)0x0200)	/* PA  7 */
+#define PA_ENET_TCLK	((ushort)0x0800)	/* PA  5 */
+#else
 #define PA_ENET_RCLK	((ushort)0x0100)	/* PA  7 */
 #define PA_ENET_TCLK	((ushort)0x0400)	/* PA  5 */
+#endif
 
 #ifndef	CONFIG_FPS850	/* not valid on FPS board */
 #define	PB_ENET_TENA	((uint)0x00002000)
@@ -530,7 +535,11 @@
  * SCC2.  Also, make sure GR2 (bit 16) and SC2 (bit 17) are zero.
  */
 #define SICR_ENET_MASK	((uint)0x0000ff00)
+#ifdef CONFIG_DBOX2
+#define SICR_ENET_CLKRT	((uint)0x00003d00)
+#else
 #define SICR_ENET_CLKRT	((uint)0x00002600)
+#endif
 
 #endif	/* CONFIG_TQM8xxL */
 
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/enet.c linux-2.4.2/arch/ppc/8xx_io/enet.c
--- linux-2.4.2.orig/arch/ppc/8xx_io/enet.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/8xx_io/enet.c	Thu Jan 10 18:35:04 2002
@@ -889,7 +889,7 @@
 	immap->im_ioport.iop_pcdir &= ~PC_ENET_TENA;
 #endif
 
-#if (defined(CONFIG_TQM8xxL) && !defined(CONFIG_FPS850))
+#if (defined(CONFIG_TQM8xxL) && !defined(CONFIG_FPS850) && !defined(CONFIG_DBOX2))
 	cp->cp_pbpar |= PB_ENET_TENA;
 	cp->cp_pbdir |= PB_ENET_TENA;
 #endif
diff -Naur linux-2.4.2.orig/arch/ppc/8xx_io/uart.c linux-2.4.2/arch/ppc/8xx_io/uart.c
--- linux-2.4.2.orig/arch/ppc/8xx_io/uart.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/8xx_io/uart.c	Thu Jan 10 18:34:55 2002
@@ -2458,7 +2458,7 @@
 	__clear_user(&serial_driver,sizeof(struct tty_driver));
 	serial_driver.magic = TTY_DRIVER_MAGIC;
 	serial_driver.driver_name = "serial";
-	serial_driver.name = "ttyS";
+	serial_driver.name = "tts/%d";
 	serial_driver.major = TTY_MAJOR;
 	serial_driver.minor_start = 64;
 	serial_driver.num = NR_PORTS;
@@ -2496,7 +2496,7 @@
 	 * major number and the subtype code.
 	 */
 	callout_driver = serial_driver;
-	callout_driver.name = "cua";
+	callout_driver.name = "cua/%d";
 	callout_driver.major = TTYAUX_MAJOR;
 	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
 	callout_driver.read_proc = 0;
@@ -2833,6 +2833,9 @@
 
 	bd = (bd_t *)__res;
 
+#ifdef CONFIG_DBOX2
+        bd->bi_baudrate=9600; /* Unsure if this is still needed */
+#endif
 	for (bidx = 0; bidx < (sizeof(baud_table) / sizeof(int)); bidx++)
 		if (bd->bi_baudrate == baud_table[bidx])
 			break;
diff -Naur linux-2.4.2.orig/arch/ppc/Makefile linux-2.4.2/arch/ppc/Makefile
--- linux-2.4.2.orig/arch/ppc/Makefile	Tue Jan 23 00:41:14 2001
+++ linux-2.4.2/arch/ppc/Makefile	Thu Jan 10 18:34:33 2002
@@ -31,7 +31,11 @@
 endif
 
 ifdef CONFIG_8xx
-CFLAGS := $(CFLAGS) -mcpu=860 -I../8xx_io
+  ifdef CONFIG_DBOX2
+    CFLAGS := $(CFLAGS) -mcpu=823 -I../8xx_io
+  else
+    CFLAGS := $(CFLAGS) -mcpu=860 -I../8xx_io
+  endif
 endif
 
 ifdef CONFIG_PPC64BRIDGE
diff -Naur linux-2.4.2.orig/arch/ppc/config.in linux-2.4.2/arch/ppc/config.in
--- linux-2.4.2.orig/arch/ppc/config.in	Tue Jan 23 00:41:14 2001
+++ linux-2.4.2/arch/ppc/config.in	Thu Jan 10 18:34:39 2002
@@ -65,6 +65,7 @@
 	 
   if [ "$CONFIG_TQM8xxL" = "y" ]; then
     bool 'FPS850 Mainboard' CONFIG_FPS850
+    bool 'Nokia dbox2' CONFIG_DBOX2
   fi
 fi
 
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/irq.c linux-2.4.2/arch/ppc/kernel/irq.c
--- linux-2.4.2.orig/arch/ppc/kernel/irq.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/kernel/irq.c	Thu Jan 10 18:35:10 2002
@@ -520,6 +520,15 @@
 		else if (irq_desc[irq].handler->enable)
 			irq_desc[irq].handler->enable(irq);
 	}
+#ifdef CONFIG_DBOX2
+	if (action)
+	{
+	  if ( action->flags & SA_ONESHOT )
+	  {
+	    disable_irq_nosync(irq);
+	  }
+	}
+#endif
 	spin_unlock(&desc->lock);
 }
 
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/m8xx_setup.c linux-2.4.2/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.2.orig/arch/ppc/kernel/m8xx_setup.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/arch/ppc/kernel/m8xx_setup.c	Thu Jan 10 18:36:19 2002
@@ -140,6 +140,22 @@
 	printk("timebase_interrupt()\n");
 }
 
+#ifdef CONFIG_DBOX2
+void m8xx_reset_watchdog(void)
+{
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0x556c;             /* write magic1 */
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0xaa39;             /* write magic2 */
+}
+
+void pit_interrupt(int irq, void * dev, struct pt_regs * regs)
+{
+	m8xx_reset_watchdog();
+
+	// Clear irq
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr |= PISCR_PS;
+}
+#endif
+
 /* The decrementer counts at the system (internal) clock frequency divided by
  * sixteen, or external oscillator divided by four.  We force the processor
  * to use system clock divided by sixteen.
@@ -148,6 +164,10 @@
 {
 	bd_t	*binfo = (bd_t *)__res;
 	int freq, fp, divisor;
+#ifdef CONFIG_DBOX2
+	unsigned long sypcr;
+	unsigned short pitc, swtc, swp;
+#endif	
 
 	/* Unlock the SCCR.
 	*/
@@ -195,6 +215,22 @@
 	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtcsc &=
 						~(RTCSC_SIE | RTCSC_ALE);
 
+	/* Enable the RTC (fixed by gillem).
+	*/
+
+// wrong define in header file ... hack ;-)
+#ifdef RTC_IRQ
+#undef RTC_IRQ
+#define RTC_IRQ 9
+#endif
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtcsc |=
+				((mk_int_int_mask(RTC_IRQ) << 8) |
+					(RTCSC_RTE));
+			
+
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtcsck = ~KAPWR_KEY;
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtcsck = KAPWR_KEY;
+
 	/* Enabling the decrementer also enables the timebase interrupts
 	 * (or from the other point of view, to get decrementer interrupts
 	 * we have to enable the timebase).  The decrementer interrupt
@@ -206,6 +242,42 @@
 
 	if (request_8xxirq(DEC_INTERRUPT, timebase_interrupt, 0, "tbint", NULL) != 0)
 		panic("Could not allocate timer IRQ!");
+
+#ifdef CONFIG_DBOX2
+	sypcr = ((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_sypcr;
+
+	if ((sypcr >> 2) & 0x1) {
+	    m8xx_reset_watchdog();
+	
+	    if (sypcr >> 16)
+		swtc = sypcr >> 16;
+	    else	
+		swtc = 0xFFFF;
+
+	    if (sypcr & 0x1)
+		swp = 2048;
+	    else
+		swp = 1;
+
+#define PITRTCLK 8192
+
+	    // Fire trigger if half of the wdt ticked down		
+	    if ((swp * swtc) > (UINT_MAX / PITRTCLK))
+		pitc = swtc * swp / binfo->bi_intfreq * PITRTCLK / 2;
+	    else
+		pitc = PITRTCLK * swtc * swp / binfo->bi_intfreq / 2;
+	    
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_pitc = pitc << 16;
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr = (mk_int_int_mask(PIT_INTERRUPT) << 8) | PISCR_PIE | PISCR_PTE;
+	
+	    if (request_8xxirq(PIT_INTERRUPT, pit_interrupt, 0, "pit", NULL) != 0)
+		    panic("mpc8xx-wdt: could not allocate pit irq!");
+
+	    printk("mpc8xx-wdt: active wdt found (SWTC: 0x%04X, SWP: 0x%01X)\n", sypcr >> 16, sypcr & 0x1);
+	    printk("mpc8xx-wdt: keep-alive trigger activated (PITC: 0x%04X)\n", pitc);
+	}
+#endif
+
 }
 
 /* The RTC on the MPC8xx is an internal register.
diff -Naur linux-2.4.2.orig/arch/ppc/kernel/ppc_ksyms.c linux-2.4.2/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.4.2.orig/arch/ppc/kernel/ppc_ksyms.c	Tue Feb 13 22:15:04 2001
+++ linux-2.4.2/arch/ppc/kernel/ppc_ksyms.c	Thu Jan 10 18:36:05 2002
@@ -242,8 +242,8 @@
 EXPORT_SYMBOL(set_backlight_enable);
 EXPORT_SYMBOL(register_backlight_controller);
 #endif /* CONFIG_PMAC_BACKLIGHT */
-EXPORT_SYMBOL_NOVERS(sys_ctrler);
 #ifndef CONFIG_MACH_SPECIFIC
+EXPORT_SYMBOL_NOVERS(sys_ctrler);
 EXPORT_SYMBOL_NOVERS(have_of);
 #endif /* CONFIG_MACH_SPECIFIC */
 #if defined(CONFIG_ALL_PPC)
@@ -280,7 +280,10 @@
 #if defined(CONFIG_SCSI) && defined(CONFIG_ALL_PPC)
 EXPORT_SYMBOL(note_scsi_host);
 #endif
+#ifndef CONFIG_DBOX2
+// das ist hier vermutlich ganz falsch
 EXPORT_SYMBOL(kd_mksound);
+#endif
 #ifdef CONFIG_NVRAM
 EXPORT_SYMBOL(nvram_read_byte);
 EXPORT_SYMBOL(nvram_write_byte);
@@ -367,3 +370,20 @@
 EXPORT_SYMBOL(last_task_used_math);
 EXPORT_SYMBOL(ret_from_except);
 #endif /* CONFIG_MOL */
+
+#ifdef CONFIG_DBOX2
+extern void m8xx_cpm_setbrg(void);
+extern void m8xx_cpm_hostalloc(void);
+extern void m8xx_cpm_dpalloc(void);
+extern void cpm_free_handler(void);
+extern void cpm_install_handler(void);
+extern void cpmp(void);
+extern int request_8xxirq(unsigned int irq,void (*handler)(int, void *, struct pt_regs *),unsigned long flags,const char *device,void *dev_id);
+EXPORT_SYMBOL(m8xx_cpm_setbrg);
+EXPORT_SYMBOL(m8xx_cpm_hostalloc);
+EXPORT_SYMBOL(m8xx_cpm_dpalloc);
+EXPORT_SYMBOL(cpm_free_handler);
+EXPORT_SYMBOL(cpm_install_handler);
+EXPORT_SYMBOL(cpmp);
+EXPORT_SYMBOL(request_8xxirq);
+#endif
diff -Naur linux-2.4.2.orig/drivers/char/console.c linux-2.4.2/drivers/char/console.c
--- linux-2.4.2.orig/drivers/char/console.c	Fri Feb  9 20:30:22 2001
+++ linux-2.4.2/drivers/char/console.c	Thu Jan 10 18:30:47 2002
@@ -108,7 +108,13 @@
 #include "console_macros.h"
 
 
-const struct consw *conswitchp;
+// const struct consw *conswitchp;
+#ifdef CONFIG_DUMMY_CONSOLE
+const struct consw *conswitchp=&dummy_con;
+#else
+const struct consw *conswitchp=0;
+#endif
+
 
 /* A bitmap for codes <32. A bit of 1 indicates that the code
  * corresponding to that bit number invokes some special action
diff -Naur linux-2.4.2.orig/drivers/mtd/Config.in linux-2.4.2/drivers/mtd/Config.in
--- linux-2.4.2.orig/drivers/mtd/Config.in	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/Config.in	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 
-# $Id: No. :) $
+# $Id: Config.in,v 1.60 2001/03/26 20:08:57 kd Exp $
 
 mainmenu_option next_comment
 comment 'Memory Technology Devices (MTD)'
@@ -15,63 +15,121 @@
 comment 'Disk-On-Chip Device Drivers'
    dep_tristate '  M-Systems Disk-On-Chip 1000' CONFIG_MTD_DOC1000 $CONFIG_MTD
    dep_tristate '  M-Systems Disk-On-Chip 2000 and Millennium' CONFIG_MTD_DOC2000 $CONFIG_MTD
-   dep_tristate '  M-Systems Disk-On-Chip Millennium-only alternative driver' CONFIG_MTD_DOC2001 $CONFIG_MTD
+   dep_tristate '  M-Systems Disk-On-Chip Millennium-only alternative driver (see help)' CONFIG_MTD_DOC2001 $CONFIG_MTD
    if [ "$CONFIG_MTD_DOC2001" = "y" -o "$CONFIG_MTD_DOC2000" = "y" ]; then
-      define_tristate CONFIG_MTD_DOCPROBE y
+      define_bool CONFIG_MTD_DOCPROBE y
    else
       if [ "$CONFIG_MTD_DOC2001" = "m" -o "$CONFIG_MTD_DOC2000" = "m" ]; then
-	 define_tristate CONFIG_MTD_DOCPROBE m
+	 define_bool CONFIG_MTD_DOCPROBE m
       else
-	 define_tristate CONFIG_MTD_DOCPROBE n
+	 define_bool CONFIG_MTD_DOCPROBE n
       fi
    fi
+
    if [ "$CONFIG_MTD_DOCPROBE" = "y" -o "$CONFIG_MTD_DOCPROBE" = "m" ]; then
-      hex  '    Physical address of DiskOnChip' CONFIG_MTD_DOCPROBE_ADDRESS 0x0000
-      bool '    Probe high addresses' CONFIG_MTD_DOCPROBE_HIGH
-      bool '    Probe for 0x55 0xAA BIOS Extension Signature' CONFIG_MTD_DOCPROBE_55AA
+      bool '    Advanced detection options for DiskOnChip' CONFIG_MTD_DOCPROBE_ADVANCED
+      if [ "$CONFIG_MTD_DOCPROBE_ADVANCED" = "n" ]; then
+         define_hex CONFIG_MTD_DOCPROBE_ADDRESS 0
+         define_bool CONFIG_MTD_DOCPROBE_HIGH n
+         define_bool CONFIG_MTD_DOCPROBE_55AA n
+      else
+         hex  '    Physical address of DiskOnChip' CONFIG_MTD_DOCPROBE_ADDRESS 0x0000
+         bool '    Probe high addresses' CONFIG_MTD_DOCPROBE_HIGH
+         bool '    Probe for 0x55 0xAA BIOS Extension Signature' CONFIG_MTD_DOCPROBE_55AA
+      fi
    fi
 
 comment 'RAM/ROM Device Drivers'
-   dep_tristate '  Use extra onboard system memory as MTD device' CONFIG_MTD_SLRAM $CONFIG_MTD
-   dep_tristate '  Ramix PMC551 PCI Mezzanine ram card support' CONFIG_MTD_PMC551 $CONFIG_MTD $CONFIG_PCI
-   if [ "$CONFIG_MTD_PMC551" != "n" ]; then
+   dep_tristate '  Ramix PMC551 PCI Mezzanine RAM card support' CONFIG_MTD_PMC551 $CONFIG_MTD $CONFIG_PCI
+   if [ "$CONFIG_MTD_PMC551" = "y" -o  "$CONFIG_MTD_PMC551" = "m" ]; then
       bool '    PMC551 256M DRAM Bugfix' CONFIG_MTD_PMC551_BUGFIX
       bool '    PMC551 Debugging' CONFIG_MTD_PMC551_DEBUG
    fi
-   dep_tristate '  Debugging RAM test driver' CONFIG_MTD_MTDRAM $CONFIG_MTD
-   if [ "$CONFIG_MTD_MTDRAM" != "n" ]; then
+   dep_tristate '  Uncached system RAM' CONFIG_MTD_SLRAM $CONFIG_MTD
+   dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
+   dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
+   dep_tristate '  Test driver using RAM' CONFIG_MTD_MTDRAM $CONFIG_MTD
+   if [ "$CONFIG_MTD_MTDRAM" = "y" -o "$CONFIG_MTD_MTDRAM" = "m" ]; then
       int 'Device size in kB' CONFIG_MTDRAM_TOTAL_SIZE 4096
       int 'Size of the erase sectors in kB' CONFIG_MTDRAM_ERASE_SIZE 128
+      if [ "$CONFIG_MTD_MTDRAM" = "y" ]; then #If not a module (I don't want to test it as a module)
+         hex 'SRAM Hexadecimal Absolute position or 0' CONFIG_MTDRAM_ABS_POS 2000000
+      fi
    fi
 
 comment 'Linearly Mapped Flash Device Drivers'
    dep_tristate '  Common Flash Interface (CFI) support' CONFIG_MTD_CFI $CONFIG_MTD
-   dep_tristate '    CFI support for Intel/Sharp Extended Command Set chips' CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_CFI
-   dep_tristate '    CFI support for AMD/Fujitsu Standard Command Set chips' CONFIG_MTD_CFI_AMDSTD $CONFIG_MTD_CFI
-   dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
-   dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
-
-# These will later become config-options
-define_bool CONFIG_MTD_JEDEC n
-
-   dep_tristate '  Flash chip mapping in physical memory' CONFIG_MTD_PHYSMAP $CONFIG_MTD_CFI
+   if [ "$CONFIG_MTD_CFI" = "y" -o "$CONFIG_MTD_CFI" = "m" ]; then
+      bool '  CFI Advanced configuration options' CONFIG_MTD_CFI_ADV_OPTIONS
+   if [ "$CONFIG_MTD_CFI_ADV_OPTIONS" = "y" ]; then
+      choice 'Flash cmd, query swapping' \
+	" \
+	 NO		CONFIG_MTD_CFI_NOSWAP     \
+	 BIG_ENDIAN_BYTE        CONFIG_MTD_CFI_BE_BYTE_SWAP  \
+	 LITTLE_ENDIAN_BYTE        CONFIG_MTD_CFI_LE_BYTE_SWAP  \
+	 LART_ENDIAN_BIT	CONFIG_MTD_CFI_LART_BIT_SWAP"	NO
+      bool '  Specific CFI Flash geometry selection' CONFIG_MTD_CFI_GEOMETRY
+      if [ "$CONFIG_MTD_CFI_GEOMETRY" = "y" ]; then
+         bool '    Support  8-bit buswidth' CONFIG_MTD_CFI_B1
+         bool '    Support 16-bit buswidth' CONFIG_MTD_CFI_B2
+         bool '    Support 32-bit buswidth' CONFIG_MTD_CFI_B4
+         bool '    Support 1-chip flash interleave' CONFIG_MTD_CFI_I1
+         bool '    Support 2-chip flash interleave' CONFIG_MTD_CFI_I2
+         bool '    Support 4-chip flash interleave' CONFIG_MTD_CFI_I4
+      fi
+   fi
+   fi
+   dep_tristate '    CFI support for Intel/Sharp Extended Commands' CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_CFI
+   if [ "$CONFIG_MTD_CFI_INTELEXT" = "y" -o  "$CONFIG_MTD_CFI_INTELEXT" = "m" ]; then
+      bool '       CFI support for Intel/Sharp Standard Commands' CONFIG_MTD_CFI_INTELSTD
+   fi          
+   dep_tristate '    CFI support for AMD/Fujitsu Standard Commands' CONFIG_MTD_CFI_AMDSTD $CONFIG_MTD_CFI
+   dep_tristate '  AMD compatible flash chip support (non-CFI)' CONFIG_MTD_AMDSTD $CONFIG_MTD
+   dep_tristate '  pre-CFI Sharp chip support' CONFIG_MTD_SHARP $CONFIG_MTD
+   dep_tristate '  CFI Flash device in physical memory map' CONFIG_MTD_PHYSMAP $CONFIG_MTD_CFI
    if [ "$CONFIG_MTD_PHYSMAP" = "y" -o "$CONFIG_MTD_PHYSMAP" = "m" ]; then
-      hex '    Physical start location of flash chip mapping' CONFIG_MTD_PHYSMAP_START 0x8000000
-      hex '    Physical length of flash chip mapping' CONFIG_MTD_PHYSMAP_LEN 0x4000000
+      hex '    Physical start address of flash mapping' CONFIG_MTD_PHYSMAP_START 0x8000000
+      hex '    Physical length of flash mapping' CONFIG_MTD_PHYSMAP_LEN 0x4000000
       int '    Bus width in octets' CONFIG_MTD_PHYSMAP_BUSWIDTH 2
    fi
-
-comment 'Drivers for chip mappings'
-   dep_tristate '  Flash chip mapping on Mixcom piggyback card' CONFIG_MTD_MIXMEM $CONFIG_MTD_JEDEC
-   dep_tristate '  Flash chip mapping on Nora' CONFIG_MTD_NORA $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on Octagon 5066 SBC' CONFIG_MTD_OCTAGON $CONFIG_MTD_JEDEC
-   dep_tristate '  Flash chip mapping on Photron PNC-2000' CONFIG_MTD_PNC2000 $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on RPXLite PPC board' CONFIG_MTD_RPXLITE $CONFIG_MTD_CFI
-   dep_tristate '  Flash chip mapping on Tempustech VMAX SBC301' CONFIG_MTD_VMAX $CONFIG_MTD_JEDEC
-
-comment 'User modules and translation layers for MTD devices'
-   dep_tristate '  Direct chardevice access to MTD devices' CONFIG_MTD_CHAR $CONFIG_MTD
-   dep_tristate '  Caching blockdevice access to MTD devices' CONFIG_MTD_BLOCK $CONFIG_MTD
+   if [ "$ARCH" = "sparc64" ]; then
+	tristate '  Sun Microsystems userflash support' CONFIG_MTD_SUN_UFLASH
+   fi
+   dep_tristate '  CFI Flash device mapped on Nora' CONFIG_MTD_NORA $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on Photron PNC-2000' CONFIG_MTD_PNC2000 $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on RPX Lite or CLLF' CONFIG_MTD_RPXLITE $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on AMD SC520 CDP' CONFIG_MTD_SC520CDP $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapped on Nokia / Sagem D-Box2' CONFIG_MTD_DBOX2 $CONFIG_MTD_CFI $CONFIG_MTD_CFI_INTELSTD $CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_CFI_AMDSTD
+   dep_tristate '  CFI Flash device mapped on Arcom SBC-MediaGX' CONFIG_MTD_SBC_MEDIAGX $CONFIG_MTD_CFI_INTELEXT
+   dep_tristate '  CFI Flash device mapped on Arcom ELAN-104NC' CONFIG_MTD_ELAN_104NC $CONFIG_MTD_CFI_INTELEXT
+   dep_tristate '  CFI Flash device mapped on StrongARM SA11x0' CONFIG_MTD_SA1100 $CONFIG_MTD_CFI $CONFIG_ARCH_SA1100
+   if [ "$CONFIG_MTD_SA1100" != "n" ]; then
+      bool '    Support for RedBoot Partition tables on SA11x0' CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+   fi
+   dep_tristate '  CFI Flash device mapped on DC21285 Footbridge' CONFIG_MTD_DC21285 $CONFIG_MTD_CFI $CONFIG_ARCH_FOOTBRIDGE
+   dep_tristate '  CFI Flash device mapped on the XScale IQ80310 board' CONFIG_MTD_IQ80310 $CONFIG_MTD_CFI $CONFIG_XSCALE_IQ80310
+   dep_tristate '  CFI and JEDEC Flash device mapping on custom board' CONFIG_MTD_CSTM_CFI_JEDEC $CONFIG_MTD_CFI
+   dep_tristate '  CFI Flash device mapping on FlagaDM' CONFIG_MTD_CFI_FLAGADM $CONFIG_MTD_CFI
+   dep_tristate '  JEDEC device support' CONFIG_MTD_JEDEC $CONFIG_MTD
+   dep_tristate '  JEDEC Flash device mapped on Mixcom piggyback card' CONFIG_MTD_MIXMEM $CONFIG_MTD_JEDEC
+   dep_tristate '  JEDEC Flash device mapped on Octagon 5066 SBC' CONFIG_MTD_OCTAGON $CONFIG_MTD_JEDEC
+   dep_tristate '  JEDEC Flash device mapped on Tempustech VMAX SBC301' CONFIG_MTD_VMAX $CONFIG_MTD_JEDEC
+   dep_tristate '  ARM Firmware Suite Flash Layout' CONFIG_MTD_ARM $CONFIG_MTD_CFI $CONFIG_ARM
+
+comment 'NAND Flash Device Drivers'
+   dep_tristate '  NAND Device Support' CONFIG_MTD_NAND $CONFIG_MTD
+   if [ "$CONFIG_MTD_NAND" = "y" -o "$CONFIG_MTD_NAND" = "m" ]; then
+      bool '    Enable ECC correction algorithm'  CONFIG_MTD_NAND_ECC y
+      bool '    Verify NAND page writes' CONFIG_MTD_NAND_VERIFY_WRITE y
+   fi
+   dep_tristate '  NAND Flash device on SPIA board' CONFIG_MTD_NAND_SPIA $CONFIG_MTD_NAND
+
+comment 'User Modules And Translation Layers'
+   dep_tristate '  Direct char device access to MTD devices' CONFIG_MTD_CHAR $CONFIG_MTD
+   dep_tristate '  Caching block device access to MTD devices' CONFIG_MTD_BLOCK $CONFIG_MTD
+   if [ "$CONFIG_MTD_BLOCK" = "n" -o "$CONFIG_MTD_BLOCK" = "m" ]; then
+   	dep_tristate '  Readonly block device access to MTD devices' CONFIG_MTD_BLOCK_RO $CONFIG_MTD
+   fi
    dep_tristate '  FTL (Flash Translation Layer) support' CONFIG_FTL $CONFIG_MTD
    dep_tristate '  NFTL (NAND Flash Translation Layer) support' CONFIG_NFTL $CONFIG_MTD
    if [ "$CONFIG_NFTL" = "y" -o "$CONFIG_NFTL" = "m" ]; then
diff -Naur linux-2.4.2.orig/drivers/mtd/Makefile linux-2.4.2/drivers/mtd/Makefile
--- linux-2.4.2.orig/drivers/mtd/Makefile	Fri Dec 29 23:07:22 2000
+++ linux-2.4.2/drivers/mtd/Makefile	Thu Jan 10 18:30:47 2002
@@ -8,7 +8,35 @@
 # Note 2! The CFLAGS definitions are now inherited from the
 # parent makes..
 #
-# $Id: Makefile,v 1.22 2000/07/14 08:10:52 dwmw2 Exp $
+# $Id: Makefile,v 1.54 2001/03/26 20:08:57 kd Exp $
+
+ifndef CONFIG_MTD
+
+# We're being invoked outside a normal kernel build. Fake it
+EXTRA_CFLAGS= -I$(shell pwd)/../include
+CC += -I$(shell pwd)/../include
+
+MIX_OBJS = mtdcore.o doc2000.o doc2001.o cfi_probe.o cfi_jedec.o cfi_cmdset_0001.o \
+	map_ram.o map_rom.o cfi_cmdset_0002.o mtdpart.o
+
+MI_OBJS = docprobe.o slram.o pmc551.o mtdram.o physmap.o \
+	cstm_cfi_jedec.o nora.o octagon-5066.o pnc2000.o rpxlite.o \
+	vmax301.o mtdchar.o mtdblock.o mtdblock_ro.o ftl.o nftl.o \
+	sbc_mediagx.o elan-104nc.o docecc.o nftlmount.o sc520cdp.o \
+	redboot.o cfi_flagadm.o dbox2-flash.o
+
+obj-m := $(MIX_OBJS) $(MI_OBJS)
+
+CFLAGS_nftl.o := -DCONFIG_NFTL_RW
+CFLAGS_mtdram.o := -DCONFIG_MTDRAM_TOTAL_SIZE=4096 -DCONFIG_MTDRAM_ERASE_SIZE=128
+CFLAGS_physmap.o := -DCONFIG_MTD_PHYSMAP_START=0x8000000 -DCONFIG_MTD_PHYSMAP_LEN=0x4000000 -DCONFIG_MTD_PHYSMAP_BUSWIDTH=2
+
+else 
+
+O_OBJS          :=
+OX_OBJS         :=
+M_OBJS          :=
+MX_OBJS         :=
 
 # Object file lists.
 
@@ -21,9 +49,32 @@
 SUB_DIRS	:=
 ALL_SUB_DIRS 	:=
 MOD_SUB_DIRS	:=
+MOD_LIST_NAME	:= MTD_MODULES
+
+export-objs	:= mtdcore.o mtdpart.o nand.o redboot.o
+list-multi	:= nftlmod.o
 
-export-objs	:=	mtdcore.o mtdpart.o jedec.o
-list-multi	:=
+#                       *** BIG UGLY NOTE ***
+#
+# The shiny new inter_module_xxx has introduced yet another ugly link
+# order dependency, which I'd previously taken great care to avoid.
+# We now have to ensure that the chip drivers are initialised before the
+# map drivers, and that the doc200[01] drivers are initialised before
+# docprobe.
+#
+# We'll hopefully merge the doc200[01] drivers and docprobe back into
+# a single driver some time soon, but the CFI drivers are going to have
+# to stay like that.
+#
+# Urgh.
+# 
+# dwmw2 21/11/0
+
+ifeq ($(VERSION),2)
+ ifeq ($(PATCHLEVEL),0)
+   obj-y += initcalls.o
+  endif
+endif
 
 # MTD devices
 obj-$(CONFIG_MTD)		+= mtdcore.o
@@ -34,28 +85,72 @@
 obj-$(CONFIG_MTD_SLRAM)		+= slram.o
 obj-$(CONFIG_MTD_PMC551)	+= pmc551.o
 obj-$(CONFIG_MTD_MTDRAM)	+= mtdram.o
+obj-$(CONFIG_MTD_NAND)		+= nand.o
+obj-$(CONFIG_MTD_NAND_ECC)	+= nand_ecc.o
 
 # Chip drivers
 obj-$(CONFIG_MTD_JEDEC)		+= jedec.o
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
-obj-$(CONFIG_MTD_CFI)		+= cfi_probe.o
 obj-$(CONFIG_MTD_CFI_INTELEXT)	+= cfi_cmdset_0001.o
 obj-$(CONFIG_MTD_CFI_AMDSTD)	+= cfi_cmdset_0002.o
+obj-$(CONFIG_MTD_CFI)		+= cfi_probe.o cfi_jedec.o mtdpart.o
+obj-$(CONFIG_MTD_NAND_SPIA)	+= spia.o mtdpart.o
+obj-$(CONFIG_MTD_SHARP)		+= sharp.o
+obj-$(CONFIG_MTD_AMDSTD)	+= amd_flash.o 
 
 # Chip mappings
-obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o
+obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o 
+obj-$(CONFIG_MTD_CSTM_CFI_JEDEC) += cstm_cfi_jedec.o mtdpart.o
 obj-$(CONFIG_MTD_MIXMEM)	+= mixmem.o
 obj-$(CONFIG_MTD_NORA)		+= nora.o
 obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
 obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o mtdpart.o
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
 obj-$(CONFIG_MTD_VMAX)		+= vmax301.o
+obj-$(CONFIG_MTD_SC520CDP)	+= sc520cdp.o
+obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o mtdpart.o
+obj-$(CONFIG_MTD_SBC_MEDIAGX)   += sbc_mediagx.o mtdpart.o
+obj-$(CONFIG_MTD_ELAN_104NC)    += elan-104nc.o mtdpart.o
+obj-$(CONFIG_MTD_SA1100)        += sa1100-flash.o mtdpart.o
+obj-$(CONFIG_MTD_SA1100_REDBOOT_PARTITIONS) += redboot.o
+obj-$(CONFIG_MTD_DC21285)       += dc21285.o mtdpart.o
+obj-$(CONFIG_MTD_IQ80310)	+= iq80310.o mtdpart.o
+obj-$(CONFIG_MTD_SUN_UFLASH)    += sun_uflash.o
+obj-$(CONFIG_MTD_ARM)		+= armflash.o
+obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
 
 # Users
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
 obj-$(CONFIG_MTD_BLOCK)		+= mtdblock.o
+obj-$(CONFIG_MTD_BLOCK_RO)	+= mtdblock_ro.o
 obj-$(CONFIG_FTL)		+= ftl.o
 obj-$(CONFIG_NFTL)		+= nftl.o nftlmount.o
+
+# Extract lists of the multi-part drivers.
+# The 'int-*' lists are the intermediate files used to build the multi's.
+
+multi-y         := $(filter $(list-multi), $(obj-y))
+multi-m         := $(filter $(list-multi), $(obj-m))
+int-y           := $(sort $(foreach m, $(multi-y), $($(basename $(m))-objs)))
+int-m           := $(sort $(foreach m, $(multi-m), $($(basename $(m))-objs)))
+
+# Files that are both resident and modular: remove from modular.
+
+obj-m           := $(filter-out $(obj-y), $(obj-m))
+int-m           := $(filter-out $(int-y), $(int-m))
+
+# Take multi-part drivers out of obj-y and put components in.
+
+obj-y           := $(filter-out $(list-multi), $(obj-y)) $(int-y)
+
+# Translate to Rules.make lists.
+
+O_OBJS          := $(filter-out $(export-objs), $(obj-y))
+OX_OBJS         := $(filter     $(export-objs), $(obj-y))
+M_OBJS          := $(sort $(filter-out $(export-objs), $(obj-m)))
+MX_OBJS         := $(sort $(filter     $(export-objs), $(obj-m)))
+
+endif
 
 include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/drivers/mtd/amd_flash.c linux-2.4.2/drivers/mtd/amd_flash.c
--- linux-2.4.2.orig/drivers/mtd/amd_flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/amd_flash.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,1245 @@
+/*
+ * MTD map driver for AMD compatible flash chips (non-CFI)
+ *
+ * Author: Jonas Holmberg <jonas.holmberg@axis.com>
+ *
+ * $Id: amd_flash.c,v 1.4 2001/03/09 13:48:24 jonashg Exp $
+ *
+ * Copyright (c) 2001 Axis Communications AB
+ *
+ * This file is under GPL.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/delay.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+
+/* There's no limit. It exists only to avoid realloc. */
+#define MAX_AMD_CHIPS 8
+
+#define DEVICE_TYPE_X8	(8 / 8)
+#define DEVICE_TYPE_X16	(16 / 8)
+#define DEVICE_TYPE_X32	(32 / 8)
+
+/* Addresses */
+#define ADDR_MANUFACTURER		0x0000
+#define ADDR_DEVICE_ID			0x0001
+#define ADDR_UNLOCK_1			0x0555
+#define ADDR_UNLOCK_2			0x02AA
+
+/* Commands */
+#define CMD_UNLOCK_DATA_1		0x00AA
+#define CMD_UNLOCK_DATA_2		0x0055
+#define CMD_MANUFACTURER_UNLOCK_DATA	0x0090
+#define CMD_UNLOCK_BYPASS_MODE		0x0020
+#define CMD_PROGRAM_UNLOCK_DATA		0x00A0
+#define CMD_RESET_DATA			0x00F0
+#define CMD_SECTOR_ERASE_UNLOCK_DATA	0x0080
+#define CMD_SECTOR_ERASE_UNLOCK_DATA_2	0x0030
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+#define D6_MASK	0x40
+
+struct amd_flash_private {
+	int device_type;	
+	int interleave;	
+	int numchips;	
+	unsigned long chipshift;
+//	const char *im_name;
+	struct flchip chips[0];
+};
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+
+
+static int amd_flash_read(struct mtd_info *, loff_t, size_t, size_t *,
+			  u_char *);
+static int amd_flash_write(struct mtd_info *, loff_t, size_t, size_t *,
+			   const u_char *);
+static int amd_flash_erase(struct mtd_info *, struct erase_info *);
+static void amd_flash_sync(struct mtd_info *);
+static int amd_flash_suspend(struct mtd_info *);
+static void amd_flash_resume(struct mtd_info *);
+static void amd_flash_destroy(struct mtd_info *);
+
+
+
+static const char im_name[] = "amd_flash";
+
+
+
+static inline __u32 wide_read(struct map_info *map, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		return map->read8(map, addr);
+	} else if (map->buswidth == 2) {
+		return map->read16(map, addr);
+	} else if (map->buswidth == 4) {
+		return map->read32(map, addr);
+        }
+
+	return 0;
+}
+
+static inline void wide_write(struct map_info *map, __u32 val, __u32 addr)
+{
+	if (map->buswidth == 1) {
+		map->write8(map, val, addr);
+	} else if (map->buswidth == 2) {
+		map->write16(map, val, addr);
+	} else if (map->buswidth == 4) {
+		map->write32(map, val, addr);
+	}
+}
+
+static inline __u32 make_cmd(struct map_info *map, __u32 cmd)
+{
+	const struct amd_flash_private *private = map->fldrv_priv;
+	if ((private->interleave == 2) &&
+	    (private->device_type == DEVICE_TYPE_X16)) {
+		cmd |= (cmd << 16);
+	}
+
+	return cmd;
+}
+
+static inline void send_unlock(struct map_info *map, unsigned long base)
+{
+	wide_write(map, (CMD_UNLOCK_DATA_1 << 16) | CMD_UNLOCK_DATA_1,
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+	wide_write(map, (CMD_UNLOCK_DATA_2 << 16) | CMD_UNLOCK_DATA_2,
+		   base + (map->buswidth * ADDR_UNLOCK_2));
+}
+
+static inline void send_cmd(struct map_info *map, unsigned long base, __u32 cmd)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd),
+		   base + (map->buswidth * ADDR_UNLOCK_1));
+}
+
+static inline void send_cmd_to_addr(struct map_info *map, unsigned long base,
+				    __u32 cmd, unsigned long addr)
+{
+	send_unlock(map, base);
+	wide_write(map, make_cmd(map, cmd), addr);
+}
+
+static inline int flash_is_busy(struct map_info *map, unsigned long addr,
+				int interleave)
+{
+
+	if ((interleave == 2) && (map->buswidth == 4)) {
+		__u32 read1, read2;
+
+		read1 = wide_read(map, addr);
+		read2 = wide_read(map, addr);
+
+		return (((read1 >> 16) & D6_MASK) !=
+			((read2 >> 16) & D6_MASK)) ||
+		       (((read1 & 0xffff) & D6_MASK) !=
+			((read2 & 0xffff) & D6_MASK));
+	}
+
+	return ((wide_read(map, addr) & D6_MASK) !=
+		(wide_read(map, addr) & D6_MASK));
+}
+
+
+
+/*
+ * Reads JEDEC manufacturer ID and device ID and returns the index of the first
+ * matching table entry (-1 if not found or alias for already found chip).
+ */ 
+static int probe_new_chip(struct mtd_info *mtd, unsigned long base,
+			  struct flchip *chips,
+			  struct amd_flash_private *private,
+			  const struct amd_flash_info *table, int table_size)
+{
+	__u32 mfr_id, dev_id;
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private temp;
+	int i;
+
+	temp.device_type = DEVICE_TYPE_X16;	// Assume X16 (FIXME)
+	temp.interleave = 2;
+	map->fldrv_priv = &temp;
+
+	/* Enter autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+	send_cmd(map, base, CMD_MANUFACTURER_UNLOCK_DATA);
+
+	mfr_id = wide_read(map, base + (map->buswidth * ADDR_MANUFACTURER));
+	dev_id = wide_read(map, base + (map->buswidth * ADDR_DEVICE_ID));
+
+	if ((map->buswidth == 4) && ((mfr_id >> 16) == (mfr_id & 0xffff)) &&
+	    ((dev_id >> 16) == (dev_id & 0xffff))) {
+		mfr_id = mfr_id & 0xffff;
+		dev_id = dev_id & 0xffff;
+	} else {
+		temp.interleave = 1;
+	}
+
+	for (i = 0; i < table_size; i++) {
+		if ((mfr_id == table[i].mfr_id) &&
+		    (dev_id == table[i].dev_id)) {
+			if (chips) {
+				int j;
+
+				/* Is this an alias for an already found chip?
+				 * In that case that chip should be in
+				 * autoselect mode now.
+				 */
+				for (j = 0; j < private->numchips; j++) {
+					if ((wide_read(map, chips[j].start +
+							    (map->buswidth *
+							     ADDR_MANUFACTURER))
+					     == mfr_id)
+					    &&
+					    (wide_read(map, chips[j].start +
+					    		    (map->buswidth *
+							     ADDR_DEVICE_ID))
+					     == dev_id)) {
+
+						/* Exit autoselect mode. */
+						send_cmd(map, base,
+							 CMD_RESET_DATA);
+
+						return -1;
+					}
+				}
+
+				if (private->numchips == MAX_AMD_CHIPS) {
+					printk(KERN_WARNING
+					       "%s: Too many flash chips "
+					       "detected. Increase "
+					       "MAX_AMD_CHIPS from %d.\n",
+					       map->name, MAX_AMD_CHIPS);
+
+					return -1;
+				}
+
+				chips[private->numchips].start = base;
+				chips[private->numchips].state = FL_READY;
+				chips[private->numchips].mutex =
+					&chips[private->numchips]._spinlock;
+				private->numchips++;
+			}
+
+			printk("%s: Found %d x %ldMb %s at 0x%x\n", map->name,
+			       temp.interleave, (table[i].size*8)/(1024*1024),
+			       table[i].name, base);
+
+			mtd->size += table[i].size * temp.interleave;
+			mtd->numeraseregions += table[i].numeraseregions;
+
+			break;
+		}
+	}
+
+	/* Exit autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+
+	if (i == table_size) {
+		printk(KERN_DEBUG "%s: unknown flash device at 0x%x, "
+		       "mfr id 0x%x, dev id 0x%x\n", map->name,
+		       base, mfr_id, dev_id);
+		map->fldrv_priv = NULL;
+
+		return -1;
+	}
+
+	private->device_type = temp.device_type;
+	private->interleave = temp.interleave;
+
+	return i;
+}
+
+
+
+struct mtd_info *amd_flash_probe(struct map_info *map)
+{
+	/* Keep this table on the stack so that it gets deallocated after the
+	 * probe is done.
+	 */
+	const struct amd_flash_info table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		size: 0x00100000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 15 },
+			{ offset: 0x0F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x0F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x0FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x10000, numblocks: 31 },
+			{ offset: 0x1F0000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x1F8000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x1FC000, erasesize: 0x04000, numblocks:  1 }
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		size: 0x00200000,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	} 
+	};
+
+	struct mtd_info *mtd;
+	struct flchip chips[MAX_AMD_CHIPS];
+	int table_pos[MAX_AMD_CHIPS];
+	struct amd_flash_private temp;
+	struct amd_flash_private *private;
+	u_long size;
+	unsigned long base;
+	int i;
+	int reg_idx;
+	int offset;
+
+	mtd = (struct mtd_info*)kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for info structure\n", map->name);
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+
+	memset(&temp, 0, sizeof(temp));
+
+	printk("%s: Probing for AMD compatible flash...\n", map->name);
+
+	if ((table_pos[0] = probe_new_chip(mtd, 0, NULL, &temp, table,
+					   sizeof(table)/sizeof(table[0])))
+	    == -1) {
+		printk(KERN_WARNING
+		       "%s: Found no AMD compatible device at location zero\n",
+		       map->name);
+		kfree(mtd);
+
+		return NULL;
+	}
+
+	chips[0].start = 0;
+	chips[0].state = FL_READY;
+	chips[0].mutex = &chips[0]._spinlock;
+	temp.numchips = 1;
+	for (size = mtd->size; size > 1; size >>= 1) {
+		temp.chipshift++;
+	}
+	switch (temp.interleave) {
+		case 2:
+			temp.chipshift += 1;
+			break;
+		case 4:
+			temp.chipshift += 2;
+			break;
+	}
+
+	/* Find out if there are any more chips in the map. */
+	for (base = (1 << temp.chipshift);
+	     base < map->size;
+	     base += (1 << temp.chipshift)) {
+	     	int numchips = temp.numchips;
+		table_pos[numchips] = probe_new_chip(mtd, base, chips,
+			&temp, table, sizeof(table)/sizeof(table[0]));
+	}
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+				    mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+		printk(KERN_WARNING "%s: Failed to allocate "
+		       "memory for MTD erase region info\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return 0;
+	}
+
+	reg_idx = 0;
+	offset = 0;
+	for (i = 0; i < temp.numchips; i++) {
+		int dev_size;
+		int j;
+
+		dev_size = 0;
+		for (j = 0; j < table[table_pos[i]].numeraseregions; j++) {
+			mtd->eraseregions[reg_idx].offset = offset +
+				(table[table_pos[i]].regions[j].offset *
+				 temp.interleave);
+			mtd->eraseregions[reg_idx].erasesize =
+				table[table_pos[i]].regions[j].erasesize *
+				temp.interleave;
+			mtd->eraseregions[reg_idx].numblocks =
+				table[table_pos[i]].regions[j].numblocks;
+			if (mtd->erasesize <
+			    mtd->eraseregions[reg_idx].erasesize) {
+				mtd->erasesize =
+					mtd->eraseregions[reg_idx].erasesize;
+			}
+			dev_size += mtd->eraseregions[reg_idx].erasesize *
+				    mtd->eraseregions[reg_idx].numblocks;
+			reg_idx++;
+		}
+		offset += dev_size;
+	}
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+	mtd->erase = amd_flash_erase;	
+	mtd->read = amd_flash_read;	
+	mtd->write = amd_flash_write;	
+	mtd->sync = amd_flash_sync;	
+	mtd->suspend = amd_flash_suspend;	
+	mtd->resume = amd_flash_resume;	
+	map->fldrv_destroy = amd_flash_destroy;
+
+	private = kmalloc(sizeof(*private) + (sizeof(struct flchip) *
+					      temp.numchips), GFP_KERNEL);
+	if (!private) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for private structure\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return NULL;
+	}
+	memcpy(private, &temp, sizeof(temp));
+	memcpy(private->chips, chips,
+	       sizeof(struct flchip) * private->numchips);
+	for (i = 0; i < private->numchips; i++) {
+		init_waitqueue_head(&private->chips[i].wq);
+		spin_lock_init(&private->chips[i]._spinlock);
+	}
+
+	map->fldrv_priv = private;
+
+	return mtd;
+}
+
+
+
+static inline int read_one_chip(struct map_info *map, struct flchip *chip,
+			       loff_t adr, size_t len, u_char *buf)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = jiffies + HZ;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk(KERN_INFO "%s: waiting for chip to read, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	adr += chip->start;
+
+	chip->state = FL_READY;
+
+	map->copy_from(map, buf, adr, len);
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long ofs;
+	int chipnum;
+	int ret = 0;
+
+	if ((from + len) > mtd->size) {
+		printk(KERN_WARNING "%s: read request past end of device "
+		       "(0x%x)\n", map->name, from + len);
+
+		return -EINVAL;
+	}
+
+	/* Offset within the first chip that the first read should start. */
+	chipnum = (from >> private->chipshift);
+	ofs = from - (chipnum <<  private->chipshift);
+
+	*retlen = 0;
+
+	while (len) {
+		unsigned long this_len;
+
+		if (chipnum >= private->numchips) {
+			break;
+		}
+
+		if ((len + ofs - 1) >> private->chipshift) {
+			this_len = (1 << private->chipshift) - ofs;
+		} else {
+			this_len = len;
+		}
+
+		ret = read_one_chip(map, &private->chips[chipnum], ofs,
+				    this_len, buf);
+		if (ret) {
+			break;
+		}
+
+		*retlen += this_len;
+		len -= this_len;
+		buf += this_len;
+
+		ofs = 0;
+		chipnum++;
+	}
+
+	return ret;
+}
+
+
+
+static int write_one_word(struct map_info *map, struct flchip *chip,
+			  unsigned long adr, __u32 datum)
+{
+	unsigned long timeo = jiffies + HZ;
+	unsigned int Last[4];
+	unsigned long Count = 0;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+	int times_left;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		printk("%s: waiting for chip to write, state = %d\n",
+		       map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		printk(KERN_INFO "%s: woke up to write\n", map->name);
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_WRITING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_PROGRAM_UNLOCK_DATA);
+	wide_write(map, datum, adr);
+
+	times_left = 500000;
+	while (times_left-- && flash_is_busy(map, chip->start,
+					     private->interleave)) {
+		if (current->need_resched) {
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			spin_lock_bh(chip->mutex);
+		}
+	}
+
+	if (!times_left) {
+		printk(KERN_WARNING "%s: write to 0x%x timed out!\n",
+		       map->name, adr);
+		ret = -EIO;
+	} else {
+		__u32 verify;
+		if ((verify = wide_read(map, adr)) != datum) {
+			printk(KERN_WARNING "%s: write to 0x%x failed. "
+			       "datum = %x, verify = %x\n",
+			       map->name, adr, datum, verify);
+			ret = -EIO;
+		}
+	}
+
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return ret;
+}
+
+
+
+static int amd_flash_write(struct mtd_info *mtd, loff_t to , size_t len,
+			   size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
+	unsigned long chipstart;
+
+	*retlen = 0;
+	if (!len) {
+		return 0;
+	}
+
+	chipnum = to >> private->chipshift;
+	ofs = to  - (chipnum << private->chipshift);
+	chipstart = private->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write. */
+	if (ofs & (map->buswidth - 1)) {
+		unsigned long bus_ofs = ofs & ~(map->buswidth - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       bus_ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len && i < map->buswidth)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], bus_ofs,
+				     datum);
+		if (ret) {
+			return ret;
+		}
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+		}
+	}
+	
+	/* We are now aligned, write as much as possible. */
+	while(len >= map->buswidth) {
+		__u32 datum;
+
+		if (map->buswidth == 1) {
+			datum = *(__u8*)buf;
+		} else if (map->buswidth == 2) {
+			datum = *(__u16*)buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+
+		ofs += map->buswidth;
+		buf += map->buswidth;
+		(*retlen) += map->buswidth;
+		len -= map->buswidth;
+
+		if (ofs >> private->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == private->numchips) {
+				return 0;
+			}
+			chipstart = private->chips[chipnum].start;
+		}
+	}
+
+	if (len & (map->buswidth - 1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[2];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf,
+			       ofs + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len--) {
+			tmp_buf[i++] = buf[n++];
+		}
+
+		if (map->buswidth == 2) {
+			datum = *(__u16*)tmp_buf;
+		} else if (map->buswidth == 4) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = write_one_word(map, &private->chips[chipnum], ofs, datum);
+
+		if (ret) {
+			return ret;
+		}
+		
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+
+
+static inline int erase_one_block(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, u_long size)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct amd_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY){
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+                
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current)) {
+			return -EINTR;
+		}
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}	
+
+	chip->state = FL_ERASING;
+
+	adr += chip->start;
+	ENABLE_VPP(map);
+	send_cmd(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA);
+	send_cmd_to_addr(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA_2, adr);
+	
+	timeo = jiffies + (HZ * 20);
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+	
+	while (flash_is_busy(map, chip->start, private->interleave)) {
+
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_INFO "%s: erase suspended. Sleeping\n",
+			       map->name);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			
+			if (signal_pending(current)) {
+				return -EINTR;
+			}
+			
+			timeo = jiffies + (HZ*2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING "%s: waiting for erase to complete "
+			       "timed out.\n", map->name);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+
+		if (current->need_resched)
+			schedule();
+		else
+			udelay(1);
+		
+		spin_lock_bh(chip->mutex);
+	}
+
+	/* Verify every single word */
+	{
+		int address;
+		int error = 0;
+		__u8 verify;
+
+		for (address = adr; address < (adr + size); address++) {
+			if ((verify = map->read8(map, address)) != 0xFF) {
+				error = 1;
+				break;
+			}
+		}
+		if (error) {
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING
+			       "%s: verify error at 0x%x, size %ld.\n",
+			       map->name, address, size);
+			DISABLE_VPP(map);
+
+			return -EIO;
+		}
+	}
+	
+	DISABLE_VPP(map);
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+
+
+static int amd_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum;
+	int ret = 0;
+	int i;
+	int first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size) {
+		return -EINVAL;
+	}
+
+	if ((instr->len + instr->addr) > mtd->size) {
+		return -EINVAL;
+	}
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+        /* Skip all erase regions which are ended before the start of
+           the requested erase. Actually, to save on the calculations,
+           we skip to the first erase region which starts after the
+           start of the requested erase, and then go back one.
+        */
+
+        while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset)) {
+               i++;
+	}
+        i--;
+
+	/* OK, now i is pointing at the erase region in which this
+	 * erase request starts. Check the start of the requested
+	 * erase range is aligned with the erase size which is in
+	 * effect here.
+	 */
+
+	if (instr->addr & (regions[i].erasesize-1)) {
+		return -EINVAL;
+	}
+
+	/* Remember the erase region we start on. */
+
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while ((i < mtd->numeraseregions) && 
+	       ((instr->addr + instr->len) >= regions[i].offset)) {
+                i++;
+	}
+
+	/* As before, drop back one to point at the region in which
+	 * the address actually falls.
+	 */
+
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1)) {
+                return -EINVAL;
+	}
+
+	chipnum = instr->addr >> private->chipshift;
+	adr = instr->addr - (chipnum << private->chipshift);
+	len = instr->len;
+
+	i = first;
+
+	while (len) {
+		ret = erase_one_block(map, &private->chips[chipnum], adr,
+				      regions[i].erasesize);
+
+		if (ret) {
+			return ret;
+		}
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if ((adr % (1 << private->chipshift)) ==
+		    ((regions[i].offset + (regions[i].erasesize *
+		    			   regions[i].numblocks))
+		     % (1 << private->chipshift))) {
+			i++;
+		}
+
+		if (adr >> private->chipshift) {
+			adr = 0;
+			chipnum++;
+			if (chipnum >= private->numchips) {
+				break;
+			}
+		}
+	}
+		
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback) {
+		instr->callback(instr);
+	}
+	
+	return 0;
+}
+
+
+
+static void amd_flash_sync(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i = 0; !ret && (i < private->numchips); i++) {
+		chip = &private->chips[i];
+
+	retry:
+		spin_lock_bh(chip->mutex);
+
+		switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+			/* No need to wake_up() on this state change - 
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_SYNCING:
+			spin_unlock_bh(chip->mutex);
+			break;
+
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+			
+			spin_unlock_bh(chip->mutex);
+
+			schedule();
+
+		        remove_wait_queue(&chip->wq, &wait);
+			
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+	for (i--; i >= 0; i--) {
+		chip = &private->chips[i];
+
+		spin_lock_bh(chip->mutex);
+		
+		if (chip->state == FL_SYNCING) {
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+
+
+static int amd_flash_suspend(struct mtd_info *mtd)
+{
+printk("amd_flash_suspend(): not implemented!\n");
+	return -EINVAL;
+}
+
+
+
+static void amd_flash_resume(struct mtd_info *mtd)
+{
+printk("amd_flash_resume(): not implemented!\n");
+}
+
+
+
+static void amd_flash_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct amd_flash_private *private = map->fldrv_priv;
+	kfree(private);
+}
+
+
+
+int __init amd_flash_init(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &amd_flash_probe);
+
+	return 0;
+}
+
+void __exit amd_flash_exit(void)
+{
+	inter_module_unregister(im_name);
+}
+
+module_init(amd_flash_init);
+module_exit(amd_flash_exit);
diff -Naur linux-2.4.2.orig/drivers/mtd/armflash.c linux-2.4.2/drivers/mtd/armflash.c
--- linux-2.4.2.orig/drivers/mtd/armflash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/armflash.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,520 @@
+/*======================================================================
+
+    drivers/mtd/armflash.c: ARM Flash Layout/Partitioning
+  
+    Copyright (C) 2000 ARM Limited
+ 
+   $Id: armflash.c,v 1.2 2001/03/26 17:47:27 dwmw2 Exp $
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+  
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+  
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  
+   This is access code for flashes using ARM's flash partitioning 
+   standards.
+
+   NOTES:  The write stuff is completely board specific and I don't think
+   that this is the right thing to do.	 Better would be to use the
+   CFI stuff.
+
+======================================================================*/
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/malloc.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/iflash.h>
+#include <linux/mtd/map.h>
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+#include <asm/arch/bits.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/platform.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#define AFS_DEBUG 0
+#define AFS_DEBUG_RW 0
+
+/* data structures */
+struct footer_struct {
+	void *infoBase;			/* Address of first word of ImageFooter  */
+	char *blockBase;		/* Start of area reserved by this footer */
+	unsigned int signature;		/* 'Magic' number proves it's a footer   */
+	unsigned int type;		/* Area type: ARM Image, SIB, customer   */
+	unsigned int checksum;		/* Just this structure                   */
+};
+
+struct image_info_struct {
+	unsigned int bootFlags;		/* Boot flags, compression etc.          */
+	unsigned int imageNumber;	/* Unique number, selects for boot etc.  */
+	char *loadAddress;		/* Address program should be loaded to   */
+	unsigned int length;		/* Actual size of image                  */
+	unsigned int address;		/* Image is executed from here           */
+	char name[16];			/* Null terminated                       */
+	char *headerBase;		/* Flash Address of any stripped header  */
+	unsigned int header_length;	/* Length of header in memory            */
+	unsigned int headerType;	/* AIF, RLF, s-record etc.               */
+	unsigned int checksum;		/* Image checksum (inc. this struct)     */
+};
+
+struct afs_info {
+	struct afs_info *next;		/* next in list                          */
+	struct mtd_info *mtd;		/* Owning mtd_info block                 */
+	struct mtd_info *dev_mtd;	/* Device MTD                            */
+	u_int base;			/* offset                                */
+	char *name;			/* Name of thing (set by AFU)            */
+};
+
+// board specific stuff - sorry, it should be in arch/arm/mach-*.
+#ifdef CONFIG_ARCH_INTEGRATOR
+
+#define FLASH_BASE	INTEGRATOR_FLASH_BASE
+#define FLASH_SIZE	INTEGRATOR_FLASH_SIZE
+
+#define FLASH_PART_SIZE 0x400000
+
+static void afs_flash_unlock(void)
+{
+	volatile unsigned int *sc_ctrlc = (unsigned int *) (IO_ADDRESS(INTEGRATOR_SC_BASE) +
+					     INTEGRATOR_SC_CTRLC_OFFSET);
+	volatile unsigned int *ebi_csr1 = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_CSR1_OFFSET);
+#if AFS_DEBUG
+	printk("AFS Flash: Debug: unlocking flash\n");
+#endif
+
+	// Set the write enable bit in system controller EBI register.
+	*ebi_csr1 |= INTEGRATOR_EBI_WRITE_ENABLE;
+	if (!(*ebi_csr1 & INTEGRATOR_EBI_WRITE_ENABLE)) {
+		volatile unsigned int *ebi_lock = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_LOCK_OFFSET);
+
+		*ebi_lock = 0xA05F;
+		*ebi_csr1 |= INTEGRATOR_EBI_WRITE_ENABLE;
+		*ebi_lock = 0;
+	}
+	// Set the Flash programming bits in the system controller.
+	*sc_ctrlc |= INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP;
+}
+
+static void afs_flash_lock(void)
+{
+	volatile unsigned int *sc_ctrls = (unsigned int *) (IO_ADDRESS(INTEGRATOR_SC_BASE) +
+					     INTEGRATOR_SC_CTRLS_OFFSET);
+	volatile unsigned int *ebi_csr1 = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_CSR1_OFFSET);
+
+#if AFS_DEBUG
+	printk("AFS Flash: Debug: locking flash\n");
+#endif
+
+	// Clear the write enable bit in system controller EBI register.
+	*ebi_csr1 &= ~INTEGRATOR_EBI_WRITE_ENABLE;
+	if (*ebi_csr1 & INTEGRATOR_EBI_WRITE_ENABLE) {
+		volatile unsigned int *ebi_lock = (unsigned int *) (IO_ADDRESS(INTEGRATOR_EBI_BASE) +
+					     INTEGRATOR_EBI_LOCK_OFFSET);
+
+		*ebi_lock = 0xA05F;
+		*ebi_csr1 &= ~INTEGRATOR_EBI_WRITE_ENABLE;
+		*ebi_lock = 0;
+	}
+	// Clear the Flash programming bits in the system controller.
+	*sc_ctrls |= INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP;
+}
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+
+#define FLASH_BASE		(0x04000000)
+#define FLASH_SIZE		(64*1024*1024)
+
+#define FLASH_PART_SIZE 	(4*1024*1024)
+#define FLASH_BLOCK_SIZE	(128*1024)
+
+static void afs_flash_unlock(void)
+{
+}
+
+static void afs_flash_lock(void)
+{
+}
+#endif
+
+// AFS flash partitioning 
+static int afs_flash_suspend(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	u_int status = 0;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_suspend() called\n");
+#endif
+
+	if (afs->dev_mtd->suspend)
+		status = afs->dev_mtd->suspend(afs->dev_mtd);
+
+	return status;
+}
+
+static void afs_flash_resume(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_resume() called\n");
+#endif
+
+	if (afs->dev_mtd->resume)
+		afs->dev_mtd->resume(afs->dev_mtd);
+}
+
+static void afs_flash_sync(struct mtd_info *mtd)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+
+#if AFS_DEBUG
+	printk("AFS FLash: afs_flash_sync() called\n");
+#endif
+
+	afs->dev_mtd->sync(afs->dev_mtd);
+}
+
+static void afs_erase_callback(struct erase_info *ei)
+{
+	struct erase_info *eii = (struct erase_info *) ei->priv;
+
+	if (eii->callback)
+		eii->callback(eii);
+}
+
+static int afs_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	struct erase_info ei = *instr;
+	u_int status;
+
+	ei.mtd = afs->dev_mtd;
+	ei.addr = afs->base + instr->addr;
+	ei.callback = afs_erase_callback;
+	ei.priv = (u_long) instr;
+	ei.next = NULL;
+
+	status = afs->dev_mtd->erase(afs->dev_mtd, &ei);
+
+	return status;
+}
+
+static int afs_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	int ret;
+
+	from += afs->base;
+
+	afs_flash_unlock();
+	ret = afs->dev_mtd->read(afs->dev_mtd, from, len, retlen, buf);
+	afs_flash_lock();
+
+	return ret;
+}
+
+
+static int afs_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf)
+{
+	struct afs_info *afs = (struct afs_info *) mtd->priv;
+	int ret;
+
+	to += afs->base;
+
+//	afs_flash_unlock();
+	ret = afs->dev_mtd->write(afs->dev_mtd, to, len, retlen, buf);
+//	afs_flash_lock();
+
+	return ret;
+}
+
+static __u8 afs_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 val = readb(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read8(0x%06lx) = 0x%02x\n", ofs, val);
+#endif
+	return val;
+}
+
+static __u16 afs_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 val = readw(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read16(0x%06lx) = 0x%04x\n", ofs, val);
+#endif
+	return val;
+}
+
+static __u32 afs_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 val = readl(ofs + map->map_priv_2);
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_read32(0x%06lx) = 0x%08x\n", ofs, val);
+#endif
+	return val;
+}
+
+static void afs_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_copy_from(0x%p, 0x%lx, %d)\n", to, from, len);
+#endif
+	memcpy(to, (void *) (from + map->map_priv_2), len);
+}
+
+static void afs_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write8(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writeb(d, adr + map->map_priv_2);
+}
+
+static void afs_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write16(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writew(d, adr + map->map_priv_2);
+}
+
+static void afs_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_write32(0x%x, 0x%lx)\n", d, adr);
+#endif
+	writel(d, adr + map->map_priv_2);
+}
+
+static void afs_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+#if  AFS_DEBUG_RW
+	printk("AFS Flash (debug): afs_copy_to(0x%lx, 0x%px, %d)\n", to, from, len);
+#endif
+	memcpy((void *) (to + map->map_priv_2), from, len);
+}
+
+static struct map_info afs_map =
+{
+	name:		"AFS",
+	read8:		afs_read8,
+	read16:		afs_read16,
+	read32:		afs_read32,
+	copy_from:	afs_copy_from,
+	write8:		afs_write8,
+	write16:	afs_write16,
+	write32:	afs_write32,
+	copy_to:	afs_copy_to,
+};
+
+static int __init afs_cfi_init(u_int base, u_int size)
+{
+	struct mtd_info *mtd;
+	u_int mask, off, idx;
+
+	/*
+	 * look for CFI based flash parts fitted to this board
+	 */
+	afs_map.size       = size;
+	afs_map.buswidth   = 4;
+	afs_map.map_priv_1 = 0;
+	afs_map.map_priv_2 = (unsigned long) base;
+
+	/*
+	 * Also, the CFI layer automatically works out what size
+	 * of chips we have, and does the necessary identification
+	 * for us automatically.
+	 *
+	 * Note that we don't want to keep the flash unlocked for
+	 * more time than necessary.
+	 */
+	afs_flash_unlock();
+	mtd = do_cfi_probe(&afs_map);
+	afs_flash_lock();
+
+	if (!mtd)
+		return -ENODEV;
+
+	mtd->module = THIS_MODULE;
+
+	/*
+	 * This is the address mask; we use this to mask off out of
+	 * range address bits.
+	 */
+	mask = afs_map.size - 1;
+
+	/*
+	 * Identify the partitions
+	 */
+	for (idx = off = 0; off < mtd->size; off += FLASH_BLOCK_SIZE) {
+		struct afs_info *afs_part;
+		struct mtd_info *my_mtd;
+		struct footer_struct fs;
+		struct image_info_struct iis;
+		u_int ptr, length;
+		size_t sz;
+		int ret;
+
+		/*
+		 * Read the footer
+		 */
+		afs_flash_unlock();
+		ret = mtd->read(mtd, off + FLASH_BLOCK_SIZE - sizeof(fs),
+				sizeof(fs), &sz, (u_char *) &fs);
+		afs_flash_lock();
+
+		if (ret) {
+			printk(KERN_ERR "error reading flash at offset 0x%x: %d\n",
+				off + FLASH_BLOCK_SIZE - sizeof(fs), ret);
+			break;
+		}
+
+		/*
+		 * Does it contain the magic number?
+		 */
+		if (fs.signature != 0xa0ffff9f)
+			continue;
+
+		/*
+		 * Read the image info block
+		 */
+		ptr = (u_int) fs.infoBase & mask;
+		if (ptr >= mtd->size)
+			continue;
+
+		memset(&iis, 0, sizeof(iis));
+		if (ptr) {
+			afs_flash_unlock();
+			ret = mtd->read(mtd, ptr, sizeof(iis), &sz, (u_char *) &iis);
+			afs_flash_lock();
+		}
+
+		if (ret) {
+			printk(KERN_ERR "error reading flash at offset 0x%x: %d\n",
+				ptr, ret);
+			break;
+		}
+
+		ptr = (u_int) fs.blockBase & mask;
+		if (ptr > mtd->size || ptr > off)
+			continue;
+
+		length = FLASH_BLOCK_SIZE + off - ptr;
+
+		afs_part = kmalloc(sizeof(struct afs_info) +
+				   sizeof(struct mtd_info) + 16,
+				   GFP_KERNEL);
+		if (!afs_part)
+			return -ENOMEM;
+
+		memset(afs_part, 0, sizeof(struct afs_info) + sizeof(struct mtd_info));
+
+		my_mtd = (struct mtd_info *) (afs_part + 1);
+
+		afs_part->dev_mtd = mtd;
+		afs_part->base    = ptr;
+		afs_part->mtd     = my_mtd;
+		afs_part->name    = (char *) (my_mtd + 1);
+
+		my_mtd->type      = mtd->type;
+		my_mtd->flags     = mtd->flags;
+		my_mtd->size      = length;
+		my_mtd->erasesize = mtd->erasesize;
+		my_mtd->oobblock  = mtd->oobblock;
+		my_mtd->oobsize   = mtd->oobsize;
+		my_mtd->ecctype   = mtd->ecctype;
+		my_mtd->eccsize   = mtd->eccsize;
+		my_mtd->name      = "ARM Firmware Suite, Flash Partition";
+		my_mtd->bank_size = mtd->bank_size;
+		my_mtd->module    = THIS_MODULE;
+		my_mtd->erase     = afs_flash_erase;
+		my_mtd->point     = NULL;
+		my_mtd->unpoint   = NULL;
+		my_mtd->read      = afs_flash_read;
+		my_mtd->write     = afs_flash_write;
+		my_mtd->read_ecc  = mtd->read_ecc;
+		my_mtd->write_ecc = mtd->write_ecc;
+		my_mtd->read_oob  = mtd->read_oob;
+		my_mtd->write_oob = mtd->write_oob;
+		my_mtd->sync      = afs_flash_sync;
+		my_mtd->suspend   = afs_flash_suspend;
+		my_mtd->resume    = afs_flash_resume;
+		my_mtd->priv      = afs_part;
+
+		memcpy(afs_part->name, iis.name, 16);
+
+		if (add_mtd_device(afs_part->mtd)) {
+			printk(KERN_ERR "AFS: MTD device registration failed!\n");
+			kfree(afs_part);
+			return -EAGAIN;
+		}
+		printk("  mtd%d: at 0x%08x, %5dKB, %8d, %s\n",
+		     idx, ptr, length / 1024, iis.imageNumber, iis.name);
+
+		idx += 1;
+	}
+
+	return 0;
+}
+
+#if defined (MODULE) && LINUX_VERSION_CODE < 0x20300
+#define init_armflash init_module
+#define cleanup_armflash cleanup_module
+#endif
+
+int __init init_armflash(void)
+{
+	unsigned int flash_base;
+
+	printk("ARM Flash Layout (V1.0)\n");
+
+	flash_base = (unsigned int)__ioremap(FLASH_BASE, FLASH_SIZE, 0);
+	return afs_cfi_init(flash_base, FLASH_SIZE);
+}
+
+static void __init cleanup_armflash(void)
+{
+	afs_flash_lock();
+	iounmap((void *)afs_map.map_priv_2);
+}
+
+#if LINUX_VERSION_CODE > 0x20300
+module_init(init_armflash);
+module_exit(cleanup_armflash);
+#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0001.c linux-2.4.2/drivers/mtd/cfi_cmdset_0001.c
--- linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0001.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_cmdset_0001.c	Thu Jan 10 18:30:47 2002
@@ -4,7 +4,15 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0001.c,v 1.21 2000/07/13 10:36:14 dwmw2 Exp $
+ * $Id: cfi_cmdset_0001.c,v 1.72 2001/03/26 13:51:15 kd Exp $
+ *
+ * 
+ * 10/10/2000	Nicolas Pitre <nico@cam.org>
+ * 	- completely revamped method functions so they are aware and
+ * 	  independent of the flash geometry (buswidth, interleave, etc.)
+ * 	- scalability vs code size is completely set at compile-time
+ * 	  (see include/linux/mtd/cfi.h for selection)
+ *	- optimized write buffer method
  */
 
 #include <linux/module.h>
@@ -15,29 +23,32 @@
 #include <asm/byteorder.h>
 
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/delay.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
+#include <linux/mtd/compatmac.h>
 
-#if LINUX_VERSION_CODE < 0x20300
-#define set_current_state(x) current->state = (x);
-#endif
-static int cfi_intelext_read_1_by_16 (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-static int cfi_intelext_write_1_by_16(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
-static int cfi_intelext_erase_1_by_16 (struct mtd_info *, struct erase_info *);
+static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_intelext_erase_varsize(struct mtd_info *, struct erase_info *);
 static void cfi_intelext_sync (struct mtd_info *);
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
 static int cfi_intelext_suspend (struct mtd_info *);
 static void cfi_intelext_resume (struct mtd_info *);
 
 static void cfi_intelext_destroy(struct mtd_info *);
 
-static void cfi_cmdset_0001(struct map_info *, int, unsigned long);
+void cfi_cmdset_0001(struct map_info *, int, unsigned long);
 
 static struct mtd_info *cfi_intelext_setup (struct map_info *);
 
 static const char im_name[] = "cfi_cmdset_0001";
 
+/* #define DEBUG_LOCK_BITS */
+
 /* This routine is made available to other mtd code via
  * inter_module_register.  It must only be accessed through
  * inter_module_get which will bump the use count of this module.  The
@@ -45,21 +56,22 @@
  * this module is non-zero, i.e. between inter_module_get and
  * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
  */
-static void cfi_cmdset_0001(struct map_info *map, int primary, unsigned long base)
+void cfi_cmdset_0001(struct map_info *map, int primary, unsigned long base)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	int i;
 	struct cfi_pri_intelext *extp;
+	int ofs_factor = cfi->interleave * cfi->device_type;
 
-	__u16 adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+	__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 
-	printk(" Intel/Sharp Extended Query Table at 0x%4.4X\n", adr);
+	//printk(" Intel/Sharp Extended Query Table at 0x%4.4X\n", adr);
 
 	if (!adr)
 		return;
 
 	/* Switch it into Query Mode */
-	switch(map->buswidth) {
+	switch(CFIDEV_BUSWIDTH) {
 	case 1:
 		map->write8(map, 0x98, 0x55);
 		break;
@@ -80,7 +92,7 @@
 	/* Read in the Extended Query Table */
 	for (i=0; i<sizeof(*extp); i++) {
 		((unsigned char *)extp)[i] = 
-			map->read8(map, (base+((adr+i)*map->buswidth)));
+		    cfi_read_query(map, (base+((adr+i)*cfi->interleave*cfi->device_type)));
 	}
 
 	if (extp->MajorVersion != '1' || 
@@ -92,8 +104,8 @@
 	}
 
 	/* Do some byteswapping if necessary */
-	extp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);
-	extp->BlkStatusRegMask = le32_to_cpu(extp->BlkStatusRegMask);
+	extp->FeatureSupport = cfi32_to_cpu(extp->FeatureSupport);
+	extp->BlkStatusRegMask = cfi32_to_cpu(extp->BlkStatusRegMask);
 
 	
 	/* Tell the user about it in lots of lovely detail */
@@ -137,7 +149,7 @@
 	/* OK. We like it. Take over the control of it. */
 
 	/* Switch it into Read Mode */
-	switch(map->buswidth) {
+	switch(CFIDEV_BUSWIDTH) {
 	case 1:
 		map->write8(map, 0xff, 0x55);
 		break;
@@ -151,7 +163,7 @@
 
 
 	/* If there was an old setup function, decrease its use count */
-	if (cfi->cmdset_setup)
+	if (cfi->im_name)
 		inter_module_put(cfi->im_name);
 	if (cfi->cmdset_priv)
 		kfree(cfi->cmdset_priv);
@@ -164,9 +176,18 @@
 		
 
 	cfi->cmdset_setup = cfi_intelext_setup;
-	cfi->im_name = im_name;
 	cfi->cmdset_priv = extp;
-	
+
+#if 1 /* Does this work? */
+	cfi_send_gen_cmd(0x90, 0x55, base, map, cfi->interleave, cfi->device_type, NULL);
+
+	cfi->mfr = cfi_read_query(map, base);
+	cfi->id = cfi_read_query(map, base + ofs_factor);
+
+	printk("JEDEC ID: %2.2X %2.2X\n", cfi->mfr, cfi->id);
+#endif
+
+        cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
 	return;
 }
 
@@ -174,9 +195,12 @@
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct mtd_info *mtd;
+	unsigned long offset = 0;
+	int i,j;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
 	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
-	printk("number of CFI chips: %d\n", cfi->numchips);
+	//printk("number of CFI chips: %d\n", cfi->numchips);
 
 	if (!mtd) {
 	  printk("Failed to allocate memory for MTD device\n");
@@ -187,13 +211,59 @@
 	memset(mtd, 0, sizeof(*mtd));
 	mtd->priv = map;
 	mtd->type = MTD_NORFLASH;
-	mtd->erasesize = 0x20000; /* FIXME */
+	mtd->size = devsize * cfi->numchips;
+
+	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) 
+			* mtd->numeraseregions, GFP_KERNEL);
+	if (!mtd->eraseregions) { 
+			printk("Failed to allocate memory for MTD erase region info\n");
+			kfree(cfi->cmdset_priv);
+			return NULL;
+	}
+	
+	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+		unsigned long ernum, ersize;
+		ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+		ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+
+		if (mtd->erasesize < ersize) {
+			mtd->erasesize = ersize;
+		}
+		for (j=0; j<cfi->numchips; j++) {
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+		}
+		offset += (ersize * ernum);
+		}
+
+		if (offset != devsize) {
+			/* Argh */
+			printk("Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk("%d: offset=0x%lx,size=0x%lx,blocks=%d\n",i,mtd->eraseregions[i].offset,
+			mtd->eraseregions[i].erasesize,mtd->eraseregions[i].numblocks);
+		}
+
 	/* Also select the correct geometry setup too */ 
-	mtd->size = (1 << cfi->cfiq.DevSize) * cfi->numchips;
-	mtd->erase = cfi_intelext_erase_1_by_16;
-	mtd->read = cfi_intelext_read_1_by_16;
-	mtd->write = cfi_intelext_write_1_by_16;
+		mtd->erase = cfi_intelext_erase_varsize;
+	mtd->read = cfi_intelext_read;
+	if ( cfi->cfiq->BufWriteTimeoutTyp ) {
+		//printk( KERN_INFO"Using buffer write method\n" );
+		mtd->write = cfi_intelext_write_buffers;
+	} else {
+		//printk( KERN_INFO"Using word write method\n" );
+		mtd->write = cfi_intelext_write_words;
+	}
 	mtd->sync = cfi_intelext_sync;
+	mtd->lock = cfi_intelext_lock;
+	mtd->unlock = cfi_intelext_unlock;
 	mtd->suspend = cfi_intelext_suspend;
 	mtd->resume = cfi_intelext_resume;
 	mtd->flags = MTD_CAP_NORFLASH;
@@ -202,101 +272,129 @@
 	return mtd;
 }
 
-static inline int do_read_1_by_16_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	__u32 status, status_OK;
+	unsigned long timeo;
 	DECLARE_WAITQUEUE(wait, current);
+	int suspended = 0;
+	unsigned long cmd_addr;
+	struct cfi_private *cfi = map->fldrv_priv;
 
 	adr += chip->start;
 
+	/* Ensure cmd read/writes are aligned. */ 
+	cmd_addr = adr & ~(CFIDEV_BUSWIDTH-1); 
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
 	/* Check that the chip's ready to talk to us.
-	 * Later, we can actually think about interrupting it
-	 * if it's in FL_ERASING or FL_WRITING state.
-	 * Not just yet, though.
+	 * If it's in FL_ERASING state, suspend it and make it talk now.
 	 */
 	switch (chip->state) {
-#if 0
 	case FL_ERASING:
-	case FL_WRITING:
-		/* Suspend the operation, set state to FL_xxx_SUSPENDED */
-#endif
-
-	case FL_CFI_QUERY:
-	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
-		chip->state = FL_STATUS;
-
-	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-			static int z=0;
-			/* Urgh. Chip not yet ready to talk to us. */
+		cfi_write (map, CMD(0xb0), cmd_addr);
+		chip->oldstate = FL_ERASING;
+		chip->state = FL_ERASE_SUSPENDING;
+//		printk("Erase suspending at 0x%lx\n", cmd_addr);
+		for (;;) {
+			status = cfi_read(map, cmd_addr);
+			if ((status & status_OK) == status_OK)
+				break;
+			
 			if (time_after(jiffies, timeo)) {
+				/* Urgh */
+				cfi_write(map, CMD(0xd0), cmd_addr);
+				chip->state = FL_ERASING;
 				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in read");
+				printk("Chip not ready after erase suspended\n");
 				return -EIO;
 			}
 
-			/* Latency issues. Drop the lock, wait a while and retry */
 			spin_unlock_bh(chip->mutex);
+			cfi_udelay(1);
+			spin_lock_bh(chip->mutex);
+		}
 
-			z++;
-			if ( 0 && !(z % 100 )) 
-				printk("chip not ready yet before read. looping\n");
+		suspended = 1;
+		cfi_write(map, CMD(0xff), cmd_addr);
+		chip->state = FL_READY;
+		break;
 
-			udelay(1);
+#if 0
+	case FL_WRITING:
+		/* Not quite yet */
+#endif
 
-			goto retry;
-		}
+	case FL_READY:
 		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+		cfi_write(map, CMD(0x70), cmd_addr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, cmd_addr);
+		if ((status & status_OK) == status_OK) {
+			cfi_write(map, CMD(0xff), cmd_addr);
+			chip->state = FL_READY;
+			break;
+		}
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in read. WSM status = %x\n", status);
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
-		if(signal_pending(current))
-			return -EINTR;
-
-
 		timeo = jiffies + HZ;
-
 		goto retry;
 	}
 
-	map->write16(map, cpu_to_le16(0x00ff), adr);
-	chip->state = FL_READY;
-
 	map->copy_from(map, buf, adr, len);
 
-	if (chip->state == FL_ERASE_SUSPENDED || 
-	    chip->state == FL_WRITE_SUSPENDED) {
-		printk("Who in hell suspended the pending operation? I didn't write that code yet!\n");
-		/* Restart it and set the state accordingly */
+	if (suspended) {
+		chip->state = chip->oldstate;
+		/* What if one interleaved chip has finished and the 
+		   other hasn't? The old code would leave the finished
+		   one in READY mode. That's bad, and caused -EROFS 
+		   errors to be returned from do_erase_oneblock because
+		   that's the only bit it checked for at the time.
+		   As the state machine appears to explicitly allow 
+		   sending the 0x70 (Read Status) command to an erasing
+		   chip and expecting it to be ignored, that's what we 
+		   do. */
+		cfi_write(map, CMD(0xd0), cmd_addr);
+		cfi_write(map, CMD(0x70), cmd_addr);		
 	}
 
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-
 	return 0;
 }
 
-static int cfi_intelext_read_1_by_16 (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+static int cfi_intelext_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -321,7 +419,7 @@
 		else
 			thislen = len;
 
-		ret = do_read_1_by_16_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
 		if (ret)
 			break;
 
@@ -335,14 +433,20 @@
 	return ret;
 }
 
-static inline int do_write_1_by_16_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u16 datum)
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
 	DECLARE_WAITQUEUE(wait, current);
-	int z = 0;
+	int z;
+
 	adr += chip->start;
 
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
@@ -352,111 +456,85 @@
 	 * Not just yet, though.
 	 */
 	switch (chip->state) {
+	case FL_READY:
+		break;
+		
 	case FL_CFI_QUERY:
 	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
+		cfi_write(map, CMD(0x70), adr);
 		chip->state = FL_STATUS;
-		timeo = jiffies + HZ;
 
 	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-
-			/* Urgh. Chip not yet ready to talk to us. */
-			if (time_after(jiffies, timeo)) {
-				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in read");
-				return -EIO;
-			}
-
-			/* Latency issues. Drop the lock, wait a while and retry */
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
 			spin_unlock_bh(chip->mutex);
-
-			z++;
-			if ( 0 && !(z % 100 ))
-				printk("chip not ready yet before write. looping\n");
-			
-			udelay(1);
-
-			goto retry;
+			printk("waiting for chip to be ready timed out in read\n");
+			return -EIO;
 		}
-		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
-		if(signal_pending(current))
-			return -EINTR;
-
 		timeo = jiffies + HZ;
-
 		goto retry;
 	}
-	
-	map->write16(map, cpu_to_le16(0x0040), adr);
-	map->write16(map, datum, adr);
-	chip->state = FL_WRITING;
 
-	timeo = jiffies + (HZ/2);
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x40), adr);
+	cfi_write(map, datum, adr);
+	chip->state = FL_WRITING;
 
 	spin_unlock_bh(chip->mutex);
-	udelay(chip->word_write_time);
+	cfi_udelay(chip->word_write_time);
 	spin_lock_bh(chip->mutex);
 
+	timeo = jiffies + (HZ/2);
 	z = 0;
-	while ( !( (status = le16_to_cpu(map->read16(map, adr)))  & 0x80 ) ) {
-
+	for (;;) {
 		if (chip->state != FL_WRITING) {
 			/* Someone's suspended the write. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			
 			spin_unlock_bh(chip->mutex);
-			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
-			if (signal_pending(current))
-				return -EINTR;
-			
 			timeo = jiffies + (HZ / 2); /* FIXME */
-
 			spin_lock_bh(chip->mutex);
 			continue;
 		}
 
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
 			spin_unlock_bh(chip->mutex);
-			printk("waiting for chip to be ready timed out in read");
+			printk("waiting for chip to be ready timed out in word write\n");
 			return -EIO;
 		}
-		
+
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock_bh(chip->mutex);
-		
 		z++;
-		if ( 0 && !(z % 100 )) 
-		  printk("chip not ready yet after write. looping\n");
-		
-		udelay(1);
-		
+		cfi_udelay(1);
 		spin_lock_bh(chip->mutex);
-		continue;
 	}
 	if (!z) {
 		chip->word_write_time--;
@@ -467,18 +545,25 @@
 		chip->word_write_time++;
 
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-	//	printk("write ret OK at %lx\n", adr);
 	return 0;
 }
 
 
-/* This version only uses the 'word write' instruction. We should update it
- * to write using 'buffer write' if it's available 
- */
-static int cfi_intelext_write_1_by_16 (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+static int cfi_intelext_write_words (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -487,27 +572,43 @@
 	unsigned long ofs;
 
 	*retlen = 0;
+	if (!len)
+		return 0;
+
 	chipnum = to >> cfi->chipshift;
 	ofs = to  - (chipnum << cfi->chipshift);
 
-	/* If it's not word-aligned, do the first byte write */
-	if (ofs & 1) {
-#if defined(__LITTLE_ENDIAN)
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF | (*buf << 8));
-#elif defined(__BIG_ENDIAN) 
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF00 | (*buf));
-#else
-#error define a sensible endianness
-#endif
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int gap = ofs - bus_ofs;
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (gap--)
+			tmp_buf[i++] = 0xff;
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       bus_ofs, datum);
 		if (ret) 
 			return ret;
 		
-		ofs++;
-		buf++;
-		(*retlen)++;
-		len--;
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
 
 		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
@@ -517,16 +618,28 @@
 		}
 	}
 	
-	while(len > 1) {
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, *(__u16 *)buf);
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				ofs, datum);
 		if (ret)
 			return ret;
 
-		ofs += 2;
-		buf += 2;
-		(*retlen) += 2;
-		len -= 2;
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
 
 		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
@@ -536,186 +649,515 @@
 		}
 	}
 
-	if (len) {
-		/* Final byte to write */
-#if defined(__LITTLE_ENDIAN)
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF00 | (*buf));
-#elif defined(__BIG_ENDIAN) 
-		ret = do_write_1_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, 0xFF | (*buf << 8));
-#else
-#error define a sensible endianness
-#endif
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
+
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+					       ofs, datum);
 		if (ret) 
 			return ret;
 		
-		(*retlen)++;
+		(*retlen) += n;
 	}
 
 	return 0;
 }
 
 
-static inline int do_erase_1_by_16_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+static inline int do_write_buffer(struct map_info *map, struct flchip *chip, 
+				  unsigned long adr, const u_char *buf, int len)
 {
-	__u16 status;
-	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int interleave = cfi->interleave;
+	__u32 status, status_OK;
+	unsigned long cmd_adr, timeo;
 	DECLARE_WAITQUEUE(wait, current);
+	int wbufsize, z;
 
+	wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
 	adr += chip->start;
+	cmd_adr = adr & ~(wbufsize-1);
+	
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
 
+	timeo = jiffies + HZ;
  retry:
 	spin_lock_bh(chip->mutex);
 
-	/* Check that the chip's ready to talk to us. */
+	/* Check that the chip's ready to talk to us.
+	 * Later, we can actually think about interrupting it
+	 * if it's in FL_ERASING state.
+	 * Not just yet, though.
+	 */
 	switch (chip->state) {
+	case FL_READY:
+		break;
+		
 	case FL_CFI_QUERY:
 	case FL_JEDEC_QUERY:
-	case FL_READY:
-		map->write16(map, cpu_to_le16(0x0070), adr);
+		cfi_write(map, CMD(0x70), cmd_adr);
 		chip->state = FL_STATUS;
-		timeo = jiffies + HZ;
 
 	case FL_STATUS:
-		status = le16_to_cpu(map->read16(map, adr));
-
-		if (!(status & (1<<7))) {
-			static int z=0;
-			/* Urgh. Chip not yet ready to talk to us. */
-			if (time_after(jiffies, timeo)) {
-				spin_unlock_bh(chip->mutex);
-				printk("waiting for chip to be ready timed out in erase");
-				return -EIO;
-			}
-
-			/* Latency issues. Drop the lock, wait a while and retry */
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
 			spin_unlock_bh(chip->mutex);
-
-			z++;
-			if ( 0 && !(z % 100 )) 
-				printk("chip not ready yet before erase. looping\n");
-
-			udelay(1);
-
-			goto retry;
+			printk("waiting for chip to be ready timed out in buffer write\n");
+			return -EIO;
 		}
-		break;
 
-	default:
-		printk("Waiting for chip, status = %d\n", chip->state);
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
 
+	default:
 		/* Stick ourselves on a wait queue to be woken when
 		   someone changes the status */
-
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
-		
 		spin_unlock_bh(chip->mutex);
-
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
 
-		if(signal_pending(current))
-			return -EINTR;
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0xe8), cmd_adr);
+	chip->state = FL_WRITING_TO_BUFFER;
 
-		timeo = jiffies + HZ;
+	z = 0;
+	for (;;) {
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
 
-		goto retry;
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+
+		if (++z > 20) {
+			/* Argh. Not ready for write to buffer */
+			cfi_write(map, CMD(0x70), cmd_adr);
+			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			printk("Chip not ready for buffer write. Xstatus = %x, status = %x\n", status, cfi_read(map, cmd_adr));
+			return -EIO;
+		}
 	}
-	
-	map->write16(map, cpu_to_le16(0x0020), adr);
-	map->write16(map, cpu_to_le16(0x00D0), adr);
 
-	chip->state = FL_ERASING;
-	
-	timeo = jiffies + (HZ*2);
-	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
-	spin_lock_bh(chip->mutex);
+	/* Write length of data to come */
+	cfi_write(map, CMD(len/CFIDEV_BUSWIDTH-1), cmd_adr );
 
-	/* FIXME. Use a timer to check this, and return immediately. */
-	/* Once the state machine's known to be working I'll do that */
+	/* Write data */
+	for (z = 0; z < len; z += CFIDEV_BUSWIDTH) {
+		if (cfi_buswidth_is_1()) {
+			map->write8 (map, *((__u8*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_2()) {
+			map->write16 (map, *((__u16*)buf)++, adr+z);
+		} else if (cfi_buswidth_is_4()) {
+			map->write32 (map, *((__u32*)buf)++, adr+z);
+		} else {
+			DISABLE_VPP(map);
+			return -EINVAL;
+		}
+	}
+	/* GO GO GO */
+	cfi_write(map, CMD(0xd0), cmd_adr);
+	chip->state = FL_WRITING;
 
-	while ( !( (status = le16_to_cpu(map->read16(map, adr)))  & 0x80 ) ) {
-		static int z=0;
+	spin_unlock_bh(chip->mutex);
+	cfi_udelay(chip->buffer_write_time);
+	spin_lock_bh(chip->mutex);
 
-		if (chip->state != FL_ERASING) {
-			/* Someone's suspended the erase. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+	timeo = jiffies + (HZ/2);
+	z = 0;
+	for (;;) {
+		if (chip->state != FL_WRITING) {
+			/* Someone's suspended the write. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
-			
 			spin_unlock_bh(chip->mutex);
-			printk("erase suspended. Sleeping\n");
-			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
-			if (signal_pending(current))
-				return -EINTR;
-			
-			timeo = jiffies + (HZ*2); /* FIXME */
+			timeo = jiffies + (HZ / 2); /* FIXME */
 			spin_lock_bh(chip->mutex);
 			continue;
 		}
 
+		status = cfi_read(map, cmd_adr);
+		if ((status & status_OK) == status_OK)
+			break;
+
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			DISABLE_VPP(map);
 			spin_unlock_bh(chip->mutex);
-			printk("waiting for erase to complete timed out.");
+			printk("waiting for chip to be ready timed out in bufwrite\n");
 			return -EIO;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock_bh(chip->mutex);
-
+		cfi_udelay(1);
 		z++;
-		if ( 0 && !(z % 100 )) 
-			printk("chip not ready yet after erase. looping\n");
-
-		udelay(1);
-		
 		spin_lock_bh(chip->mutex);
-		continue;
 	}
-	
+	if (!z) {
+		chip->buffer_write_time--;
+		if (!chip->buffer_write_time)
+			chip->buffer_write_time++;
+	}
+	if (z > 1) 
+		chip->buffer_write_time++;
+
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_STATUS;
+	/* check for lock bit */
+	if (status & CMD(0x02)) {
+		/* clear status */
+		cfi_write(map, CMD(0x50), cmd_adr);
+		/* put back into read status register mode */
+		cfi_write(map, CMD(0x70), adr);
+		wake_up(&chip->wq);
+		spin_unlock_bh(chip->mutex);
+		return -EROFS;
+	}
 	wake_up(&chip->wq);
 	spin_unlock_bh(chip->mutex);
-	//printk("erase ret OK\n");
 	return 0;
 }
 
-static int cfi_intelext_erase_1_by_16 (struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_intelext_write_buffers (struct mtd_info *mtd, loff_t to, 
+				       size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
-	unsigned long adr, len;
-	int chipnum, ret = 0;
+	int interleave = cfi->interleave;
+	int wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
+	int ret = 0;
+	int chipnum;
+	unsigned long ofs;
 
-	if (instr->addr & (mtd->erasesize - 1))
-		return -EINVAL;
+	*retlen = 0;
+	if (!len)
+		return 0;
 
-	if (instr->len & (mtd->erasesize -1))
-		return -EINVAL;
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
 
-	if ((instr->len + instr->addr) > mtd->size)
-		return -EINVAL;
+	/* If it's not bus-aligned, do the first word write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		size_t local_len = (-ofs)&(CFIDEV_BUSWIDTH-1);
+		if (local_len > len)
+			local_len = len;
+		ret = cfi_intelext_write_words(mtd, to, local_len,
+					       retlen, buf);
+		if (ret)
+			return ret;
+		ofs += local_len;
+		buf += local_len;
+		len -= local_len;
 
-	chipnum = instr->addr >> cfi->chipshift;
-	adr = instr->addr - (chipnum << cfi->chipshift);
-	len = instr->len;
+		if (ofs >> cfi->chipshift) {
+			chipnum ++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
 
-	while(len) {
-		ret = do_erase_1_by_16_oneblock(map, &cfi->chips[chipnum], adr);
-		
+	/* Write buffer is worth it only if more than one word to write... */
+	while(len > CFIDEV_BUSWIDTH) {
+		/* We must not cross write block boundaries */
+		int size = wbufsize - (ofs & (wbufsize-1));
+
+		if (size > len)
+			size = len & ~(CFIDEV_BUSWIDTH-1);
+		ret = do_write_buffer(map, &cfi->chips[chipnum], 
+				      ofs, buf, size);
 		if (ret)
 			return ret;
 
-		adr += mtd->erasesize;
-		len -= mtd->erasesize;
+		ofs += size;
+		buf += size;
+		(*retlen) += size;
+		len -= size;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* ... and write the remaining bytes */
+	if (len > 0) {
+		size_t local_retlen;
+		ret = cfi_intelext_write_words(mtd, ofs + (chipnum << cfi->chipshift),
+					       len, &local_retlen, buf);
+		if (ret)
+			return ret;
+		(*retlen) += local_retlen;
+	}
+
+	return 0;
+}
+
+
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo;
+	int retries = 3;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in erase\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	/* Clear the status register first */
+	cfi_write(map, CMD(0x50), adr);
+
+	/* Now erase */
+	cfi_write(map, CMD(0x20), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_ERASING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*20);
+	for (;;) {
+		if (chip->state != FL_ERASING) {
+			/* Someone's suspended the erase. Sleep */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			timeo = jiffies + (HZ*2); /* FIXME */
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for erase to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	DISABLE_VPP(map);
+	ret = 0;
+
+	/* We've broken this before. It doesn't hurt to be safe */
+	cfi_write(map, CMD(0x70), adr);
+	chip->state = FL_STATUS;
+	status = cfi_read(map, adr);
+
+	/* check for lock bit */
+	if (status & CMD(0x3a)) {
+		unsigned char chipstatus = status;
+		if (status != CMD(status & 0xff)) {
+			int i = cfi->interleave;
+			for (i = 1; i<cfi->interleave; i++) {
+				      chipstatus |= status >> (cfi->device_type * 8);
+			}
+			printk(KERN_WARNING "Status is not identical for all chips: 0x%x. Merging to give 0x%02x\n", status, chipstatus);
+		}
+		/* Reset the error bits */
+		cfi_write(map, CMD(0x50), adr);
+		cfi_write(map, CMD(0x70), adr);
+		
+		if (chipstatus & 0x30) {
+			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x02) {
+			/* Protection bit set */
+			ret = -EROFS;
+		} else if (chipstatus & 0x8) {
+			/* Voltage */
+			printk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\n", status);
+			ret = -EIO;
+		} else if (chipstatus & 0x20) {
+			if (retries--) {
+				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, status);
+				timeo = jiffies + HZ;
+				chip->state = FL_STATUS;
+				spin_unlock_bh(chip->mutex);
+				goto retry;
+			}
+			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, status);
+			ret = -EIO;
+		}
+	}
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return ret;
+}
+
+int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+{	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+		
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
 
 		if (adr >> cfi->chipshift) {
 			adr = 0;
@@ -726,14 +1168,13 @@
 		}
 	}
 		
+	instr->state = MTD_ERASE_DONE;
 	if (instr->callback)
 		instr->callback(instr);
 	
 	return 0;
 }
 
-
-
 static void cfi_intelext_sync (struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -760,6 +1201,7 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_SYNCING:
 			spin_unlock_bh(chip->mutex);
 			break;
 
@@ -769,9 +1211,8 @@
 			
 			spin_unlock_bh(chip->mutex);
 			schedule();
+		        remove_wait_queue(&chip->wq, &wait);
 			
-			remove_wait_queue(&chip->wq, &wait);
-
 			goto retry;
 		}
 	}
@@ -791,6 +1232,288 @@
 	}
 }
 
+static inline int do_lock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK) 
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in lock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0x01), adr);
+	chip->state = FL_LOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for lock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	if (ofs & (mtd->erasesize - 1))
+		return -EINVAL;
+
+	if (len & (mtd->erasesize -1))
+		return -EINVAL;
+
+	if ((len + ofs) > mtd->size)
+		return -EINVAL;
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+	while(len) {
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		printk("before lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif
+
+		ret = do_lock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		printk("after lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif	
+		
+		if (ret)
+			return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+	return 0;
+}
+static inline int do_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u32 status, status_OK;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+
+	adr += chip->start;
+
+	/* Let's determine this according to the interleave only once */
+	status_OK = CMD(0x80);
+
+	timeo = jiffies + HZ;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	/* Check that the chip's ready to talk to us. */
+	switch (chip->state) {
+	case FL_CFI_QUERY:
+	case FL_JEDEC_QUERY:
+	case FL_READY:
+		cfi_write(map, CMD(0x70), adr);
+		chip->state = FL_STATUS;
+
+	case FL_STATUS:
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* Urgh. Chip not yet ready to talk to us. */
+		if (time_after(jiffies, timeo)) {
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in unlock\n");
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		goto retry;
+
+	default:
+		/* Stick ourselves on a wait queue to be woken when
+		   someone changes the status */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+		spin_unlock_bh(chip->mutex);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+
+	ENABLE_VPP(map);
+	cfi_write(map, CMD(0x60), adr);
+	cfi_write(map, CMD(0xD0), adr);
+	chip->state = FL_UNLOCKING;
+	
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	/* FIXME. Use a timer to check this, and return immediately. */
+	/* Once the state machine's known to be working I'll do that */
+
+	timeo = jiffies + (HZ*2);
+	for (;;) {
+
+		status = cfi_read(map, adr);
+		if ((status & status_OK) == status_OK)
+			break;
+		
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo)) {
+			cfi_write(map, CMD(0x70), adr);
+			chip->state = FL_STATUS;
+			printk("waiting for unlock to complete timed out. Xstatus = %x, status = %x.\n", status, cfi_read(map, adr));
+			DISABLE_VPP(map);
+			spin_unlock_bh(chip->mutex);
+			return -EIO;
+		}
+		
+		/* Latency issues. Drop the unlock, wait a while and retry */
+		spin_unlock_bh(chip->mutex);
+		cfi_udelay(1);
+		spin_lock_bh(chip->mutex);
+	}
+	
+	/* Done and happy. */
+	chip->state = FL_STATUS;
+	DISABLE_VPP(map);
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+	return 0;
+}
+static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+#ifdef DEBUG_LOCK_BITS
+	int ofs_factor = cfi->interleave * cfi->device_type;
+#endif
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+#ifdef DEBUG_LOCK_BITS
+	{
+		unsigned long temp_adr = adr;
+		unsigned long temp_len = len;
+                 
+		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+                while (temp_len) {
+			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
+			temp_adr += mtd->erasesize;
+			temp_len -= mtd->erasesize;
+		}
+		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+	}
+#endif
+
+	ret = do_unlock_oneblock(map, &cfi->chips[chipnum], adr);
+
+#ifdef DEBUG_LOCK_BITS
+	cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+	printk("after unlock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));
+	cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+#endif
+	
+	return ret;
+}
 
 static int cfi_intelext_suspend(struct mtd_info *mtd)
 {
@@ -816,6 +1539,7 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_PM_SUSPENDED:
 			break;
 
 		default:
@@ -827,17 +1551,19 @@
 
 	/* Unlock the chips again */
 
-	for (i--; i >=0; i--) {
-		chip = &cfi->chips[i];
-
-		spin_lock_bh(chip->mutex);
-		
-		if (chip->state == FL_PM_SUSPENDED) {
-			chip->state = chip->oldstate;
-			wake_up(&chip->wq);
+	if (ret) {
+		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
+			
+			spin_lock_bh(chip->mutex);
+			
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			spin_unlock_bh(chip->mutex);
 		}
-		spin_unlock_bh(chip->mutex);
-	}
+	} 
 	
 	return ret;
 }
@@ -859,8 +1585,6 @@
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		else
-			printk("Argh. Chip not in PM_SUSPENDED state upon resume()\n");
 
 		spin_unlock_bh(chip->mutex);
 	}
@@ -871,18 +1595,21 @@
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	kfree(cfi->cmdset_priv);
-	inter_module_put(cfi->im_name);
 	kfree(cfi);
 }
 
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_intelext_init init_module
+#define cfi_intelext_exit cleanup_module
+#endif
 
-static int __init cfi_intelext_init(void)
+mod_init_t cfi_intelext_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0001);
 	return 0;
 }
 
-static void __exit cfi_intelext_exit(void)
+mod_exit_t cfi_intelext_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0002.c linux-2.4.2/drivers/mtd/cfi_cmdset_0002.c
--- linux-2.4.2.orig/drivers/mtd/cfi_cmdset_0002.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_cmdset_0002.c	Thu Jan 10 18:30:47 2002
@@ -1,12 +1,14 @@
 /*
  * Common Flash Interface support:
- *   AMD & Fujitsu Extended Vendor Command Set (ID 0x0002)
+ *   AMD & Fujitsu Standard Vendor Command Set (ID 0x0002)
  *
  * Copyright (C) 2000 Crossnet Co. <info@crossnet.co.jp>
  *
+ * 2_by_8 routines added by Simon Munton
+ *
  * This code is GPL
  *
- * $Id: cfi_cmdset_0002.c,v 1.1 2000/07/11 12:32:09 dwmw2 Exp $
+ * $Id: cfi_cmdset_0002.c,v 1.42 2001/03/27 06:26:10 dwmw2 Exp $
  *
  */
 
@@ -18,68 +20,111 @@
 #include <asm/byteorder.h>
 
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/delay.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 
-#if LINUX_VERSION_CODE < 0x20300
-#define set_current_state(x) current->state = (x);
-#endif
-
-static int cfi_amdext_read_2_by_16 (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-static int cfi_amdext_write_2_by_16(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
-static int cfi_amdext_erase_2_by_16 (struct mtd_info *, struct erase_info *);
-static void cfi_amdext_sync (struct mtd_info *);
-static int cfi_amdext_suspend (struct mtd_info *);
-static void cfi_amdext_resume (struct mtd_info *);
+#define AMD_BOOTLOC_BUG
 
-static void cfi_amdext_destroy(struct mtd_info *);
+static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int cfi_amdstd_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int cfi_amdstd_erase_onesize(struct mtd_info *, struct erase_info *);
+static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
+static void cfi_amdstd_sync (struct mtd_info *);
+static int cfi_amdstd_suspend (struct mtd_info *);
+static void cfi_amdstd_resume (struct mtd_info *);
 
-static void cfi_cmdset_0002(struct map_info *, int, unsigned long);
+static void cfi_amdstd_destroy(struct mtd_info *);
 
-static struct mtd_info *cfi_amdext_setup (struct map_info *);
+void cfi_cmdset_0002(struct map_info *, int, unsigned long);
+static struct mtd_info *cfi_amdstd_setup (struct map_info *);
 
 static const char im_name[] = "cfi_cmdset_0002";
 
-static void cfi_cmdset_0002(struct map_info *map, int primary, unsigned long base)
+void cfi_cmdset_0002(struct map_info *map, int primary, unsigned long base)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned char bootloc;
+	int ofs_factor = cfi->interleave * cfi->device_type;
 	int i;
+	__u8 major, minor;
 //	struct cfi_pri_intelext *extp;
 
-	__u16 adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+    if (cfi->cfi_mode==0){
+	__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 
-	printk(" Amd/Fujitsu Extended Query Table at 0x%4.4X\n", adr);
+	cfi_send_gen_cmd(0x98, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
 
+	major = cfi_read_query(map, (adr+3)*ofs_factor);
+	minor = cfi_read_query(map, (adr+4)*ofs_factor);
 
-	/* If there was an old setup function, decrease its use count */
-	if (cfi->cmdset_setup)
+	printk(" Amd/Fujitsu Extended Query Table v%c.%c at 0x%4.4X\n",
+	       major, minor, adr);
+
+	cfi_send_gen_cmd(0xf0, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+
+	cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x90, 0x555, base, map, cfi->interleave, cfi->device_type, NULL);
+	cfi->mfr = cfi_read_query(map, base);
+	cfi->id = cfi_read_query(map, base + ofs_factor);
+
+	/* Wheee. Bring me the head of someone at AMD. */
+#ifdef AMD_BOOTLOC_BUG
+	if (((major << 8) | minor) < 0x3131) {
+		/* CFI version 1.0 => don't trust bootloc */
+		if (cfi->id & 0x80) {
+			printk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);
+			bootloc = 3;	/* top boot */
+		} else {
+			bootloc = 2;	/* bottom boot */
+		}
+	} else
+#endif
+	{
+		cfi_send_gen_cmd(0x98, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+		bootloc = cfi_read_query(map, (adr+15)*ofs_factor);
+	}
+	if (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {
+		printk(KERN_WARNING "%s: Swapping erase regions for broken CFI table.\n", map->name);
+
+		for (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {
+			int j = (cfi->cfiq->NumEraseRegions-1)-i;
+			__u32 swap;
+
+			swap = cfi->cfiq->EraseRegionInfo[i];
+			cfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];
+			cfi->cfiq->EraseRegionInfo[j] = swap;
+		}
+	}
+    }
+
+    /* If there was an old setup function, decrease its use count */
+    if (cfi->im_name)
 		inter_module_put(cfi->im_name);
-	if (cfi->cmdset_priv)
+    if (cfi->cmdset_priv)
 		kfree(cfi->cmdset_priv);
 
-	for (i=0; i< cfi->numchips; i++) {
-		cfi->chips[i].word_write_time = 128;
-		cfi->chips[i].buffer_write_time = 128;
-		cfi->chips[i].erase_time = 1024;
-	}		
-		
-
-	cfi->cmdset_setup = cfi_amdext_setup;
-	cfi->im_name = im_name;
-//	cfi->cmdset_priv = extp;
-	
-	return;
+    for (i=0; i< cfi->numchips; i++) {
+		cfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;
+		cfi->chips[i].buffer_write_time = 1<<cfi->cfiq->BufWriteTimeoutTyp;
+		cfi->chips[i].erase_time = 1<<cfi->cfiq->BlockEraseTimeoutTyp;
+    }		
+
+    cfi->cmdset_setup = cfi_amdstd_setup;
+    cfi_send_gen_cmd(0xf0, 0x55, 0, map, cfi->interleave, cfi->device_type, NULL);
+    return;
 }
 
-static struct mtd_info *cfi_amdext_setup(struct map_info *map)
+static struct mtd_info *cfi_amdstd_setup(struct map_info *map)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct mtd_info *mtd;
+	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
 	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
-	printk("number of CFI chips: %d\n", cfi->numchips);
+	printk("number of %s chips: %d\n", (cfi->cfi_mode)?"JEDEC":"CFI",cfi->numchips);
 
 	if (!mtd) {
 	  printk("Failed to allocate memory for MTD device\n");
@@ -90,42 +135,105 @@
 	memset(mtd, 0, sizeof(*mtd));
 	mtd->priv = map;
 	mtd->type = MTD_NORFLASH;
-	mtd->erasesize = 0x20000; /* FIXME */
 	/* Also select the correct geometry setup too */ 
-	mtd->size = (1 << cfi->cfiq.DevSize) * cfi->numchips * cfi->interleave;
-	mtd->erase = cfi_amdext_erase_2_by_16;
-	mtd->read = cfi_amdext_read_2_by_16;
-	mtd->write = cfi_amdext_write_2_by_16;
-	mtd->sync = cfi_amdext_sync;
-	mtd->suspend = cfi_amdext_suspend;
-	mtd->resume = cfi_amdext_resume;
+	mtd->size = devsize * cfi->numchips;
+	
+	if (cfi->cfiq->NumEraseRegions == 1) {
+		/* No need to muck about with multiple erase sizes */
+		mtd->erasesize = ((cfi->cfiq->EraseRegionInfo[0] >> 8) & ~0xff) * cfi->interleave;
+	} else {
+		unsigned long offset = 0;
+		int i,j;
+
+		mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
+		mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) * mtd->numeraseregions, GFP_KERNEL);
+		if (!mtd->eraseregions) { 
+			printk("Failed to allocate memory for MTD erase region info\n");
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+			
+		for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
+			unsigned long ernum, ersize;
+			ersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;
+			ernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;
+			
+			if (mtd->erasesize < ersize) {
+				mtd->erasesize = ersize;
+			}
+			for (j=0; j<cfi->numchips; j++) {
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
+				mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
+			}
+			offset += (ersize * ernum);
+		}
+		if (offset != devsize) {
+			/* Argh */
+			printk("Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);
+			kfree(mtd->eraseregions);
+			kfree(cfi->cmdset_priv);
+			return NULL;
+		}
+		// debug
+		for (i=0; i<mtd->numeraseregions;i++){
+			printk("%d: offset=0x%lx,size=0x%lx,blocks=%d\n",i,mtd->eraseregions[i].offset,
+			mtd->eraseregions[i].erasesize,mtd->eraseregions[i].numblocks);
+		}
+	}
+
+	switch (CFIDEV_BUSWIDTH)
+	{
+	case 1:
+	case 2:
+	case 4:
+#if 1
+		if (mtd->numeraseregions > 1)
+			mtd->erase = cfi_amdstd_erase_varsize;
+		else
+#endif
+			mtd->erase = cfi_amdstd_erase_onesize;
+		mtd->read = cfi_amdstd_read;
+		mtd->write = cfi_amdstd_write;
+		break;
+
+	default:
+	        printk("Unsupported buswidth\n");
+		kfree(mtd);
+		kfree(cfi->cmdset_priv);
+		return NULL;
+		break;
+	}
+	mtd->sync = cfi_amdstd_sync;
+	mtd->suspend = cfi_amdstd_suspend;
+	mtd->resume = cfi_amdstd_resume;
 	mtd->flags = MTD_CAP_NORFLASH;
-	map->fldrv_destroy = cfi_amdext_destroy;
+	map->fldrv_destroy = cfi_amdstd_destroy;
 	mtd->name = map->name;
 	return mtd;
 }
 
-static inline int do_read_2_by_16_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
+static inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long timeo = jiffies + HZ;
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-printk("Waiting for chip to read, status = %d\n", chip->state);
-		set_current_state(TASK_INTERRUPTIBLE);
+	        printk("Waiting for chip to read, status = %d\n", chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -133,19 +241,17 @@
 
 	adr += chip->start;
 
-//     	map->write32(map, cpu_to_le32(0x00F000F0), adr);
-
 	chip->state = FL_READY;
 
 	map->copy_from(map, buf, adr, len);
 
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
+	cfi_spin_unlock(chip->mutex);
 
 	return 0;
 }
 
-static int cfi_amdext_read_2_by_16 (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+static int cfi_amdstd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -156,8 +262,8 @@
 	/* ofs: offset within the first chip that the first read should start */
 
 	chipnum = (from >> cfi->chipshift);
-	chipnum /= (cfi->interleave);
-	ofs = from - (chipnum <<  cfi->chipshift) * (cfi->interleave);
+	ofs = from - (chipnum <<  cfi->chipshift);
+
 
 	*retlen = 0;
 
@@ -167,12 +273,12 @@
 		if (chipnum >= cfi->numchips)
 			break;
 
-		if (((len + ofs -1) >> cfi->chipshift) / (cfi->interleave))
-			thislen = (1<<cfi->chipshift) * (cfi->interleave) - ofs;
+		if ((len + ofs -1) >> cfi->chipshift)
+			thislen = (1<<cfi->chipshift) - ofs;
 		else
 			thislen = len;
 
-		ret = do_read_2_by_16_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
+		ret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);
 		if (ret)
 			break;
 
@@ -186,30 +292,32 @@
 	return ret;
 }
 
-static inline int do_write_2_by_16_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum)
+static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, __u32 datum, int fast)
 {
 	unsigned long timeo = jiffies + HZ;
 	unsigned int Last[4];
 	unsigned long Count = 0;
+	struct cfi_private *cfi = map->fldrv_priv;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-printk("Waiting for chip to write, status = %d\n", chip->state);
-		set_current_state(TASK_INTERRUPTIBLE);
+	        printk("Waiting for chip to write, status = %d\n", chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-printk("Wake up to write:\n");
+		printk("Wake up to write:\n");
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -218,125 +326,217 @@
 	chip->state = FL_WRITING;
 
 	adr += chip->start;
-
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00A000A0), 0x555 *4);
-	map->write32(map, cpu_to_le32(datum), adr);
-
-	spin_unlock_bh(chip->mutex);
-	udelay(chip->word_write_time);
-	spin_lock_bh(chip->mutex);
-
-	Last[0] = map->read32(map, adr);
-	Last[1] = map->read32(map, adr);
-	Last[2] = map->read32(map, adr);
+	ENABLE_VPP(map);
+	if (fast) { /* Unlock bypass */
+		cfi_send_gen_cmd(0xA0, 0, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	}
+	else {
+	        cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	        cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	        cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	}
+
+	cfi_write(map, datum, adr);
+
+	cfi_spin_unlock(chip->mutex);
+	cfi_udelay(chip->word_write_time);
+	cfi_spin_lock(chip->mutex);
+
+	Last[0] = cfi_read(map, adr);
+	//	printk("Last[0] is %x\n", Last[0]);
+	Last[1] = cfi_read(map, adr);
+	//	printk("Last[1] is %x\n", Last[1]);
+	Last[2] = cfi_read(map, adr);
+	//	printk("Last[2] is %x\n", Last[2]);
 
 	for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] && Count < 10000; Count++){
-		udelay(10);
-
-		Last[Count % 4] = map->read32(map, adr);
+		cfi_spin_unlock(chip->mutex);
+		cfi_udelay(10);
+		cfi_spin_lock(chip->mutex);
+		
+	        Last[Count % 4] = cfi_read(map, adr);
+		//		printk("Last[%d%%4] is %x\n", Count, Last[Count%4]);
 	}
-
+	
 	if (Last[(Count - 1) % 4] != datum){
-	     	map->write32(map, cpu_to_le32(0x00F000F0), adr);
+		printk("Last[%ld] is %x, datum is %x\n",(Count - 1) % 4,Last[(Count - 1) % 4],datum);
+	        cfi_send_gen_cmd(0xF0, 0, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+		DISABLE_VPP(map);
 		ret = -EIO;
 	}       
-
+	DISABLE_VPP(map);
 	chip->state = FL_READY;
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
-
+	cfi_spin_unlock(chip->mutex);
+	
 	return ret;
 }
 
-
-static int cfi_amdext_write_2_by_16 (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
+static int cfi_amdstd_write (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	int ret = 0;
 	int chipnum;
-	unsigned long ofs;
+	unsigned long ofs, chipstart;
 
 	*retlen = 0;
+	if (!len)
+		return 0;
 
-	chipnum = (to >> cfi->chipshift);
-	chipnum /= cfi->interleave;
-	ofs = to  - (chipnum << cfi->chipshift) * cfi->interleave;
-
-	while(len > 3) {
+	chipnum = to >> cfi->chipshift;
+	ofs = to  - (chipnum << cfi->chipshift);
+	chipstart = cfi->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write */
+	if (ofs & (CFIDEV_BUSWIDTH-1)) {
+		unsigned long bus_ofs = ofs & ~(CFIDEV_BUSWIDTH-1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, bus_ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len && i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
 
-		ret = do_write_2_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, *(__u32 *)buf);
-		if (ret)
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				bus_ofs, datum, 0);
+		if (ret) 
 			return ret;
+		
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
 
-		ofs += 4;
-		buf += 4;
-		(*retlen) += 4;
-		len -= 4;
-
-		if ((ofs >> cfi->chipshift) / cfi->interleave) {
+		if (ofs >> cfi->chipshift) {
 			chipnum ++; 
 			ofs = 0;
 			if (chipnum == cfi->numchips)
 				return 0;
 		}
 	}
+	
+	/* Go into unlock bypass mode */
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+
+	/* We are now aligned, write as much as possible */
+	while(len >= CFIDEV_BUSWIDTH) {
+		__u32 datum;
+
+		if (cfi_buswidth_is_1()) {
+			datum = *(__u8*)buf;
+		} else if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)buf;
+		} else {
+			return -EINVAL;
+		}
+		ret = do_write_oneword(map, &cfi->chips[chipnum],
+				       ofs, datum, cfi->fast_prog);
+		if (ret) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
+			return ret;
+		}
 
-	if (len) {
-		unsigned int tmp;
-
-		/* Final byte to write */
-#if defined(__LITTLE_ENDIAN)
-		tmp = map->read32(map, ofs);
-
-		tmp = 0xffffffff >> (len*8);
-		tmp = tmp << (len*8);
-
-		tmp |= *(__u32 *)(buf);
+		ofs += CFIDEV_BUSWIDTH;
+		buf += CFIDEV_BUSWIDTH;
+		(*retlen) += CFIDEV_BUSWIDTH;
+		len -= CFIDEV_BUSWIDTH;
+
+		if (ofs >> cfi->chipshift) {
+			if (cfi->fast_prog){
+				/* Get out of unlock bypass mode */
+				cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
 
-		ret = do_write_2_by_16_oneword(map, &cfi->chips[chipnum],
-					       ofs, tmp);
+			chipnum ++; 
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+			chipstart = cfi->chips[chipnum].start;
+			if (cfi->fast_prog){
+				/* Go into unlock bypass mode for next set of chips */
+				cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+				cfi_send_gen_cmd(0x20, cfi->addr_unlock1, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+			}
+		}
+	}
 
-#elif defined(__BIG_ENDIAN) 
-#error not support big endian yet
-#else
-#error define a sensible endianness
-#endif
+	if (cfi->fast_prog){
+		/* Get out of unlock bypass mode */
+		cfi_send_gen_cmd(0x90, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x00, 0, chipstart, map, cfi->interleave, cfi->device_type, NULL);
+	}
+
+	if (len & (CFIDEV_BUSWIDTH-1)) {
+		int i = 0, n = 0;
+		u_char tmp_buf[4];
+		__u32 datum;
+
+		map->copy_from(map, tmp_buf, ofs + cfi->chips[chipnum].start, CFIDEV_BUSWIDTH);
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+
+		if (cfi_buswidth_is_2()) {
+			datum = *(__u16*)tmp_buf;
+		} else if (cfi_buswidth_is_4()) {
+			datum = *(__u32*)tmp_buf;
+		} else {
+			return -EINVAL;  /* should never happen, but be safe */
+		}
 
+		ret = do_write_oneword(map, &cfi->chips[chipnum], 
+				ofs, datum, 0);
 		if (ret) 
 			return ret;
 		
-		(*retlen)+=len;
+		(*retlen) += n;
 	}
 
 	return 0;
 }
 
-
-static inline int do_erase_2_by_16_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
 {
 	unsigned int status;
 	unsigned long timeo = jiffies + HZ;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned int rdy_mask;
 	DECLARE_WAITQUEUE(wait, current);
 
  retry:
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-		set_current_state(TASK_INTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		add_wait_queue(&chip->wq, &wait);
                 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		schedule();
 		remove_wait_queue(&chip->wq, &wait);
-
+#if 0
 		if(signal_pending(current))
 			return -EINTR;
-
+#endif
 		timeo = jiffies + HZ;
 
 		goto retry;
@@ -345,83 +545,175 @@
 	chip->state = FL_ERASING;
 
 	adr += chip->start;
-
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00800080), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00AA00AA), 0x555 *4);
-	map->write32(map, cpu_to_le32(0x00550055), 0x2AA *4);
-	map->write32(map, cpu_to_le32(0x00300030), adr);
-
+	ENABLE_VPP(map);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi->interleave, cfi->device_type, NULL);
+	cfi_write(map, CMD(0x30), adr);
 	
 	timeo = jiffies + (HZ*20);
 
-	spin_unlock_bh(chip->mutex);
+	cfi_spin_unlock(chip->mutex);
 	schedule_timeout(HZ);
-	spin_lock_bh(chip->mutex);
+	cfi_spin_lock(chip->mutex);
+	
+	rdy_mask = CMD(0x80);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
 	/* Once the state machine's known to be working I'll do that */
 
-	while ( ( (status = le32_to_cpu(map->read32(map, 0x00))) & 0x80808080 ) != 0x80808080 ) {
+	while ( ( (status = cfi_read(map,adr)) & rdy_mask ) != rdy_mask ) {
 		static int z=0;
 
 		if (chip->state != FL_ERASING) {
 			/* Someone's suspended the erase. Sleep */
-			set_current_state(TASK_INTERRUPTIBLE);
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 			
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 			printk("erase suspended. Sleeping\n");
 			
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
-			
+#if 0			
 			if (signal_pending(current))
 				return -EINTR;
-			
+#endif			
 			timeo = jiffies + (HZ*2); /* FIXME */
-			spin_lock_bh(chip->mutex);
+			cfi_spin_lock(chip->mutex);
 			continue;
 		}
 
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_READY;
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 			printk("waiting for erase to complete timed out.");
+			DISABLE_VPP(map);
 			return -EIO;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 
 		z++;
 		if ( 0 && !(z % 100 )) 
 			printk("chip not ready yet after erase. looping\n");
 
-		udelay(1);
+		cfi_udelay(1);
 		
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		continue;
 	}
 	
 	/* Done and happy. */
+	DISABLE_VPP(map);
 	chip->state = FL_READY;
 	wake_up(&chip->wq);
-	spin_unlock_bh(chip->mutex);
-	printk("erase ret OK\n");
+	cfi_spin_unlock(chip->mutex);
 	return 0;
 }
 
-static int cfi_amdext_erase_2_by_16 (struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long adr, len;
 	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && instr->addr >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (instr->addr & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+	
+	chipnum = instr->addr >> cfi->chipshift;
+	adr = instr->addr - (chipnum << cfi->chipshift);
+	len = instr->len;
+
+	i=first;
+
+	while(len) {
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
+
+		if (ret)
+			return ret;
+
+		adr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
+			i++;
 
-//printk("erase : 0x%x 0x%x 0x%x\n", instr->addr, instr->len, mtd->size);
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+	
+	return 0;
+}
+
+static int cfi_amdstd_erase_onesize(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr, len;
+	int chipnum, ret = 0;
 
 	if (instr->addr & (mtd->erasesize - 1))
 		return -EINVAL;
@@ -433,15 +725,11 @@
 		return -EINVAL;
 
 	chipnum = instr->addr >> cfi->chipshift;
-	chipnum /= cfi->interleave;
-	adr = instr->addr - (chipnum << cfi->chipshift) * (cfi->interleave);
+	adr = instr->addr - (chipnum << cfi->chipshift);
 	len = instr->len;
 
-	printk("erase : 0x%lx 0x%lx 0x%x 0x%lx\n", adr, len, chipnum, mtd->size);
-
 	while(len) {
-//printk("erase : 0x%x 0x%x 0x%x 0x%x\n", chipnum, adr, len, cfi->chipshift);
-		ret = do_erase_2_by_16_oneblock(map, &cfi->chips[chipnum], adr);
+		ret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);
 
 		if (ret)
 			return ret;
@@ -449,7 +737,7 @@
 		adr += mtd->erasesize;
 		len -= mtd->erasesize;
 
-		if ((adr >> cfi->chipshift) / (cfi->interleave)) {
+		if (adr >> cfi->chipshift) {
 			adr = 0;
 			chipnum++;
 			
@@ -458,15 +746,14 @@
 		}
 	}
 		
+	instr->state = MTD_ERASE_DONE;
 	if (instr->callback)
 		instr->callback(instr);
 	
 	return 0;
 }
 
-
-
-static void cfi_amdext_sync (struct mtd_info *mtd)
+static void cfi_amdstd_sync (struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -474,13 +761,12 @@
 	struct flchip *chip;
 	int ret = 0;
 	DECLARE_WAITQUEUE(wait, current);
-printk("sync\n");
 
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
 	retry:
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -493,19 +779,20 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
-			spin_unlock_bh(chip->mutex);
+		case FL_SYNCING:
+			cfi_spin_unlock(chip->mutex);
 			break;
 
 		default:
 			/* Not an idle state */
 			add_wait_queue(&chip->wq, &wait);
 			
-			spin_unlock_bh(chip->mutex);
+			cfi_spin_unlock(chip->mutex);
 
 			schedule();
-			
-			remove_wait_queue(&chip->wq, &wait);
 
+		        remove_wait_queue(&chip->wq, &wait);
+			
 			goto retry;
 		}
 	}
@@ -515,19 +802,18 @@
 	for (i--; i >=0; i--) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		
 		if (chip->state == FL_SYNCING) {
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
-printk("sync end\n");
 }
 
 
-static int cfi_amdext_suspend(struct mtd_info *mtd)
+static int cfi_amdstd_suspend(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -539,7 +825,7 @@
 	for (i=0; !ret && i<cfi->numchips; i++) {
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 
 		switch(chip->state) {
 		case FL_READY:
@@ -552,33 +838,36 @@
 			 * as the whole point is that nobody can do anything
 			 * with the chip now anyway.
 			 */
+		case FL_PM_SUSPENDED:
 			break;
 
 		default:
 			ret = -EAGAIN;
 			break;
 		}
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
 
 	/* Unlock the chips again */
 
-	for (i--; i >=0; i--) {
-		chip = &cfi->chips[i];
+	if (ret) {
+    		for (i--; i >=0; i--) {
+			chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+			cfi_spin_lock(chip->mutex);
 		
-		if (chip->state == FL_PM_SUSPENDED) {
-			chip->state = chip->oldstate;
-			wake_up(&chip->wq);
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			cfi_spin_unlock(chip->mutex);
 		}
-		spin_unlock_bh(chip->mutex);
 	}
 	
 	return ret;
 }
 
-static void cfi_amdext_resume(struct mtd_info *mtd)
+static void cfi_amdstd_resume(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -590,7 +879,7 @@
 	
 		chip = &cfi->chips[i];
 
-		spin_lock_bh(chip->mutex);
+		cfi_spin_lock(chip->mutex);
 		
 		if (chip->state == FL_PM_SUSPENDED) {
 			chip->state = chip->oldstate;
@@ -599,30 +888,34 @@
 		else
 			printk("Argh. Chip not in PM_SUSPENDED state upon resume()\n");
 
-		spin_unlock_bh(chip->mutex);
+		cfi_spin_unlock(chip->mutex);
 	}
 }
 
-static void cfi_amdext_destroy(struct mtd_info *mtd)
+static void cfi_amdstd_destroy(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	kfree(cfi->cmdset_priv);
-	inter_module_put(cfi->im_name);
 	kfree(cfi);
 }
 
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_amdstd_init init_module
+#define cfi_amdstd_exit cleanup_module
+#endif
 
-static int __init cfi_amdext_init(void)
+mod_init_t cfi_amdstd_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0002);
 	return 0;
 }
 
-static void __exit cfi_amdext_exit(void)
+mod_exit_t cfi_amdstd_exit(void)
 {
 	inter_module_unregister(im_name);
 }
 
-module_init(cfi_amdext_init);
-module_exit(cfi_amdext_exit);
+module_init(cfi_amdstd_init);
+module_exit(cfi_amdstd_exit);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_flagadm.c linux-2.4.2/drivers/mtd/cfi_flagadm.c
--- linux-2.4.2.orig/drivers/mtd/cfi_flagadm.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cfi_flagadm.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,164 @@
+/*
+ *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
+ *
+ *  $Id: cfi_flagadm.c,v 1.2 2001/03/26 21:43:22 dwmw2 Exp $
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+/* We split the flash chip up into two parts.
+ * part one is the bootloader and the kernelimage, in total the first 0x90000
+ * bytes.
+ * part two is the boot disk, i.e. 0x400000 - 0x90000 = 0x370000 bytes.
+ */
+
+#define FLASH_PHYS_ADDR 0x40000000
+#define FLASH_SIZE 0x400000  
+
+#define FLASH_PARTITION1_ADDR 0x00000000
+#define FLASH_PARTITION1_SIZE 0x00090000
+#define FLASH_PARTITION2_ADDR (FLASH_PARTITION1_ADDR | FLASH_PARTITION1_SIZE)
+#define FLASH_PARTITION2_SIZE 0x00370000
+
+__u8 flagadm_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 flagadm_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 flagadm_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void flagadm_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void flagadm_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void flagadm_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info flagadm_map = {
+		name: "FlagaDM flash device",
+		size: FLASH_SIZE,
+		buswidth: 2,
+		read8: flagadm_read8,
+		read16: flagadm_read16,
+		read32: flagadm_read32,
+		copy_from: flagadm_copy_from,
+		write8: flagadm_write8,
+		write16: flagadm_write16,
+		write32: flagadm_write32,
+		copy_to: flagadm_copy_to
+};
+
+struct mtd_partition flagadm_parts[] = {
+	{
+		offset	: FLASH_PARTITION1_ADDR,
+		size	: FLASH_PARTITION1_SIZE
+	},
+	{
+		offset	: FLASH_PARTITION2_ADDR,
+		size	: FLASH_PARTITION2_SIZE
+	}
+};
+
+#define PARTITION_COUNT (sizeof(flagadm_parts)/sizeof(struct mtd_partition))
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_flagadm init_module
+#define cleanup_flagadm cleanup_module
+#endif
+
+static struct mtd_info *mymtd;
+
+int __init init_flagadm(void)
+{	
+	printk(KERN_NOTICE "FlagaDM flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	flagadm_map.map_priv_1 = (unsigned long)ioremap(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!flagadm_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_cfi_probe(&flagadm_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, flagadm_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "FlagaDM flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)flagadm_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_flagadm(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (flagadm_map.map_priv_1) {
+		iounmap((void *)flagadm_map.map_priv_1);
+		flagadm_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_flagadm);
+module_exit(cleanup_flagadm);
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_jedec.c linux-2.4.2/drivers/mtd/cfi_jedec.c
--- linux-2.4.2.orig/drivers/mtd/cfi_jedec.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cfi_jedec.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,285 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_ATMEL	0x001f
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_TOSHIBA	0x0098
+
+/* AMD */
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+
+/* Atmel */
+#define AT49BV16X4	0x00c0
+#define AT49BV16X4T	0x00c2
+
+/* Fujitsu */
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+
+/* ST - www.st.com */
+#define M29W800T	0x00D7
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+
+/* SST */
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const int DevSize;
+	const int InterfaceDesc;
+	const int NumEraseRegions;
+	const ulong regions[4];
+};
+
+#define ERASEINFO(size,blocks) (size<<8)|(blocks-1)
+
+#define SIZE_1MB 20
+#define SIZE_2MB 21
+#define SIZE_4MB 22
+
+static const struct amd_flash_info jedec_table[] = {
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DT,
+		name: "AMD AM29LV160DT",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVT160,
+		name: "Toshiba TC58FVT160",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160TE,
+		name: "Fujitsu MBM29LV160TE",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_TOSHIBA,
+		dev_id: TC58FVB160,
+		name: "Toshiba TC58FVB160",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_FUJITSU,
+		dev_id: MBM29LV160BE,
+		name: "Fujitsu MBM29LV160BE",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BB,
+		name: "AMD AM29F800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,15),
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BT,
+		name: "AMD AM29LV800BT",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29F800BT,
+		name: "AMD AM29F800BT",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W800T,
+		name: "ST M29W800T",
+		DevSize: SIZE_1MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,15),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DT,
+		name: "ST M29W160DT",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,31),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,31)
+		}
+	}, {
+		mfr_id: MANUFACTURER_ATMEL,
+		dev_id: AT49BV16X4,
+		name: "Atmel AT49BV16X4",
+		DevSize: SIZE_2MB,
+		NumEraseRegions: 3,
+		regions: {ERASEINFO(0x02000,8),
+			  ERASEINFO(0x08000,2),
+			  ERASEINFO(0x10000,30)
+		}
+	}, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16X4T,
+                name: "Atmel AT49BV16X4T",
+                DevSize: SIZE_2MB,
+                NumEraseRegions: 3,
+                regions: {ERASEINFO(0x10000,30),
+                          ERASEINFO(0x08000,2),
+			  ERASEINFO(0x02000,8)
+                }
+        }, {
+		0
+	} 
+};
+
+int cfi_jedec_lookup(int index, int mfr_id, int dev_id)
+{
+  	if (index>=0){
+		if (jedec_table[index].mfr_id == mfr_id &&
+		    jedec_table[index].dev_id == dev_id) return index;
+  	}
+  	else{
+		for (index=0; jedec_table[index].mfr_id; index++){
+		    if (jedec_table[index].mfr_id == mfr_id &&
+		        jedec_table[index].dev_id == dev_id) return index;
+		}
+  	}
+	return -1;
+}
+
+int cfi_jedec_setup(struct cfi_private *p_cfi, int index)
+{
+int i,num_erase_regions;
+
+	num_erase_regions = jedec_table[index].NumEraseRegions;
+	
+	p_cfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+	if (!p_cfi->cfiq) {
+		//xx printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+		return -1;
+	}
+
+	memset(p_cfi->cfiq,0,sizeof(struct cfi_ident));	
+	
+	p_cfi->cfiq->P_ID = P_ID_AMD_STD;
+	p_cfi->cfiq->NumEraseRegions = jedec_table[index].NumEraseRegions;
+	p_cfi->cfiq->DevSize = jedec_table[index].DevSize;
+
+	for (i=0; i<num_erase_regions; i++){
+		p_cfi->cfiq->EraseRegionInfo[i] = jedec_table[index].regions[i];
+	}	
+	return 0; 	/* ok */
+}
+
diff -Naur linux-2.4.2.orig/drivers/mtd/cfi_probe.c linux-2.4.2/drivers/mtd/cfi_probe.c
--- linux-2.4.2.orig/drivers/mtd/cfi_probe.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/cfi_probe.c	Thu Jan 10 18:30:47 2002
@@ -1,30 +1,42 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: cfi_probe.c,v 1.12 2000/07/03 13:29:16 dwmw2 Exp $
+   $Id: cfi_probe.c,v 1.47 2001/03/26 11:59:46 dwmw2 Exp $
 */
 
 
+/*! \file cfi_probe.c
+  \brief Common Flash Interface probe code. (C) 2000 Red Hat. GPL'd.
+
+  \version $Id: cfi_probe.c,v 1.47 2001/03/26 11:59:46 dwmw2 Exp $
+*/
+
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 
+/* #define DEBUG_CFI */
 
-struct mtd_info *cfi_probe(struct map_info *);
-
+#ifdef DEBUG_CFI
 static void print_cfi_ident(struct cfi_ident *);
+#endif
+
+int cfi_jedec_setup(struct cfi_private *p_cfi, int index);
+int cfi_jedec_lookup(int index, int mfr_id, int dev_id);
+
 static void check_cmd_set(struct map_info *, int, unsigned long);
 static struct cfi_private *cfi_cfi_probe(struct map_info *);
-
 static const char im_name[] = "cfi_probe";
 
+
 /* This routine is made available to other mtd code via
  * inter_module_register.  It must only be accessed through
  * inter_module_get which will bump the use count of this module.  The
@@ -32,10 +44,13 @@
  * this module is non-zero, i.e. between inter_module_get and
  * inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
  */
+/*! \brief test only 
+ */
 struct mtd_info *cfi_probe(struct map_info *map)
 {
 	struct mtd_info *mtd = NULL;
 	struct cfi_private *cfi;
+
 	/* First probe the map to see if we have CFI stuff there. */
 	cfi = cfi_cfi_probe(map);
 	
@@ -43,8 +58,6 @@
 		return NULL;
 
 	map->fldrv_priv = cfi;
-	map->im_name = im_name;
-
 	/* OK we liked it. Now find a driver for the command set it talks */
 
 	check_cmd_set(map, 1, cfi->chips[0].start); /* First the primary cmdset */
@@ -60,197 +73,232 @@
 		
 		if (mtd)
 			return mtd;
-		inter_module_put(cfi->im_name);
+		if (cfi->im_name)
+			inter_module_put(cfi->im_name);
 	}
-	printk("No supported Vendor Command Set found\n");
+	printk(KERN_WARNING"cfi_probe: No supported Vendor Command Set found\n");
 	
+	kfree(cfi->cfiq);
 	kfree(cfi);
 	map->fldrv_priv = NULL;
 	return NULL;
+}
 
+static __u32 cfi_send_cmd(u_char cmd, __u32 base, struct map_info *map, u_char interleave, int type, __u32 *prev_val)
+{
+	return cfi_send_gen_cmd(cmd, 0x55, base, map, interleave, type, prev_val);
 }
 
-static int cfi_probe_new_chip(struct map_info *map, unsigned long base,
-			      struct flchip *chips, struct cfi_private *cfi)
+/* check for QRY, or search for jedec id.
+   in: interleave,type,mode
+   ret: table index, <0 for error
+ */
+static int cfi_check_qry_or_id(struct map_info *map, __u32 base, int index,
+				struct cfi_private *cfi)
 {
-	switch (map->buswidth) {
-		
-	case 1: {
-		unsigned char tmp = map->read8(map, base + 0x55);
+	__u32 manufacturer_id, device_id;
+	int osf = cfi->interleave * cfi->device_type;	// scale factor
+
+	//printk("cfi_check_qry_or_id: base=0x%08lx interl=%d type=%d index=%d\n",base,cfi->interleave,cfi->device_type,index);
 
-		/* If there's a device there, put it in Query Mode */
-		map->write8(map, 0x98, base+0x55);
+	switch(cfi->cfi_mode){
+	case 0:
+		if (cfi_read(map,base+osf*0x10)==cfi_build_cmd('Q',map,cfi->interleave) &&
+		    cfi_read(map,base+osf*0x11)==cfi_build_cmd('R',map,cfi->interleave) &&
+		    cfi_read(map,base+osf*0x12)==cfi_build_cmd('Y',map,cfi->interleave))
+			return 0;	// ok !
+		break;
 		
-		if (map->read8(map,base+0x10) == 'Q' &&
-		    map->read8(map,base+0x11) == 'R' &&
-		    map->read8(map,base+0x12) == 'Y') {
-			printk("%s: Found a CFI device at 0x%lx in 8 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-				/* Put it back into Read Mode */
-				map->write8(map, 0x98, base+0x55);
-			}
-			return 1;
-		} else {
-			if (map->read8(map, base + 0x55) == 0x98) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write8(map, tmp, base+0x55);
-			}
-			return 0;
-		}
+	case 1:
+		manufacturer_id = cfi_read(map,base+0*osf);
+		device_id 	= cfi_read(map,base+1*osf);
+		//printk("cfi_check_qry_or_id: man=0x%lx,id=0x%lx\n",manufacturer_id, device_id);
+		
+		return cfi_jedec_lookup(index,manufacturer_id,device_id);	
 	}
 	
-	case 2: {
-		__u16 tmp = map->read16(map, base + 0xaa);
-		
-		/* If there's a device there, put it into Query Mode */
-		map->write16(map, 0x9898, base+0xAA);
-		
-		if (map->read16(map, base+0x20) == cpu_to_le16(0x0051) &&
-		    map->read16(map, base+0x22) == cpu_to_le16(0x0052) &&
-		    map->read16(map, base+0x24) == cpu_to_le16(0x0059)) {
-			printk("%s: Found a CFI device at 0x%lx in 16 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				int i;
-
-				for (i=0; i < cfi->numchips; i++) {
-					/* This chip should be in read mode if it's one 
-					   we've already touched. */
-					if (map->read16(map, chips[i].start+0x20) == cpu_to_le16(0x0051) &&
-					    map->read16(map, chips[i].start+0x22) == cpu_to_le16(0x0052) &&
-					    map->read16(map, chips[i].start+0x24) == cpu_to_le16(0x0059)){
-						/* Either the old chip has got 'Q''R''Y' in a most
-						   unfortunate place, or it's an alias of the new
-						   chip. Double-check that it's in read mode, and check. */
-						map->write16(map, 0xffff, chips[i].start+0x20);
-						if (map->read16(map, chips[i].start+0x20) == cpu_to_le16(0x0051) &&
-						    map->read16(map, chips[i].start+0x22) == cpu_to_le16(0x0052) &&
-						    map->read16(map, chips[i].start+0x24) == cpu_to_le16(0x0059)) {
-							/* Yes it's got QRY for data. Most unfortunate. 
-							   Stick the old one in read mode too. */
-							map->write16(map, 0xffff, base);
-							if (map->read16(map, base+0x20) == cpu_to_le16(0x0051) &&
-							    map->read16(map, base+0x22) == cpu_to_le16(0x0052) &&
-							    map->read16(map, base+0x24) == cpu_to_le16(0x0059)) {
-								/* OK, so has the new one. Assume it's an alias */
-								printk("T'was probably an alias for the chip at 0x%lx\n", chips[i].start);
-								return 1;
-							} /* else no, they're different, fall through. */
-						} else {
-							/* No the old one hasn't got QRY for data. Therefore,
-							   it's an alias of the new one. */
-							map->write16(map, 0xffff, base+0xaa);
-							/* Just to be paranoid. */
-							map->write16(map, 0xffff, chips[i].start+0xaa);
-							printk("T'was an alias for the chip at 0x%lx\n", chips[i].start);
-							return 1;
-						}
-					} 
-					/* No, the old one didn't look like it's in query mode. Next. */
-				}
-				
-				/* OK, if we got to here, then none of the previous chips appear to
-				   be aliases for the current one. */
-				if (cfi->numchips == MAX_CFI_CHIPS) {
-					printk("%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
-					/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
-					return 1;
-				}
-				printk("Not an alias. Adding\n");
-				chips[cfi->numchips].start = base;
-				chips[cfi->numchips].state = FL_READY;
-				chips[cfi->numchips].mutex = &chips[cfi->numchips]._spinlock;
-				cfi->numchips++;
-
-				/* Put it back into Read Mode */
-				map->write16(map, 0xffff, base+0xaa);
-			}
-			
-			return 1;
-		}	
-		else if (map->read16(map, base+0x20) == 0x5151 &&
-			 map->read16(map, base+0x22) == 0x5252 &&
-			 map->read16(map, base+0x24) == 0x5959) {
-			printk("%s: Found a coupled pair of CFI devices at %lx in 8 bit mode\n",
-			       map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-
-				/* Put it back into Read Mode */
-				map->write16(map, 0xffff, base+0xaa);
-			}
+	return -1; 	// nothing found
+}
 
-			return 2;
-		} else {
-			if (map->read16(map, base+0xaa) == 0x9898) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write16(map, tmp, base+0xaa);
-			}
-			return 0;
-		}
+static void cfi_qry_mode(struct map_info *map, __u32 base, struct cfi_private *cfi)
+{
+	switch(cfi->cfi_mode){
+	case 0:
+		/* Query */
+		cfi_send_cmd(0x98, base, map, cfi->interleave, cfi->device_type, NULL);
+		break;
+		
+	case 1:
+		/* Autoselect */
+		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi->interleave, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi->interleave, cfi->device_type, NULL);
+		break;
 	}
+}
 
+static int cfi_probe_chip_1(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi)
+{
+	int index;
+	__u32 tmp,ofs;
+	
+	ofs = cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave,cfi->device_type, &tmp);
+	
+	cfi_qry_mode(map,base,cfi);
+	
+	index=cfi_check_qry_or_id(map,base,-1,cfi);
+	if (index<0) return -1;
+	
+	if (chips){
+		int i;
+
+		for (i=0; i<cfi->numchips; i++){
+			/* This chip should be in read mode if it's one
+			   we've already touched. */
+			if (cfi_check_qry_or_id(map,chips[i].start,index,cfi) >= 0){
+				cfi_send_gen_cmd(0xF0, 0, chips[i].start, map, cfi->interleave, cfi->device_type, NULL);
+				if (cfi_check_qry_or_id(map,chips[i].start,index,cfi) >= 0){
+					/* Yes it's got QRY for data. Most unfortunate.
+					   Stick the old one in read mode too. */
+					cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave, cfi->device_type, NULL);
+					if (cfi_check_qry_or_id(map,base,index,cfi) >= 0){
+						/* OK, so has the new one. Assume it's an alias */
+						printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+						       map->name, base, chips[i].start);
+						return -1;
+					}
+				} else {
+					cfi_send_gen_cmd(0xF0, 0, base+0xaa*cfi->interleave * cfi->device_type, map, cfi->interleave, cfi->device_type, NULL);
+					cfi_send_gen_cmd(0xF0, 0, chips[i].start+0xaa*cfi->interleave * cfi->device_type, map, cfi->interleave, cfi->device_type, NULL);
+					return -1;
+				}
+			}
+		} /* for i */
 		
-	case 4: {
-		__u32 tmp = map->read32(map, base+0x154);
-		
-		/* If there's a device there, put it into Query Mode */
-		map->write32(map, 0x98989898, base+0x154);
+		/* OK, if we got to here, then none of the previous chips appear to
+		   be aliases for the current one. */
+		if (cfi->numchips == MAX_CFI_CHIPS) {
+			printk(KERN_WARNING"%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.\n", map->name, MAX_CFI_CHIPS);
+			/* Doesn't matter about resetting it to Read Mode - we're not going to talk to it anyway */
+			return -1;
+		}
+		chips[cfi->numchips].start = base;
+		chips[cfi->numchips].state = FL_READY;
+		chips[cfi->numchips].mutex = &chips[cfi->numchips]._spinlock;
+		cfi->numchips++;
 		
-		if (map->read32(map, base+0x40) == cpu_to_le32(0x00000051) &&
-		    map->read32(map, base+0x44) == cpu_to_le32(0x00000052) &&
-		    map->read32(map, base+0x48) == cpu_to_le32(0x00000059)) {
-				/* This isn't actually in the CFI spec - only x8 and x16 are. */
-			printk("%s: Found a CFI device at %lx in 32 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
-
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 1;
-		} 
-		else if (map->read32(map, base+0x40) == cpu_to_le32(0x00510051) &&
-			 map->read32(map, base+0x44) == cpu_to_le32(0x00520052) &&
-			 map->read32(map, base+0x48) == cpu_to_le32(0x00590059)) {
-			printk("%s: Found a coupled pair of CFI devices at location %lx in 16 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
+		/* Put it back into Read Mode */
+		cfi_send_gen_cmd(0xF0, 0, base, map, cfi->interleave, cfi->device_type, NULL);
+	}
+	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit mode\n", map->name, 
+	       cfi->interleave, cfi->device_type*8, base, map->buswidth*8);
+	
+	return index;
+}
 
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 2;
-		}
-		else if (map->read32(map, base+0x40) == 0x51515151 &&
-			 map->read32(map, base+0x44) == 0x52525252 &&
-			 map->read32(map, base+0x48) == 0x59595959) {
-			printk("%s: Found four side-by-side CFI devices at location %lx in 8 bit mode\n", map->name, base);
-			if (chips) {
-				/* Check previous chips for aliases */
-				printk("FIXME: Do alias check at line %d of cfi_probe.c\n", __LINE__);
+/*  put dev into qry mode, and try cfi and jedec modes for the given type/interleave
+ */
+static int cfi_probe_chip(struct map_info *map, __u32 base,
+			  struct flchip *chips, struct cfi_private *cfi)
+{
+	int index;
+	cfi->cfi_mode=0;	/* cfi mode */
+	cfi->addr_unlock1=0x555; cfi->addr_unlock2=0x2aa; 
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	if (index>=0) return index;
+	
+	cfi->cfi_mode=1;	/* jedec mode */
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	if (index>=0) return index;
+	
+	cfi->addr_unlock1=0x5555; cfi->addr_unlock2=0x2aaa; 
+	index = cfi_probe_chip_1(map,base,chips,cfi);
+	
+	return index;
+}
 
-				/* Put it back into read mode */
-				map->write32(map, 0xffffffff, base+0x154);
-			}
-			return 4;
-		} else {
-			if (map->read32(map, base+0x154) == 0x98989898) {
-				/* It looks like RAM. Put back the stuff we overwrote */
-				map->write32(map, tmp, base+0x154);
-			}
-			return 0;
-		}
-	}	
+/*
+ * Since probeing for CFI chips requires writing to the device problems may
+ * occur if the flash is not present and RAM is accessed instead.  For now we
+ * assume that the flash is present so we don't check for RAM or replace
+ * possibly overwritten data.
+ */
+static int cfi_probe_new_chip(struct map_info *map, unsigned long base,
+			      struct flchip *chips, struct cfi_private *cfi)
+{
+int index;
+	switch (map->buswidth) {
+#ifdef CFIDEV_BUSWIDTH_1		
+	case CFIDEV_BUSWIDTH_1:
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+		break;			
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_2		
+	case CFIDEV_BUSWIDTH_2:
+#ifdef CFIDEV_INTERLEAVE_1
+		cfi->interleave = CFIDEV_INTERLEAVE_1;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+#endif
+		break;			
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_4
+	case CFIDEV_BUSWIDTH_4:
+#ifdef CFIDEV_INTERLEAVE_4
+		cfi->interleave = CFIDEV_INTERLEAVE_4;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X32;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+
+		cfi->device_type = CFI_DEVICETYPE_X8;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_2
+		cfi->interleave = CFIDEV_INTERLEAVE_2;
+		cfi->device_type = CFI_DEVICETYPE_X16;
+		index = cfi_probe_chip(map,base,chips,cfi);
+		if (index>=0) return index;
+#endif
+#ifdef CFIDEV_INTERLEAVE_1
+                cfi->interleave = CFIDEV_INTERLEAVE_1;
+                cfi->device_type = CFI_DEVICETYPE_X32;
+                index = cfi_probe_chip(map,base,chips,cfi);
+                if (index>=0) return index;
+#endif
+		break;
+#endif
 	default:
-		printk(KERN_WARNING "cfi_probe called with strange buswidth %d\n", map->buswidth);
-		return 0;
-	}
+		printk(KERN_WARNING "cfi_probe called with unsupported buswidth %d\n", map->buswidth);
+		return -1;
+	} // switch
+	return -1;
 }
 
 static struct cfi_private *cfi_cfi_probe(struct map_info *map)
@@ -259,85 +307,121 @@
 	struct cfi_private cfi;
 	struct cfi_private *retcfi;
 	struct flchip chip[MAX_CFI_CHIPS];
-	int i;
+	int i,index; 
+	char num_erase_regions;
+ 	int ofs_factor;
 
 	memset(&cfi, 0, sizeof(cfi));
 
 	/* The first invocation (with chips == NULL) leaves the device in Query Mode */
-	cfi.interleave = cfi_probe_new_chip(map, 0, NULL, NULL);
+	index = cfi_probe_new_chip(map, 0, NULL, &cfi);
 
-	if (!cfi.interleave) {
-		printk("%s: Found no CFI device at location zero\n", map->name);
+	if (index<0) {
+		printk(KERN_WARNING"%s: Found no CFI device at location zero\n", map->name);
 		/* Doesn't appear to be CFI-compliant at all */
 		return NULL;
 	}
 
 	/* Read the Basic Query Structure from the device */
 
-	for (i=0; i<sizeof(struct cfi_ident); i++) {
-		((unsigned char *)&cfi.cfiq)[i] = map->read8(map,base + ((0x10 + i)*map->buswidth));
-	}
+ 	ofs_factor = cfi.interleave*cfi.device_type;
 
-	/* Do any necessary byteswapping */
-	cfi.cfiq.P_ID = le16_to_cpu(cfi.cfiq.P_ID);
-	cfi.cfiq.P_ADR = le16_to_cpu(cfi.cfiq.P_ADR);
-	cfi.cfiq.A_ID = le16_to_cpu(cfi.cfiq.A_ID);
-	cfi.cfiq.A_ADR = le16_to_cpu(cfi.cfiq.A_ADR);
-	cfi.cfiq.InterfaceDesc = le16_to_cpu(cfi.cfiq.InterfaceDesc);
-	cfi.cfiq.MaxBufWriteSize = le16_to_cpu(cfi.cfiq.MaxBufWriteSize);
-	
-#if 1
-	/* Dump the information therein */
-	print_cfi_ident(&cfi.cfiq);
+	/* First, work out the amount of space to allocate */
+	if (cfi.cfi_mode==0){
+		num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);
+
+#ifdef DEBUG_CFI
+		printk("Number of erase regions: %d\n", num_erase_regions);
+#endif
+
+		cfi.cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);
+		if (!cfi.cfiq) {
+			printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
+			return NULL;
+		}
 
-	for (i=0; i<cfi.cfiq.NumEraseRegions; i++) {
-		__u16 EraseRegionInfoNum = (map->read8(map,base + ((0x2d + (4*i))*map->buswidth))) + 
-			(((map->read8(map,(0x2e + (4*i))*map->buswidth)) << 8));
-		__u16 EraseRegionInfoSize = (map->read8(map, base + ((0x2f + (4*i))*map->buswidth))) + 
-			(map->read8(map, base + ((0x30 + (4*i))*map->buswidth)) << 8);
-		
-		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
-		       i, EraseRegionInfoSize * 256, EraseRegionInfoNum+1);
+		memset(cfi.cfiq,0,sizeof(struct cfi_ident));	
+
+		cfi.fast_prog=1;		/* CFI supports fast programming */
+
+			/* CFI flash */
+		for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++) {
+			((unsigned char *)cfi.cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);
+		}
+
+		/* Do any necessary byteswapping */
+		cfi.cfiq->P_ID = le16_to_cpu(cfi.cfiq->P_ID);
+		cfi.cfiq->P_ADR = le16_to_cpu(cfi.cfiq->P_ADR);
+		cfi.cfiq->A_ID = le16_to_cpu(cfi.cfiq->A_ID);
+		cfi.cfiq->A_ADR = le16_to_cpu(cfi.cfiq->A_ADR);
+		cfi.cfiq->InterfaceDesc = le16_to_cpu(cfi.cfiq->InterfaceDesc);
+		cfi.cfiq->MaxBufWriteSize = le16_to_cpu(cfi.cfiq->MaxBufWriteSize);
+
+#ifdef CONFIG_MTD_CFI_INTELSTD
+		if (cfi.cfiq->P_ID == 3)
+		    cfi.cfiq->P_ID = 1;
+#endif
+
+		for (i=0; i<cfi.cfiq->NumEraseRegions; i++) {
+			cfi.cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi.cfiq->EraseRegionInfo[i]);
+
+#ifdef DEBUG_CFI		
+			printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
+		       		i, (cfi.cfiq->EraseRegionInfo[i] >> 8) & ~0xff, 
+		       		(cfi.cfiq->EraseRegionInfo[i] & 0xffff) + 1);
+#endif
+		}
+	}
+	else{
+		/* JEDEC flash */
+		if (cfi_jedec_setup(&cfi,index)<0){
+			printk(KERN_WARNING "cfi_jedec_setup failed\n");
+			return NULL;
+		}
 	}
-	
-	printk("\n");
-#endif	
 
-	/* Switch the chip back into Read Mode, to make the alias detection work */
-	switch(map->buswidth) {
-	case 1:
-		map->write8(map, 0xff, 0x55);
-		break;
-	case 2:
-		map->write16(map, 0xffff, 0xaa);
-		break;
-	case 4:
-		map->write32(map, 0xffffffff, 0x154);
-		break;
+	if (cfi.cfiq->NumEraseRegions == 0) {
+		printk(KERN_WARNING "Number of erase regions is zero\n");
+		kfree(cfi.cfiq);
+		return NULL;
 	}
 
+#ifdef DEBUG_CFI
+	/* Dump the information therein */
+	print_cfi_ident(cfi.cfiq);
+#endif
+
+	cfi_send_cmd(0xFF, base, map, cfi.interleave, cfi.device_type, NULL);
+
 	/* OK. We've worked out what it is and we're happy with it. Now see if there are others */
 
 	chip[0].start = 0;
 	chip[0].state = FL_READY;
 	chip[0].mutex = &chip[0]._spinlock;
 
-	cfi.chipshift =  cfi.cfiq.DevSize;
+	cfi.chipshift = cfi.cfiq->DevSize;
 	cfi.numchips = 1;
 
 	if (!cfi.chipshift) {
-		printk("cfi.chipsize is zero. This is bad. cfi.cfiq.DevSize is %d\n", cfi.cfiq.DevSize);
+		printk(KERN_ERR"cfi.chipsize is zero. This is bad. cfi.cfiq->DevSize is %d\n", cfi.cfiq->DevSize);
+		kfree(cfi.cfiq);
 		return NULL;
 	}
+	switch (cfi.interleave) {
+	    case 2: cfi.chipshift += 1; break;
+	    case 4: cfi.chipshift += 2; break;
+	}
 
 	for (base = (1<<cfi.chipshift); base < map->size; base += (1<<cfi.chipshift))
-		cfi_probe_new_chip(map, base, &chip[0], &cfi);
+		cfi_probe_chip_1(map, base, &chip[0], &cfi);
 
 	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
 
-	if (!retcfi)
+	if (!retcfi) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);
+		kfree(cfi.cfiq);
 		return NULL;
-
+	}
 	memcpy(retcfi, &cfi, sizeof(cfi));
 	memcpy(&retcfi->chips[0], chip, sizeof(struct flchip) * cfi.numchips);
 	for (i=0; i< retcfi->numchips; i++) {
@@ -347,6 +431,7 @@
 	return retcfi;
 }
 
+#ifdef DEBUG_CFI
 static char *vendorname(__u16 vendor) 
 {
 	switch (vendor) {
@@ -379,14 +464,15 @@
 	}
 }
 
-		
+
 static void print_cfi_ident(struct cfi_ident *cfip)
 {
+#if 0
 	if (cfip->qry[0] != 'Q' || cfip->qry[1] != 'R' || cfip->qry[2] != 'Y') {
 		printk("Invalid CFI ident structure.\n");
 		return;
 	}	
-		
+#endif		
 	printk("Primary Vendor Command Set: %4.4X (%s)\n", cfip->P_ID, vendorname(cfip->P_ID));
 	if (cfip->P_ADR)
 		printk("Primary Algorithm Table at %4.4X\n", cfip->P_ADR);
@@ -460,55 +546,102 @@
 	printk("Number of Erase Block Regions: %d\n", cfip->NumEraseRegions);
 	
 }
+#endif DEBUG_CFI
 
-static void check_cmd_set(struct map_info *map, int primary, unsigned long base)
+typedef void cfi_cmdset_fn_t(struct map_info *, int, unsigned long);
+
+extern cfi_cmdset_fn_t cfi_cmdset_0001;
+extern cfi_cmdset_fn_t cfi_cmdset_0002;
+
+static void cfi_cmdset_unknown(struct map_info *map, int primary, unsigned long base)
 {
 	__u16 adr;
 	struct cfi_private *cfi = map->fldrv_priv;
-	__u16 type = primary?cfi->cfiq.P_ID:cfi->cfiq.A_ID;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+#ifdef HAVE_INTER_MODULE
 	char probename[32];
-	void (*probe_function)(struct map_info *, int, unsigned long);
-	
-	if (type == P_ID_NONE || type == P_ID_RESERVED)
-		return;
-	
+	cfi_cmdset_fn_t *probe_function;
+
 	sprintf(probename, "cfi_cmdset_%4.4X", type);
-	
+		
 	probe_function = inter_module_get_request(probename, probename);
+
 	if (probe_function) {
 		(*probe_function)(map, primary, base);
 		return;
-	}
-
+	}	
+#endif
+	printk(KERN_NOTICE "Support for command set %04X not present\n", type);
 	/* This was a command set we don't know about. Print only the basic info */
-	adr = primary?cfi->cfiq.P_ADR:cfi->cfiq.A_ADR;
+	adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 	
 	if (!adr) {
 		printk(" No Extended Query Table\n");
 	}
-	else if (map->read8(map,base+(adr*map->buswidth)) != (primary?'P':'A') ||
-		 map->read8(map,base+((adr+1)*map->buswidth)) != (primary?'R':'L') ||
-		 map->read8(map,base+((adr+2)*map->buswidth)) != (primary?'I':'T')) {
-		printk ("Invalid Extended Query Table at %4.4X: %2.2X %2.2X %2.2X\n",
-			adr,
-			map->read8(map,base+(adr*map->buswidth)),
-			map->read8(map,base+((adr+1)*map->buswidth)),
-			map->read8(map,base+((adr+2)*map->buswidth)));
-	}
 	else {
-		printk(" Extended Query Table version %c.%c\n",
-		       map->read8(map,base+((adr+3)*map->buswidth)), 
-		       map->read8(map,base+((adr+4)*map->buswidth)));
+ 		int ofs_factor = cfi->interleave * cfi->device_type;
+
+		if (cfi_read_query(map,base + adr*ofs_factor) != (primary?'P':'A') ||
+		    cfi_read_query(map,base + (adr+1)*ofs_factor) != (primary?'R':'L') ||
+		    cfi_read_query(map,base + (adr+2)*ofs_factor) != (primary?'I':'T')) {
+			printk ("Invalid Extended Query Table at %4.4X: %2.2X %2.2X %2.2X\n",
+				adr,
+				cfi_read_query(map,base + adr*ofs_factor),
+				cfi_read_query(map,base + (adr+1)*ofs_factor),
+				cfi_read_query(map,base + (adr+2)*ofs_factor));
+		}
+		else {
+			printk(" Extended Query Table version %c.%c\n",
+			       cfi_read_query(map,base + (adr+3)*ofs_factor), 
+			       cfi_read_query(map,base + (adr+4)*ofs_factor));
+		}
+	}
+	cfi_send_cmd(0xff, base, map, cfi->interleave, cfi->device_type, NULL);
+}
+
+static void check_cmd_set(struct map_info *map, int primary, unsigned long base)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+	
+	if (type == P_ID_NONE || type == P_ID_RESERVED)
+		return;
+	/* Put it in query mode */
+	cfi_qry_mode(map,base,cfi);
+
+	switch(type){
+		/* Urgh. Ifdefs. The version with weak symbols was
+		 * _much_ nicer. Shame it didn't seem to work on
+		 * anything but x86, really.
+		 * But we can't rely in inter_module_get() because
+		 * that'd mean we depend on link order.
+		 */
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	case 0x0001:
+		return cfi_cmdset_0001(map, primary, base);
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	case 0x0002:
+		return cfi_cmdset_0002(map, primary, base);
+#endif
 	}
+
+	return cfi_cmdset_unknown(map, primary, base);
 }
 
-static int __init cfi_probe_init(void)
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define cfi_probe_init init_module
+#define cfi_probe_exit cleanup_module
+#endif
+
+mod_init_t cfi_probe_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_probe);
 	return 0;
 }
 
-static void __exit cfi_probe_exit(void)
+mod_exit_t cfi_probe_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/cstm_cfi_jedec.c linux-2.4.2/drivers/mtd/cstm_cfi_jedec.c
--- linux-2.4.2.orig/drivers/mtd/cstm_cfi_jedec.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/cstm_cfi_jedec.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,339 @@
+/*
+ * $Id: cstm_cfi_jedec.c,v 1.5 2001/03/17 19:18:42 dwmw2 Exp $
+ *
+ * Mapping of a custom board with both AMD CFI and JEDEC flash in partitions.
+ * Config with both CFI and JEDEC device support.
+ *
+ * Basically physmap.c with the addition of partitions and 
+ * an array of mapping info to accomodate more than one flash type per board.
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#include <linux/delay.h>
+#endif
+
+__u8 cstm_cfi_jedec_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+__u16 cstm_cfi_jedec_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+__u32 cstm_cfi_jedec_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+void cstm_cfi_jedec_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cstm_cfi_jedec_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+void cstm_cfi_jedec_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define CC_GCR             0xB4013818
+#define CC_GPBCR           0xB401380A
+#define CC_GPBDR           0xB4013808
+#define CC_M68K_DEVICE     1
+#define CC_M68K_FUNCTION   6
+#define CC_CONFADDR        0xB8004000
+#define CC_CONFDATA        0xB8004004
+#define CC_FC_FCR          0xB8002004
+#define CC_FC_DCR          0xB8002008
+#define CC_GPACR           0xB4013802
+#define CC_GPAICR          0xB4013804
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+void cstm_cfi_jedec_set_vpp(struct map_info *map,int vpp)
+{
+  if (vpp) {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+        __u8	data1;
+	static u8 first = 1;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff0f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) | 0x08;
+	if (first) {
+		first = 0;
+		/* need to have this delay for first
+		   enabling vpp after powerup */
+		udelay(40);
+	}
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+  else {
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        __u16	data;
+
+	// Set GPIO port B pin3 to high
+	data = *(__u16 *)(CC_GPBCR);
+	data = (data & 0xff3f) | 0x0040;
+	*(__u16 *)CC_GPBCR = data;
+	*(__u8 *)CC_GPBDR = (*(__u8*)CC_GPBDR) & 0xf7;
+#endif /* CONFIG_MIPS_ITE8172 */
+  }
+}
+
+const struct map_info basic_cstm_cfi_jedec_map = {
+	NULL,
+	0,
+	0,
+	cstm_cfi_jedec_read8,
+	cstm_cfi_jedec_read16,
+	cstm_cfi_jedec_read32,
+	cstm_cfi_jedec_copy_from,
+	cstm_cfi_jedec_write8,
+	cstm_cfi_jedec_write16,
+	cstm_cfi_jedec_write32,
+	cstm_cfi_jedec_copy_to,
+        cstm_cfi_jedec_set_vpp,
+	0,
+	0
+};
+
+/* board and partition description */
+
+#define MAX_PHYSMAP_PARTITIONS    8
+struct cstm_cfi_jedec_info {
+	char *name;
+	unsigned long window_addr;
+	unsigned long window_size;
+	int buswidth;
+	int num_partitions;
+};
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+#define PHYSMAP_NUMBER  1  // number of physmap_info structs needed
+const struct cstm_cfi_jedec_info cstm_cfi_jedec_board_desc[PHYSMAP_NUMBER] = 
+{
+    {   // 28F128J3A in 2x16 configuration
+        "big flash",     // name
+	0x08000000,      // window_addr
+	0x02000000,      // window_size
+        4,               // buswidth
+	1,               // num_partitions
+    }
+
+};
+static struct mtd_partition cstm_cfi_jedec_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{   // 28F128J3A in 2x16 configuration
+	{
+		name: "main partition ",
+		size: 0x02000000, // 128 x 2 x 128k byte sectors
+		offset: 0,
+	},
+},
+};
+#else /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+#define PHYSMAP_NUMBER  2  // number of cstm_cfi_jedec_info structs needed, one per contiguous flash type 
+const struct cstm_cfi_jedec_info cstm_cfi_jedec_board_desc[PHYSMAP_NUMBER] = 
+{
+    {   // Am29DL323D in 2x16 configuration - CFI flash
+        "big flash",                   // name
+	0x40000000,      // window_addr
+	0x00800000,      // window_size
+        4,               // buswidth
+	2,                             // num_partitions
+    },
+    {   // Am29W040B in 1x8 configuration - JEDEC flash
+        "boot flash",    // name
+	0xfff80000,      // window_addr
+	0x00060000,      // window_size
+        1,               // buswidth
+	2,               // num_partitions
+    },
+
+};
+static struct mtd_partition cstm_cfi_jedec_partitions[PHYSMAP_NUMBER][MAX_PHYSMAP_PARTITIONS] = {
+{  // Am29DL323D in 2x16 configuration
+	{
+		name: "big flash 128k sectors",
+		size: 0x007E0000, // 63 x (2 x 64k) byte sectors
+		offset: 0,
+	},
+	{
+		name: "big flash 16k sectors",
+		size: 0x00020000, // 8  x (2 x 8k)  byte sectors
+		offset: 0x007E0000,
+	},
+},
+{  // Am29W040B in 1x8 configuration  
+	{
+		name: "boot environment",
+		size: 0x00010000, // 1 x 64k byte sectors
+		offset: 0
+	},
+	{
+		name: "boot flash sectors",
+		size: 0x00050000, // 5 x 64k byte sectors
+		offset: 0x10000
+	},
+	// leaving last 2 sectors of flash unaccessable by this driver
+}
+};
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+struct map_info cstm_cfi_jedec_map[PHYSMAP_NUMBER];
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_cstm_cfi_jedec init_module
+#define cleanup_cstm_cfi_jedec cleanup_module
+#endif
+
+int __init init_cstm_cfi_jedec(void)
+{
+	int i;
+	int jedec;
+        struct mtd_info *mymtd;
+        struct mtd_partition *parts;
+
+	/* Initialize mapping */
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+		printk(KERN_NOTICE "cstm_cfi_jedec flash device: %lx at %lx\n", cstm_cfi_jedec_board_desc[i].window_size, cstm_cfi_jedec_board_desc[i].window_addr);
+                memcpy((char *)&cstm_cfi_jedec_map[i],(char *)&basic_cstm_cfi_jedec_map,sizeof(struct map_info));
+		cstm_cfi_jedec_map[i].map_priv_1 = (unsigned long)ioremap(cstm_cfi_jedec_board_desc[i].window_addr, cstm_cfi_jedec_board_desc[i].window_size);
+		if (!cstm_cfi_jedec_map[i].map_priv_1) {
+			printk(KERN_WARNING "Failed to ioremap\n");
+			return -EIO;
+	        }
+		cstm_cfi_jedec_map[i].name = cstm_cfi_jedec_board_desc[i].name;
+		cstm_cfi_jedec_map[i].size = cstm_cfi_jedec_board_desc[i].window_size;
+		cstm_cfi_jedec_map[i].buswidth = cstm_cfi_jedec_board_desc[i].buswidth;
+		//printk(KERN_NOTICE "cstm_cfi_jedec: ioremap is %x\n",(unsigned int)(cstm_cfi_jedec_map[i].map_priv_1));
+	}
+
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+        setup_ITE_IVR_flash();
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+                parts = &cstm_cfi_jedec_partitions[i][0];
+		jedec = 0;
+		mymtd = (struct mtd_info *)do_cfi_probe(&cstm_cfi_jedec_map[i]);
+		//printk(KERN_NOTICE "phymap %d cfi_probe: mymtd is %x\n",i,(unsigned int)mymtd);
+		if (!mymtd) {
+			jedec = 1;
+			mymtd = (struct mtd_info *)do_jedec_probe(&cstm_cfi_jedec_map[i]);
+		        printk(KERN_NOTICE "cstm_cfi_jedec %d jedec: mymtd is %x\n",i,(unsigned int)mymtd);
+		}
+		if (mymtd) {
+			mymtd->module = THIS_MODULE;
+
+	                cstm_cfi_jedec_map[i].map_priv_2 = (unsigned long)mymtd;
+		        add_mtd_partitions(mymtd, parts, cstm_cfi_jedec_board_desc[i].num_partitions);
+		}
+		else
+	           return -ENXIO;
+	}
+	return 0;
+}
+
+static void __exit cleanup_cstm_cfi_jedec(void)
+{
+	int i;
+        struct mtd_info *mymtd;
+
+	for (i=0;i<PHYSMAP_NUMBER;i++) {
+	        mymtd = (struct mtd_info *)cstm_cfi_jedec_map[i].map_priv_2;
+		if (mymtd) {
+			del_mtd_partitions(mymtd);
+			map_destroy(mymtd);
+		}
+		if (cstm_cfi_jedec_map[i].map_priv_1) {
+			iounmap((void *)cstm_cfi_jedec_map[i].map_priv_1);
+			cstm_cfi_jedec_map[i].map_priv_1 = 0;
+		}
+	}
+}
+#if defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR)
+void PCISetULongByOffset(__u32 DevNumber, __u32 FuncNumber, __u32 Offset, __u32 data)
+{
+	__u32	offset;
+
+	offset = ( unsigned long )( 0x80000000 | ( DevNumber << 11 ) + ( FuncNumber << 8 ) + Offset) ;
+
+	*(__u32 *)CC_CONFADDR = offset;	
+	*(__u32 *)CC_CONFDATA = data;
+}
+void setup_ITE_IVR_flash()
+{
+		__u32	size, base;
+
+		size = 0x0e000000;		// 32MB byte
+		base = (0x08000000) >> 8 >>1; // Bug: we must shift one more bit
+
+		/* need to set ITE flash to 32 bits instead of default 8 */
+#ifdef CONFIG_MIPS_IVR
+		*(__u32 *)CC_FC_FCR = 0x55;
+		*(__u32 *)CC_GPACR = 0xfffc;
+#else
+		*(__u32 *)CC_FC_FCR = 0x77;
+#endif
+		/* turn bursting off */
+		*(__u32 *)CC_FC_DCR = 0x0;
+
+		/* setup for one chip 4 byte PCI access */
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x60, size | base);
+		PCISetULongByOffset(CC_M68K_DEVICE, CC_M68K_FUNCTION, 0x64, 0x02);
+}
+#endif /* defined(CONFIG_MIPS_ITE8172) || defined(CONFIG_MIPS_IVR) */
+
+module_init(init_cstm_cfi_jedec);
+module_exit(cleanup_cstm_cfi_jedec);
diff -Naur linux-2.4.2.orig/drivers/mtd/dbox2-flash.c linux-2.4.2/drivers/mtd/dbox2-flash.c
--- linux-2.4.2.orig/drivers/mtd/dbox2-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/dbox2-flash.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,131 @@
+/*
+ * $Id: dbox2-flash.c,v 1.11 2001/03/17 19:08:45 dwmw2 Exp $
+ *
+ * Normal mappings of chips in physical memory
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x800000
+
+static struct mtd_info *mymtd;
+
+__u8 dbox2_flash_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 dbox2_flash_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 dbox2_flash_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void dbox2_flash_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void dbox2_flash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dbox2_flash_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info dbox2_flash_map = {
+	name: "Physically mapped flash",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: dbox2_flash_read8,
+	read16: dbox2_flash_read16,
+	read32: dbox2_flash_read32,
+	copy_from: dbox2_flash_copy_from,
+	write8: dbox2_flash_write8,
+	write16: dbox2_flash_write16,
+	write32: dbox2_flash_write32,
+	copy_to: dbox2_flash_copy_to
+};
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_dbox2_flash init_module
+#define cleanup_dbox2_flash cleanup_module
+#endif
+
+mod_init_t init_dbox2_flash(void)
+{
+       	printk(KERN_NOTICE "Nokia / Sagem flash driver (mem->0x%X size->0x%X)\n", WINDOW_SIZE, WINDOW_ADDR);
+	dbox2_flash_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dbox2_flash_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	// Probe for Nokia / Sagem with 2x Intel 28F320 or 2x AMD
+	mymtd = do_cfi_probe(&dbox2_flash_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		add_mtd_device(mymtd);
+		return 0;
+	}
+
+	// Probe for Sagem with Intel 28F640
+	dbox2_flash_map.buswidth = 2;
+	
+	mymtd = do_cfi_probe(&dbox2_flash_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		add_mtd_device(mymtd);
+		return 0;
+	}
+
+	iounmap((void *)dbox2_flash_map.map_priv_1);
+	return -ENXIO;
+}
+
+mod_exit_t cleanup_dbox2_flash(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dbox2_flash_map.map_priv_1) {
+		iounmap((void *)dbox2_flash_map.map_priv_1);
+		dbox2_flash_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dbox2_flash);
+module_exit(cleanup_dbox2_flash);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/dc21285.c linux-2.4.2/drivers/mtd/dc21285.c
--- linux-2.4.2.orig/drivers/mtd/dc21285.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/dc21285.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,193 @@
+/*
+ * MTD map driver for flash on the DC21285 (the StrongARM-110 companion chip)
+ *
+ * (C) 2000  Nicolas Pitre <nico@cam.org>
+ *
+ * This code is GPL
+ * 
+ * $Id: dc21285.c,v 1.3 2001/03/17 17:10:21 dwmw2 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/hardware/dec21285.h>
+
+
+static struct mtd_info *mymtd;
+
+__u8 dc21285_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8*)(map->map_priv_1 + ofs);
+}
+
+__u16 dc21285_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16*)(map->map_priv_1 + ofs);
+}
+
+__u32 dc21285_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32*)(map->map_priv_1 + ofs);
+}
+
+void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void*)(map->map_priv_1 + from), len);
+}
+
+void dc21285_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr;
+	adr &= ~3;
+	*(__u8*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*CSR_ROMWRITEREG = adr;
+	adr &= ~1;
+	*(__u16*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32*)(map->map_priv_1 + adr) = d;
+}
+
+void dc21285_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	switch (map->buswidth) {
+		case 4:
+			while (len > 0) {
+				__u32 d = *((__u32*)from)++;
+				dc21285_write32(map, d, to);
+				to += 4;
+				len -= 4;
+			}
+			break;
+		case 2:
+			while (len > 0) {
+				__u16 d = *((__u16*)from)++;
+				dc21285_write16(map, d, to);
+				to += 2;
+				len -= 2;
+			}
+			break;
+		case 1:
+			while (len > 0) {
+				__u8 d = *((__u8*)from)++;
+				dc21285_write8(map, d, to);
+				to++;
+				len--;
+			}
+			break;
+	}
+}
+
+struct map_info dc21285_map = {
+	name: "DC21285 flash",
+	size: 16*1024*1024,
+	read8: dc21285_read8,
+	read16: dc21285_read16,
+	read32: dc21285_read32,
+	copy_from: dc21285_copy_from,
+	write8: dc21285_write8,
+	write16: dc21285_write16,
+	write32: dc21285_write32,
+	copy_to: dc21285_copy_to
+};
+
+
+/* Partition stuff */
+static struct mtd_partition *dc21285_parts;
+		      
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+
+int __init init_dc21285(void)
+{
+	/* Determine buswidth */
+	switch (*CSR_SA110_CNTL & (3<<14)) {
+		case SA110_CNTL_ROMWIDTH_8: 
+			dc21285_map.buswidth = 1;
+			break;
+		case SA110_CNTL_ROMWIDTH_16: 
+			dc21285_map.buswidth = 2; 
+			break;
+		case SA110_CNTL_ROMWIDTH_32: 
+			dc21285_map.buswidth = 4; 
+			break;
+		default:
+			printk (KERN_ERR "DC21285 flash: undefined buswidth\n");
+			return -ENXIO;
+	}
+	printk (KERN_NOTICE "DC21285 flash support (%d-bit buswidth)\n",
+		dc21285_map.buswidth*8);
+
+	/* Let's map the flash area */
+	dc21285_map.map_priv_1 = (unsigned long)__ioremap(DC21285_FLASH, 16*1024*1024, 0);
+	if (!dc21285_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	mymtd = do_cfi_probe(&dc21285_map);
+	if (mymtd) {
+		int nrparts;
+
+		mymtd->module = THIS_MODULE;
+			
+		/* partition fixup */
+
+		nrparts = parse_redboot_partitions(mymtd, &dc21285_parts);
+		if (nrparts <=0) {
+			printk(KERN_NOTICE "RedBoot partition table failed\n");
+			iounmap((void *)dc21285_map.map_priv_1);
+			return -ENXIO;
+		}
+
+		add_mtd_partitions(mymtd, dc21285_parts, nrparts);
+
+		/* 
+		 * Flash timing is determined with bits 19-16 of the
+		 * CSR_SA110_CNTL.  The value is the number of wait cycles, or
+		 * 0 for 16 cycles (the default).  Cycles are 20 ns.
+		 * Here we use 7 for 140 ns flash chips.
+		 */
+		/* access time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x000f0000) | (7 << 16));
+		/* burst time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x00f00000) | (7 << 20));
+		/* tristate time */
+		*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x0f000000) | (7 << 24));
+
+		return 0;
+	}
+
+	iounmap((void *)dc21285_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dc21285(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+		mymtd = NULL;
+	}
+	if (dc21285_map.map_priv_1) {
+		iounmap((void *)dc21285_map.map_priv_1);
+		dc21285_map.map_priv_1 = 0;
+	}
+	if(dc21285_parts)
+		kfree(dc21285_parts);
+}
+
+module_init(init_dc21285);
+module_exit(cleanup_dc21285);
diff -Naur linux-2.4.2.orig/drivers/mtd/doc1000.c linux-2.4.2/drivers/mtd/doc1000.c
--- linux-2.4.2.orig/drivers/mtd/doc1000.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc1000.c	Thu Jan 10 18:30:47 2002
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: doc1000.c,v 1.11 2000/11/24 13:43:16 dwmw2 Exp $
+  $Id: doc1000.c,v 1.12 2000/11/27 08:50:21 dwmw2 Exp $
 
 ======================================================================*/
 
@@ -12,7 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -286,9 +286,9 @@
 static inline int byte_write (volatile u_char *addr, u_char byte)
 {
 	register u_char status;
- 	register u_short i = 0;
-  	
- 	do {
+	register u_short i = 0;
+	
+	do {
 		status = readb(addr);
 		if (status & CSR_WR_READY)
 		{
@@ -510,7 +510,7 @@
 
 }
 
-#if defined (MODULE) && LINUX_VERSION_CODE < 0x20211
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_doc1000 init_module
 #define cleanup_doc1000 cleanup_module
 #endif
@@ -591,7 +591,5 @@
 	kfree(mymtd);
 }
 
-#if LINUX_VERSION_CODE >= 0x20211
 module_init(init_doc1000);
 module_exit(cleanup_doc1000);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/doc2000.c linux-2.4.2/drivers/mtd/doc2000.c
--- linux-2.4.2.orig/drivers/mtd/doc2000.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc2000.c	Thu Jan 10 18:30:47 2002
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.39 2000/12/01 17:34:29 dwmw2 Exp $
+ * $Id: doc2000.c,v 1.41 2001/03/17 17:10:21 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -15,7 +15,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
@@ -719,6 +719,13 @@
 		WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
 	}
 
+	/* according to 11.4.1, we need to wait for the busy line 
+         * drop if we read to the end of the page.  */
+	if(0 == ((from + *retlen) & 0x1ff))
+	{
+	    DoC_WaitReady(this);
+	}
+
 	return ret;
 }
 
@@ -931,7 +938,10 @@
 	DoC_ReadBuf(this, &buf[len256], len - len256);
 
 	*retlen = len;
-	return 0;
+	/* Reading the full OOB data drops us off of the end of the page,
+         * causing the flash device to go into busy mode, so we need
+         * to wait until ready 11.4.1 and Toshiba TC58256FT docs */
+	return DoC_WaitReady(this);
 
 }
 
@@ -1028,13 +1038,13 @@
 int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
-	unsigned long ofs = instr->addr;
-	unsigned long len = instr->len;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
 	unsigned long docptr;
 	struct Nand *mychip;
 
 	if (len != mtd->erasesize)
-		printk(KERN_WARNING "Erase not right size (%lx != %lx)n",
+		printk(KERN_WARNING "Erase not right size (%x != %x)n",
 		       len, mtd->erasesize);
 
 	docptr = this->virtadr;
diff -Naur linux-2.4.2.orig/drivers/mtd/doc2001.c linux-2.4.2/drivers/mtd/doc2001.c
--- linux-2.4.2.orig/drivers/mtd/doc2001.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/doc2001.c	Thu Jan 10 18:30:47 2002
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001.c,v 1.24 2000/12/01 13:11:02 dwmw2 Exp $
+ * $Id: doc2001.c,v 1.25 2001/03/17 17:10:21 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -15,7 +15,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
@@ -789,13 +789,13 @@
 {
 	volatile char dummy;
 	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long ofs = instr->addr;
-	unsigned long len = instr->len;
+	__u32 ofs = instr->addr;
+	__u32 len = instr->len;
 	unsigned long docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	if (len != mtd->erasesize) 
-		printk(KERN_WARNING "Erase not right size (%lx != %lx)n",
+		printk(KERN_WARNING "Erase not right size (%x != %x)n",
 		       len, mtd->erasesize);
 
 	/* Find the chip which is to be used and select it */
@@ -829,7 +829,7 @@
 	dummy = ReadDOC(docptr, CDSNSlowIO);
 	DoC_Delay(docptr, 2);
 	if (ReadDOC(docptr, Mil_CDSN_IO) & 1) {
-		printk("Error Erasing at 0x%lx\n", ofs);
+		printk("Error Erasing at 0x%x\n", ofs);
 		/* There was an error
 		   FIXME: implement Bad Block Replacement (in nftl.c ??) */
 		instr->state = MTD_ERASE_FAILED;
diff -Naur linux-2.4.2.orig/drivers/mtd/docecc.c linux-2.4.2/drivers/mtd/docecc.c
--- linux-2.4.2.orig/drivers/mtd/docecc.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/docecc.c	Thu Jan 10 18:30:47 2002
@@ -31,7 +31,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/docprobe.c linux-2.4.2/drivers/mtd/docprobe.c
--- linux-2.4.2.orig/drivers/mtd/docprobe.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/docprobe.c	Thu Jan 10 18:30:47 2002
@@ -41,7 +41,6 @@
 */
 #define DOC_SINGLE_DRIVER
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -50,7 +49,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/elan-104nc.c linux-2.4.2/drivers/mtd/elan-104nc.c
--- linux-2.4.2.orig/drivers/mtd/elan-104nc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/elan-104nc.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,277 @@
+/* elan-104nc.c -- MTD map driver for Arcom Control Systems ELAN-104NC
+ 
+   Copyright (C) 2000 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: elan-104nc.c,v 1.8 2001/03/17 16:25:24 dwmw2 Exp $
+
+The ELAN-104NC has up to 8 Mibyte of Intel StrataFlash (28F320/28F640) in x16
+mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   32 kbyte memory window at 0xb0000-0xb7fff
+   
+   16 bit I/O port (0x22) for some sort of paging.
+
+The single flash device is divided into 3 partition which appear as seperate
+MTD devices.
+
+Linux thinks that the I/O port is used by the PIC and hence check_region() will
+always fail.  So we don't do it.  I just hope it doesn't break anything.
+*/
+#include <linux/module.h>
+#include <linux/malloc.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_START 0xb0000
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 15
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x22
+#define PAGE_IO_SIZE 2
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t elan_104nc_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "ELAN-104NC flash boot partition", 
+      offset: 0, 
+      size: 640*1024 },
+    { name: "ELAN-104NC flash partition 1", 
+      offset: 640*1024, 
+      size: 896*1024 },
+    { name: "ELAN-104NC flash partition 2", 
+      offset: (640+896)*1024 }
+};
+#define NUM_PARTITIONS (sizeof(partition_info)/sizeof(partition_info[0]))
+
+/*
+ * If no idea what is going on here.  This is taken from the FlashFX stuff.
+ */
+#define ROMCS 1
+
+static inline void elan_104nc_setup(void)
+{
+    u16 t;
+
+    outw( 0x0023 + ROMCS*2, PAGE_IO );
+    t=inb( PAGE_IO+1 );
+
+    t=(t & 0xf9) | 0x04;
+
+    outw( ((0x0023 + ROMCS*2) | (t << 8)), PAGE_IO );
+}
+
+static inline void elan_104nc_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+       
+	if( page!=page_in_window ) {
+		int cmd1;
+		int cmd2;
+
+		cmd1=(page & 0x700) + 0x0833 + ROMCS*0x4000;
+		cmd2=((page & 0xff) << 8) + 0x0032;
+
+		outw( cmd1, PAGE_IO );
+		outw( cmd2, PAGE_IO );
+
+		page_in_window = page;
+	}
+}
+
+
+static __u8 elan_104nc_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u16 elan_104nc_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static __u32 elan_104nc_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+	return ret;
+}
+
+static void elan_104nc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&elan_104nc_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void elan_104nc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&elan_104nc_spin);
+	elan_104nc_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&elan_104nc_spin);
+}
+
+static void elan_104nc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&elan_104nc_spin);
+		elan_104nc_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&elan_104nc_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info elan_104nc_map = {
+	name: "ELAN-104NC flash",
+	size: 8*1024*1024, /* this must be set to a maximum possible amount
+			of flash so the cfi probe routines find all
+			the chips */
+	buswidth: 2,
+	read8: elan_104nc_read8,
+	read16: elan_104nc_read16,
+	read32: elan_104nc_read32,
+	copy_from: elan_104nc_copy_from,
+	write8: elan_104nc_write8,
+	write16: elan_104nc_write16,
+	write32: elan_104nc_write32,
+	copy_to: elan_104nc_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_elan_104nc init_module
+#define cleanup_elan_104nc cleanup_module
+#endif
+
+mod_exit_t cleanup_elan_104nc(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+mod_init_t init_elan_104nc(void)
+{
+	/* Urg! We use I/O port 0x22 without request_region()ing it */
+	/*
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			elan_104nc_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+	*/
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			elan_104nc_map.name );
+		return -EIO;
+	}
+
+	/*
+	request_region( PAGE_IO, PAGE_IO_SIZE, "ELAN-104NC flash" );
+	*/
+
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		elan_104nc_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	elan_104nc_setup();
+
+	/* Probe for chip. */
+	all_mtd = do_cfi_probe( &elan_104nc_map );
+	if( !all_mtd ) {
+		cleanup_elan_104nc();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions( all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_elan_104nc);
+module_exit(cleanup_elan_104nc);
diff -Naur linux-2.4.2.orig/drivers/mtd/ftl.c linux-2.4.2/drivers/mtd/ftl.c
--- linux-2.4.2.orig/drivers/mtd/ftl.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/ftl.c	Thu Jan 10 18:30:47 2002
@@ -1,10 +1,6 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- *
- * - Based on Id: ftl.c,v 1.21 2000/08/01 13:07:49 dwmw2 Exp
- * - With the Franz Galiana's set_bam_entry fix from v1.23
- * - Perhaps it's about time I made a branch for the 2.4 series.
-
- * Originally based on:
+ * $Id: ftl.c,v 1.28 2001/03/17 17:10:21 dwmw2 Exp $
+ * Based on:
  */
 /*======================================================================
 
@@ -30,7 +26,7 @@
     are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
 
     Alternatively, the contents of this file may be used under the
-    terms of the GNU General Public License version 2 (the "GPL"), in which
+    terms of the GNU Public License version 2 (the "GPL"), in which
     case the provisions of the GPL are applicable instead of the
     above.  If you wish to allow the use of your version of this file
     only under the terms of the GPL and not to allow others to use
@@ -55,11 +51,6 @@
     contact M-Systems (http://www.m-sys.com) directly.
       
 ======================================================================*/
-#define FTL_DEBUG 5
-#ifdef FTL_DEBUG
-#define DEBUGLVL debug
-#endif
-
 #include <linux/module.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/mtd.h>
@@ -68,7 +59,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -108,19 +99,16 @@
 /*====================================================================*/
 
 /* Parameters that can be set with 'insmod' */
-
-/* Major device # for FTL device */
 static int shuffle_freq = 50;
-
 MODULE_PARM(shuffle_freq, "i");
 
 /*====================================================================*/
 
+/* Major device # for FTL device */
 #ifndef FTL_MAJOR
 #define FTL_MAJOR	44
 #endif
 
-
 /* Funky stuff for setting up a block device */
 #define MAJOR_NR		FTL_MAJOR
 #define DEVICE_NAME		"ftl"
@@ -135,17 +123,8 @@
 
 #include <linux/blk.h>
 
-#ifdef FTL_DEBUG
-static int debug = FTL_DEBUG;
-MODULE_PARM(debug, "i");
-#endif
-
 /*====================================================================*/
 
-#ifndef FTL_MAJOR
-#define FTL_MAJOR	44
-#endif
-
 /* Maximum number of separate memory devices we'll allow */
 #define MAX_DEV		4
 
@@ -296,7 +275,7 @@
 	return -1;
     }
     if ((1 << header.EraseUnitSize) != part->mtd->erasesize) {
-	printk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %lx\n",
+	printk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %x\n",
 	       1 << header.EraseUnitSize,part->mtd->erasesize);
 	return -1;
     }
@@ -429,7 +408,7 @@
     struct erase_info *erase;
 
     xfer = &part->XferInfo[xfernum];
-    DEBUG(1, "ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);
+    DEBUG(MTD_DEBUG_LEVEL1, "ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);
     xfer->state = XFER_ERASING;
 
     /* Is there a free erase slot? Always in MTD. */
@@ -504,7 +483,7 @@
     xfer = &part->XferInfo[i];
     xfer->state = XFER_FAILED;
     
-    DEBUG(1, "ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
+    DEBUG(MTD_DEBUG_LEVEL1, "ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
 
     /* Write the transfer unit header */
     header = part->header;
@@ -565,7 +544,7 @@
 
     eun = &part->EUNInfo[srcunit];
     xfer = &part->XferInfo[xferunit];
-    DEBUG(2, "ftl_cs: copying block 0x%x to 0x%x\n",
+    DEBUG(MTD_DEBUG_LEVEL2, "ftl_cs: copying block 0x%x to 0x%x\n",
 	  eun->Offset, xfer->Offset);
 	
     
@@ -698,8 +677,8 @@
     u_int32_t best;
     int queued, ret;
 
-    DEBUG(0, "ftl_cs: reclaiming space...\n");
-    DEBUG(4, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
+    DEBUG(MTD_DEBUG_LEVEL0, "ftl_cs: reclaiming space...\n");
+    DEBUG(MTD_DEBUG_LEVEL3, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
     /* Pick the least erased transfer unit */
     best = 0xffffffff; xfer = 0xffff;
     do {
@@ -707,22 +686,22 @@
 	for (i = 0; i < part->header.NumTransferUnits; i++) {
 	    int n=0;
 	    if (part->XferInfo[i].state == XFER_UNKNOWN) {
-		DEBUG(4,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
+		DEBUG(MTD_DEBUG_LEVEL3,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
 		n=1;
 		erase_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_ERASING) {
-		DEBUG(4,"XferInfo[%d].state == XFER_ERASING\n",i);
+		DEBUG(MTD_DEBUG_LEVEL3,"XferInfo[%d].state == XFER_ERASING\n",i);
 		n=1;
 		queued = 1;
 	    }
 	    else if (part->XferInfo[i].state == XFER_ERASED) {
-		DEBUG(4,"XferInfo[%d].state == XFER_ERASED\n",i);
+		DEBUG(MTD_DEBUG_LEVEL3,"XferInfo[%d].state == XFER_ERASED\n",i);
 		n=1;
 		prepare_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_PREPARED) {
-		DEBUG(4,"XferInfo[%d].state == XFER_PREPARED\n",i);
+		DEBUG(MTD_DEBUG_LEVEL3,"XferInfo[%d].state == XFER_PREPARED\n",i);
 		n=1;
 		if (part->XferInfo[i].EraseCount <= best) {
 		    best = part->XferInfo[i].EraseCount;
@@ -730,12 +709,12 @@
 		}
 	    }
 		if (!n)
-		    DEBUG(4,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
+		    DEBUG(MTD_DEBUG_LEVEL3,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
 
 	}
 	if (xfer == 0xffff) {
 	    if (queued) {
-		DEBUG(1, "ftl_cs: waiting for transfer "
+		DEBUG(MTD_DEBUG_LEVEL1, "ftl_cs: waiting for transfer "
 		      "unit to be prepared...\n");
 		if (part->mtd->sync)
 			part->mtd->sync(part->mtd);
@@ -745,7 +724,7 @@
 		    printk(KERN_NOTICE "ftl_cs: reclaim failed: no "
 			   "suitable transfer units!\n");
 		else
-		    DEBUG(1, "ftl_cs: reclaim failed: no "
+		    DEBUG(MTD_DEBUG_LEVEL1, "ftl_cs: reclaim failed: no "
 			  "suitable transfer units!\n");
 			
 		return -EIO;
@@ -755,7 +734,7 @@
 
     eun = 0;
     if ((jiffies % shuffle_freq) == 0) {
-	DEBUG(1, "ftl_cs: recycling freshest block...\n");
+	DEBUG(MTD_DEBUG_LEVEL1, "ftl_cs: recycling freshest block...\n");
 	best = 0xffffffff;
 	for (i = 0; i < part->DataUnits; i++)
 	    if (part->EUNInfo[i].EraseCount <= best) {
@@ -775,7 +754,7 @@
 		printk(KERN_NOTICE "ftl_cs: reclaim failed: "
 		       "no free blocks!\n");
 	    else
-		DEBUG(1,"ftl_cs: reclaim failed: "
+		DEBUG(MTD_DEBUG_LEVEL1,"ftl_cs: reclaim failed: "
 		       "no free blocks!\n");
 
 	    return -EIO;
@@ -860,7 +839,7 @@
 	printk(KERN_NOTICE "ftl_cs: bad free list!\n");
 	return 0;
     }
-    DEBUG(2, "ftl_cs: found free block at %d in %d\n", blk, eun);
+    DEBUG(MTD_DEBUG_LEVEL2, "ftl_cs: found free block at %d in %d\n", blk, eun);
     return blk;
     
 } /* find_free */
@@ -904,7 +883,7 @@
             return -EROFS;
     }
     
-    DEBUG(0, "ftl_cs: ftl_open(%d)\n", minor);
+    DEBUG(MTD_DEBUG_LEVEL0, "ftl_cs: ftl_open(%d)\n", minor);
 
     atomic_inc(&partition->open);
 
@@ -922,7 +901,7 @@
     partition_t *part = myparts[minor >> 4];
     int i;
     
-    DEBUG(0, "ftl_cs: ftl_close(%d)\n", minor);
+    DEBUG(MTD_DEBUG_LEVEL0, "ftl_cs: ftl_close(%d)\n", minor);
 
     /* Flush all writes */
     fsync_dev(inode->i_rdev);
@@ -962,7 +941,7 @@
     int ret;
     size_t offset, retlen;
     
-    DEBUG(2, "ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
+    DEBUG(MTD_DEBUG_LEVEL2, "ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
 	  part, sector, nblocks);
     if (!(part->state & FTL_FORMATTED)) {
 	printk(KERN_NOTICE "ftl_cs: bad partition\n");
@@ -1011,7 +990,7 @@
     int ret;
     size_t retlen, offset;
 
-    DEBUG(2, "ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",
+    DEBUG(MTD_DEBUG_LEVEL2, "ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",
 	  part, log_addr, virt_addr);
     bsize = 1 << part->header.EraseUnitSize;
     eun = log_addr / bsize;
@@ -1076,7 +1055,7 @@
     int ret;
     size_t retlen, offset;
 
-    DEBUG(2, "ftl_cs: ftl_write(0x%p, %ld, %ld)\n",
+    DEBUG(MTD_DEBUG_LEVEL2, "ftl_cs: ftl_write(0x%p, %ld, %ld)\n",
 	  part, sector, nblocks);
     if (!(part->state & FTL_FORMATTED)) {
 	printk(KERN_NOTICE "ftl_cs: bad partition\n");
@@ -1220,16 +1199,24 @@
     partition_t *part = myparts[minor >> 4];
     int i, whole;
 
-    DEBUG(0, "ftl_cs: ftl_reread_partition(%d)\n", minor);
+    DEBUG(MTD_DEBUG_LEVEL0, "ftl_cs: ftl_reread_partition(%d)\n", minor);
     if ((atomic_read(&part->open) > 1)) {
-	    return -EBUSY;
+	return -EBUSY;
     }
     whole = minor & ~(MAX_PART-1);
 
-    for (i = 0; i < MAX_PART; i++) {
+    i = MAX_PART - 1;
+    while (i-- > 0) {
 	if (ftl_hd[whole+i].nr_sects > 0) {
 	    kdev_t rdev = MKDEV(FTL_MAJOR, whole+i);
+#if LINUX_VERSION_CODE > 0x20200
+	    struct super_block *sb = get_super(rdev);
+#endif
 	    sync_dev(rdev);
+#if LINUX_VERSION_CODE > 0x20200
+	    if (sb) 
+		invalidate_inodes(sb);
+#endif
 	    invalidate_buffers(rdev);
 	}
 	ftl_hd[whole+i].start_sect = 0;
@@ -1402,13 +1389,10 @@
 		}
 }
 
-
-#if LINUX_VERSION_CODE < 0x20300
-#ifdef MODULE
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_ftl init_module
 #define cleanup_ftl cleanup_module
 #endif
-#endif
 
 mod_init_t init_ftl(void)
 {
@@ -1416,6 +1400,8 @@
 
     memset(myparts, 0, sizeof(myparts));
     
+    DEBUG(MTD_DEBUG_LEVEL0, "$Id: ftl.c,v 1.28 2001/03/17 17:10:21 dwmw2 Exp $\n");
+    
     if (register_blkdev(FTL_MAJOR, "ftl", &ftl_blk_fops)) {
 	printk(KERN_NOTICE "ftl_cs: unable to grab major "
 	       "device number!\n");
@@ -1456,7 +1442,5 @@
 	}
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_ftl);
 module_exit(cleanup_ftl);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/initcalls.c linux-2.4.2/drivers/mtd/initcalls.c
--- linux-2.4.2.orig/drivers/mtd/initcalls.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/initcalls.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,123 @@
+/*
+ * $Id: initcalls.c,v 1.3 2001/03/26 20:08:19 kd Exp $
+ *
+ * Init calls for MTD drivers in kernels < 2.2.18
+ * Split off into a separate file so they don't pollute
+ * the 2.4 and 2.2.18+ versions.
+ */
+#include <linux/config.h>
+
+extern int init_doc1000(void);
+extern int init_doc2000(void);
+extern int init_doc2001(void);
+extern int init_doc(void);
+extern int cfi_probe_init(void);
+extern int cfi_intelext_init(void);
+extern int cfi_amdstd_init(void);
+extern int map_rom_init(void);
+extern int map_rom_init(void);
+extern int init_physmap(void);
+extern int init_rpxlite(void);
+extern int init_octagon5066(void);
+extern int init_pnc2000(void);
+extern int init_vmax301(void);
+extern int init_mixmem(void);
+extern int init_pmc551(void);
+extern int init_nora(void);
+extern int init_sbc_mediagx(void);
+extern int init_elan_104nc(void);
+extern int spia_init(void);
+extern int init_mtdram(void);
+extern int init_ftl(void);
+extern int init_nftl(void);
+extern int init_mtdblock(void);
+extern int init_mtdchar(void);
+extern int init_flagadm(void);
+
+void init_mtd_devices(void)
+{
+	/* Shedloads of calls to init functions of all the
+	 * other drivers and users of MTD, which we can
+	 * ditch in 2.2.18 because of the sexy new way of
+	 * finding init routines.
+	 */
+#ifdef CONFIG_MTD_DOC1000
+	init_doc1000();
+#endif
+#ifdef CONFIG_MTD_DOC2000
+	init_doc2000();
+#endif
+#ifdef CONFIG_MTD_DOC2001
+	init_doc2001();
+#endif
+#ifdef CONFIG_MTD_DOCPROBE
+	init_doc();
+#endif
+#ifdef CONFIG_MTD_CFI
+	cfi_probe_init();
+#endif
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	cfi_intelext_init();
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	cfi_amdstd_init();
+#endif
+#ifdef CONFIG_MTD_RAM
+	map_rom_init();
+#endif
+#ifdef CONFIG_MTD_ROM
+	map_rom_init();
+#endif
+#ifdef CONFIG_MTD_PHYSMAP
+	init_physmap();
+#endif
+#ifdef CONFIG_MTD_RPXLITE
+	init_rpxlite();
+#endif
+#ifdef CONFIG_MTD_OCTAGON
+	init_octagon5066();
+#endif
+#ifdef CONFIG_MTD_PNC2000
+	init_pnc2000();
+#endif
+#ifdef CONFIG_MTD_VMAX
+	init_vmax301();
+#endif
+#ifdef CONFIGF_MTD_MIXMEM
+	init_mixmem();
+#endif
+#ifdef CONFIG_MTD_PMC551
+	init_pmc551();
+#endif
+#ifdef CONFIG_MTD_NORA
+	init_nora();
+#endif
+#ifdef CONFIG_MTD_SBC_MEDIAGX
+	init_sbc_mediagx();
+#endif
+#ifdef CONFIG_MTD_ELAN_104NC
+	init_elan_104nc();
+#endif
+#ifdef CONFIG_MTD_NAND_SPIA
+	spia_init();
+#endif
+#ifdef CONFIG_MTD_MTDRAM
+	init_mtdram();
+#endif
+#ifdef CONFIG_FTL
+	init_ftl();
+#endif
+#ifdef CONFIG_NFTL
+	init_nftl();
+#endif
+#if defined(CONFIG_MTD_BLOCK) || defined(CONFIG_MTD_BLOCK_RO)
+	init_mtdblock();
+#endif
+#ifdef CONFIG_MTD_CHAR
+	init_mtdchar();
+#endif
+#ifdef CONFIG_MTD_FLAGADM
+	init_flagadm();
+#endif
+}
+
diff -Naur linux-2.4.2.orig/drivers/mtd/iq80310.c linux-2.4.2/drivers/mtd/iq80310.c
--- linux-2.4.2.orig/drivers/mtd/iq80310.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/iq80310.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,134 @@
+/*
+ * $Id: iq80310.c,v 1.2 2001/03/26 18:08:44 nico Exp $
+ *
+ * Mapping for the Intel XScale IQ80310 evaluation board
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 	0
+#define WINDOW_SIZE 	8*1024*1024
+#define BUSWIDTH 	1
+
+static struct mtd_info *mymtd;
+
+static __u8 iq80310_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 iq80310_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 iq80310_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void iq80310_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void iq80310_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void iq80310_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info iq80310_map = {
+	name: "IQ80310 flash",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8:		iq80310_read8,
+	read16:		iq80310_read16,
+	read32:		iq80310_read32,
+	copy_from:	iq80310_copy_from,
+	write8:		iq80310_write8,
+	write16:	iq80310_write16,
+	write32:	iq80310_write32,
+	copy_to:	iq80310_copy_to
+};
+
+static struct mtd_partition iq80310_partitions[3] = {
+	{
+		name:		"firmware",
+		size:		0x00080000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE  /* force read-only */
+	},{
+		name:		"kernel",
+		size:		0x00080000,
+		offset:		0x00080000,
+	},{
+		name:		"filesystem",
+		size:		0x00700000,
+		offset:		0x00100000
+	}
+};
+
+static int __init init_iq80310(void)
+{
+	iq80310_map.map_priv_1 = (unsigned long)__ioremap(WINDOW_ADDR, WINDOW_SIZE, 0);
+
+	if (!iq80310_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_cfi_probe(&iq80310_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, iq80310_partitions, 3);
+		return 0;
+	}
+
+	iounmap((void *)iq80310_map.map_priv_1);
+	return -ENXIO;
+}
+
+static int __exit cleanup_iq80310(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (iq80310_map.map_priv_1) {
+		iounmap((void *)iq80310_map.map_priv_1);
+		iq80310_map.map_priv_1 = 0;
+	}
+	return 0;
+}
+
+module_init(init_iq80310);
+module_exit(cleanup_iq80310);
+
diff -Naur linux-2.4.2.orig/drivers/mtd/jedec.c linux-2.4.2/drivers/mtd/jedec.c
--- linux-2.4.2.orig/drivers/mtd/jedec.c	Tue Jul  4 19:10:05 2000
+++ linux-2.4.2/drivers/mtd/jedec.c	Thu Jan 10 18:30:47 2002
@@ -11,7 +11,7 @@
  * not going to guess how to send commands to them, plus I expect they will
  * all speak CFI..
  *
- * $Id: jedec.c,v 1.1 2000/07/04 07:21:57 jgg Exp $
+ * $Id: jedec.c,v 1.5 2001/03/01 15:05:14 cwryu Exp $
  */
 
 #include <linux/mtd/jedec.h>
@@ -28,15 +28,20 @@
 static int flash_erase(struct mtd_info *mtd, struct erase_info *instr);
 static int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
 		       size_t *retlen, const u_char *buf);
+
+static const char im_name[] = "jedec_probe";
    
-EXPORT_SYMBOL(jedec_probe);
+static unsigned long my_bank_size;
 
 /* Listing of parts and sizes. We need this table to learn the sector
    size of the chip and the total length */
 static const struct JEDECTable JEDEC_table[] = 
-  {{0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+  {{0x013D,"AMD Am29F017D",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {0x01A4,"AMD Am29F040",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x20E3,"AMD Am29W040B",512*1024,64*1024,MTD_CAP_NORFLASH},
+   {0xC2AD,"Macronix MX29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
    {}};
 
 static void jedec_sync(struct mtd_info *mtd) {};
@@ -46,8 +51,8 @@
 			     size_t *retlen, u_char *buf);
 
 /* Probe entry point */
-   struct jedec_private priv;
-   struct mtd_info __MTD;
+struct jedec_private priv;
+struct mtd_info __MTD;
 struct mtd_info *jedec_probe(struct map_info *map)
 {
    struct mtd_info *MTD = &__MTD;
@@ -58,26 +63,29 @@
    char Part[200];
    memset(&priv,0,sizeof(priv));
    
-   if (map->bank_size == 0)
-      map->bank_size = map->size;
+   my_bank_size = map->size;
 
-   if (map->size/map->bank_size > MAX_JEDEC_CHIPS)
+   if (map->size/my_bank_size > MAX_JEDEC_CHIPS)
    {
       printk("mtd: Increase MAX_JEDEC_CHIPS, too many banks.\n");
       return 0;
    }
    
-   for (Base = 0; Base < map->size; Base += map->bank_size)
+   for (Base = 0; Base < map->size; Base += my_bank_size)
    {
       // Perhaps zero could designate all tests?
-      if (map->bus_width == 0)
-	 map->bus_width = 8;
+      if (map->buswidth == 0)
+	 map->buswidth = 1;
       
-      if (map->bus_width == 8)
-	 jedec_probe8(map,Base,&priv);
-      if (map->bus_width == 16)
+      if (map->buswidth == 1){
+	 if (jedec_probe8(map,Base,&priv) == 0) {
+		 printk("did recognize jedec chip\n");
+	         return 0;
+	 }
+      }
+      if (map->buswidth == 2)
 	 jedec_probe16(map,Base,&priv);
-      if (map->bus_width == 32)
+      if (map->buswidth == 4)
 	 jedec_probe32(map,Base,&priv);
    }
    
@@ -85,6 +93,8 @@
    SectorSize = 0;
    for (I = 0; priv.chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
    {
+	   printk("priv.chips[%d].jedec is %x\n",I,priv.chips[I].jedec);
+	   printk("priv.chips[%d].sectorsize is %lx\n",I,priv.chips[I].sectorsize);
       if (priv.chips[I].sectorsize > SectorSize)
 	 SectorSize = priv.chips[I].sectorsize;
    }
@@ -141,34 +151,50 @@
       are empty banks. Note, the last bank does not count here, only the
       first banks are important. Holes on non-bank boundaries can not exist
       due to the way the detection algorithm works. */
-   if (priv.size < map->bank_size)
-      map->bank_size = priv.size;
+   if (priv.size < my_bank_size)
+      my_bank_size = priv.size;
    priv.is_banked = 0;
-   for (I = 0; I != priv.size/map->bank_size - 1; I++)
-   {
-      if (priv.bank_fill[I] != map->bank_size)
-	 priv.is_banked = 1;
-      
-      /* This even could be eliminated, but new de-optimized read/write
-         functions have to be written */
-      if (priv.bank_fill[I] != priv.bank_fill[0])
-      {
-	 printk("mtd: Failed. Cannot handle unsymetric banking\n");
-	 return 0;
-      }      
+   //printk("priv.size is %x, my_bank_size is %x\n",priv.size,my_bank_size);
+   //printk("priv.bank_fill[0] is %x\n",priv.bank_fill[0]);
+   if (!priv.size) {
+	   printk("priv.size is zero\n");
+	   return 0;
+   }
+   if (priv.size/my_bank_size) {
+	   if (priv.size/my_bank_size == 1) {
+		   priv.size = my_bank_size;
+	   }
+	   else {
+		   for (I = 0; I != priv.size/my_bank_size - 1; I++)
+		   {
+		      if (priv.bank_fill[I] != my_bank_size)
+			 priv.is_banked = 1;
+		      
+		      /* This even could be eliminated, but new de-optimized read/write
+			 functions have to be written */
+		      printk("priv.bank_fill[%d] is %lx, priv.bank_fill[0] is %lx\n",I,priv.bank_fill[I],priv.bank_fill[0]);
+		      if (priv.bank_fill[I] != priv.bank_fill[0])
+		      {
+			 printk("mtd: Failed. Cannot handle unsymetric banking\n");
+			 return 0;
+		      }      
+		   }
+	   }
    }
    if (priv.is_banked == 1)
       strcat(Part,", banked");
 
-   xprintf("Part: '%s'\n",Part);
+   printk("Part: '%s'\n",Part);
    
    memset(MTD,0,sizeof(*MTD));
-   strncpy(MTD->name,Part,sizeof(MTD->name));
-   MTD->name[sizeof(MTD->name)-1] = 0;
+  // strncpy(MTD->name,Part,sizeof(MTD->name));
+  // MTD->name[sizeof(MTD->name)-1] = 0;
    MTD->type = MTD_NORFLASH;
    MTD->flags = MTD_CAP_NORFLASH;
-   MTD->erasesize = SectorSize*(map->bus_width/8);
+   MTD->erasesize = SectorSize*(map->buswidth);
+   printk("MTD->erasesize is %x\n",(unsigned int)MTD->erasesize);
    MTD->size = priv.size;
+   printk("MTD->size is %x\n",(unsigned int)MTD->size);
    //MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
    MTD->erase = flash_erase;
    if (priv.is_banked == 1)
@@ -274,10 +300,10 @@
       for (Bank = Count; Bank != 1; Bank >>= 1, priv->chips[I].addrshift++);
       
       // Determine how filled this bank is.
-      Bank = base & (~(map->bank_size-1));
-      if (priv->bank_fill[Bank/map->bank_size] < base + 
+      Bank = base & (~(my_bank_size-1));
+      if (priv->bank_fill[Bank/my_bank_size] < base + 
 	  (JEDEC->size << priv->chips[I].addrshift) - Bank)
-	 priv->bank_fill[Bank/map->bank_size] =  base + (JEDEC->size << priv->chips[I].addrshift) - Bank;
+	 priv->bank_fill[Bank/my_bank_size] =  base + (JEDEC->size << priv->chips[I].addrshift) - Bank;
       I++;
    }
 
@@ -301,7 +327,53 @@
 int jedec_probe8(struct map_info *map,unsigned long base,
 		  struct jedec_private *priv)
 { 
-   return 0;
+   #define flread(x) map->read8(map,base+x)
+   #define flwrite(v,x) map->write8(map,v,base+x)
+
+   const unsigned long AutoSel1 = 0xAA;
+   const unsigned long AutoSel2 = 0x55;
+   const unsigned long AutoSel3 = 0x90;
+   const unsigned long Reset = 0xF0;
+   __u32 OldVal;
+   __u8 Mfg[1];
+   __u8 Id[1];
+   unsigned I;
+   unsigned long Size;
+
+   // Wait for any write/erase operation to settle
+   OldVal = flread(base);
+   for (I = 0; OldVal != flread(base) && I < 10000; I++)
+      OldVal = flread(base);
+   
+   // Reset the chip
+   flwrite(Reset,0x555); 
+   
+   // Send the sequence
+   flwrite(AutoSel1,0x555);
+   flwrite(AutoSel2,0x2AA);
+   flwrite(AutoSel3,0x555);
+   
+   //  Get the JEDEC numbers
+   Mfg[0] = flread(0);
+   Id[0] = flread(1);
+   printk("Mfg is %x, Id is %x\n",Mfg[0],Id[0]);
+      
+   Size = handle_jedecs(map,Mfg,Id,1,base,priv);
+   printk("handle_jedecs Size is %x\n",(unsigned int)Size);
+   if (Size == 0)
+   {
+      flwrite(Reset,0x555);
+      return 0;
+   }
+   
+
+   // Reset.
+   flwrite(Reset,0x555);
+   
+   return 1;
+   
+   #undef flread
+   #undef flwrite
 }
 
 // Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
@@ -321,7 +393,7 @@
    const unsigned long AutoSel1 = 0xAAAAAAAA;
    const unsigned long AutoSel2 = 0x55555555;
    const unsigned long AutoSel3 = 0x90909090;
-   const unsigned long Reset = 0x90909090;
+   const unsigned long Reset = 0xF0F0F0F0;
    __u32 OldVal;
    __u8 Mfg[4];
    __u8 Id[4];
@@ -370,7 +442,7 @@
       more flashes have a truncated address space the probe test will still
       work */
    if (base + Size+0x555 < map->size &&
-       base + Size+0x555 < (base & (~(map->bank_size-1))) + map->bank_size)
+       base + Size+0x555 < (base & (~(my_bank_size-1))) + my_bank_size)
    {
       if (flread(base+Size) != flread(base+Size + 0x100) ||
 	  flread(base+Size + 1) != flread(base+Size + 0x101))
@@ -418,7 +490,7 @@
 	 get = priv->bank_fill[0] - offset;
 
       bank /= priv->bank_fill[0];      
-      map->copy_from(map,buf + *retlen,bank*map->bank_size + offset,get);
+      map->copy_from(map,buf + *retlen,bank*my_bank_size + offset,get);
       
       len -= get;
       *retlen += get;
@@ -477,16 +549,9 @@
       if (chip->length == 0)
 	 continue;
       
-      // Send the erase setup code
-      xprintf("Erase: ");
-      puth(chip->start); putc(' ');
-      puth(chip->base); putc(' ');
-      puth(chip->length); putc(' ');
-      puth(chip->sectorsize); putc('\n');
-      
       if (chip->start + chip->length > chip->size)
       {
-	 xprintf("DIE\n");
+	 printk("DIE\n");
 	 return -EIO;
       }     
       
@@ -497,20 +562,10 @@
       flwrite(0xAA,chip->start + 0x555);
       flwrite(0x55,chip->start + 0x2AA);
 
-      // Use chip erase if possible
-      if (chip->start == 0 && chip->length == chip->size)
-      {
-	 flwrite(0x10,0x555);
-	 continue;
-      }
-            
       /* Once we start selecting the erase sectors the delay between each 
          command must not exceed 50us or it will immediately start erasing 
          and ignore the other sectors */
-/*    how do you portably turn off interrupts?
-      save_flags(flags);
-      cli();*/
-      for (off = 0; off < chip->length; off += chip->sectorsize)
+      for (off = 0; off < len; off += chip->sectorsize)
       {
 	 // Check to make sure we didn't timeout
 	 flwrite(0x30,chip->start + off);
@@ -522,7 +577,6 @@
 	    return -EIO;
 	 }       	 
       }
-//      restore_flags(flags);
    }   
 
    /* We could split this into a timer routine and return early, performing
@@ -560,7 +614,7 @@
 	 }	 
       }
 
-      xprintf("todo: %x %x %x %x\n",(short)todo[0],(short)todo[1],
+      printk("todo: %x %x %x %x\n",(short)todo[0],(short)todo[1],
 	      (short)todo[2],(short)todo[3]);
       
       while (1)
@@ -571,9 +625,23 @@
 	 /* During erase bit 7 is held low and bit 6 toggles, we watch this,
 	    should it stop toggling or go high then the erase is completed,
   	    or this is not really flash ;> */
-	 Last[0] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
-	 Last[1] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
-	 Last[2] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	 switch (map->buswidth) {
+	 case 1:
+	    Last[0] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 2:
+	    Last[0] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 case 3:
+	    Last[0] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[1] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    Last[2] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	    break;
+	 }
 	 Count = 3;
 	 while (todo_left != 0)
 	 {
@@ -604,12 +672,20 @@
 /*	    if (NoTime == 0)
 	       Time += HZ/10 - schedule_timeout(HZ/10);*/
 	    NoTime = 0;
-	    
-	    Last[Count % 4] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+
+	    switch (map->buswidth) {
+	    case 1:
+	       Last[Count % 4] = map->read8(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 2:
+	       Last[Count % 4] = map->read16(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    case 4:
+	       Last[Count % 4] = map->read32(map,(chip->base >> chip->addrshift) + chip->start + off);
+	      break;
+	    }
 	    Count++;
 	    
-	    putc('.');
-	    
 /*	    // Count time, max of 15s per sector (according to AMD)
 	    if (Time > 15*len/mtd->erasesize*HZ)
 	    {
@@ -618,8 +694,6 @@
 	    }	    */
 	 }
 	 	 
-	 puts("out\n");
-	    
 	 // Skip to the next chip if we used chip erase
 	 if (chip->length == chip->size)
 	    off = chip->size;
@@ -639,7 +713,9 @@
       }      
    }
        	    
-   puts("done\n");
+   //printk("done\n");
+   if (instr->callback)
+	instr->callback(instr);
    return 0;
    
    #undef flread
@@ -663,12 +739,14 @@
    struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
    unsigned long base;
    unsigned long off;
+   size_t save_len = len;
    
    if (start + len > mtd->size)
       return -EIO;
    
-   puts("Here");
+   //printk("Here");
    
+   //printk("flash_write: start is %x, len is %x\n",start,(unsigned long)len);
    while (len != 0)
    {
       struct jedec_flash_chip *chip = priv->chips;
@@ -676,16 +754,17 @@
       unsigned long boffset;
 	 
       // Compute the base of the flash.
-      off = start % (chip->size << chip->addrshift);
+      off = ((unsigned long)start) % (chip->size << chip->addrshift);
       base = start - off;
 
       // Perform banked addressing translation.
       bank = base & (~(priv->bank_fill[0]-1));
       boffset = base & (priv->bank_fill[0]-1);
-      bank = (bank/priv->bank_fill[0])*map->bank_size;
+      bank = (bank/priv->bank_fill[0])*my_bank_size;
       base = bank + boffset;
       
-      xprintf("Flasing %X %X %X\n",base,chip->size,len);
+    //  printk("Flasing %X %X %X\n",base,chip->size,len);
+     // printk("off is %x, compare with %x\n",off,chip->size << chip->addrshift);
       
       // Loop over this page
       for (; off != (chip->size << chip->addrshift) && len != 0; start++, len--, off++,buf++)
@@ -694,10 +773,10 @@
 	 unsigned char Last[4];
 	 unsigned long Count = 0;
 
-//	 putc('.');
-	 
-	 if (oldbyte == *buf)
+	 if (oldbyte == *buf) {
+	//	 printk("oldbyte and *buf is %x,len is %x\n",oldbyte,len);
 	    continue;
+	 }
 	 if (((~oldbyte) & *buf) != 0)
 	    printk("mtd: warn: Trying to set a 0 to a 1\n");
 	     
@@ -724,7 +803,7 @@
 	 }	 
       }
    }
-   *retlen = len;
+   *retlen = save_len;
    return 0;
 }
 
@@ -771,3 +850,21 @@
    }
 }
 									/*}}}*/
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define jedec_probe_init init_module
+#define jedec_probe_exit cleanup_module
+#endif
+
+int __init jedec_probe_init(void)
+{
+	inter_module_register(im_name, THIS_MODULE, &jedec_probe);
+	return 0;
+}
+
+static void __exit jedec_probe_exit(void)
+{
+	inter_module_unregister(im_name);
+}
+
+module_init(jedec_probe_init);
+module_exit(jedec_probe_exit);
diff -Naur linux-2.4.2.orig/drivers/mtd/map_ram.c linux-2.4.2/drivers/mtd/map_ram.c
--- linux-2.4.2.orig/drivers/mtd/map_ram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/map_ram.c	Thu Jan 10 18:30:47 2002
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple RAM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_ram.c,v 1.7 2000/12/10 01:39:13 dwmw2 Exp $
+ * $Id: map_ram.c,v 1.8 2000/12/18 00:03:26 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -10,7 +10,7 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 
@@ -60,7 +60,6 @@
 
 	memset(mtd, 0, sizeof(*mtd));
 
-	map->im_name = im_name;
 	map->fldrv_destroy = mapram_nop;
 	mtd->priv = map;
 	mtd->name = map->name;
diff -Naur linux-2.4.2.orig/drivers/mtd/map_rom.c linux-2.4.2/drivers/mtd/map_rom.c
--- linux-2.4.2.orig/drivers/mtd/map_rom.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/map_rom.c	Thu Jan 10 18:30:47 2002
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple ROM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_rom.c,v 1.10 2000/12/10 01:39:13 dwmw2 Exp $
+ * $Id: map_rom.c,v 1.12 2000/12/18 16:14:51 eauth Exp $
  */
 
 #include <linux/module.h>
@@ -10,7 +10,7 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #include <linux/mtd/map.h>
 
@@ -38,7 +38,6 @@
 
 	memset(mtd, 0, sizeof(*mtd));
 
-	map->im_name = im_name;
 	map->fldrv_destroy = maprom_nop;
 	mtd->priv = map;
 	mtd->name = map->name;
@@ -79,13 +78,13 @@
 #define map_rom_exit cleanup_module
 #endif
 
-static int __init map_rom_init(void)
+mod_init_t map_rom_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &map_rom_probe);
 	return 0;
 }
 
-static void __exit map_rom_exit(void)
+mod_exit_t map_rom_exit(void)
 {
 	inter_module_unregister(im_name);
 }
diff -Naur linux-2.4.2.orig/drivers/mtd/mapped.c linux-2.4.2/drivers/mtd/mapped.c
--- linux-2.4.2.orig/drivers/mtd/mapped.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/mapped.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,672 @@
+// Description                                                          /*{{{*/
+// $Id: mapped.c,v 1.10 2000/11/21 08:43:04 dwmw2 Exp $
+/* ######################################################################
+
+   Flash MTD Routines
+
+   These routine support IDing and manipulating flash. Currently the 
+   older JEDEC ID mechanism and a table is used for determining the
+   flash characterisitics, but it is trivial to add support for the
+   CFI specification:
+     http://www.pentium.com/design/flash/ in the technote section.
+   
+   ##################################################################### */
+									/*}}}*/
+#include <linux/mtd/mapped.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+struct JEDECTable mtd_JEDEC_table[] = 
+  {{0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
+   {}};
+
+// flash_setup - Setup the mapped_mtd_info structure for normal flash	/*{{{*/
+// ---------------------------------------------------------------------
+/* There is a set of commands that flash manufactures follow for getting the
+   JEDEC id, erasing and writing. So long as your flash device supports 
+   getting the JEDEC ID in this (standard?) way it will be supported as flash,
+   otherwise it is converted to ROM. Upon completion the structure is 
+   registered with the MTD layer */
+int mtd_mapped_setup(struct mapped_mtd_info *map)
+{
+   DEBUG(MTD_DEBUG_LEVEL1, "\n");
+   // Must define a page function to use the defaults!
+   if (map->page == 0)
+      return -1;
+   
+   if (map->jedec_sense == 0)
+      map->jedec_sense = flash_jedec;
+
+   if (map->jedec_sense(map) != 0)
+      return -1;
+
+   if (map->mtd.erase == 0 && map->mtd.type == MTD_NORFLASH)
+      map->mtd.erase = flash_erase;
+   if (map->mtd.write == 0)
+   {
+      if (map->mtd.type == MTD_NORFLASH)
+	 map->mtd.write = flash_write;
+      if (map->mtd.type == MTD_RAM)
+	 map->mtd.write = ram_write;      
+   }   
+   if (map->mtd.read == 0)
+      map->mtd.read = rom_read;   
+   
+   return add_mtd_device(&map->mtd);
+}
+									/*}}}*/
+// flash_remove - Remove the flash device from the MTD layer		/*{{{*/
+// ---------------------------------------------------------------------
+/* Free any memory allocated for the device here */
+int mtd_mapped_remove(struct mapped_mtd_info *map)
+{
+   return del_mtd_device(&map->mtd);
+}
+									/*}}}*/
+
+// checkparity - Checks a number for odd parity				/*{{{*/
+// ---------------------------------------------------------------------
+/* Helper for the JEDEC function, JEDEC numbers all have odd parity */
+static int checkparity(u_char C)
+{
+   u_char parity = 0;
+   while (C != 0)
+   {
+      parity ^= C & 1;
+      C >>= 1;
+   }
+   
+   return parity == 1;
+}
+									/*}}}*/
+// SetJedec - Set the jedec information for a chip			/*{{{*/
+// ---------------------------------------------------------------------
+/* We track the configuration of each chip separately in the chip list, 
+   each chip can have a different type and configuration to allow for 
+   maximum flexability. */
+void set_jedec(struct mapped_mtd_info *map,unsigned chip,unsigned char mfr,
+	      unsigned char id)
+{
+   unsigned long longID = (mfr << 8) + id;
+   unsigned int I;
+   
+   map->mtd.type = MTD_NORFLASH;
+   map->mfr = mfr;
+   map->id = id;
+
+   // Locate the chip in the jedec table
+   for (I = 0; mtd_JEDEC_table[I].jedec != 0; I++)
+   {      
+      if (mtd_JEDEC_table[I].jedec == longID)
+	 break;
+   }
+
+   if (mtd_JEDEC_table[I].jedec != longID || longID == 0)
+   {
+      printk("Unknown JEDEC number %x-%x, treating as ROM\n",map->mfr,
+	     map->id);
+      map->mtd.type = MTD_ROM;
+      return;
+   }
+      
+   // Setup the MTD from the JEDEC information
+//   map->mtd.size = mtd_JEDEC_table[I].size;
+//   map->mtd.erasesize = mtd_JEDEC_table[I].sectorsize;
+//   map->mtd.capabilities = mtd_JEDEC_table[I].capabilities;
+//   strncpy(map->mtd.part,mtd_JEDEC_table[I].name,sizeof(map->mtd.part)-1);
+   
+   map->chips[chip].jedec = longID;
+   map->chips[chip].size = mtd_JEDEC_table[I].size;
+   map->chips[chip].sectorsize = mtd_JEDEC_table[I].sectorsize;
+   map->chips[chip].capabilities = mtd_JEDEC_table[I].capabilities;
+   map->chips[chip].base = 0; 
+}
+									/*}}}*/
+// isjedec - Check if reading from the memory location gives jedec #s	/*{{{*/
+// ---------------------------------------------------------------------
+/* This is ment to be called on the flash window once it is in jedec mode */
+int isjedec(unsigned long base)
+{
+   // Test #1, JEDEC numbers are readable from 0x??00/0x??01
+   if (readb(base + 0) != readb(base + 0x100) || 
+       readb(base + 1) != readb(base + 0x101))
+      return 0;
+   
+   // Test #2 JEDEC numbers exhibit odd parity
+   if (checkparity(readb(base + 0)) == 0 || checkparity(readb(base + 1)) == 0)
+      return 0;
+   return 1;
+}
+									/*}}}*/
+// flash_jedec - JEDEC ID sensor					/*{{{*/
+// ---------------------------------------------------------------------
+/* The mysterious jedec flash probe sequence writes a specific pattern of
+   bytes to the flash. This should be general enough to work with any MTD
+   structure that may contain a flash chip, but note that it will corrupt
+   address 0x5555 on SRAM cards if the machine dies between the two 
+   critical operations. */
+int flash_jedec(struct mapped_mtd_info *map)
+{
+   unsigned I;
+   u_char OldVal;
+   unsigned long base;
+   unsigned long baseaddr = 0;
+   unsigned chip = 0;
+   unsigned count;
+   
+   // Who has a page size this small? :>
+   if (map->pagesize < 0x555)
+      return 1;
+   
+   base = map->page(map,0);
+   
+   // Wait for any write/erase operation to settle
+   OldVal = readb(base);
+   for (I = 0; OldVal != readb(base) && I < 10000; I++)
+      OldVal = readb(base);
+   
+   /* Check for sram by writing to it, the write also happens to be part 
+      of the flash reset sequence.. */
+   OldVal = readb(base + 0x555);
+   writeb(OldVal,base + 0x555);
+   writeb(0xF0,base + 0x555);
+   if (OldVal != readb(base + 0x555))
+   {
+      udelay(100);
+      
+      // Set it back and make sure..
+      writeb(OldVal,base + 0x555);
+      if (OldVal == readb(base + 0x555))
+      {
+	 map->mtd.type = MTD_RAM;
+	 return 0;
+      }
+      
+      writeb(0xF0,base + 0x555);
+   }
+   
+   // Probe for chips
+   while (chip < sizeof(map->chips)/sizeof(map->chips[0]))
+   {
+      // Already in jedec mode, we might be doing some address wrap around
+      if (chip != 0 && isjedec(base) != 0)
+      {
+	 /* Try to reset this page and check if that resets the first page
+	    to confirm */
+	 writeb(0xF0,base + 0x555);
+	 if (isjedec(base) != 0)
+	    break;
+	 base = map->page(map,0);
+	 if (isjedec(base) == 0)
+	    break;
+	 base = map->page(map,baseaddr/map->pagesize);
+      }
+      
+      // Send the sequence
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+      writeb(0x90,base + 0x555);
+
+      // Check the jedec number
+      if (isjedec(base) == 0)
+      {
+	 /* If this is the first chip it must be rom, otherwise it is the
+	    end of the flash region */
+	 if (chip == 0)
+	 {
+	    map->mtd.type = MTD_ROM;
+	    return 0;
+	 }
+	 break;
+      }      
+      
+      // Store the jdec info
+      set_jedec(map,chip,readb(base + 0),readb(base + 1));
+      map->chips[chip].base = baseaddr;
+      
+      // Jump to the next chip
+      baseaddr += map->chips[chip].size;
+      if (baseaddr/map->pagesize > map->maxsize)
+	 break;
+      base = map->page(map,baseaddr/map->pagesize);
+      if (base == 0)
+	 return -EIO;
+      
+      chip++;
+   }
+
+   // Reset all of the chips
+   map->mtd.size = 0;
+   baseaddr = 0;
+   map->mtd.flags = 0xFFFF;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      // Fill in the various MTD structures
+      map->mtd.size += map->chips[I].size;
+      if (map->mtd.erasesize < map->chips[I].sectorsize)
+	 map->mtd.erasesize = map->chips[I].sectorsize;
+      map->mtd.flags &= map->chips[I].capabilities;
+      
+      base = map->page(map,baseaddr/map->pagesize);
+      baseaddr += map->chips[chip].size;
+      writeb(0xF0,base + 0);  // Reset      
+   }   
+   
+   /* Generate a part name that includes the number of different chips and
+      other configuration information */
+   count = 1;
+   map->part[0] = 0;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      unsigned J;
+      if (map->chips[I+1].jedec == map->chips[I].jedec)
+      {
+	 count++;
+	 continue;
+      }
+      
+      // Locate the chip in the jedec table
+      for (J = 0; mtd_JEDEC_table[J].jedec != 0; J++)
+      {      
+	 if (mtd_JEDEC_table[J].jedec == map->chips[I].jedec)
+	    break;
+      }
+      
+      if (map->part[0] != 0)
+	 strcat(map->part,",");
+      
+      if (count != 1)
+	 sprintf(map->part+strlen(map->part),"%u*[%s]",count,
+		 mtd_JEDEC_table[J].name);
+      else
+	 sprintf(map->part+strlen(map->part),"%s",
+		 mtd_JEDEC_table[J].name);
+      count = 1;
+   }   
+   return 0;
+}
+									/*}}}*/
+
+// flash_failed - Print a console message about why the failure		/*{{{*/
+// ---------------------------------------------------------------------
+/* Pass the flags value that the flash return before it re-entered read 
+   mode. */
+static void flash_failed(unsigned char code)
+{
+   /* Bit 5 being high indicates that there was an internal device
+      failure, erasure time limits exceeded or something */
+   if ((code & (1 << 5)) != 0)
+   {
+      printk("mtd: Internal Flash failure\n");
+      return;
+   }
+   printk("mtd: Programming didn't take\n");
+}
+									/*}}}*/
+// flash_erase - Generic erase function					/*{{{*/
+// ---------------------------------------------------------------------
+/* This uses the erasure function described in the AMD Flash Handbook, 
+   it will work for flashes with a fixed sector size only. Flashes with
+   a selection of sector sizes (ie the AMD Am29F800B) will need a different
+   routine. This routine tries to parallize erasing multiple chips/sectors 
+   where possible */
+int flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+   unsigned long Time = 0;
+   unsigned long NoTime = 0;
+   unsigned long start = instr->addr, len = instr->len;
+   unsigned int I;
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+
+   // Verify the arguments..
+   if (start + len > map->mtd.size ||
+       (start % map->mtd.erasesize) != 0 ||
+       (len % map->mtd.erasesize) != 0 ||
+       (len/map->mtd.erasesize) == 0)
+      return -EINVAL;
+   
+   flash_chip_scan(map,start,len);
+
+   // Start the erase sequence on each chip
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      unsigned long off;
+      struct flash_chip *chip = map->chips + I;
+      unsigned long base;
+      unsigned long flags;
+      
+      if (chip->length == 0)
+	 continue;
+      
+      if (page_jump(map,chip->base + chip->start,0x555,&base,0) != 0)
+	 return -EIO;
+      
+      // Send the erase setup code
+      writeb(0xF0,base + 0x555);
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+      writeb(0x80,base + 0x555);
+      writeb(0xAA,base + 0x555);
+      writeb(0x55,base + 0x2AA);
+
+      // Use chip erase if possible
+      if (chip->start == 0 && chip->length == chip->size)
+      {
+	 writeb(0x10,base+0x555);
+	 continue;
+      }
+            
+      /* Once we start selecting the erase sectors the delay between each 
+         command must not exceed 50us or it will immediately start erasing 
+         and ignore the other sectors */
+      save_flags(flags);
+      cli();
+      for (off = 0; off < chip->length; off += chip->sectorsize)
+      {
+	 if (page_jump(map,chip->base + chip->start + off,1,&base,0) != 0)
+	    return -EIO;
+	 
+	 // Check to make sure we didn't timeout
+	 writeb(0x30,base);
+	 if ((readb(base) & (1 << 3)) != 0)
+	 {
+	    printk("mtd: Ack! We timed out the erase timer!\n");
+	    return -EIO;
+	 }       	 
+      }
+      restore_flags(flags);
+   }   
+
+   /* We could split this into a timer routine and return early, performing
+      background erasure.. Maybe later if the need warrents */
+   
+   /* Poll the flash for erasure completion, specs say this can take as long
+      as 480 seconds to do all the sectors (for a 2 meg flash). 
+      Erasure time is dependant on chip age, temp and wear.. */
+   Time = 0;
+   NoTime = 0;
+   for (I = 0; map->chips[I].jedec != 0; I++)
+   {
+      struct flash_chip *chip = map->chips + I;
+      unsigned long base;
+      unsigned long off = 0;
+      if (chip->length == 0)
+	 continue;
+      
+      if (page_jump(map,chip->base + chip->start,1,&base,0) != 0)
+	 return -EIO;
+      
+      while (1)
+      {
+	 unsigned char Last[4];
+	 unsigned long Count = 0;
+	 
+	 /* During erase bit 7 is held low and bit 6 toggles, we watch this,
+	    should it stop toggling or go high then the erase is completed,
+  	    or this is not really flash ;> */
+	 Last[0] = readb(base);
+	 Last[1] = readb(base);
+	 Last[2] = readb(base);
+	 for (Count = 3; (Last[(Count - 1) % 4] & (1 << 7)) == 0 && 
+	      Last[(Count - 1) % 4] != Last[(Count - 2) % 4]; Count++)
+	 {
+	    if (NoTime == 0)
+	       Time += HZ/10 - schedule_timeout(HZ/10);
+	    NoTime = 0;
+	    
+	    Last[Count % 4] = readb(base);
+	 
+	    // Count time, max of 15s per sector (according to AMD)
+	    if (Time > 15*len/mtd->erasesize*HZ)
+	    {
+	       printk("mtd: Flash Erase Timed out\n");
+	       return -EIO;
+	    }	    
+	 }
+	 
+	 if (Last[(Count - 1) % 4] == Last[(Count - 2) % 4])
+	 {
+	    flash_failed(Last[(Count - 3) % 4]);
+	    return -EIO;
+	 }
+	 
+	 // Skip to the next chip if we used chip erase
+	 if (chip->length == chip->size)
+	    off = chip->size;
+	 else
+	    off += chip->sectorsize;
+	 
+	 if (off >= chip->length)
+	    break;
+	 if (page_jump(map,chip->base + chip->start + off,1,&base,0) != 0)
+	    return -EIO;	 
+	 NoTime = 1;
+      }      
+   }
+       	 
+   // Paranoid verify of erasure
+   {
+      unsigned long base;
+      unsigned long buflen;
+      while (len > 0)
+      {
+	 unsigned long step;
+	 
+	 if (page_jump(map,start,len,&base,&buflen) != 0)
+	    return -EIO;
+	 start += buflen;
+	 len -= buflen;
+	 step = buflen/128;
+	 for (;buflen != 0; buflen -= step)
+	 {
+	    if (readb(base+buflen-1) != 0xFF)
+	    {
+	       printk("mtd: Flash Erase didn't take %lu %lu %lu\n",buflen,len,start);
+	       return -EIO;
+	    }
+	 }	 
+      }      
+   }   
+   
+   return 0;
+}
+#if 1
+									/*}}}*/
+// flash_write - Generic writing function				/*{{{*/
+// ---------------------------------------------------------------------
+/* This could do parallel writes on multiple chips but doesnt, memory 
+   constraints make that infeasable. This should work with any sort of 
+   linear flash that is not interleved */
+extern int flash_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   unsigned long base;
+   unsigned long off;
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Compute the page offset and reposition
+      base = map->page(map,(u_long)start/map->pagesize);
+      off = (u_long)start %  map->pagesize;
+
+      // Loop over this page
+      for (; off != map->pagesize && len != 0; start++, len--, off++,buf++)
+      {
+	 unsigned char oldbyte = readb(base+off);
+	 unsigned char Last[4];
+	 unsigned long Count = 0;
+
+	 if (oldbyte == *buf)
+	    continue;
+	 if (((~oldbyte) & *buf) != 0)
+	    printk("mtd: warn: Trying to set a 0 to a 1\n");
+	     
+	 // Write
+	 writeb(0xAA,base + 0x555);
+	 writeb(0x55,base + 0x2AA);
+	 writeb(0xA0,base + 0x555);
+	 writeb(*buf,base + off);
+	 Last[0] = readb(base + off);
+	 Last[1] = readb(base + off);
+	 Last[2] = readb(base + off);
+	 
+	 /* Wait for the flash to finish the operation. We store the last 4
+	    status bytes that have been retrieved so we can determine why
+	    it failed. The toggle bits keep toggling when there is a 
+	    failure */
+	 for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] &&
+	      Count < 10000; Count++)
+	    Last[Count % 4] = readb(base + off);
+	 if (Last[(Count - 1) % 4] != *buf)
+	 {
+	    flash_failed(Last[(Count - 3) % 4]);
+	    return -EIO;
+	 }	 
+      }
+   }
+   *retlen = len;
+   return 0;
+}
+#endif
+
+// ram_write - Generic writing function	for ram				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+extern int ram_write(struct mtd_info *mtd, loff_t start, size_t len,
+		       size_t *retlen, const u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   unsigned long base;
+   size_t origlen = len;
+   unsigned long buflen;
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Reposition..
+      if (page_jump(map,start,len,&base,&buflen) != 0)
+	 return -EIO;
+      
+      // Copy
+      memcpy_toio(base,buf,buflen);
+      len -= buflen;
+      start += buflen;
+   }
+   *retlen = origlen;
+   return 0;
+}
+
+// rom_read - Read handler for any sort of device			/*{{{*/
+// ---------------------------------------------------------------------
+/* This is a generic read function that should work with any device in the
+   mapped region. */
+extern int rom_read(struct mtd_info *mtd, loff_t start, size_t len,
+		    size_t *retlen, u_char *buf)
+{
+   struct mapped_mtd_info *map = (struct mapped_mtd_info *)mtd;
+   size_t origlen = len;
+   unsigned long base;
+   unsigned long buflen;
+
+   printk("Rom_Read\n");
+   if (start + len > mtd->size)
+      return -EIO;
+   
+   while (len != 0)
+   {
+      // Reposition..
+      if (page_jump(map,start,len,&base,&buflen) != 0)
+	 return -EIO;
+      
+      // Copy
+      memcpy_fromio(buf,base,buflen);
+      len -= buflen;
+      start += buflen;
+   }
+   *retlen = origlen;
+   return 0;
+}
+
+// page_jump - Move the window and return the buffer			/*{{{*/
+// ---------------------------------------------------------------------
+/* Unlike the page function this returns a buffer and length adjusted for
+   the page dimensions and the reading offset into the page, simplifies
+   many of the other routines */
+int page_jump(struct mapped_mtd_info *map,unsigned long start,
+	      unsigned long len,unsigned long *base,
+	      unsigned long *retlen)
+{
+   DEBUG(MTD_DEBUG_LEVEL1,"Page Jump\n");
+   if (start > map->mtd.size || start + len > map->mtd.size)
+      return -EINVAL;
+      
+   *base = map->page(map,start/map->pagesize);
+   if (*base == 0)
+      return -EIO;
+
+   *base += start % map->pagesize;
+
+   // If retlen is 0 that mean the caller requires len bytes, no quibbling.
+   if (retlen == 0)
+   {
+      if (len > map->pagesize  - (start % map->pagesize))
+	 return -EIO;
+      return 0;
+   }
+   
+   // Compute the buffer paramaters and return
+   if (len > map->pagesize - (start % map->pagesize))
+      *retlen = map->pagesize - (start % map->pagesize);
+   else
+      *retlen = len;
+   return 0;
+}
+									/*}}}*/
+// flash_chip_scan - Intersect a region with the flash chip structure	/*{{{*/
+// ---------------------------------------------------------------------
+/* This is used to enhance the speed of the erase routine,
+   when things are being done to multiple chips it is possible to
+   parallize the operations, particularly full memory erases of multi
+   chip memories benifit */
+
+void flash_chip_scan(struct mapped_mtd_info *map,unsigned long start,
+		     unsigned long len)
+{
+   unsigned int I = 0;
+
+   DEBUG(MTD_DEBUG_LEVEL1,"\n");
+   // Zero the records
+   for (I = 0; map->chips[I].jedec != 0; I++)
+      map->chips[I].start = map->chips[I].length = 0;
+   
+   // Intesect our region with the chip structures
+   for (I = 0; map->chips[I].jedec != 0 && len != 0; I++)
+   {
+      // Havent found the start yet
+      if (start >= map->chips[I].base + map->chips[I].size)
+	 continue;
+
+      // Store the portion of this chip that is being effected
+      map->chips[I].start = start - map->chips[I].base;
+      if (len <= map->chips[I].size - map->chips[I].start)
+	 map->chips[I].length = len;
+      else
+	 map->chips[I].length = map->chips[I].size - map->chips[I].start;
+      len -= map->chips[I].length;
+      start = map->chips[I].base + map->chips[I].size;
+   }
+}
+									/*}}}*/
+
diff -Naur linux-2.4.2.orig/drivers/mtd/mixmem.c linux-2.4.2/drivers/mtd/mixmem.c
--- linux-2.4.2.orig/drivers/mtd/mixmem.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mixmem.c	Thu Jan 10 18:30:47 2002
@@ -4,6 +4,8 @@
  *
  * Author: Gergely Madarasz <gorgo@itc.hu> 
  *
+ * $Id: mixmem.c,v 1.8 2000/11/14 10:58:02 dwmw2 Exp $
+ *
  * Copyright (c) 1999 ITConsult-Pro Co. <info@itc.hu>
  *
  * This code is GPL
@@ -11,7 +13,7 @@
  */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <linux/init.h>
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdblock.c linux-2.4.2/drivers/mtd/mtdblock.c
--- linux-2.4.2.orig/drivers/mtd/mtdblock.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdblock.c	Thu Jan 10 18:30:47 2002
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id: mtdblock.c,v 1.38 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: mtdblock.c,v 1.40 2001/01/08 15:29:04 dwmw2 Exp $
  *
  * 02-nov-2000	Nicolas Pitre		Added read-modify-write with cache
  */
@@ -10,7 +10,7 @@
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/mtd/mtd.h>
 
 #define MAJOR_NR MTD_BLOCK_MAJOR
@@ -610,7 +610,7 @@
 #define cleanup_mtdblock cleanup_module
 #endif
 
-int __init init_mtdblock(void)
+mod_init_t init_mtdblock(void)
 {
 	int i;
 
@@ -652,7 +652,7 @@
 	return 0;
 }
 
-static void __exit cleanup_mtdblock(void)
+mod_exit_t cleanup_mtdblock(void)
 {
 	leaving = 1;
 	wake_up(&thr_wq);
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdblock_ro.c linux-2.4.2/drivers/mtd/mtdblock_ro.c
--- linux-2.4.2.orig/drivers/mtd/mtdblock_ro.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/mtdblock_ro.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,325 @@
+// Description
+// $Id: mtdblock_ro.c,v 1.3 2001/03/17 17:10:22 dwmw2 Exp $
+/* ######################################################################
+
+   Memory Technology Devices Manager
+
+   TODO:
+     - Add a ioctl method to the mtd structure and move all flash related
+       stuff into a new separated structure so as not to pollute the 
+       main mtd info.
+     - Flexible partitioning
+   
+   ##################################################################### */
+
+#ifdef MTDBLOCK_DEBUG
+#define DEBUGLVL debug
+#endif							       
+
+
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+
+#define MAJOR_NR MTD_BLOCK_MAJOR
+#define DEVICE_NAME "mtdblock"
+#define DEVICE_REQUEST mtdblock_request
+#define DEVICE_NR(device) (device)
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+#define DEVICE_NO_RANDOM
+#include <linux/blk.h>
+
+#if LINUX_VERSION_CODE < 0x20300
+#define RQFUNC_ARG void
+#define blkdev_dequeue_request(req) do {CURRENT = req->next;} while (0)
+#else
+#define RQFUNC_ARG request_queue_t *q
+#endif
+
+#ifdef MTDBLOCK_DEBUG
+static int debug = MTDBLOCK_DEBUG;
+MODULE_PARM(debug, "i");
+#endif
+
+#if 0
+static void mtdblock_end_request(struct request *req, int res)
+{
+	if (end_that_request_first( req, res, "mtdblock" ))
+                return;
+        end_that_request_last( req );
+}
+#endif
+
+static int mtd_sizes[MAX_MTD_DEVICES];
+
+
+/* Keeping a separate list rather than just getting stuff directly out of 
+   the MTD core's mtd_table is perhaps not very nice, but I happen
+   to dislike the idea of directly accessing mtd_table even more.
+   dwmw2 31/3/0
+*/
+
+static int mtdblock_open(struct inode *inode, struct file *file)
+{
+	struct mtd_info *mtd = NULL;
+
+	int dev;
+
+	DEBUG(1,"mtdblock_open\n");
+	
+	if (inode == 0)
+		return -EINVAL;
+	
+	dev = MINOR(inode->i_rdev);
+	
+	MOD_INC_USE_COUNT;
+
+	mtd = get_mtd_device(NULL, dev);
+
+	if (!mtd) {
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+
+	mtd_sizes[dev] = mtd->size>>9;
+
+	DEBUG(1, "ok\n");
+
+	return 0;
+}
+
+static release_t mtdblock_release(struct inode *inode, struct file *file)
+{
+	int dev;
+	struct mtd_info *mtd;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	struct super_block * sb = get_super(inode->i_rdev);
+#endif
+   	DEBUG(1, "mtdblock_release\n");
+
+	if (inode == NULL)
+		release_return(-ENODEV);
+   
+	fsync_dev(inode->i_rdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	if (sb) invalidate_inodes(sb);
+#endif
+	invalidate_buffers(inode->i_rdev);
+
+	dev = MINOR(inode->i_rdev);
+	mtd = __get_mtd_device(NULL, dev);
+
+	if (!mtd) {
+		printk(KERN_WARNING "MTD device is absent on mtd_release!\n");
+		MOD_DEC_USE_COUNT;
+		release_return(-ENODEV);
+		
+	}
+	
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+
+	DEBUG(1, "ok\n");
+
+	MOD_DEC_USE_COUNT;
+	release_return(0);
+}  
+
+
+static void mtdblock_request(RQFUNC_ARG)
+{
+   struct request *current_request;
+   unsigned int res = 0;
+   struct mtd_info *mtd;
+
+   while (1)
+   {
+      /* Grab the Request and unlink it from the request list, INIT_REQUEST
+       	 will execute a return if we are done. */
+      INIT_REQUEST;
+      current_request = CURRENT;
+   
+      if (MINOR(current_request->rq_dev) >= MAX_MTD_DEVICES)
+      {
+	 printk("mtd: Unsupported device!\n");
+	 end_request(0);
+	 continue;
+      }
+      
+      // Grab our MTD structure
+
+      mtd = __get_mtd_device(NULL, MINOR(current_request->rq_dev));
+      if (!mtd) {
+	      printk("MTD device %d doesn't appear to exist any more\n", CURRENT_DEV);
+	      end_request(0);
+      }
+
+      if (current_request->sector << 9 > mtd->size ||
+	  (current_request->sector + current_request->nr_sectors) << 9 > mtd->size)
+      {
+	 printk("mtd: Attempt to read past end of device!\n");
+	 printk("size: %x, sector: %lx, nr_sectors %lx\n", mtd->size, current_request->sector, current_request->nr_sectors);
+	 end_request(0);
+	 continue;
+      }
+      
+      /* Remove the request we are handling from the request list so nobody messes
+         with it */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+      //	blkdev_dequeue_request(current_request);
+      
+      /* Now drop the lock that the ll_rw_blk functions grabbed for us
+         and process the request. This is necessary due to the extreme time
+         we spend processing it. */
+      spin_unlock_irq(&io_request_lock);
+#endif
+
+      // Handle the request
+      switch (current_request->cmd)
+      {
+         size_t retlen;
+
+	 case READ:
+	 if (MTD_READ(mtd,current_request->sector<<9, 
+		      current_request->nr_sectors << 9, 
+		      &retlen, current_request->buffer) == 0)
+	    res = 1;
+	 else
+	    res = 0;
+	 break;
+	 
+	 case WRITE:
+//printk("mtdblock_request WRITE sector=%d(%d)\n",current_request->sector,
+//	current_request->nr_sectors);
+
+	 // Read only device
+	 if ((mtd->flags & MTD_CAP_RAM) == 0)
+	 {
+	    res = 0;
+	    break;
+	 }
+
+	 // Do the write
+	 if (MTD_WRITE(mtd,current_request->sector<<9, 
+		       current_request->nr_sectors << 9, 
+		       &retlen, current_request->buffer) == 0)
+	    res = 1;
+	 else
+	    res = 0;
+	 break;
+	 
+	 // Shouldn't happen
+	 default:
+	 printk("mtd: unknown request\n");
+	 break;
+      }
+
+      // Grab the lock and re-thread the item onto the linked list
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	spin_lock_irq(&io_request_lock);
+//	mtdblock_end_request(current_request, res);
+#endif
+	end_request(res);
+   }
+}
+
+
+
+static int mtdblock_ioctl(struct inode * inode, struct file * file,
+		      unsigned int cmd, unsigned long arg)
+{
+	struct mtd_info *mtd;
+
+	mtd = __get_mtd_device(NULL, MINOR(inode->i_rdev));
+
+	if (!mtd) return -EINVAL;
+
+	switch (cmd) {
+	case BLKGETSIZE:   /* Return device size */
+		if (!arg)  return -EFAULT;
+		return Put_user((mtd->size >> 9),
+                                (long *) arg);
+		
+	case BLKFLSBUF:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+		if(!capable(CAP_SYS_ADMIN))  return -EACCES;
+#endif
+		fsync_dev(inode->i_rdev);
+		invalidate_buffers(inode->i_rdev);
+		if (mtd->sync)
+			mtd->sync(mtd);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+									/*}}}*/
+#if LINUX_VERSION_CODE < 0x20326
+static struct file_operations mtd_fops =
+{
+	open: mtdblock_open,
+	ioctl: mtdblock_ioctl,
+	release: mtdblock_release,
+	read: block_read,
+	write: block_write
+};
+#else
+static struct block_device_operations mtd_fops = 
+{
+	open: mtdblock_open,
+	release: mtdblock_release,
+	ioctl: mtdblock_ioctl
+};
+#endif
+
+#if LINUX_VERSION_CODE < 0x20300
+#ifdef MODULE
+#define init_mtdblock init_module
+#define cleanup_mtdblock cleanup_module
+#endif
+#define __exit
+#endif
+
+
+int __init init_mtdblock(void)
+{
+	int i;
+
+	if (register_blkdev(MAJOR_NR,DEVICE_NAME,&mtd_fops)) {
+		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
+		       MTD_BLOCK_MAJOR);
+		return EAGAIN;
+	}
+	
+	/* We fill it in at open() time. */
+	for (i=0; i< MAX_MTD_DEVICES; i++) {
+		mtd_sizes[i] = 0;
+	}
+	
+	/* Allow the block size to default to BLOCK_SIZE. */
+	blksize_size[MAJOR_NR] = NULL;
+	blk_size[MAJOR_NR] = mtd_sizes;
+	
+#if LINUX_VERSION_CODE < 0x20320
+	blk_dev[MAJOR_NR].request_fn = mtdblock_request;
+#else
+	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), &mtdblock_request);
+#endif
+	return 0;
+}
+
+static void __exit cleanup_mtdblock(void)
+{
+	unregister_blkdev(MAJOR_NR,DEVICE_NAME);
+}
+
+#if LINUX_VERSION_CODE > 0x20300
+module_init(init_mtdblock);
+module_exit(cleanup_mtdblock);
+#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdchar.c linux-2.4.2/drivers/mtd/mtdchar.c
--- linux-2.4.2.orig/drivers/mtd/mtdchar.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdchar.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.21.2.3 2001/01/09 00:18:31 dwmw2 Exp $
+ * $Id: mtdchar.c,v 1.28 2001/03/23 23:09:48 kd Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -7,12 +7,11 @@
 
 
 #include <linux/mtd/compatmac.h>
-
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/mtd/mtd.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 #ifdef CONFIG_DEVFS_FS
 #include <linux/devfs_fs_kernel.h>
@@ -78,16 +77,21 @@
 	if ((file->f_mode & 2) && (minor & 1))
 		return -EACCES;
 
+	MOD_INC_USE_COUNT;
+
 	mtd = get_mtd_device(NULL, devnum);
 		
-	if (!mtd)
+	if (!mtd) {
+		MOD_DEC_USE_COUNT;
 		return -ENODEV;
+	}
 	
 	file->private_data = mtd;
 		
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
+		MOD_DEC_USE_COUNT;
 		return -EACCES;
 	}
 		
@@ -110,6 +114,7 @@
 	
 	put_mtd_device(mtd);
 
+	MOD_DEC_USE_COUNT;
 	release_return(0);
 } /* mtd_close */
 
@@ -119,6 +124,8 @@
 #define FILE_POS file->f_pos
 #endif
 
+#define MAX_KMALLOC_SIZE 0x20000
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
 static ssize_t mtd_read(struct file *file, char *buf, size_t count,loff_t *ppos)
 #else
@@ -127,9 +134,12 @@
 {
 	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
 	size_t retlen=0;
+	size_t total_retlen=0;
 	int ret=0;
+#ifndef NO_MM
+	int len;
 	char *kbuf;
-	
+#endif	
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
 	if (FILE_POS + count > mtd->size)
@@ -141,24 +151,47 @@
 	/* FIXME: Use kiovec in 2.3 or 2.2+rawio, or at
 	 * least split the IO into smaller chunks.
 	 */
-	
-	kbuf = vmalloc(count);
-	if (!kbuf)
-		return -ENOMEM;
-	
-	ret = MTD_READ(mtd, FILE_POS, count, &retlen, kbuf);
+#ifdef NO_MM	
+	ret = MTD_READ(mtd, FILE_POS, count, &retlen, buf);
 	if (!ret) {
 		FILE_POS += retlen;
-		if (copy_to_user(buf, kbuf, retlen))
-			ret = -EFAULT;
+		ret = retlen;
+	}
+	total_retlen = ret;
+#else
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
 		else
-			ret = retlen;
+			len = count;
+
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+		
+		ret = MTD_READ(mtd, FILE_POS, len, &retlen, kbuf);
+		if (!ret) {
+			FILE_POS += retlen;
+			if (copy_to_user(buf, kbuf, retlen)) {
+			        kfree(kbuf);
+				return -EFAULT;
+			}
+			else
+				total_retlen += retlen;
 
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
 	}
 	
-	vfree(kbuf);
-	
-	return ret;
+#endif	
+	return total_retlen;
 } /* mtd_read */
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
@@ -168,9 +201,13 @@
 #endif
 {
 	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
-	char *kbuf;
 	size_t retlen;
+	size_t total_retlen=0;
 	int ret=0;
+#ifndef NO_MM
+	int len;
+	char *kbuf;
+#endif
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
 	
@@ -183,27 +220,47 @@
 	if (!count)
 		return 0;
 
-	kbuf=vmalloc(count);
-
-	if (!kbuf)
-		return -ENOMEM;
-	
-	if (copy_from_user(kbuf, buf, count)) {
-		vfree(kbuf);
-		return -EFAULT;
-	}
-		
-
-	ret = (*(mtd->write))(mtd, FILE_POS, count, &retlen, buf);
-		
+#ifdef NO_MM	
+	ret = MTD_WRITE(mtd, FILE_POS, count, &retlen, buf);
 	if (!ret) {
 		FILE_POS += retlen;
 		ret = retlen;
 	}
+	total_retlen = ret;
+#else
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
 
-	vfree(kbuf);
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf) {
+			printk("kmalloc is null\n");
+			return -ENOMEM;
+		}
 
-	return ret;
+		if (copy_from_user(kbuf, buf, len)) {
+			kfree(kbuf);
+			return -EFAULT;
+		}
+		
+	        ret = (*(mtd->write))(mtd, FILE_POS, len, &retlen, kbuf);
+		if (!ret) {
+			FILE_POS += retlen;
+			total_retlen += retlen;
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
+	}
+#endif		
+	return total_retlen;
 } /* mtd_write */
 
 /*======================================================================
@@ -236,6 +293,26 @@
 	}
 	
 	switch (cmd) {
+	case MEMGETREGIONCOUNT :
+		if(copy_to_user((int *) arg, &(mtd->numeraseregions), sizeof(int)))
+			return -EFAULT;
+		break;
+	case MEMGETREGIONINFO :
+	{
+		struct mtd_erase_region_info * kr;
+		struct region_info_user * ur;
+		kr = (struct mtd_erase_region_info *) arg;
+		ur = (struct region_info_user *) arg;
+
+		if( ur->regionindex >= mtd->numeraseregions)
+			return -EFAULT;
+			
+		if(copy_to_user( (struct mtd_erase_region_info *) arg, 
+				&(mtd->eraseregions[ur->regionindex]),
+				sizeof(struct mtd_erase_region_info)))
+			return -EFAULT;
+		break;
+	}
 	case MEMGETINFO:
 		if (copy_to_user((struct mtd_info *)arg, mtd,
 				 sizeof(struct mtd_info_user)))
@@ -369,6 +446,7 @@
 			ret = -EOPNOTSUPP;
 		else
 			ret = mtd->lock(mtd, adrs[0], adrs[1]);
+		break;
 	}
 
 	case MEMUNLOCK:
@@ -382,6 +460,7 @@
 			ret = -EOPNOTSUPP;
 		else
 			ret = mtd->unlock(mtd, adrs[0], adrs[1]);
+		break;
 	}
 
 		
@@ -394,8 +473,14 @@
 } /* memory_ioctl */
 
 static struct file_operations mtd_fops = {
+#if LINUX_VERSION_CODE >= 0x20300	/* Someone knows when these made their debut? */
 	owner:		THIS_MODULE,
+#endif
+#if LINUX_VERSION_CODE >=0x20200
 	llseek:		mtd_lseek,     	/* lseek */
+#else
+	lseek:		mtd_lseek,     	/* lseek */
+#endif
 	read:		mtd_read,	/* read */
 	write: 		mtd_write, 	/* write */
 	ioctl:		mtd_ioctl,	/* ioctl */
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdcore.c linux-2.4.2/drivers/mtd/mtdcore.c
--- linux-2.4.2.orig/drivers/mtd/mtdcore.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdcore.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.27 2000/12/10 01:10:09 dwmw2 Exp $
+ * $Id: mtdcore.c,v 1.29 2001/03/17 17:10:22 dwmw2 Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -258,8 +258,8 @@
 	if (!this)
 		return 0;
 
-	return sprintf(buf, "mtd%d: %8.8lx \"%s\"\n", i, this->size,
-		       this->name);
+	return sprintf(buf, "mtd%d: %8.8x %8.8x \"%s\"\n", i, this->size,
+		       this->erasesize, this->name);
 }
 
 static int mtd_read_proc ( char *page, char **start, off_t off,int count
@@ -270,11 +270,12 @@
 #endif
 			)
 {
-	int len = 0, l, i;
+	int len, l, i;
         off_t   begin = 0;
 
 	down(&mtd_table_mutex);
 
+	len = sprintf(page, "dev:    size   erasesize  name\n");
         for (i=0; i< MAX_MTD_DEVICES; i++) {
 
                 l = mtd_proc_info(page + len, i);
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdpart.c linux-2.4.2/drivers/mtd/mtdpart.c
--- linux-2.4.2.orig/drivers/mtd/mtdpart.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdpart.c	Thu Jan 10 18:30:47 2002
@@ -5,13 +5,13 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.7 2000/12/09 23:29:47 dwmw2 Exp $
+ * $Id: mtdpart.c,v 1.16 2001/03/17 17:10:22 dwmw2 Exp $
  */
 
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/list.h>
 
 #include <linux/mtd/mtd.h>
@@ -25,7 +25,7 @@
 struct mtd_part {
 	struct mtd_info mtd;
 	struct mtd_info *master;
-	loff_t offset;
+	u_long offset;
 	int index;
 	struct list_head list;
 };
@@ -100,15 +100,36 @@
 static int part_lock (struct mtd_info *mtd, loff_t ofs, size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	if ((len + ofs) > mtd->size) 
+		return -EINVAL;
 	return part->master->lock(part->master, ofs + part->offset, len);
 }
 
 static int part_unlock (struct mtd_info *mtd, loff_t ofs, size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	if ((len + ofs) > mtd->size) 
+		return -EINVAL;
 	return part->master->unlock(part->master, ofs + part->offset, len);
 }
 
+static void part_sync(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	part->master->sync(part->master);
+}
+
+static int part_suspend(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	return part->master->suspend(part->master);
+}
+
+static void part_resume(struct mtd_info *mtd)
+{
+	struct mtd_part *part = PART(mtd);
+	part->master->resume(part->master);
+}
 
 /* 
  * This function unregisters and destroy all slave MTD objects which are 
@@ -137,7 +158,6 @@
 	return 0;
 }
 
-
 /*
  * This function, given a master MTD object and a partition table, creates
  * and registers slave MTD objects which are bound to the master according to
@@ -155,6 +175,7 @@
 
 	for (i = 0; i < nbparts; i++) {
 		/* allocate the partition structure */
+
 		slave = kmalloc (sizeof(*slave), GFP_KERNEL);
 		if (!slave) {
 			printk ("memory allocation error while creating partitions for \"%s\"\n",
@@ -162,58 +183,94 @@
 			del_mtd_partitions(master);
 			return -ENOMEM;
 		}
+		memset(slave, 0, sizeof(*slave));
 		list_add(&slave->list, &mtd_partitions);
 
 		/* set up the MTD object for this partition */
-		slave->mtd = *master;
-		slave->mtd.name = parts[i].name;
+		slave->mtd.type = master->type;
+		slave->mtd.flags = master->flags & ~parts[i].mask_flags;
 		slave->mtd.size = parts[i].size;
-		slave->mtd.flags &= ~parts[i].mask_flags;
+		slave->mtd.oobblock = master->oobblock;
+		slave->mtd.oobsize = master->oobsize;
+		slave->mtd.ecctype = master->ecctype;
+		slave->mtd.eccsize = master->eccsize;
+
+		slave->mtd.name = parts[i].name;
+		slave->mtd.bank_size = master->bank_size;
+
+		slave->mtd.module = master->module;
+
 		slave->mtd.read = part_read;
 		slave->mtd.write = part_write;
-		if (slave->mtd.writev)
+		slave->mtd.sync = part_sync;
+		if (!i && master->suspend && master->resume) {
+				slave->mtd.suspend = part_suspend;
+				slave->mtd.resume = part_resume;
+		}
+
+		if (master->writev)
 			slave->mtd.writev = part_writev;
-		if (slave->mtd.readv)
+		if (master->readv)
 			slave->mtd.readv = part_readv;
-		if (slave->mtd.lock)
+		if (master->lock)
 			slave->mtd.lock = part_lock;
-		if (slave->mtd.unlock)
+		if (master->unlock)
 			slave->mtd.unlock = part_unlock;
 		slave->mtd.erase = part_erase;
 		slave->master = master;
 		slave->offset = parts[i].offset;
 		slave->index = i;
 
-		if (slave->offset == 0)
+		if (slave->offset == MTDPART_OFS_APPEND)
 			slave->offset = cur_offset;
-		if (slave->mtd.size == 0)
+		if (slave->mtd.size == MTDPART_SIZ_FULL)
 			slave->mtd.size = master->size - slave->offset;
 		cur_offset = slave->offset + slave->mtd.size;
-
+	
 		/* let's do some sanity checks */
+		if (slave->offset >= master->size) {
+				/* let's register it anyway to preserve ordering */
+			slave->offset = 0;
+			slave->mtd.size = 0;
+			printk ("mtd: partition \"%s\" is out of reach -- disabled\n",
+				parts[i].name);
+		}
+		if (slave->offset + slave->mtd.size > master->size) {
+			slave->mtd.size = master->size - slave->offset;
+			printk ("mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#x\n",
+				parts[i].name, master->name, slave->mtd.size);
+		}
+		if (master->numeraseregions>1) {
+			/* Deal with variable erase size stuff */
+			int i;
+			struct mtd_erase_region_info *regions = master->eraseregions;
+			
+			/* Find the first erase regions which is part of this partition. */
+			for (i=0; i < master->numeraseregions && slave->offset >= regions[i].offset; i++)
+				;
+
+			for (i--; i < master->numeraseregions && slave->offset + slave->mtd.size > regions[i].offset; i++) {
+				if (slave->mtd.erasesize < regions[i].erasesize) {
+					slave->mtd.erasesize = regions[i].erasesize;
+				}
+			}
+		} else {
+			/* Single erase size */
+			slave->mtd.erasesize = master->erasesize;
+		}
+
 		if ((slave->mtd.flags & MTD_WRITEABLE) && 
-		    (parts[i].offset % master->erasesize)) {
+		    (slave->offset % slave->mtd.erasesize)) {
+				/* Doesn't start on a boundary of major erase size */
 			slave->mtd.flags &= ~MTD_WRITEABLE;
 			printk ("mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
-					parts[i].name);
+				parts[i].name);
 		}
 		if ((slave->mtd.flags & MTD_WRITEABLE) && 
-		    (parts[i].size % master->erasesize)) {
+		    (slave->mtd.size % slave->mtd.erasesize)) {
 			slave->mtd.flags &= ~MTD_WRITEABLE;
 			printk ("mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
-					parts[i].name);
-		}
-		if (parts[i].offset >= master->size) {
-			/* let's register it anyway to preserve ordering */
-			slave->offset = 0;
-			slave->mtd.size = 0;
-			printk ("mtd: partition \"%s\" is out of reach -- disabled\n",
-					parts[i].name);
-		}
-		if (parts[i].offset + parts[i].size > master->size) {
-			slave->mtd.size = master->size - parts[i].offset;
-			printk ("mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#lx\n",
-					parts[i].name, master->name, slave->mtd.size);
+				parts[i].name);
 		}
 
 		/* register our partition */
diff -Naur linux-2.4.2.orig/drivers/mtd/mtdram.c linux-2.4.2/drivers/mtd/mtdram.c
--- linux-2.4.2.orig/drivers/mtd/mtdram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/mtdram.c	Thu Jan 10 18:30:47 2002
@@ -1,7 +1,7 @@
-/* 
+/*
  * mtdram - a test mtd device
- * $Id: mtdram.c,v 1.15 2000/07/13 12:40:46 scote1 Exp $
- * Author: Alexander Larsson <alex@cendio.se> 
+ * $Id: mtdram.c,v 1.21 2001/03/17 19:08:45 dwmw2 Exp $
+ * Author: Alexander Larsson <alex@cendio.se>
  *
  * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
  *
@@ -9,17 +9,32 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
-
-#include <linux/slab.h>
+#include <linux/config.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/mtd.h>
 
+#ifndef CONFIG_MTDRAM_ABS_POS
+  #define CONFIG_MTDRAM_ABS_POS 0
+#endif
+
+#if CONFIG_MTDRAM_ABS_POS > 0
+  #include <asm/io.h>
+#endif
 
+#ifdef MODULE
+static unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;
+static unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;
+MODULE_PARM(total_size,"l");
+MODULE_PARM(erase_size,"l");
+#define MTDRAM_TOTAL_SIZE (total_size * 1024)
+#define MTDRAM_ERASE_SIZE (erase_size * 1024)
+#else
 #define MTDRAM_TOTAL_SIZE (CONFIG_MTDRAM_TOTAL_SIZE * 1024)
 #define MTDRAM_ERASE_SIZE (CONFIG_MTDRAM_ERASE_SIZE * 1024)
+#endif
 
 
 // We could store these in the mtd structure, but we only support 1 device..
@@ -29,11 +44,14 @@
 static int
 ram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-  if (instr->addr + instr->len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_erase(pos:%ld, len:%ld)\n", (long)instr->addr, (long)instr->len);
+  if (instr->addr + instr->len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_erase() out of bounds (%ld > %ld)\n", (long)(instr->addr + instr->len), (long)mtd->size);
     return -EINVAL;
+  }
 	
   memset((char *)mtd->priv + instr->addr, 0xff, instr->len);
-  
+
   instr->state = MTD_ERASE_DONE;
 
   if (instr->callback)
@@ -45,7 +63,7 @@
 {
   if (from + len > mtd->size)
     return -EINVAL;
-  
+
   *mtdbuf = mtd->priv + from;
   *retlen = len;
   return 0;
@@ -53,13 +71,17 @@
 
 static void ram_unpoint (struct mtd_info *mtd, u_char *addr)
 {
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_unpoint\n");
 }
 
 static int ram_read(struct mtd_info *mtd, loff_t from, size_t len,
 	     size_t *retlen, u_char *buf)
 {
-  if (from + len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_read(pos:%ld, len:%ld)\n", (long)from, (long)len);
+  if (from + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_read() out of bounds (%ld > %ld)\n", (long)(from + len), (long)mtd->size);
     return -EINVAL;
+  }
 
   memcpy(buf, mtd->priv + from, len);
 
@@ -70,21 +92,22 @@
 static int ram_write(struct mtd_info *mtd, loff_t to, size_t len,
 	      size_t *retlen, const u_char *buf)
 {
-  if (to + len > mtd->size)
+  DEBUG(MTD_DEBUG_LEVEL2, "ram_write(pos:%ld, len:%ld)\n", (long)to, (long)len);
+  if (to + len > mtd->size) {
+    DEBUG(MTD_DEBUG_LEVEL1, "ram_write() out of bounds (%ld > %ld)\n", (long)(to + len), (long)mtd->size);
     return -EINVAL;
-  
+  }
+
   memcpy ((char *)mtd->priv + to, buf, len);
 
   *retlen=len;
   return 0;
 }
 
-#if LINUX_VERSION_CODE < 0x20300
-#ifdef MODULE
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_mtdram init_module
 #define cleanup_mtdram cleanup_module
 #endif
-#endif
 
 //static void __exit cleanup_mtdram(void)
 mod_exit_t cleanup_mtdram(void)
@@ -92,20 +115,22 @@
   if (mtd_info) {
     del_mtd_device(mtd_info);
     if (mtd_info->priv)
+#if CONFIG_MTDRAM_ABS_POS > 0
+      iounmap(mtd_info->priv);
+#else
       vfree(mtd_info->priv);
+#endif	
     kfree(mtd_info);
   }
 }
 
-extern struct module __this_module;
-
 mod_init_t init_mtdram(void)
 {
    // Allocate some memory
    mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
    if (mtd_info == 0)
       return 0;
-   
+
    memset(mtd_info, 0, sizeof(*mtd_info));
 
    // Setup the MTD structure
@@ -114,14 +139,19 @@
    mtd_info->flags = MTD_CAP_RAM;
    mtd_info->size = MTDRAM_TOTAL_SIZE;
    mtd_info->erasesize = MTDRAM_ERASE_SIZE;
+#if CONFIG_MTDRAM_ABS_POS > 0
+   mtd_info->priv = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
+#else
    mtd_info->priv = vmalloc(MTDRAM_TOTAL_SIZE);
    memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+#endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
    mtd_info->module = THIS_MODULE;			
 #endif
 
    if (!mtd_info->priv) {
+     DEBUG(MTD_DEBUG_LEVEL1, "Failed to vmalloc(/ioremap) memory region of size %ld (ABS_POS:%ld)\n", (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
      kfree(mtd_info);
      mtd_info = NULL;
      return -ENOMEM;
@@ -133,16 +163,18 @@
    mtd_info->write = ram_write;
 
    if (add_mtd_device(mtd_info)) {
+#if CONFIG_MTDRAM_ABS_POS > 0
+     iounmap(mtd_info->priv);
+#else
      vfree(mtd_info->priv);
+#endif	
      kfree(mtd_info);
      mtd_info = NULL;
      return -EIO;
    }
-   
+
    return 0;
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_mtdram);
 module_exit(cleanup_mtdram);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/nand.c linux-2.4.2/drivers/mtd/nand.c
--- linux-2.4.2.orig/drivers/mtd/nand.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,1369 @@
+/*
+ *  drivers/mtd/nand.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: nand.c,v 1.10 2001/03/20 07:26:01 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is the generic MTD driver for NAND flash devices. It should be
+ *   capable of working with almost all NAND chips currently available.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ids.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_MTD_NAND_ECC
+#include <linux/mtd/nand_ecc.h>
+#endif
+
+/*
+ * Macros for low-level register control
+ */
+#define NAND_CTRL (*(volatile unsigned char *) \
+			((struct nand_chip *) mtd->priv)->CTRL_ADDR)
+#define nand_select()	NAND_CTRL &= ~this->NCE; \
+			nand_command(mtd, NAND_CMD_RESET, -1, -1); \
+			udelay (10);
+#define nand_deselect() NAND_CTRL |= ~this->NCE;
+
+/*
+ * NAND low-level MTD interface functions
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf);
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code);
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf);
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf);
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code);
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf);
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen);
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr);
+static void nand_sync (struct mtd_info *mtd);
+
+/*
+ * Send command to NAND device
+ */
+static void nand_command (struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+	register unsigned long NAND_IO_ADDR = this->IO_ADDR;
+
+	/* Begin command latch cycle */
+	NAND_CTRL |= this->CLE;
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command != NAND_CMD_SEQIN)	
+		writeb (command, NAND_IO_ADDR);
+	else {
+		if (mtd->oobblock == 256 && column >= 256) {
+			column -= 256;
+			writeb(NAND_CMD_RESET, NAND_IO_ADDR);
+			writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+		else if (mtd->oobblock == 512 && column >= 256) {
+			if (column < 512) {
+				column -= 256;
+				writeb(NAND_CMD_READ1, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+			else {
+				column -= 512;
+				writeb(NAND_CMD_READOOB, NAND_IO_ADDR);
+				writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+		}
+		else {
+			writeb(NAND_CMD_READ0, NAND_IO_ADDR);
+			writeb(NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+	}
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_CTRL &= ~this->CLE;
+	NAND_CTRL |= this->ALE;
+
+	/* Serially input address */
+	if (column != -1)
+		writeb (column, NAND_IO_ADDR);
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+		/* One more address cycle for higher density devices */
+		if (mtd->size & 0x0c000000) {
+			writeb ((unsigned char) ((page_addr >> 16) & 0x0f),
+					NAND_IO_ADDR);
+		}
+	}
+
+	/* Latch in address */
+	NAND_CTRL &= ~this->ALE;
+
+	/* Pause for 15us */
+	udelay (15);
+}
+
+/*
+ * NAND read
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_read_ecc (mtd, from, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_read_ecc (mtd, from, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND read with ECC
+ */
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf, u_char *ecc_code)
+{
+	int j, col, page, state;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_result;
+	u_char ecc_calc[6];
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_ecc: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+retry:
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* First we calculate the starting page */
+	page = from >> this->page_shift;
+
+	/* Get raw starting column */
+	col = from & (mtd->oobblock - 1);
+
+	/* State machine for devices having pages larger than 256 bytes */
+	state = (col < mtd->eccsize) ? 0 : 1;
+
+	/* Calculate column address within ECC block context */
+	col = (col >= mtd->eccsize) ? (col - mtd->eccsize) : col;
+
+	/* Initialize return value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Loop until all data read */
+	while (*retlen < len) {
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, 0x00, page);
+
+		/* Read in a block big enough for ECC */
+		for (j=0 ; j < mtd->eccsize ; j++)
+			this->data_buf[j] = readb (this->IO_ADDR);
+
+		/* Read in the out-of-band data */
+		if (!state) {
+			nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+			for (j=0 ; j<3 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+		else {
+			nand_command (mtd, NAND_CMD_READOOB, 0x03, page);
+			for (j=3 ; j<6 ; j++)
+				ecc_code[j] = readb(this->IO_ADDR);
+			nand_command (mtd, NAND_CMD_READ0, 0x00, page);
+		}
+
+		/* Calculate the ECC and verify it */
+		if (!state) {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[0]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[0], &ecc_calc[0]);
+		}
+		else {
+			nand_calculate_ecc (&this->data_buf[0],
+						&ecc_calc[3]);
+			ecc_result = nand_correct_data (&this->data_buf[0],
+						&ecc_code[3], &ecc_calc[3]);
+		}
+		if (ecc_result == -1) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_read_ecc: " \
+				"Failed ECC read, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			if (erase_state)
+				this->state = FL_ERASING;
+			else
+				this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Read the data from ECC data buffer into return buffer */
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = this->data_buf[col++];
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = this->data_buf[j];
+#else
+		/* Send the read command */
+		if (!state)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else 
+			nand_command (mtd, NAND_CMD_READ1, col, page);
+
+		/* Read the data directly into the return buffer */ 
+		if ((*retlen + (mtd->eccsize - col)) >= len) {
+			while (*retlen < len)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+			/* We're done */
+			continue;
+		}
+		else
+			for (j=col ; j < mtd->eccsize ; j++)
+				buf[(*retlen)++] = readb (this->IO_ADDR);
+#endif
+
+		/*
+		 * If the amount of data to be read is greater than
+		 * (256 - col), then all subsequent reads will take
+		 * place on page or half-page (in the case of 512 byte
+		 * page devices) aligned boundaries and the column
+		 * address will be zero. Setting the column address to
+		 * to zero after the first read allows us to simplify
+		 * the reading of data and the if/else statements above.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Increment page address */
+		if ((mtd->oobblock == 256) || state)
+			page++;
+
+		/* Toggle state machine */
+		if (mtd->oobblock == 512)
+			state = state ? 0 : 1;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+	
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND read out-of-band
+ */
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len,
+				size_t *retlen, u_char *buf)
+{
+	int i, col, page;
+	int erase_state = 0;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) from) >> this->page_shift;
+
+	/* Mask to get column */
+	col = from & 0x0f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow read past end of page */
+	if ((col + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_read_oob: Attempt read past end of page " \
+			"0x%08x, column %i, length %i\n", page, col, len);
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_READING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	case FL_ERASING:
+		this->state = FL_READING;
+		erase_state = 1;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Send the read command */
+	nand_command (mtd, NAND_CMD_READOOB, col, page);	
+
+	/* Read the data */
+	for (i = 0 ; i < len ; i++)
+		buf[i] = readb (this->IO_ADDR);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	if (erase_state)
+		this->state = FL_ERASING;
+	else
+		this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write
+ */
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf)
+{
+#ifdef CONFIG_MTD_NAND_ECC
+	struct nand_chip *this = mtd->priv;
+	
+	return nand_write_ecc (mtd, to, len, retlen, buf, this->ecc_code_buf);
+#else
+	return nand_write_ecc (mtd, to, len, retlen, buf, NULL);
+#endif
+}
+
+/*
+ * NAND write with ECC
+ */
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf,
+				u_char *ecc_code)
+{
+	int i, page, col, cnt, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Do not allow write past end of page */
+	if ((to + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_ecc: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all data is written */
+	while (*retlen < len) {
+		/* Write data into buffer */
+		if ((col + len) >= mtd->oobblock)
+			for(i=col, cnt=0 ; i < mtd->oobblock ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		else
+			for(i=col, cnt=0 ; cnt < (len - *retlen) ; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			ecc_code[i] = 0x00;
+
+		/* Calculate and write the ECC if we have enough data */
+		if ((col < mtd->eccsize) &&
+			((col + (len - *retlen)) >= mtd->eccsize)) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0], &ecc_code[0]);
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Calculate and write the second ECC if we have enough data */
+		if ((mtd->oobblock == 512) &&
+			((col + (len - *retlen)) >= mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256], &ecc_code[3]);
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					ecc_code[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+
+		/* Write pre-padding bytes into buffer */
+		for (i=0 ; i < col ; i++)
+			this->data_buf[i] = 0xff;
+
+		/* Write post-padding bytes into buffer */
+		if ((col + (len - *retlen)) < mtd->oobblock) {
+			for(i=(col + cnt) ; i < mtd->oobblock ; i++)
+				this->data_buf[i] = 0xff;
+		}
+
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_ecc: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != ecc_code[i]) &&
+					ecc_code[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_write_ecc: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+
+		/*
+		 * If we are writing a large amount of data and/or it
+		 * crosses page or half-page boundaries, we set the
+		 * the column to zero. It simplifies the program logic.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Update written bytes count */
+		*retlen += cnt;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write out-of-band
+ */
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	int i, column, page, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to,
+		(int) len);
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Mask to get column */
+	column = to & 0x1f;
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow write past end of page */
+	if ((column + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Write out desired data */
+	nand_command (mtd, NAND_CMD_SEQIN, column + 512, page);
+	for (i=0 ; i<len ; i++)
+		writeb (buf[i], this->IO_ADDR);
+
+	/* Send command to program the OOB data */
+	nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/*
+	 * Wait for program operation to complete. This could
+	 * take up to 3000us (3ms) on some devices, so we try
+	 * and exit as quickly as possible.
+	 */
+	status = 0;
+	for (i=0 ; i<24 ; i++) {
+		/* Delay for 125us */
+		udelay (125);
+
+		/* Check the status */
+		nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+		status = (int) readb (this->IO_ADDR);
+		if (status & 0x40)
+			break;
+	}
+
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_write_oob: " \
+			"Failed write, page 0x%08x\n", page);
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	nand_command (mtd, NAND_CMD_READOOB, column, page);
+
+	/* Loop through and verify the data */
+	for (i=0 ; i<len ; i++) {
+		if (buf[i] != readb (this->IO_ADDR)) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_write_oob: " \
+				"Failed write verify, page 0x%08x\n", page);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+	}
+#endif
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/*
+ * NAND write with iovec
+ */
+static int nand_writev (struct mtd_info *mtd, const struct iovec *vecs,
+				unsigned long count, loff_t to, size_t *retlen)
+{
+	int i, page, col, cnt, len, total_len, status;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+#ifdef CONFIG_MTD_NAND_ECC
+	int ecc_bytes = (mtd->oobblock == 512) ? 6 : 3;
+#endif
+
+	/* Calculate total length of data */
+	total_len = 0;
+	for (i=0 ; i < count ; i++)
+		total_len += (int) vecs[i].iov_len;
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_writev: to = 0x%08x, len = %i\n", (unsigned int) to,
+			(unsigned int) total_len);
+
+	/* Do not allow write past end of page */
+	if ((to + total_len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_WRITING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get page */
+	page = ((int) to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_writev: Device is write protected!!!\n");
+		nand_deselect ();
+		spin_lock_bh (&this->chip_lock);
+		this->state = FL_READY;
+		wake_up (&this->wq);
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop until all iovecs' data has been written */
+	cnt = col;
+	len = 0;
+	while (count) {
+		/* Do any need pre-fill for partial page programming */
+		for (i=0 ; i < cnt ; i++)
+			this->data_buf[i] = 0xff;
+
+		/*
+		 * Read data out of each tuple until we have a full page
+		 * to write or we've read all the tuples.
+		 */
+		while ((cnt < mtd->oobblock) && count) {
+			this->data_buf[cnt++] =
+				((u_char *) vecs->iov_base)[len++];
+			if (len >= (int) vecs->iov_len) {
+				vecs++;
+				len = 0;
+				count--;
+			}
+		}
+		
+		/* Do any need post-fill for partial page programming */
+		for (i=cnt ; i < mtd->oobblock ; i++)
+			this->data_buf[i] = 0xff;
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/* Zero out the ECC array */
+		for (i=0 ; i < 6 ; i++)
+			this->ecc_code_buf[i] = 0x00;
+
+		/* Calculate and write the first ECC */
+		if (col >= mtd->eccsize) {
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+			for (i=0 ; i < col ; i++)
+				this->data_buf[i] = readb (this->IO_ADDR); 
+			nand_calculate_ecc (&this->data_buf[0],
+				&(this->ecc_code_buf[0]));
+			for (i=0 ; i<3 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Calculate and write the second ECC */
+		if ((mtd->oobblock == 512) && (cnt == mtd->oobblock)) {
+			nand_calculate_ecc (&this->data_buf[256],
+				&(this->ecc_code_buf[3]));
+			for (i=3 ; i<6 ; i++)
+				this->data_buf[(mtd->oobblock + i)] =
+					this->ecc_code_buf[i];
+		}
+
+		/* Write ones for partial page programming */
+		for (i=ecc_bytes ; i < mtd->oobsize ; i++)
+			this->data_buf[(mtd->oobblock + i)] = 0xff;
+#else
+		/* Write ones for partial page programming */
+		for (i=mtd->oobblock ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			this->data_buf[i] = 0xff;
+#endif
+		/* Send command to begin auto page programming */
+		nand_command (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		for (i=0 ; i < (mtd->oobblock + mtd->oobsize) ; i++)
+			writeb (this->data_buf[i], this->IO_ADDR);
+
+		/* Send command to actually program the data */
+		nand_command (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 3000us (3ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<24 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_writev: " \
+				"Failed write, page 0x%08x, " \
+				"%6i bytes were succesful\n", page, *retlen);
+			nand_deselect ();
+			spin_lock_bh (&this->chip_lock);
+			this->state = FL_READY;
+			wake_up (&this->wq);
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+		/*
+		 * The NAND device assumes that it is always writing to
+		 * a cleanly erased page. Hence, it performs its internal
+		 * write verification only on bits that transitioned from
+		 * 1 to 0. The device does NOT verify the whole page on a
+		 * byte by byte basis. It is possible that the page was
+		 * not completely erased or the page is becoming unusable
+		 * due to wear. The read with ECC would catch the error
+		 * later when the ECC page check fails, but we would rather
+		 * catch it early in the page write stage. Better to write
+		 * no data than invalid data.
+		 */
+		
+		/* Send command to read back the page */
+		if (col < mtd->eccsize)
+			nand_command (mtd, NAND_CMD_READ0, col, page);
+		else
+			nand_command (mtd, NAND_CMD_READ1, col - 256, page);
+
+		/* Loop through and verify the data */
+		for (i=col ; i < cnt ; i++) {
+			if (this->data_buf[i] != readb (this->IO_ADDR)) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: " \
+					"Failed write verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, *retlen);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+
+#ifdef CONFIG_MTD_NAND_ECC
+		/*
+		 * We also want to check that the ECC bytes wrote
+		 * correctly for the same reasons stated above.
+		 */
+		nand_command (mtd, NAND_CMD_READOOB, 0x00, page);
+		for (i=0 ; i < ecc_bytes ; i++) {
+			if ((readb (this->IO_ADDR) != this->ecc_code_buf[i]) &&
+					this->ecc_code_buf[i]) {
+				DEBUG (MTD_DEBUG_LEVEL0,
+					"nand_writev: Failed ECC write " \
+					"verify, page 0x%08x, " \
+					"%6i bytes were succesful\n",
+					page, i);
+				nand_deselect ();
+				spin_lock_bh (&this->chip_lock);
+				this->state = FL_READY;
+				wake_up (&this->wq);
+				spin_unlock_bh (&this->chip_lock);
+				return -EIO;
+			}
+		}
+#endif
+
+#endif
+		/* Update written bytes count */
+		*retlen += (cnt - col);
+
+		/* Reset written byte counter and column */
+		col = cnt = 0;
+
+		/* Increment page address */
+		page++;
+	}
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND erase a block
+ */
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	int i, page, len, status, pages_per_block;
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+		"nand_erase: start = 0x%08x, len = %i\n",
+		(unsigned int) instr->addr, (unsigned int) instr->len);
+
+	/* Start address must align on block boundary */
+	if (instr->addr & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Unaligned address\n");
+		return -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (instr->len & (mtd->erasesize - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Length not block aligned\n");
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((instr->len + instr->addr) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Erase past end of device\n");
+		return -EINVAL;
+	}
+
+retry:
+	/* Grab the lock and see if the device is available */
+	spin_lock_bh (&this->chip_lock);
+
+	switch (this->state) {
+	case FL_READY:
+		this->state = FL_ERASING;
+		break;
+
+	default:
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	};
+
+	/* Shift to get first page */
+	page = (int) (instr->addr >> this->page_shift);
+
+	/* Calculate pages in each block */
+	pages_per_block = mtd->erasesize / mtd->oobblock;
+
+	/* Select the NAND device */
+	nand_select ();
+
+	/* Check the WP bit */
+	nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(readb (this->IO_ADDR) & 0x80)) {
+		DEBUG (MTD_DEBUG_LEVEL0,
+			"nand_erase: Device is write protected!!!\n");
+		nand_deselect ();
+		this->state = FL_READY;
+		spin_unlock_bh (&this->chip_lock);
+		return -EIO;
+	}
+
+	/* Loop through the pages */
+	len = instr->len;
+	while (len) {
+		/* Send commands to erase a page */
+		nand_command(mtd, NAND_CMD_ERASE1, -1, page);
+		nand_command(mtd, NAND_CMD_ERASE2, -1, -1);
+
+		/*
+		 * Wait for program operation to complete. This could
+		 * take up to 4000us (4ms) on some devices, so we try
+		 * and exit as quickly as possible.
+		 */
+		status = 0;
+		for (i=0 ; i<32 ; i++) {
+			/* Delay for 125us */
+			udelay (125);
+
+			/* Check the status */
+			nand_command (mtd, NAND_CMD_STATUS, -1, -1);
+			status = (int) readb (this->IO_ADDR);
+			if (status & 0x40)
+				break;
+		}
+
+		/* See if block erase succeeded */
+		if (status & 0x01) {
+			DEBUG (MTD_DEBUG_LEVEL0,
+				"nand_erase: " \
+				"Failed erase, page 0x%08x\n", page);
+			nand_deselect ();
+			this->state = FL_READY;
+			spin_unlock_bh (&this->chip_lock);
+			return -EIO;
+		}
+
+		/* Increment page address and decrement length */
+		len -= mtd->erasesize;
+		page += pages_per_block;
+
+		/* Release the spin lock */
+		spin_unlock_bh (&this->chip_lock);
+
+erase_retry:
+		/* Check the state and sleep if it changed */
+		spin_lock_bh (&this->chip_lock);
+		if (this->state == FL_ERASING) {
+			continue;
+		}
+		else {
+			set_current_state (TASK_UNINTERRUPTIBLE);
+			add_wait_queue (&this->wq, &wait);
+			spin_unlock_bh (&this->chip_lock);
+			schedule();
+
+			remove_wait_queue (&this->wq, &wait);
+			goto erase_retry;
+		}
+	}
+	spin_unlock_bh (&this->chip_lock);
+
+	/* De-select the NAND device */
+	nand_deselect ();
+
+	/* Do call back function */
+	if (instr->callback)
+		instr->callback (instr);
+
+	/* The device is ready */
+	spin_lock_bh (&this->chip_lock);
+	this->state = FL_READY;
+	spin_unlock_bh (&this->chip_lock);
+
+	/* Return happy */
+	return 0;
+}
+
+/*
+ * NAND sync
+ */
+static void nand_sync (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
+
+retry:
+	/* Grab the spinlock */
+	spin_lock_bh(&this->chip_lock);
+
+	/* See what's going on */
+	switch(this->state) {
+	case FL_READY:
+	case FL_SYNCING:
+		this->state = FL_SYNCING;
+		spin_unlock_bh (&this->chip_lock);
+		break;
+
+	default:
+		/* Not an idle state */
+		add_wait_queue (&this->wq, &wait);
+		spin_unlock_bh (&this->chip_lock);
+		schedule ();
+
+		remove_wait_queue (&this->wq, &wait);
+		goto retry;
+	}
+
+        /* Lock the device */
+	spin_lock_bh (&this->chip_lock);
+
+	/* Set the device to be ready again */
+	if (this->state == FL_SYNCING) {
+		this->state = FL_READY;
+		wake_up (&this->wq);
+	}
+
+        /* Unlock the device */
+	spin_unlock_bh (&this->chip_lock);
+}
+
+/*
+ * Scan for the NAND device
+ */
+int nand_scan (struct mtd_info *mtd)
+{
+	int i, nand_maf_id, nand_dev_id;
+	struct nand_chip *this = mtd->priv;
+
+	/* Select the device */
+	nand_select ();
+
+	/* Send the command for reading device ID */
+	nand_command (mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	nand_maf_id = readb (this->IO_ADDR);
+	nand_dev_id = readb (this->IO_ADDR);
+
+	/* Print and store flash device information */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (nand_maf_id == nand_flash_ids[i].manufacture_id &&
+		    nand_dev_id == nand_flash_ids[i].model_id) {
+			if (!mtd->size) {
+				mtd->name = nand_flash_ids[i].name;
+				mtd->erasesize = nand_flash_ids[i].erasesize;
+				mtd->size = (1 << nand_flash_ids[i].chipshift);
+				mtd->eccsize = 256;
+				if (nand_flash_ids[i].page256) {
+					mtd->oobblock = 256;
+					mtd->oobsize = 8;
+					this->page_shift = 8;
+				}
+				else {
+					mtd->oobblock = 512;
+					mtd->oobsize = 16;
+					this->page_shift = 9;
+				}
+			}
+			printk (KERN_INFO "NAND device: Manufacture ID:" \
+				" 0x%02x, Chip ID: 0x%02x (%s)\n",
+			       nand_maf_id, nand_dev_id, mtd->name);
+			break;
+		}
+	}
+
+	/* Initialize state and spinlock */
+	this->state = FL_READY;
+	spin_lock_init(&this->chip_lock);
+
+	/* De-select the device */
+	nand_deselect ();
+
+	/* Print warning message for no device */
+	if (!mtd->size) {
+		printk (KERN_WARNING "No NAND device found!!!\n");
+		return 1;
+	}
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
+	mtd->module = THIS_MODULE;
+	mtd->ecctype = MTD_ECC_SW;
+	mtd->erase = nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = nand_read;
+	mtd->write = nand_write;
+	mtd->read_ecc = nand_read_ecc;
+	mtd->write_ecc = nand_write_ecc;
+	mtd->read_oob = nand_read_oob;
+	mtd->write_oob = nand_write_oob;
+	mtd->readv = NULL;
+	mtd->writev = nand_writev;
+	mtd->sync = nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = NULL;
+	mtd->resume = NULL;
+
+	/* Return happy */
+	return 0;
+}
+
+EXPORT_SYMBOL(nand_scan);
diff -Naur linux-2.4.2.orig/drivers/mtd/nand_ecc.c linux-2.4.2/drivers/mtd/nand_ecc.c
--- linux-2.4.2.orig/drivers/mtd/nand_ecc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/nand_ecc.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,204 @@
+/*
+ *  drivers/mtd/nand_ecc.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *                     Toshiba America Electronics Components, Inc.
+ *
+ * $Id: nand_ecc.c,v 1.4 2001/01/03 20:02:20 mgadbois Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains an ECC algorithm from Toshiba that detects and
+ * corrects 1 bit errors in a 256 byte block of data.
+ */
+
+#include <linux/types.h>
+
+/*
+ * Pre-calculated 256-way 1 byte column parity
+ */
+const u_char nand_ecc_precalc_table[] = {
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
+};
+
+
+/*
+ * Creates non-inverted ECC code from line parity
+ */
+void nand_trans_result(u_char reg2, u_char reg3,
+	u_char *ecc_code)
+{
+	u_char a, b, i, tmp1, tmp2;
+	
+	/* Initialize variables */
+	a = b = 0x80;
+	tmp1 = tmp2 = 0;
+	
+	/* Calculate first ECC byte */
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
+			tmp1 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Calculate second ECC byte */
+	b = 0x80;
+	for (i = 0; i < 4; i++) {
+		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
+			tmp2 |= b;
+		b >>= 1;
+		a >>= 1;
+	}
+	
+	/* Store two of the ECC bytes */
+	ecc_code[0] = tmp1;
+	ecc_code[1] = tmp2;
+}
+
+/*
+ * Calculate 3 byte ECC code for 256 byte block
+ */
+void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
+{
+	u_char idx, reg1, reg2, reg3;
+	int j;
+	
+	/* Initialize variables */
+	reg1 = reg2 = reg3 = 0;
+	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;
+	
+	/* Build up column parity */ 
+	for(j = 0; j < 256; j++) {
+		
+		/* Get CP0 - CP5 from table */
+		idx = nand_ecc_precalc_table[dat[j]];
+		reg1 ^= (idx & 0x3f);
+		
+		/* All bit XOR = 1 ? */
+		if (idx & 0x40) {
+			reg3 ^= (u_char) j;
+			reg2 ^= ~((u_char) j);
+		}
+	}
+	
+	/* Create non-inverted ECC code from line parity */
+	nand_trans_result(reg2, reg3, ecc_code);
+	
+	/* Calculate final ECC code */
+	ecc_code[0] = ~ecc_code[0];
+	ecc_code[1] = ~ecc_code[1];
+	ecc_code[2] = ((~reg1) << 2) | 0x03;
+}
+
+/*
+ * Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	u_char a, b, c, d1, d2, d3, add, bit, i;
+	
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+	
+	if ((d1 | d2 | d3) == 0) {
+		/* No errors */
+		return 0;
+	}
+	else {
+		a = (d1 ^ (d1 >> 1)) & 0x55;
+		b = (d2 ^ (d2 >> 1)) & 0x55;
+		c = (d3 ^ (d3 >> 1)) & 0x54;
+		
+		/* Found and will correct single bit error in the data */
+		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
+			c = 0x80;
+			add = 0;
+			a = 0x80;
+			for (i=0; i<4; i++) {
+				if (d1 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			c = 0x80;
+			for (i=0; i<4; i++) {
+				if (d2 & c)
+					add |= a;
+				c >>= 2;
+				a >>= 1;
+			}
+			bit = 0;
+			b = 0x04;
+			c = 0x80;
+			for (i=0; i<3; i++) {
+				if (d3 & c)
+					bit |= b;
+				c >>= 2;
+				b >>= 1;
+			}
+			b = 0x01;
+			a = dat[add];
+			a ^= (b << bit);
+			dat[add] = a;
+			return 1;
+		}
+		else {
+			i = 0;
+			while (d1) {
+				if (d1 & 0x01)
+					++i;
+				d1 >>= 1;
+			}
+			while (d2) {
+				if (d2 & 0x01)
+					++i;
+				d2 >>= 1;
+			}
+			while (d3) {
+				if (d3 & 0x01)
+					++i;
+				d3 >>= 1;
+			}
+			if (i == 1) {
+				/* ECC Code Error Correction */
+				read_ecc[0] = calc_ecc[0];
+				read_ecc[1] = calc_ecc[1];
+				read_ecc[2] = calc_ecc[2];
+				return 2;
+			}
+			else {
+				/* Uncorrectable Error */
+				return -1;
+			}
+		}
+	}
+	
+	/* Should never happen */
+	return -1;
+}
diff -Naur linux-2.4.2.orig/drivers/mtd/nftl.c linux-2.4.2/drivers/mtd/nftl.c
--- linux-2.4.2.orig/drivers/mtd/nftl.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/nftl.c	Thu Jan 10 18:30:47 2002
@@ -1,56 +1,13 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $ */
+/* $Id: nftl.c,v 1.68 2001/03/26 15:44:47 dwmw2 Exp $ */
 
 /*
   The contents of this file are distributed under the GNU General
-  Public License version 2 ("GPL"). The author places no additional
-  restrictions of any kind on it. However, local legislation in some
-  countries may restrict the use of the algorithms implemented by this
-  code in certain circumstances.
-
-  The legal note below refers only to the _use_ of the code in the 
-  affected jurisdictions, and does not in any way affect the copying,
-  distribution and modification of this code, which are permitted, and
-  indeed required, under the terms of the GPL.
-
-  Section 0 of the GPL says:
- "Activities other than copying, distribution and modification are not
-  covered by this License; they are outside its scope."
-
-  You may copy, distribute and modify this code to your hearts'
-  content - it's just that in some jurisdictions, you may only _use_
-  it under the terms of the patent grant below. This puts it in a
-  similar situation to the ISDN code, which you may need telco
-  approval to use, and indeed any code which has uses that may be
-  restricted in law. For example, certain malicious uses of the
-  networking stack may be illegal, but that doesn't prevent the
-  networking code from being under GPL.
-
-  In fact the ISDN case is worse than this, because modification of
-  the code automatically invalidates its approval. Modification,
-  unlike usage, _is_ one of the rights which is protected by the
-  GPL. Happily, the law in those places where approval is required
-  doesn't actually prevent you from modifying the code - it's just
-  that you may not be allowed to _use_ it once you've done so - and
-  because usage isn't addressed by the GPL, that's just fine.
-
-  dwmw2@infradead.org
-  30/10/0
-
-  LEGAL NOTE: The NFTL format is patented by M-Systems.  They have
-  granted a licence for its use with their DiskOnChip products:
-
-    "M-Systems grants a royalty-free, non-exclusive license under
-    any presently existing M-Systems intellectual property rights
-    necessary for the design and development of NFTL-compatible
-    drivers, file systems and utilities to use the data formats with, 
-    and solely to support, M-Systems' DiskOnChip products"
-
-  A signed copy of this agreement from M-Systems is kept on file by
-  Red Hat UK Limited. In the unlikely event that you need access to it,
-  please contact dwmw2@redhat.com for assistance.  */
+  Public License version 2. The author places no additional
+  restrictions of any kind on it.
+ */
 
 #define PRERELEASE
 
@@ -63,10 +20,11 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/blkpg.h>
+
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
@@ -109,8 +67,8 @@
 static struct gendisk nftl_gendisk = {
         MAJOR_NR,     /* Major number */      
         "nftl",          /* Major name */
-        4,              /* Bits to shift to get real from partition */
-        15,             /* Number of partitions per real */
+        NFTL_PARTN_BITS, /* Bits to shift to get real from partition */
+        (1<<NFTL_PARTN_BITS)-1, /* Number of partitions per real */
 #if LINUX_VERSION_CODE < 0x20328
         MAX_NFTLS,      /* maximum number of real */
         dummy_init,     /* init function */
@@ -209,7 +167,7 @@
 #if LINUX_VERSION_CODE < 0x20328
 	resetup_one_dev(&nftl_gendisk, firstfree);
 #else
-	grok_partitions(&nftl_gendisk, firstfree, 1<<4, nftl->nr_sects);
+	grok_partitions(&nftl_gendisk, firstfree, 1<<NFTL_PARTN_BITS, nftl->nr_sects);
 #endif
 }
 
@@ -654,7 +612,17 @@
 			
 			//printk("Write to VirtualUnitChain %d, calling makefreeblock()\n", thisVUC);
 			writeEUN = NFTL_makefreeblock(nftl, 0xffff);
-			
+
+			if (writeEUN == BLOCK_NIL) {
+				/* OK, we accept that the above comment is 
+				   lying - there may have been free blocks
+				   last time we called NFTL_findfreeblock(),
+				   but they are reserved for when we're
+				   desperate. Well, now we're desperate.
+				*/
+				DEBUG(MTD_DEBUG_LEVEL1, "Using desperate==1 to find free EUN to accommodate write to VUC %d\n", thisVUC);
+				writeEUN = NFTL_findfreeblock(nftl, 1);
+			}
 			if (writeEUN == BLOCK_NIL) {
 				/* Ouch. This should never happen - we should
 				   always be able to make some room somehow. 
@@ -806,8 +774,9 @@
 static int nftl_ioctl(struct inode * inode, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct NFTLrecord *nftl;
+	int p;
 
-	nftl = NFTLs[MINOR(inode->i_rdev) / 16];
+	nftl = NFTLs[MINOR(inode->i_rdev) >> NFTL_PARTN_BITS];
 
 	if (!nftl) return -EINVAL;
 
@@ -837,11 +806,34 @@
 	case BLKRRPART:
 		if (!capable(CAP_SYS_ADMIN)) return -EACCES;
 		if (nftl->usecount > 1) return -EBUSY;
+		/* 
+		 * We have to flush all buffers and invalidate caches,
+		 * or we won't be able to re-use the partitions,
+		 * if there was a change and we don't want to reboot
+		 */
+		p = (1<<NFTL_PARTN_BITS) - 1;
+		while (p-- > 0) {
+			kdev_t devp = MKDEV(MAJOR(inode->i_dev), MINOR(inode->i_dev)+p);
+			if (part_table[p].nr_sects > 0) {
+#if LINUX_VERSION_CODE > 0x20200
+				struct super_block * sb = get_super(devp);
+#endif
+				fsync_dev(devp);
+#if LINUX_VERSION_CODE > 0x20200
+				if (sb)
+					invalidate_inodes(sb);
+#endif
+				invalidate_buffers (devp);
+			}
+			part_table[MINOR(inode->i_dev)+p].start_sect = 0;
+			part_table[MINOR(inode->i_dev)+p].nr_sects = 0;
+		}
+		
 #if LINUX_VERSION_CODE < 0x20328
-		resetup_one_dev(&nftl_gendisk, MINOR(inode->i_rdev) / 16);
+		resetup_one_dev(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS);
 #else
-		grok_partitions(&nftl_gendisk, MINOR(inode->i_rdev) / 16,
-				1<<4, nftl->nr_sects);
+		grok_partitions(&nftl_gendisk, MINOR(inode->i_rdev) >> NFTL_PARTN_BITS,
+				1<<NFTL_PARTN_BITS, nftl->nr_sects);
 #endif
 		return 0;
 
@@ -886,7 +878,7 @@
 		buffer = req->buffer;
 		res = 1; /* succeed */
 
-		if (dev >= MAX_NFTLS * 16) {
+		if (dev >= MAX_NFTLS * (1<<NFTL_PARTN_BITS)) {
 			/* there is no such partition */
 			printk("nftl: bad minor number: device = %s\n",
 			       kdevname(req->rq_dev));
@@ -894,7 +886,7 @@
 			goto repeat;
 		}
 		
-		nftl = NFTLs[dev / 16];
+		nftl = NFTLs[dev / (1<<NFTL_PARTN_BITS)];
 		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
 		down(&nftl->mutex);
 		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
@@ -962,7 +954,7 @@
 
 static int nftl_open(struct inode *ip, struct file *fp)
 {
-	int nftlnum = MINOR(ip->i_rdev) / 16;
+	int nftlnum = MINOR(ip->i_rdev) >> NFTL_PARTN_BITS;
 	struct NFTLrecord *thisNFTL;
 	thisNFTL = NFTLs[nftlnum];
 
@@ -1052,14 +1044,14 @@
 static struct mtd_notifier nftl_notifier = {NFTL_notify_add, NFTL_notify_remove, NULL};
 
 /* static int __init init_nftl(void) */
-int __init init_nftl(void)
+mod_init_t init_nftl(void)
 {
 	int i;
 
 	printk(KERN_NOTICE
 	       "M-Systems NAND Flash Translation Layer driver. (C) 1999 MVHI\n");
 #ifdef PRERELEASE 
-	printk(KERN_INFO"$Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $\n");
+	printk(KERN_INFO"$Id: nftl.c,v 1.68 2001/03/26 15:44:47 dwmw2 Exp $\n");
 #endif
 
 	if (register_blkdev(MAJOR_NR, "nftl", &nftl_fops)){
@@ -1086,12 +1078,13 @@
 	return 0;
 }
 
-static void __exit cleanup_nftl(void)
+/*  static void __exit cleanup_nftl(void) */
+mod_exit_t cleanup_nftl(void)
 {
-	struct gendisk *gd, **gdp;
-
-  	unregister_mtd_user(&nftl_notifier);
-  	unregister_blkdev(MAJOR_NR, "nftl");
+        struct gendisk *gd, **gdp;
+     
+        unregister_mtd_user(&nftl_notifier);
+        unregister_blkdev(MAJOR_NR, "nftl");
   	
 #if LINUX_VERSION_CODE < 0x20320
   	blk_dev[MAJOR_NR].request_fn = 0;
@@ -1105,7 +1098,7 @@
     		if (*gdp == &nftl_gendisk) {
       			gd = *gdp; *gdp = gd->next;
       			break;
-    	}
+		}
 }
 
 module_init(init_nftl);
diff -Naur linux-2.4.2.orig/drivers/mtd/nftlmount.c linux-2.4.2/drivers/mtd/nftlmount.c
--- linux-2.4.2.orig/drivers/mtd/nftlmount.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/nftlmount.c	Thu Jan 10 18:30:47 2002
@@ -4,7 +4,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: nftlmount.c,v 1.11 2000/11/17 12:24:09 ollie Exp $
+ * $Id: nftlmount.c,v 1.13 2001/03/17 16:32:15 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,6 +20,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -28,7 +29,7 @@
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/mtd/mtd.h>
@@ -118,7 +119,7 @@
 				break;
 			}
 		}
-	ReplUnitTable:;
+	ReplUnitTable:
 	}
 
 	if (boot_record_count == 0) {
@@ -359,8 +360,7 @@
 {
 	struct nftl_uci1 h1;
 	unsigned int erase_mark;
-	int i, retlen;
-	unsigned char buf[SECTORSIZE];
+	int retlen;
 
 	/* check erase mark. */
 	if (MTD_READOOB(nftl->mtd, block * nftl->EraseSize + SECTORSIZE + 8, 8, 
@@ -652,7 +652,7 @@
 				}
 			}
 		}
-	examine_ReplUnitTable:;
+	examine_ReplUnitTable:
 	}
 
 	/* second pass to format unreferenced blocks  and init free block count */
diff -Naur linux-2.4.2.orig/drivers/mtd/nora.c linux-2.4.2/drivers/mtd/nora.c
--- linux-2.4.2.orig/drivers/mtd/nora.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/nora.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: nora.c,v 1.17 2000/12/03 19:32:21 dwmw2 Exp $
+ * $Id: nora.c,v 1.18 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * This is so simple I love it.
  */
@@ -179,9 +179,7 @@
 
 	mymtd = do_cfi_probe(&nora_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
 		
 		add_mtd_device(&nora_mtds[2]);
 		add_mtd_device(&nora_mtds[0]);
diff -Naur linux-2.4.2.orig/drivers/mtd/octagon-5066.c linux-2.4.2/drivers/mtd/octagon-5066.c
--- linux-2.4.2.orig/drivers/mtd/octagon-5066.c	Sat Feb 17 01:02:36 2001
+++ linux-2.4.2/drivers/mtd/octagon-5066.c	Thu Jan 10 18:30:47 2002
@@ -1,4 +1,4 @@
-// $Id: octagon-5066.c,v 1.12.2.1 2001/02/15 10:12:48 dwmw2 Exp $
+// $Id: octagon-5066.c,v 1.15 2001/03/17 16:17:35 dwmw2 Exp $
 /* ######################################################################
 
    Octagon 5066 MTD Driver. 
@@ -25,7 +25,7 @@
    ##################################################################### */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <asm/io.h>
@@ -188,7 +188,7 @@
    change pages while monitoring the window. A change in the window, 
    controlled by the PAGE_IO port is a functioning 5066 board. This will
    fail if the thing in the socket is set to a uniform value. */
-static int __init OctProbe()
+static int __init OctProbe(void)
 {
    unsigned int Base = (1 << 6);
    unsigned long I;
@@ -264,9 +264,9 @@
 		if (!oct5066_mtd[i])
 			oct5066_mtd[i] = do_jedec_probe(&oct5066_map[i]);
 		if (!oct5066_mtd[i])
-			oct5066_mtd[i] = do_ram_probe(&oct5066_map[i]);
+			oct5066_mtd[i] = do_map_ram_probe(&oct5066_map[i]);
 		if (!oct5066_mtd[i])
-			oct5066_mtd[i] = do_rom_probe(&oct5066_map[i]);
+			oct5066_mtd[i] = do_map_rom_probe(&oct5066_map[i]);
 		if (oct5066_mtd[i]) {
 			oct5066_mtd[i]->module = THIS_MODULE;
 			add_mtd_device(oct5066_mtd[i]);
diff -Naur linux-2.4.2.orig/drivers/mtd/physmap.c linux-2.4.2/drivers/mtd/physmap.c
--- linux-2.4.2.orig/drivers/mtd/physmap.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/physmap.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: physmap.c,v 1.8 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: physmap.c,v 1.11 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * Normal mappings of chips in physical memory
  */
@@ -21,17 +21,17 @@
 
 __u8 physmap_read8(struct map_info *map, unsigned long ofs)
 {
-	return readb(map->map_priv_1 + ofs);
+	return __raw_readb(map->map_priv_1 + ofs);
 }
 
 __u16 physmap_read16(struct map_info *map, unsigned long ofs)
 {
-	return readw(map->map_priv_1 + ofs);
+	return __raw_readw(map->map_priv_1 + ofs);
 }
 
 __u32 physmap_read32(struct map_info *map, unsigned long ofs)
 {
-	return readl(map->map_priv_1 + ofs);
+	return __raw_readl(map->map_priv_1 + ofs);
 }
 
 void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
@@ -41,17 +41,20 @@
 
 void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
 {
-	writeb(d, map->map_priv_1 + adr);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
 {
-	writew(d, map->map_priv_1 + adr);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
 {
-	writel(d, map->map_priv_1 + adr);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
 }
 
 void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
@@ -78,7 +81,7 @@
 #define cleanup_physmap cleanup_module
 #endif
 
-int __init init_physmap(void)
+mod_init_t init_physmap(void)
 {
        	printk(KERN_NOTICE "physmap flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 	physmap_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
@@ -89,9 +92,8 @@
 	}
 	mymtd = do_cfi_probe(&physmap_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
+
 		add_mtd_device(mymtd);
 		return 0;
 	}
@@ -100,7 +102,7 @@
 	return -ENXIO;
 }
 
-static void __exit cleanup_physmap(void)
+mod_exit_t cleanup_physmap(void)
 {
 	if (mymtd) {
 		del_mtd_device(mymtd);
diff -Naur linux-2.4.2.orig/drivers/mtd/pmc551.c linux-2.4.2/drivers/mtd/pmc551.c
--- linux-2.4.2.orig/drivers/mtd/pmc551.c	Sat Feb 17 01:02:36 2001
+++ linux-2.4.2/drivers/mtd/pmc551.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.c,v 1.11 2000/11/23 13:40:12 dwmw2 Exp $
+ * $Id: pmc551.c,v 1.13 2001/01/11 15:08:59 dwmw2 Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -78,7 +78,7 @@
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -483,7 +483,7 @@
         pci_write_config_word( dev, PMC551_SDRAM_CMD, 0x00bf );
 
         /*
-         * Wait until command has gone through
+         * Wait untill command has gone through
          * FIXME: register spinning issue
          */
         do {	pci_read_config_word( dev, PMC551_SDRAM_CMD, &cmd );
@@ -635,13 +635,11 @@
 /*
  * Kernel version specific module stuffages
  */
-#if LINUX_VERSION_CODE < 0x20211
-#ifdef MODULE
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
 #define init_pmc551 init_module
 #define cleanup_pmc551 cleanup_module
 #endif
-#define __exit
-#endif
 
 #if defined(MODULE)
 MODULE_AUTHOR("Mark Ferrell <mferrell@mvista.com>");
@@ -709,7 +707,7 @@
                        PCI_Device->irq);
 
                 /*
-                 * The PMC551 device acts VERY weird if you don't init it
+                 * The PMC551 device acts VERY wierd if you don't init it
                  * first.  i.e. it will not correctly report devsel.  If for
                  * some reason the sdram is in a wrote-protected state the
                  * device will DEVSEL when it is written to causing problems
@@ -804,7 +802,7 @@
 
                 if (add_mtd_device(mtd)) {
                         printk(KERN_NOTICE "pmc551: Failed to register new device\n");
-			iounmap(priv->start);
+			iounmap(((struct mypriv *)mtd->priv)->start);
                         kfree(mtd->priv);
                         kfree(mtd);
                         break;
@@ -857,7 +855,5 @@
 	printk(KERN_NOTICE "pmc551: %d pmc551 devices unloaded\n", found);
 }
 
-#if LINUX_VERSION_CODE >= 0x20211
 module_init(init_pmc551);
 module_exit(cleanup_pmc551);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/pnc2000.c linux-2.4.2/drivers/mtd/pnc2000.c
--- linux-2.4.2.orig/drivers/mtd/pnc2000.c	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/drivers/mtd/pnc2000.c	Thu Jan 10 18:30:47 2002
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: pnc2000.c,v 1.4 2000/11/27 08:50:22 dwmw2 Exp $
+ * $Id: pnc2000.c,v 1.6 2000/12/21 23:52:43 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -107,11 +107,11 @@
 static struct mtd_info *mymtd;
 
 #if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
-#define init_pnc init_module
+#define init_pnc2000 init_module
 #define cleanup_pnc cleanup_module
 #endif
 
-int __init init_pnc(void)
+int __init init_pnc2000(void)
 {
 	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 
@@ -124,7 +124,7 @@
 	return -ENXIO;
 }
 
-static void __exit cleanup_pnc(void)
+static void __exit cleanup_pnc2000(void)
 {
 	if (mymtd) {
 		del_mtd_partitions(mymtd);
@@ -132,5 +132,5 @@
 	}
 }
 
-module_init(init_pnc);
-module_exit(cleanup_pnc);
+module_init(init_pnc2000);
+module_exit(cleanup_pnc2000);
diff -Naur linux-2.4.2.orig/drivers/mtd/redboot.c linux-2.4.2/drivers/mtd/redboot.c
--- linux-2.4.2.orig/drivers/mtd/redboot.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/redboot.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,148 @@
+/*
+ * $Id: redboot.c,v 1.3 2001/03/17 16:32:50 dwmw2 Exp $
+ *
+ * Parse RedBoot-style Flash Image System (FIS) tables and
+ * produce a Linux partition array to match.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+struct fis_image_desc {
+    unsigned char name[16];      // Null terminated name
+    unsigned long flash_base;    // Address within FLASH of image
+    unsigned long mem_base;      // Address in memory where it executes
+    unsigned long size;          // Length of image
+    unsigned long entry_point;   // Execution entry point
+    unsigned long data_length;   // Length of actual data
+    unsigned char _pad[256-(16+7*sizeof(unsigned long))];
+    unsigned long desc_cksum;    // Checksum over image descriptor
+    unsigned long file_cksum;    // Checksum over image data
+};
+
+struct fis_list {
+	struct fis_image_desc *img;
+	struct fis_list *next;
+};
+
+static inline int redboot_checksum(struct fis_image_desc *img)
+{
+	/* RedBoot doesn't actually write the desc_cksum field yet AFAICT */
+	return 1;
+}
+
+int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+{
+	int nrparts = 0;
+	struct fis_image_desc *buf;
+	struct mtd_partition *parts;
+	struct fis_list *fl = NULL, *tmp_fl;
+	int ret, i;
+	size_t retlen;
+	char *names;
+	int namelen = 0;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	/* Read the start of the last erase block */
+	ret = master->read(master, master->size - master->erasesize,
+			   PAGE_SIZE, &retlen, (void *)buf);
+
+	if (ret)
+		goto out;
+
+	if (retlen != PAGE_SIZE) {
+		ret = -EIO;
+		goto out;
+	}
+
+	if (memcmp(buf, "RedBoot", 8)) {
+		ret = 0;
+		goto out;
+	}
+
+	for (i = 0; i < PAGE_SIZE / sizeof(struct fis_image_desc); i++) {
+		struct fis_list *new_fl, **prev;
+
+		if (buf[i].name[0] == 0xff)
+			break;
+		if (!redboot_checksum(&buf[i]))
+			break;
+
+		new_fl = kmalloc(sizeof(struct fis_list), GFP_KERNEL);
+		namelen += strlen(buf[i].name)+1;
+		if (!new_fl) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		new_fl->img = &buf[i];
+		buf[i].flash_base &= master->size-1;
+
+		/* I'm sure the JFFS2 code has done me permanent damage.
+		 * I now think the following is _normal_
+		 */
+		prev = &fl;
+		while(*prev && (*prev)->img->flash_base < new_fl->img->flash_base)
+			prev = &(*prev)->next;
+		new_fl->next = *prev;
+		*prev = new_fl;
+
+		nrparts++;
+	}
+	if (fl->img->flash_base)
+		nrparts++;
+
+	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
+		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize < tmp_fl->next->img->flash_base)
+			nrparts++;
+	}
+	parts = kmalloc(sizeof(*parts)*nrparts + namelen, GFP_KERNEL);
+
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	names = (char *)&parts[nrparts];
+	memset(parts, 0, sizeof(*parts)*nrparts + namelen);
+	i=0;
+
+	if (fl->img->flash_base) {
+	       parts[0].name = "unallocated space";
+	       parts[0].size = fl->img->flash_base;
+	       parts[0].offset = 0;
+	}
+	for ( ; i<nrparts; i++) {
+		parts[i].size = fl->img->size;
+		parts[i].offset = fl->img->flash_base;
+		parts[i].name = names;
+
+		strcpy(names, fl->img->name);
+		names += strlen(names)+1;
+
+		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize < fl->next->img->flash_base) {
+			i++;
+			parts[i].offset = parts[i-1].size + parts[i-1].offset;
+			parts[i].size = fl->next->img->flash_base - parts[i].offset;
+			parts[i].name = "unallocated space";
+		}
+		tmp_fl = fl;
+		fl = fl->next;
+		kfree(tmp_fl);
+	}
+	ret = nrparts;
+	*pparts = parts;
+ out:
+	while (fl) {
+		struct fis_list *old = fl;
+		fl = fl->next;
+		kfree(old);
+	}
+	kfree(buf);
+	return ret;
+}
diff -Naur linux-2.4.2.orig/drivers/mtd/rpxlite.c linux-2.4.2/drivers/mtd/rpxlite.c
--- linux-2.4.2.orig/drivers/mtd/rpxlite.c	Sun Feb  4 19:05:30 2001
+++ linux-2.4.2/drivers/mtd/rpxlite.c	Thu Jan 10 18:30:47 2002
@@ -1,5 +1,5 @@
 /*
- * $Id: rpxlite.c,v 1.8 2000/12/09 22:00:31 dwmw2 Exp $
+ * $Id: rpxlite.c,v 1.11 2001/03/17 19:08:45 dwmw2 Exp $
  *
  * Handle mapping of the flash on the RPX Lite and CLLF boards
  */
@@ -19,7 +19,7 @@
 
 __u8 rpxlite_read8(struct map_info *map, unsigned long ofs)
 {
-	return readb(map->map_priv_1 * ofs);
+	return readb(map->map_priv_1 + ofs);
 }
 
 __u16 rpxlite_read16(struct map_info *map, unsigned long ofs)
@@ -87,9 +87,7 @@
 	}
 	mymtd = do_cfi_probe(&rpxlite_map);
 	if (mymtd) {
-#ifdef MODULE
-		mymtd->module = &__this_module;
-#endif
+		mymtd->module = THIS_MODULE;
 		add_mtd_device(mymtd);
 		return 0;
 	}
diff -Naur linux-2.4.2.orig/drivers/mtd/sa1100-flash.c linux-2.4.2/drivers/mtd/sa1100-flash.c
--- linux-2.4.2.orig/drivers/mtd/sa1100-flash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sa1100-flash.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,534 @@
+/*
+ * Flash memory access on SA11x0 based devices
+ * 
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ * 
+ * $Id: sa1100-flash.c,v 1.9 2001/03/26 12:02:19 dwmw2 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+
+
+#ifndef CONFIG_ARCH_SA1100
+#error This is for SA1100 architecture only
+#endif
+
+
+#define WINDOW_ADDR 0xe8000000
+
+static __u8 sa1100_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(WINDOW_ADDR + ofs);
+}
+
+static __u16 sa1100_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(WINDOW_ADDR + ofs);
+}
+
+static __u32 sa1100_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(WINDOW_ADDR + ofs);
+}
+
+static void sa1100_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(WINDOW_ADDR + from), len);
+}
+
+static void sa1100_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(WINDOW_ADDR + adr) = d;
+}
+
+static void sa1100_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(WINDOW_ADDR + to), from, len);
+}
+
+
+#ifdef CONFIG_SA1100_BITSY
+
+static void bitsy_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp)
+		set_bitsy_egpio(EGPIO_BITSY_VPP_ON);
+	else
+		clr_bitsy_egpio(EGPIO_BITSY_VPP_ON);
+}
+
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+
+static void jornada720_set_vpp(int vpp)
+{
+  if (vpp)
+      PPSR |= 0x80;
+  else
+      PPSR &= ~0x80;
+  PPDR |= 0x80;
+}
+
+#endif
+
+static struct map_info sa1100_map = {
+	name:		"SA1100",
+	read8:		sa1100_read8,
+	read16:		sa1100_read16,
+	read32:		sa1100_read32,
+	copy_from:	sa1100_copy_from,
+	write8:		sa1100_write8,
+	write16:	sa1100_write16,
+	write32:	sa1100_write32,
+	copy_to:	sa1100_copy_to
+};
+
+
+/*
+ * Here are partition information for all known SA1100-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ * 
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the 
+ * value specified in the mapping definition in arch/arm/mm/mm-sa1100.c 
+ * for the corresponding machine.
+ */
+
+#ifdef CONFIG_SA1100_ASSABET
+
+static unsigned long assabet_max_flash_size = 0x02000000;
+static struct mtd_partition assabet_partitions[] = {
+	{ offset: 0,			size: 0x00040000, 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x000c0000, 	},
+	{ offset: MTDPART_OFS_APPEND,	size: MTDPART_SIZ_FULL 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+static unsigned long huw_webpanel_max_flash_size = 0x01000000;
+static struct mtd_partition huw_webpanel_partitions[] = {
+	{ 
+	  name: "Loader",
+	  size: 0x00040000,
+	  offset: 0,
+	},{
+	  name: "Sector 1",
+	  size: 0x00040000,
+	  offset: MTDPART_OFS_APPEND,
+	},{
+	  size: MTDPART_SIZ_FULL,
+	  offset: MTDPART_OFS_APPEND,
+	}
+};
+#endif /* CONFIG_SA1100_HUW_WEBPANEL */
+
+
+#ifdef CONFIG_SA1100_BITSY
+
+static unsigned long bitsy_max_flash_size = 0x02000000;
+static struct mtd_partition bitsy_partitions[] = {
+	{
+		name: "BITSY boot firmware",
+		size: 0x00040000,
+		offset: 0,
+		mask_flags: MTD_WRITEABLE  /* force read-only */
+	},{
+		name: "BITSY kernel",
+		size: 0x00080000,
+		offset: 0x40000
+	},{
+		name: "BITSY params",
+		size: 0x00040000,
+		offset: 0xC0000
+	},{
+#ifdef CONFIG_JFFS2_FS
+		name: "BITSY root jffs2",
+		offset: 0x00100000,
+		size: MTDPART_SIZ_FULL
+#else
+		name: "BITSY initrd",
+		size: 0x00100000,
+		offset: 0x00100000
+	},{
+		name: "BITSY root cramfs",
+		size: 0x00300000,
+		offset: 0x00200000
+	},{
+		name: "BITSY usr cramfs",
+		size: 0x00800000,
+		offset: 0x00500000
+	},{
+		name: "BITSY usr local",
+		offset: 0x00d00000,
+		size: MTDPART_SIZ_FULL
+#endif
+	}
+};
+
+#endif
+#ifdef CONFIG_SA1100_FREEBIRD
+static unsigned long freebird_max_flash_size = 0x02000000;
+static struct mtd_partition freebird_partitions[] = {
+#if CONFIG_SA1100_FREEBIRD_NEW
+    {
+     name: "firmware",
+     size: 0x00040000,
+     offset: 0,
+     mask_flags: MTD_WRITEABLE  /* force read-only */
+    },{
+     name: "kernel",
+     size: 0x00080000,
+     offset: 0x40000
+    },{
+     name: "params",
+     size: 0x00040000,
+     offset: 0xC0000
+    },{
+     name: "initrd",
+     size: 0x00100000,
+     offset: 0x00100000
+    },{
+     name: "root cramfs",
+     size: 0x00300000,
+     offset: 0x00200000
+    },{
+     name: "usr cramfs",
+     size: 0x00800000,
+     offset: 0x00500000
+    },{
+	 name: "local",
+	 offset: 0x00d00000,
+	 size: 0
+	}
+#else
+	{ offset: 0,            		size: 0x00040000,   },
+	{ offset: MTDPART_OFS_APPEND,   size: 0x000c0000,   },
+	{ offset: MTDPART_OFS_APPEND,	size: 0x00400000,	},
+	{ offset: MTDPART_OFS_APPEND,   size: MTDPART_SIZ_FULL  }
+#endif
+	};
+#endif
+																									
+
+#ifdef CONFIG_SA1100_CERF
+
+static unsigned long cerf_max_flash_size = 0x01000000;
+static struct mtd_partition cerf_partitions[] = {
+	{ offset: 0,			size: 0x00800000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x00800000 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+
+static unsigned long graphicsclient_max_flash_size = 0x01000000;
+static struct mtd_partition graphicsclient_partitions[] = {
+	{ 
+	 name: "Bootloader + zImage",
+	 offset: 0,
+	 size: 0x100000
+	},
+	{ 
+         name: "ramdisk.gz",
+         offset: MTDPART_OFS_APPEND,
+         size: 0x300000 		
+	},
+	{ 
+	  name: "User FS",
+          offset: MTDPART_OFS_APPEND,	
+          size: MTDPART_SIZ_FULL
+	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_LART
+
+static unsigned long lart_max_flash_size = 0x00400000;
+static struct mtd_partition lart_partitions[] = {
+	{ offset: 0,			size: 0x020000 		},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x0e0000 		},
+	{ offset: MTDPART_OFS_APPEND,	size: MTDPART_SIZ_FULL 	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+
+static unsigned long pangolin_max_flash_size = 0x04000000;
+static struct mtd_partition pangolin_partitions[] = {
+	{
+	  name: "boot firmware",
+	  offset: 0x00000000,
+	  size: 0x00080000,
+	  mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+	  name: "kernel",
+	  offset: 0x00080000,
+	  size: 0x00100000,
+	},
+	{
+	  name: "initrd",
+	  offset: 0x00180000,
+	  size: 0x00200000,
+	},
+	{
+	  name: "initrd-test",
+	  offset: 0x00400000,
+	  size: 0x03C00000,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+
+static unsigned long yopy_max_flash_size = 0x08000000;
+static struct mtd_partition yopy_partitions[] = {
+	{
+		name: "boot firmware",
+		offset: 0x00000000,
+		size: 0x00040000,
+		mask_flags: MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		name: "kernel",
+		offset: 0x00080000,
+		size: 0x00080000,
+	},
+	{
+		name: "initrd",
+		offset: 0x00100000,
+		size: 0x00300000,
+	},
+	{
+		name: "root",
+		offset: 0x00400000,
+		size: 0x01000000,
+	},
+};
+
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+
+static unsigned long jornada720_max_flash_size = 0x02000000;
+static struct mtd_partition jornada720_partitions[] = {
+	{
+		name: "JORNADA720 boot firmware",
+		size: 0x00040000,
+		offset: 0,
+		mask_flags: MTD_WRITEABLE  /* force read-only */
+	},{
+		name: "JORNADA720 kernel",
+		size: 0x000c0000,
+		offset: 0x40000
+	},{
+		name: "JORNADA720 params",
+		size: 0x00040000,
+		offset: 0x100000
+	},{
+		name: "JORNADA720 initrd",
+		size: 0x00100000,
+		offset: 0x00140000
+	},{
+		name: "JORNADA720 root cramfs",
+		size: 0x00300000,
+		offset: 0x00240000
+	},{
+		name: "JORNADA720 usr cramfs",
+		size: 0x00800000,
+		offset: 0x00540000
+	},{
+		name: "JORNADA720 usr local",
+		offset: 0x00d00000,
+		size: 0  /* will expand to the end of the flash */
+	}
+};
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+
+static unsigned long sherman_max_flash_size = 0x02000000;
+static struct mtd_partition sherman_partitions[] = {
+	{ offset: 0,			size: 0x50000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x70000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0x600000 	},
+	{ offset: MTDPART_OFS_APPEND,	size: 0xA0000 	}
+};
+
+#endif
+
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+static int redboot_nr_parts;
+static struct mtd_partition *redboot_parts;
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+
+int __init sa1100_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int buswidth = (MSC0 & MSC_RBW) ? 2 : 4;
+	
+#ifdef CONFIG_SA1100_ASSABET
+	if (machine_is_assabet()) {
+		parts = assabet_partitions;
+		nb_parts = NB_OF(assabet_partitions);
+		sa1100_map.size = assabet_max_flash_size;
+	}
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+	if (machine_is_huw_webpanel()) {
+		parts = huw_webpanel_partitions;
+		nb_parts = NB_OF(huw_webpanel_partitions);
+		sa1100_map.size = huw_webpanel_max_flash_size;
+	}
+#endif
+
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		parts = bitsy_partitions;
+		nb_parts = NB_OF(bitsy_partitions);
+		sa1100_map.size = bitsy_max_flash_size;
+		sa1100_map.set_vpp = bitsy_set_vpp;
+	}
+#endif
+#ifdef CONFIG_SA1100_FREEBIRD
+	if (machine_is_freebird()) {
+		parts = freebird_partitions;
+		nb_parts = NB_OF(freebird_partitions);
+		sa1100_map.size = freebird_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_CERF
+	if (machine_is_cerf()) {
+		parts = cerf_partitions;
+		nb_parts = NB_OF(cerf_partitions);
+		sa1100_map.size = cerf_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+	if (machine_is_graphicsclient()) {
+		parts = graphicsclient_partitions;
+		nb_parts = NB_OF(graphicsclient_partitions);
+		sa1100_map.size = graphicsclient_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_LART
+	if (machine_is_lart()) {
+		parts = lart_partitions;
+		nb_parts = NB_OF(lart_partitions);
+		sa1100_map.size = lart_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_PANGOLIN
+	if (machine_is_pangolin()) {
+		parts = pangolin_partitions;
+		nb_parts = NB_OF(pangolin_partitions);
+		sa1100_map.size = pangolin_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_JORNADA720
+	if (machine_is_jornada720()) {
+		parts = jornada720_partitions;
+		nb_parts = NB_OF(jornada720_partitions);
+		sa1100_map.size = jornada720_max_flash_size;
+		sa1100_map.set_vpp = jornada720_set_vpp;
+	}
+#endif
+#ifdef CONFIG_SA1100_YOPY
+	if (machine_is_yopy()) {
+		parts = yopy_partitions;
+		nb_parts = NB_OF(yopy_partitions);
+		sa1100_map.size = yopy_max_flash_size;
+	}
+#endif
+#ifdef CONFIG_SA1100_SHERMAN
+	if (machine_is_sherman()) {
+		parts = sherman_partitions;
+		nb_parts = NB_OF(sherman_partitions);
+		sa1100_map.size = sherman_max_flash_size;
+	}
+#endif
+	sa1100_map.buswidth = buswidth;
+
+	if (!nb_parts) {
+		printk(KERN_WARNING "MTD: no known flash definition for this SA1100 machine\n");
+		return -ENXIO;
+	}
+	printk(KERN_NOTICE "SA1100 flash: probing for %d partitions (buswidth = %d)\n",
+		nb_parts, buswidth);
+
+	mymtd = do_cfi_probe(&sa1100_map);
+	if (!mymtd)
+		return -ENXIO;
+
+	mymtd->module = THIS_MODULE;
+
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+	redboot_nr_parts = parse_redboot_partitions(mymtd, &redboot_parts);
+	if (redboot_nr_parts > 0) {
+		int i;
+
+		parts = redboot_parts;
+		nb_parts = redboot_nr_parts;
+
+		for (i=0; i<nb_parts; i++) {
+			printk(KERN_NOTICE "RedBoot Partition: \"%s\", 0x%08lx-0x%08lx\n",
+			       parts[i].name, parts[i].offset, parts[i].offset+parts[i].size);
+		}
+	} else {
+		printk(KERN_NOTICE "No RedBoot partition table found. Using default partitioning\n");
+	}
+#endif
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	printk(KERN_NOTICE "SA1100 flash access initialized\n");
+	return 0;
+}
+
+static void __exit sa1100_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+#ifdef CONFIG_MTD_SA1100_REDBOOT_PARTITIONS
+		if (redboot_parts)
+			kfree(redboot_parts);
+#endif
+	}
+}
+
+module_init(sa1100_mtd_init);
+module_exit(sa1100_mtd_cleanup);
diff -Naur linux-2.4.2.orig/drivers/mtd/sbc_mediagx.c linux-2.4.2/drivers/mtd/sbc_mediagx.c
--- linux-2.4.2.orig/drivers/mtd/sbc_mediagx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sbc_mediagx.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,250 @@
+/* sbc_mediagx.c -- MTD map driver for Arcom Control Systems SBC-MediaGX
+ 
+   Copyright (C) 2000 Arcom Control System Ltd
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+   $Id: sbc_mediagx.c,v 1.11 2001/03/17 16:24:05 dwmw2 Exp $
+
+The SBC-MediaGX has up to 16 Mbyte of Intel StrataFlash (28F320/28F640) in x8
+mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
+
+The flash is accessed as follows:
+
+   16 kbyte memory window at 0xdc000-0xdffff
+   Two IO address locations for paging
+   0x258
+       bit 0-7: address bit 14-21
+   0x259
+       bit 0-1: address bit 22-23
+       bit 7:   0 - reset/powered down
+                1 - device enabled
+
+The single flash device is divided into 3 partition which appear as seperate
+MTD devices.
+*/
+#include <linux/module.h>
+#include <linux/malloc.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_START 0xdc000
+/* Number of bits in offset. */
+#define WINDOW_SHIFT 14
+#define WINDOW_LENGTH (1 << WINDOW_SHIFT)
+/* The bits for the offset into the window. */
+#define WINDOW_MASK (WINDOW_LENGTH-1)
+#define PAGE_IO 0x258
+#define PAGE_IO_SIZE 2
+
+/* bit 7 of 0x259 must be 1 to enable device. */
+#define DEVICE_ENABLE 0x8000
+
+static volatile int page_in_window = -1; // Current page in window.
+static unsigned long iomapadr;
+static spinlock_t sbc_mediagx_spin = SPIN_LOCK_UNLOCKED;
+
+/* partition_info gives details on the logical partitions that the split the 
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[]={
+    { name: "SBC-MediaGX flash boot partition", 
+      offset: 0, 
+      size: 640*1024 },
+    { name: "SBC-MediaGX flash partition 1", 
+      offset: 640*1024, 
+      size: 2*1024*1024-640*1024 },
+    { name: "SBC-MediaGX flash partition 2", 
+      offset: 2*1024*1024 }
+};
+#define NUM_PARTITIONS 3
+
+static inline void sbc_mediagx_page(struct map_info *map, unsigned long ofs)
+{
+	unsigned long page = ofs >> WINDOW_SHIFT;
+
+	if( page!=page_in_window ) {
+		outw( page | DEVICE_ENABLE, PAGE_IO );
+		page_in_window = page;
+	}
+}
+
+
+static __u8 sbc_mediagx_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readb(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static __u16 sbc_mediagx_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readw(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static __u32 sbc_mediagx_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, ofs);
+	ret = readl(iomapadr + (ofs & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+	return ret;
+}
+
+static void sbc_mediagx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
+		
+		spin_lock(&sbc_mediagx_spin);
+		sbc_mediagx_page(map, from);
+		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
+		spin_unlock(&sbc_mediagx_spin);
+		(__u8*)to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static void sbc_mediagx_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writeb(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writew(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	spin_lock(&sbc_mediagx_spin);
+	sbc_mediagx_page(map, adr);
+	writel(d, iomapadr + (adr & WINDOW_MASK));
+	spin_unlock(&sbc_mediagx_spin);
+}
+
+static void sbc_mediagx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{	
+	while(len) {
+		unsigned long thislen = len;
+		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
+			thislen = WINDOW_LENGTH-(to & WINDOW_MASK);
+		
+		spin_lock(&sbc_mediagx_spin);
+		sbc_mediagx_page(map, to);
+		memcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);
+		spin_unlock(&sbc_mediagx_spin);
+		to += thislen;
+		from += thislen;
+		len -= thislen;
+	}
+}
+
+static struct map_info sbc_mediagx_map = {
+	name: "SBC-MediaGX flash",
+	size: 16*1024*1024, /* this must be set to a maximum possible amount
+			 of flash so the cfi probe routines find all
+			 the chips */
+	buswidth: 1,
+	read8: sbc_mediagx_read8,
+	read16: sbc_mediagx_read16,
+	read32: sbc_mediagx_read32,
+	copy_from: sbc_mediagx_copy_from,
+	write8: sbc_mediagx_write8,
+	write16: sbc_mediagx_write16,
+	write32: sbc_mediagx_write32,
+	copy_to: sbc_mediagx_copy_to
+};
+
+/* MTD device for all of the flash. */
+static struct mtd_info *all_mtd;
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_sbc_mediagx init_module
+#define cleanup_sbc_mediagx cleanup_module
+#endif
+
+mod_exit_t cleanup_sbc_mediagx(void)
+{
+	if( all_mtd ) {
+		del_mtd_partitions( all_mtd );
+		map_destroy( all_mtd );
+	}
+
+	iounmap((void *)iomapadr);
+	release_region(PAGE_IO,PAGE_IO_SIZE);
+}
+
+mod_init_t init_sbc_mediagx(void)
+{
+	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
+		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
+			sbc_mediagx_map.name,
+			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
+		return -EAGAIN;
+	}
+  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+	if (!iomapadr) {
+		printk( KERN_ERR"%s: failed to ioremap memory region\n",
+			sbc_mediagx_map.name );
+		return -EIO;
+	}
+	
+	request_region( PAGE_IO, PAGE_IO_SIZE, "SBC-MediaGX flash" );
+	
+	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
+		sbc_mediagx_map.name,
+		PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,
+		WINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );
+
+	/* Probe for chip. */
+	all_mtd = do_cfi_probe( &sbc_mediagx_map );
+	if( !all_mtd ) {
+		cleanup_sbc_mediagx();
+		return -ENXIO;
+	}
+	
+	all_mtd->module=THIS_MODULE;
+
+	/* Create MTD devices for each partition. */
+	add_mtd_partitions(all_mtd, partition_info, NUM_PARTITIONS );
+
+	return 0;
+}
+
+module_init(init_sbc_mediagx);
+module_exit(cleanup_sbc_mediagx);
diff -Naur linux-2.4.2.orig/drivers/mtd/sc520cdp.c linux-2.4.2/drivers/mtd/sc520cdp.c
--- linux-2.4.2.orig/drivers/mtd/sc520cdp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sc520cdp.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,163 @@
+/* sc520cdp.c -- MTD map driver for AMD SC520 Customer Development Platform
+ *
+ * Copyright (C) 2001 Sysgo Real-Time Solutions GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * $Id: sc520cdp.c,v 1.2 2001/03/17 19:08:45 dwmw2 Exp $
+ *
+ *
+ * The SC520CDP is an evaluation board for the Elan SC520 processor available
+ * from AMD. It has two banks of 32-bit Flash ROM, each 8 Megabytes in size.
+ * For details see http://www.amd.com/products/epd/desiging/evalboards/18.elansc520/520_cdp_brief/index.html
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+
+#define WINDOW_ADDR_0	0x08400000
+#define WINDOW_ADDR_1	0x08C00000
+#define WINDOW_SIZE		0x00800000
+
+static __u8 sc520cdp_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 sc520cdp_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 sc520cdp_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void sc520cdp_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void sc520cdp_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sc520cdp_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info sc520cdp_map[] = {
+	{
+		name: "SC520CDP Flash Bank #0",
+		size: WINDOW_SIZE,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_0
+	},
+	{
+		name: "SC520CDP Flash Bank #1",
+		size: WINDOW_SIZE,
+		buswidth: 4,
+		read8: sc520cdp_read8,
+		read16: sc520cdp_read16,
+		read32: sc520cdp_read32,
+		copy_from: sc520cdp_copy_from,
+		write8: sc520cdp_write8,
+		write16: sc520cdp_write16,
+		write32: sc520cdp_write32,
+		copy_to: sc520cdp_copy_to,
+		map_priv_2: WINDOW_ADDR_1
+	},
+};
+
+#define NUM_FLASH_BANKS	(sizeof(sc520cdp_map)/sizeof(struct map_info))
+
+static struct mtd_info *mymtd[NUM_FLASH_BANKS];
+
+
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_sc520cdp init_module
+#define cleanup_sc520cdp cleanup_module
+#endif
+
+static int __init init_sc520cdp(void)
+{
+	int i;
+	
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		printk(KERN_NOTICE "SC520 CDP flash device: %x at %lx\n", WINDOW_SIZE, sc520cdp_map[i].map_priv_2);
+		sc520cdp_map[i].map_priv_1 = (unsigned long)ioremap(sc520cdp_map[i].map_priv_2, WINDOW_SIZE);
+
+		if (!sc520cdp_map[i].map_priv_1) {
+			printk("Failed to ioremap\n");
+			return -EIO;
+		}
+		mymtd[i] = do_cfi_probe(&sc520cdp_map[i]);
+		if (mymtd[i]) {
+			mymtd[i]->module = THIS_MODULE;
+			add_mtd_device(mymtd[i]);
+		}
+		else {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+			return -ENXIO;
+		}
+	}
+	return 0;
+}
+
+static void __exit cleanup_sc520cdp(void)
+{
+	int i;
+	
+	for (i = 0; i < NUM_FLASH_BANKS; i++) {
+		if (mymtd[i]) {
+			del_mtd_device(mymtd[i]);
+			map_destroy(mymtd[i]);
+		}
+		if (sc520cdp_map[i].map_priv_1) {
+			iounmap((void *)sc520cdp_map[i].map_priv_1);
+			sc520cdp_map[i].map_priv_1 = 0;
+		}
+	}
+}
+
+module_init(init_sc520cdp);
+module_exit(cleanup_sc520cdp);
diff -Naur linux-2.4.2.orig/drivers/mtd/sharp.c linux-2.4.2/drivers/mtd/sharp.c
--- linux-2.4.2.orig/drivers/mtd/sharp.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sharp.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,474 @@
+/*
+ * MTD map driver for pre-CFI Sharp flash chips
+ *
+ * Copyright 2000 David Schleef <ds@lineo.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/delay.h>
+
+struct mtd_info *sharp_probe(struct map_info *);
+
+static int sharp_probe_map(struct map_info *map);
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf);
+static int sharp_write(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, const u_char *buf);
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr);
+static void sharp_sync(struct mtd_info *mtd);
+static int sharp_suspend(struct mtd_info *mtd);
+static void sharp_resume(struct mtd_info *mtd);
+static void sharp_destroy(struct mtd_info *mtd);
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum);
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+
+static struct map_driver sharp_driver={
+	name:		"sharp",
+	module:		THIS_MODULE,
+	probe:		sharp_probe,
+};
+
+struct sharp_info{
+	struct flchip *chip;
+	int bogus;
+	int chipshift;
+	int numchips;
+	struct flchip chips[1];
+};
+
+
+struct mtd_info *sharp_probe(struct map_info *map)
+{
+	struct mtd_info *mtd = NULL;
+	struct sharp_info *sharp = NULL;
+	int width;
+
+	width = sharp_probe_map(map);
+	if(!width)
+		return NULL;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if(!mtd)
+		return NULL;
+
+	sharp = kmalloc(sizeof(*sharp), GFP_KERNEL);
+	if(!sharp)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	mtd->erasesize = 0x10000 * width;
+	mtd->size = 0x200000 * width;
+	mtd->erase = sharp_erase;
+	mtd->read = sharp_read;
+	mtd->write = sharp_write;
+	mtd->sync = sharp_sync;
+	mtd->suspend = sharp_suspend;
+	mtd->resume = sharp_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+
+	sharp->chipshift = 23;
+	sharp->numchips = 1;
+	sharp->chips[0].start = 0;
+	sharp->chips[0].state = FL_READY;
+	sharp->chips[0].mutex = &sharp->chips[0]._spinlock;
+	init_waitqueue_head(&sharp->chips[0].wq);
+	spin_lock_init(&sharp->chips[0]._spinlock);
+
+	map->fldrv_destroy = sharp_destroy;
+	map->fldrv_priv = sharp;
+
+	return mtd;
+}
+
+static int sharp_probe_map(struct map_info *map)
+{
+	unsigned long tmp;
+	unsigned long base = 0;
+	u32 read0, read4;
+
+	tmp = map->read32(map, base+0);
+
+	map->write32(map, 0x90909090, base+0);
+
+	read0=map->read32(map, base+0);
+	read4=map->read32(map, base+4);
+	if(read0 == 0x89898989){
+		printk("Looks like sharp flash\n");
+		if((read4 == 0xaaaaaaaa) || (read4 == 0xa0a0a0a0)) {
+			/* aa - 16Mb (that's 2MB to you and me) */
+			/* a0 - 16Mb -Z4 */
+			return 4;
+		}else{
+			printk("Sort-of looks like sharp flash, 0x%08x 0x%08x\n",
+				read0,read4);
+		}
+	}else if((map->read32(map, base+0) == 0x90909090)){
+		/* RAM, probably */
+		printk("Looks like RAM\n");
+		map->write32(map, tmp, base+0);
+	}else{
+		printk("Doesn't look like sharp flash, 0x%08x 0x%08x\n",
+			read0,read4);
+	}
+
+	return 0;
+}
+
+/* This function returns with the chip->mutex lock held. */
+static int sharp_wait(struct map_info *map, struct flchip *chip)
+{
+	__u16 status;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+	int adr = 0;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	switch(chip->state){
+	case FL_READY:
+		map->write32(map,0x70707070,adr);
+		chip->state = FL_STATUS;
+	case FL_STATUS:
+		status = map->read32(map,adr);
+//printk("status=%08x\n",status);
+
+		udelay(100);
+		if((status & 0x80808080)!=0x80808080){
+//printk(".status=%08x\n",status);
+			udelay(100);
+		}
+		break;
+	default:
+		printk("Waiting for chip\n");
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	map->write32(map,0xffffffff, adr);
+
+	chip->state = FL_READY;
+
+	return 0;
+}
+
+static void sharp_release(struct flchip *chip)
+{
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+}
+
+/* Needs to be called _with_ lock, and returns with lock
+ * unless there is an error */
+static int sharp_wait_state(struct map_info *map,struct flchip *chip,
+	int state,unsigned long adr)
+{
+	int timeo;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if(chip->state != state){
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current))
+			return -EINTR;
+		
+		timeo = jiffies + (HZ/2);
+
+		spin_lock_bh(chip->mutex);
+	}
+	if(chip->state != state){
+		return 0;
+	}
+
+	return 1;
+}
+
+static int sharp_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int chipnum;
+	int ret = 0;
+	int ofs = 0;
+
+	chipnum = (from >> sharp->chipshift);
+	ofs = from & ((1 << sharp->chipshift)-1);
+
+	*retlen = 0;
+
+	while(len){
+		unsigned long thislen;
+
+		if(chipnum>=sharp->numchips)
+			break;
+
+		thislen = len;
+		if(ofs+thislen >= (1<<sharp->chipshift))
+			thislen = (1<<sharp->chipshift) - ofs;
+
+		ret = sharp_wait(map,&sharp->chips[chipnum]);
+		if(ret<0)
+			break;
+
+		map->copy_from(map,buf,ofs,thislen);
+
+		sharp_release(&sharp->chips[chipnum]);
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int sharp_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	int ret = 0;
+	int i,j;
+	int chipnum;
+	unsigned long ofs;
+	union { u32 l; unsigned char uc[4]; } tbuf;
+
+	*retlen = 0;
+
+	while(len){
+		tbuf.l = 0xffffffff;
+		chipnum = to >> sharp->chipshift;
+		ofs = to & ((1<<sharp->chipshift)-1);
+
+		j=0;
+		for(i=ofs&3;i<4 && len;i++){
+			tbuf.uc[i] = *buf;
+			buf++;
+			to++;
+			len--;
+			j++;
+		}
+		sharp_write_oneword(map, &sharp->chips[chipnum], ofs&~3, tbuf.l);
+		if(ret<0)
+			return ret;
+		(*retlen)+=j;
+	}
+
+	return 0;
+}
+
+static int sharp_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum)
+{
+	int ret;
+	int timeo;
+	int z;
+
+	ret = sharp_wait(map,chip);
+
+	map->write32(map,0x40404040,adr);
+	/* cpu_to_le32 -> hack to fix the writel be->le conversion */
+	map->write32(map,cpu_to_le32(datum),adr);
+
+	chip->state = FL_WRITING;
+
+	timeo = jiffies + (HZ/2);
+
+	spin_unlock_bh(chip->mutex);
+	udelay(chip->word_write_time);
+	spin_lock_bh(chip->mutex);
+
+	while(1){
+		ret = sharp_wait_state(map,chip,FL_WRITING,adr);
+		if(ret < 0)return ret;
+		if(ret==1)break;
+
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in read\n");
+			return -EIO;
+		}
+
+		spin_unlock_bh(chip->mutex);
+
+		z++;
+
+		udelay(1);
+
+		spin_lock_bh(chip->mutex);
+		continue;
+	}
+	chip->word_write_time += (z)?+1:-1;
+	if(chip->word_write_time<1)chip->word_write_time = 1;
+
+	chip->state = FL_STATUS;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+static int sharp_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct sharp_info *sharp = map->fldrv_priv;
+	unsigned long adr,len;
+	int chipnum, ret=0;
+
+printk("sharp_erase()\n");
+	if(instr->addr & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len + instr->addr > mtd->size)
+		return -EINVAL;
+
+	chipnum = instr->addr >> sharp->chipshift;
+	adr = instr->addr & ((1<<sharp->chipshift)-1);
+	len = instr->len;
+
+	while(len){
+		ret = sharp_erase_oneblock(map, &sharp->chips[chipnum], adr);
+		if(ret)return ret;
+
+		adr += mtd->erasesize;
+		len -= mtd->erasesize;
+		if(adr >> sharp->chipshift){
+			adr = 0;
+			chipnum++;
+			if(chipnum>=sharp->numchips)
+				break;
+		}
+	}
+
+printk("callback: %p\n",instr->callback);
+	if(instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+static int sharp_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	int timeo;
+
+printk("sharp_erase_oneblock()\n");
+	ret = sharp_wait(map,chip);
+
+	map->write32(map,0x20202020,adr);
+	map->write32(map,0xd0d0d0d0,adr);
+
+	chip->state = FL_ERASING;
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	timeo = jiffies + HZ;
+
+	while(1){
+		ret = sharp_wait_state(map,chip,FL_ERASING,adr);
+		if(ret < 0)return ret;
+		if(ret==1)break;
+
+		if (time_after(jiffies, timeo)) {
+			chip->state = FL_STATUS;
+			spin_unlock_bh(chip->mutex);
+			printk("waiting for chip to be ready timed out in erase\n");
+			return -EIO;
+		}
+
+		spin_unlock_bh(chip->mutex);
+
+		udelay(1);
+
+		spin_lock_bh(chip->mutex);
+		continue;
+	}
+
+	chip->state = FL_STATUS;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+printk("sharp_erase_oneblock() done\n");
+
+	return 0;
+}
+
+static void sharp_sync(struct mtd_info *mtd)
+{
+	printk("sharp_sync()\n");
+	
+}
+
+static int sharp_suspend(struct mtd_info *mtd)
+{
+	printk("sharp_suspend()\n");
+	return -EINVAL;
+}
+
+static void sharp_resume(struct mtd_info *mtd)
+{
+	printk("sharp_resume()\n");
+	
+}
+
+static void sharp_destroy(struct mtd_info *mtd)
+{
+	printk("sharp_destroy()\n");
+
+}
+
+
+static int __init sharp_init(void)
+{
+	printk("MTD Sharp chip driver <ds@lineo.com>\n");
+	mtd_register_map_driver(&sharp_driver);
+}
+
+static void __exit sharp_cleanup(void)
+{
+	mtd_unregister_map_driver(&sharp_driver);
+}
+
+module_init(sharp_init);
+module_cleanup(sharp_cleanup);
+
+
diff -Naur linux-2.4.2.orig/drivers/mtd/slram.c linux-2.4.2/drivers/mtd/slram.c
--- linux-2.4.2.orig/drivers/mtd/slram.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/slram.c	Thu Jan 10 18:30:47 2002
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: slram.c,v 1.10 2000/07/03 10:01:38 dwmw2 Exp $
+  $Id: slram.c,v 1.14 2001/01/11 15:17:42 dwmw2 Exp $
 
 ======================================================================*/
 
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -106,15 +106,12 @@
 static u_long length = 33554432;
 static u_long end = 0;
 
-#if LINUX_VERSION_CODE < 0x20300
 #ifdef MODULE
+#if LINUX_VERSION_CODE < 0x20212
 #define init_slram init_module
 #define cleanup_slram cleanup_module
 #endif
-#define __exit
-#endif
 
-#ifdef MODULE
 MODULE_PARM(start,"l");
 MODULE_PARM(length,"l");
 MODULE_PARM(end,"l");
@@ -179,8 +176,10 @@
 		return -ENOMEM;
 	}
 	
-	
-	((struct mypriv *)mymtd->priv)->start = ioremap(start, length);
+	if (!(((struct mypriv *)mymtd->priv)->start = ioremap(start, length))) {
+		printk(KERN_NOTICE "slram: ioremap failed\n");
+		return -EIO;
+	}
 	((struct mypriv *)mymtd->priv)->end = ((struct mypriv *)mymtd->priv)->start + length;
 
 
@@ -200,9 +199,9 @@
 	if (add_mtd_device(mymtd))
 	{
 		printk("Failed to register new device\n");
-	        iounmap(((struct mypriv *)mymtd->priv)->start);
 		kfree(mymtd->priv);
 		kfree(mymtd);
+		iounmap(((struct mypriv *)mymtd->priv)->start);
 		return -EAGAIN;
 	}
 	printk("Registered physmem device from %dKb to %dKb\n",
@@ -215,13 +214,11 @@
 
 static void __exit cleanup_slram(void)
 {
+	del_mtd_device(mymtd);
 	iounmap(((struct mypriv *)mymtd->priv)->start);
 	kfree (mymtd->priv);
-	del_mtd_device(mymtd);
 	kfree(mymtd);
 }
 
-#if LINUX_VERSION_CODE > 0x20300
 module_init(init_slram);
 module_exit(cleanup_slram);
-#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/spia.c linux-2.4.2/drivers/mtd/spia.c
--- linux-2.4.2.orig/drivers/mtd/spia.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/spia.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,129 @@
+/*
+ *  drivers/mtd/spia.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: spia.c,v 1.7 2000/12/04 16:14:19 sjhill Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   SPIA board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 64Mbit (8MB x 8 bits) NAND flash device.
+ */
+
+#include <linux/malloc.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+/*
+ * MTD structure for SPIA board
+ */
+static struct mtd_info *spia_mtd = NULL;
+
+/*
+ * Module stuff
+ */
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+  #define spia_init init_module
+  #define spia_cleanup cleanup_module
+#endif
+
+/*
+ * Define partitions for flash device
+ */
+const static struct mtd_partition partition_info[] = {
+	{ name: "SPIA flash partition 1",
+	  offset: 0,
+	  size: 2*1024*1024 },
+	{ name: "SPIA flash partition 2",
+	  offset: 2*1024*1024,
+	  size: 6*1024*1024 }
+};
+#define NUM_PARTITIONS 2
+
+/*
+ * Main initialization routine
+ */
+int __init spia_init (void)
+{
+	struct nand_chip *this;
+
+	/* Allocate memory for MTD device structure and private data */
+	spia_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+	if (!spia_mtd) {
+		printk ("Unable to allocate SPIA NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&spia_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) spia_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	spia_mtd->priv = this;
+
+	/*
+	 * Set GPIO Port E control register so that the pins are configured
+	 * to be outputs for controlling the NAND flash.
+	 */
+	(*(volatile unsigned char *) (IO_BASE + PEDDR)) = 0x07;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR = FIO_BASE;
+	this->CTRL_ADDR = IO_BASE + PEDR;
+	this->CLE = 0x01;
+	this->ALE = 0x02;
+	this->NCE = 0x04;
+
+	/* Scan to find existance of the device */
+	if (nand_scan (spia_mtd)) {
+		kfree (spia_mtd);
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+	this->data_buf = kmalloc (sizeof(u_char) * (spia_mtd->oobblock + spia_mtd->oobsize), GFP_KERNEL);
+	if (!this->data_buf) {
+		printk ("Unable to allocate NAND data buffer for SPIA.\n");
+		kfree (spia_mtd);
+		return -ENOMEM;
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(spia_mtd, partition_info, NUM_PARTITIONS);
+
+	/* Return happy */
+	return 0;
+}
+module_init(spia_init);
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit spia_cleanup (void)
+{
+	struct nand_chip *this = (struct nand_chip *) &spia_mtd[1];
+
+	/* Unregister the device */
+	del_mtd_device (spia_mtd);
+
+	/* Free internal data buffer */
+	kfree (this->data_buf);
+
+	/* Free the MTD device structure */
+	kfree (spia_mtd);
+}
+module_exit(spia_cleanup);
+#endif
diff -Naur linux-2.4.2.orig/drivers/mtd/sun_uflash.c linux-2.4.2/drivers/mtd/sun_uflash.c
--- linux-2.4.2.orig/drivers/mtd/sun_uflash.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/drivers/mtd/sun_uflash.c	Thu Jan 10 18:30:47 2002
@@ -0,0 +1,224 @@
+/* $Id: sun_uflash.c,v 1.1 2001/03/17 12:13:54 dwmw2 Exp $
+ *
+ * sun_uflash - Driver implementation for user-programmable flash
+ * present on many Sun Microsystems SME boardsets.
+ *
+ * This driver does NOT provide access to the OBP-flash for
+ * safety reasons-- use <linux>/drivers/sbus/char/flash.c instead.
+ *
+ * Copyright (c) 2001 Eric Brower (ebrower@usa.net)
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/ebus.h>
+#include <asm/oplib.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+#define UFLASH_OBPNAME	"flashprom"
+#define UFLASH_DEVNAME 	"userflash"
+
+#define UFLASH_WINDOW_SIZE	0x200000
+#define UFLASH_BUSWIDTH		1			/* EBus is 8-bit */
+
+MODULE_AUTHOR
+	("Eric Brower <ebrower@usa.net>");
+MODULE_DESCRIPTION
+	("User-programmable flash device on Sun Microsystems boardsets");
+MODULE_SUPPORTED_DEVICE
+	("userflash");
+
+static LIST_HEAD(device_list);
+struct uflash_dev {
+	char *			name;	/* device name */
+	struct map_info 	map;	/* mtd map info */
+	struct mtd_info *	mtd;	/* mtd info */
+	struct list_head	list;
+};
+
+__u8 uflash_read8(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readb(map->map_priv_1 + ofs));
+}
+
+__u16 uflash_read16(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readw(map->map_priv_1 + ofs));
+}
+
+__u32 uflash_read32(struct map_info *map, unsigned long ofs)
+{
+	return(__raw_readl(map->map_priv_1 + ofs));
+}
+
+void uflash_copy_from(struct map_info *map, void *to, unsigned long from, 
+		      ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void uflash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+}
+
+void uflash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+}
+
+void uflash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+}
+
+void uflash_copy_to(struct map_info *map, unsigned long to, const void *from,
+		    ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info uflash_map_templ = {
+		name:		"SUNW,???-????",
+		size:		UFLASH_WINDOW_SIZE,
+		buswidth:	UFLASH_BUSWIDTH,
+		read8:		uflash_read8,
+		read16:		uflash_read16,
+		read32:		uflash_read32,
+		copy_from:	uflash_copy_from,
+		write8:		uflash_write8,
+		write16:	uflash_write16,
+		write32:	uflash_write32,
+		copy_to:	uflash_copy_to
+};
+
+int uflash_devinit(struct linux_ebus_device* edev)
+{
+	int iTmp, nregs;
+	struct linux_prom_registers regs[2];
+	struct uflash_dev *pdev;
+
+	iTmp = prom_getproperty(
+		edev->prom_node, "reg", (void *)regs, sizeof(regs));
+	if ((iTmp % sizeof(regs[0])) != 0) {
+		printk("%s: Strange reg property size %d\n", 
+			UFLASH_DEVNAME, iTmp);
+		return -ENODEV;
+	}
+
+	nregs = iTmp / sizeof(regs[0]);
+
+	if (nregs != 1) {
+		/* Non-CFI userflash device-- once I find one we
+		 * can work on supporting it.
+		 */
+		printk("%s: unsupported device at 0x%lx (%d regs): " \
+			"email ebrower@usa.net\n", 
+			UFLASH_DEVNAME, edev->resource[0].start, nregs);
+		return -ENODEV;
+	}
+
+	if(0 == (pdev = kmalloc(sizeof(struct uflash_dev), GFP_KERNEL))) {
+		printk("%s: unable to kmalloc new device\n", UFLASH_DEVNAME);
+		return(-ENOMEM);
+	}
+	
+	/* copy defaults and tweak parameters */
+	memcpy(&pdev->map, &uflash_map_templ, sizeof(uflash_map_templ));
+	pdev->map.size = regs[0].reg_size;
+
+	iTmp = prom_getproplen(edev->prom_node, "model");
+	pdev->name = kmalloc(iTmp, GFP_KERNEL);
+	prom_getstring(edev->prom_node, "model", pdev->name, iTmp);
+	if(0 != pdev->name && 0 < strlen(pdev->name)) {
+		pdev->map.name = pdev->name;
+	}
+
+	pdev->map.map_priv_1 = 
+		(unsigned long)ioremap_nocache(edev->resource[0].start, pdev->map.size);
+	if(0 == pdev->map.map_priv_1) {
+		printk("%s: failed to map device\n", __FUNCTION__);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-1);
+	}
+
+	/* MTD registration */
+	pdev->mtd = do_cfi_probe(&pdev->map);
+	if(0 == pdev->mtd) {
+		iounmap((void *)pdev->map.map_priv_1);
+		kfree(pdev->name);
+		kfree(pdev);
+		return(-ENXIO);
+	}
+
+	list_add(&pdev->list, &device_list);
+
+	pdev->mtd->module = THIS_MODULE;
+
+	add_mtd_device(pdev->mtd);
+	return(0);
+}
+
+static int __init uflash_init(void)
+{
+	struct linux_ebus *ebus = NULL;
+	struct linux_ebus_device *edev = NULL;
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, UFLASH_OBPNAME)) {
+				if(0 > prom_getproplen(edev->prom_node, "user")) {
+					DEBUG(2, "%s: ignoring device at 0x%lx\n",
+							UFLASH_DEVNAME, edev->resource[0].start);
+				} else {
+					uflash_devinit(edev);
+				}
+			}
+		}
+	}
+
+	if(list_empty(&device_list)) {
+		printk("%s: unable to locate device\n", UFLASH_DEVNAME);
+		return -ENODEV;
+	}
+	return(0);
+}
+
+static void __exit uflash_cleanup(void)
+{
+	struct list_head *udevlist;
+	struct uflash_dev *udev;
+
+	list_for_each(udevlist, &device_list) {
+		udev = list_entry(udevlist, struct uflash_dev, list);
+		DEBUG(2, "%s: removing device %s\n", 
+			UFLASH_DEVNAME, udev->name);
+
+		if(0 != udev->mtd) {
+			del_mtd_device(udev->mtd);
+			map_destroy(udev->mtd);
+		}
+		if(0 != udev->map.map_priv_1) {
+			iounmap((void*)udev->map.map_priv_1);
+			udev->map.map_priv_1 = 0;
+		}
+		if(0 != udev->name) {
+			kfree(udev->name);
+		}
+		kfree(udev);
+	}	
+}
+
+module_init(uflash_init);
+module_exit(uflash_cleanup);
diff -Naur linux-2.4.2.orig/drivers/mtd/vmax301.c linux-2.4.2/drivers/mtd/vmax301.c
--- linux-2.4.2.orig/drivers/mtd/vmax301.c	Fri Feb  9 20:30:23 2001
+++ linux-2.4.2/drivers/mtd/vmax301.c	Thu Jan 10 18:30:47 2002
@@ -1,4 +1,4 @@
-// $Id: vmax301.c,v 1.15 2000/11/27 08:50:22 dwmw2 Exp $
+// $Id: vmax301.c,v 1.19 2001/03/17 16:18:29 dwmw2 Exp $
 /* ######################################################################
 
    Tempustech VMAX SBC301 MTD Driver.
@@ -17,7 +17,7 @@
    ##################################################################### */
 
 #include <linux/module.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <asm/spinlock.h>
@@ -219,9 +219,9 @@
 		if (!vmax_mtd[i])
 			vmax_mtd[i] = do_jedec_probe(&vmax_map[i]);
 		if (!vmax_mtd[i])
-			vmax_mtd[i] = do_ram_probe(&vmax_map[i]);
+			vmax_mtd[i] = do_map_ram_probe(&vmax_map[i]);
 		if (!vmax_mtd[i])
-			vmax_mtd[i] = do_rom_probe(&vmax_map[i]);
+			vmax_mtd[i] = do_map_rom_probe(&vmax_map[i]);
 		if (vmax_mtd[i]) {
 			vmax_mtd[i]->module = THIS_MODULE;
 			add_mtd_device(vmax_mtd[i]);
@@ -229,7 +229,7 @@
 	}
 
 	if (!vmax_mtd[1] && !vmax_mtd[2]) {
-		iounmap(iomapadr);
+		iounmap((void *)iomapadr);
 		return -ENXIO;
 	}
 
diff -Naur linux-2.4.2.orig/fs/binfmt_elf.c linux-2.4.2/fs/binfmt_elf.c
--- linux-2.4.2.orig/fs/binfmt_elf.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/binfmt_elf.c	Thu Jan 10 18:37:37 2002
@@ -163,7 +163,9 @@
 	sp -= 3*2;
 	NEW_AUX_ENT(0, AT_HWCAP, hwcap);
 	NEW_AUX_ENT(1, AT_PAGESZ, ELF_EXEC_PAGESIZE);
+#ifndef CONFIG_DBOX2
 	NEW_AUX_ENT(2, AT_CLKTCK, CLOCKS_PER_SEC);
+#endif
 
 	if (exec) {
 		sp -= 10*2;
diff -Naur linux-2.4.2.orig/fs/jffs/Makefile linux-2.4.2/fs/jffs/Makefile
--- linux-2.4.2.orig/fs/jffs/Makefile	Fri Dec 29 23:07:23 2000
+++ linux-2.4.2/fs/jffs/Makefile	Thu Jan 10 18:30:48 2002
@@ -1,7 +1,7 @@
 #
 # Makefile for the linux Journalling Flash FileSystem (JFFS) routines.
 #
-# $Id: Makefile,v 1.7 2000/08/04 12:46:34 dwmw2 Exp $
+# $Id: Makefile,v 1.9 2001/01/11 00:10:21 dwmw2 Exp $
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
@@ -30,7 +30,12 @@
 endif
 
 O_TARGET := jffs.o
-obj-m    := $(O_TARGET)
-obj-y    := jffs_fm.o intrep.o $(INODE_O)
+M_OBJS   := $(O_TARGET)
+O_OBJS   := jffs_fm.o intrep.o $(INODE_O)
 
+ifeq ($(CONFIG_JFFS_PROC_FS),y)
+O_OBJS   += jffs_proc.o
+endif
+obj-y := $(O_OBJS)
+obj-m := jffs.o
 include $(TOPDIR)/Rules.make
diff -Naur linux-2.4.2.orig/fs/jffs/inode-v22.c linux-2.4.2/fs/jffs/inode-v22.c
--- linux-2.4.2.orig/fs/jffs/inode-v22.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/inode-v22.c	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,1964 @@
+/*
+ * JFFS -- Journalling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 1999, 2000  Axis Communications AB.
+ *
+ * Created by Finn Hakansson <finn@axis.com>.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * $Id: inode-v22.c,v 1.61 2001/01/26 12:23:42 smunton Exp $
+ *
+ * Ported to Linux 2.2.x by Sebastien Cote:
+ * Copyright (C) 2000 Matrox Electronic Systems
+ *
+ */
+
+/* inode.c -- Contains the code that is called from the VFS.  */
+
+/* Argh. Some architectures have kernel_thread in asm/processor.h
+   Some have it in unistd.h and you need to define __KERNEL_SYSCALLS__
+   Pass me a baseball bat and the person responsible.
+   dwmw2
+*/
+#define __KERNEL_SYSCALLS__
+#include <linux/sched.h>
+#include <linux/unistd.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/jffs.h>
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <linux/stat.h>
+#include <linux/blkdev.h>
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#if CONFIG_JFFS_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include "jffs_fm.h"
+#include "intrep.h"
+#if CONFIG_JFFS_PROC_FS
+#include "jffs_proc.h"
+#endif
+
+static int jffs_remove(struct inode *dir, struct dentry *dentry, int type);
+
+static struct super_operations jffs_ops;
+static struct file_operations jffs_file_operations;
+static struct inode_operations jffs_file_inode_operations;
+static struct file_operations jffs_dir_operations;
+static struct inode_operations jffs_dir_inode_operations;
+static struct inode_operations jffs_symlink_inode_operations;
+
+kmem_cache_t     *node_cache = NULL;
+kmem_cache_t     *fm_cache = NULL;
+
+/* Called by the VFS at mount time to initialize the whole file system.  */
+static struct super_block *
+jffs_read_super(struct super_block *sb, void *data, int silent)
+{
+	kdev_t dev = sb->s_dev;
+	struct inode *root_inode;
+	struct jffs_control *c;
+	
+	D1(printk(KERN_NOTICE "JFFS: Trying to mount device %s.\n",
+			kdevname(dev)));
+	
+	if (MAJOR(dev)!=MTD_BLOCK_MAJOR) {
+		printk(KERN_WARNING "JFFS: Trying to mount non-mtd device.\n");
+		return 0;
+	}
+	
+	MOD_INC_USE_COUNT;
+	lock_super(sb);
+	
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->u.generic_sbp = (void *) 0;
+	
+	/* Build the file system.  */
+	if (jffs_build_fs(sb) < 0) {
+		goto jffs_sb_err1;
+	}
+	
+	/*
+	 * set up enough so that we can read an inode
+	 */
+	sb->s_magic = JFFS_MAGIC_SB_BITMASK;
+	sb->s_op = &jffs_ops;
+	
+	unlock_super(sb);
+	
+	root_inode = iget(sb, JFFS_MIN_INO);
+	if (!root_inode)
+		goto jffs_sb_err2;
+	
+	/* Get the root directory of this file system.  */
+	if (!(sb->s_root = d_alloc_root(root_inode, NULL))) {
+		goto jffs_sb_err3;
+	}
+	
+	c = (struct jffs_control *) sb->u.generic_sbp;
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	/* Set up the jffs proc file system.  */
+	if (jffs_register_jffs_proc_dir(dev, c) < 0) {
+		printk(KERN_WARNING "JFFS: Failed to initialize the JFFS "
+			"proc file system for device %s.\n",
+			kdevname(dev));
+	}
+#endif
+	
+	/* Set the Garbage Collection thresholds */
+	
+	/* GC if free space goes below 5% of the total size */
+	c->gc_minfree_threshold = c->fmc->flash_size / 20;
+	
+	if (c->gc_minfree_threshold < c->fmc->sector_size)
+		c->gc_minfree_threshold = c->fmc->sector_size;
+	
+	/* GC if dirty space exceeds 33% of the total size. */
+	c->gc_maxdirty_threshold = c->fmc->flash_size / 3;
+	
+	if (c->gc_maxdirty_threshold < c->fmc->sector_size)
+		c->gc_maxdirty_threshold = c->fmc->sector_size;
+	
+	c->thread_pid = kernel_thread (jffs_garbage_collect_thread,
+			(void *) c,
+			CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+	D1(printk(KERN_NOTICE "JFFS: GC thread pid=%d.\n", (int) c->thread_pid));
+	
+	D1(printk(KERN_NOTICE "JFFS: Successfully mounted device %s.\n",
+			kdevname(dev)));
+	return sb;
+	
+	jffs_sb_err3:
+	iput(root_inode);
+	jffs_sb_err2:
+	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
+	jffs_sb_err1:
+	unlock_super(sb);
+	MOD_DEC_USE_COUNT;
+	printk(KERN_WARNING "JFFS: Failed to mount device %s.\n",
+		kdevname(dev));
+	return 0;
+}
+
+
+/* This function is called when the file system is umounted.  */
+static void
+jffs_put_super(struct super_block *sb)
+{
+	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
+	D1(kdev_t dev = sb->s_dev);
+	
+	D2(printk("jffs_put_super()\n"));
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_unregister_jffs_proc_dir(c);
+#endif
+	
+	if (c->gc_task) {
+		D1(printk (KERN_NOTICE "jffs_put_super(): Telling gc thread to die.\n"));
+		send_sig(SIGKILL, c->gc_task, 1);
+	}
+	down (&c->gc_thread_sem);
+	
+	D1(printk (KERN_NOTICE "jffs_put_super(): Successfully waited on thread.\n"));
+	
+	sb->s_dev = 0;
+	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
+	MOD_DEC_USE_COUNT;
+	D1(printk(KERN_NOTICE "JFFS: Successfully unmounted device %s.\n",
+			kdevname(dev)));
+}
+
+
+/* This function is called when user commands like chmod, chgrp and
+   chown are executed. System calls like trunc() results in a call
+   to this function.  */
+static int
+jffs_notify_change(struct dentry *dentry, struct iattr *iattr)
+{
+	struct inode *inode = dentry->d_inode;
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_fmcontrol *fmc;
+	struct jffs_file *f;
+	struct jffs_node *new_node;
+	int update_all;
+	int res;
+	int recoverable = 0;
+	
+	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	fmc = c->fmc;
+	
+	if ((res = inode_change_ok(inode, iattr)))
+		return res;
+	
+	D3(printk (KERN_NOTICE "notify_change(): down biglock\n"));
+	down(&fmc->biglock);
+	
+	f = jffs_find_file(c, inode->i_ino);
+	
+	ASSERT(if (!f) {
+		printk("jffs_notify_change(): Invalid inode number: %lu\n",
+			inode->i_ino);
+		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
+		up(&fmc->biglock);
+		return -EINVAL;
+	});
+	
+	D1(printk("***jffs_notify_change(): file: \"%s\", ino: %u\n",
+			f->name, f->ino));
+	
+	update_all = iattr->ia_valid & ATTR_FORCE;
+	
+	if ( (update_all || iattr->ia_valid & ATTR_SIZE)
+		&& (iattr->ia_size + 128 < f->size) ) {
+		/* We're shrinking the file by more than 128 bytes.
+		   We'll be able to GC and recover this space, so
+		   allow it to go into the reserved space. */
+		recoverable = 1;
+	}
+	
+	if (!(new_node = jffs_alloc_node())) {
+		D(printk("jffs_notify_change(): Allocation failed!\n"));
+		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
+		up(&fmc->biglock);
+		return -ENOMEM;
+	}
+	
+	new_node->data_offset = 0;
+	new_node->removed_size = 0;
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = f->ino;
+	raw_inode.pino = f->pino;
+/*  	raw_inode.version = f->highest_version + 1; */
+	raw_inode.mode = f->mode;
+	raw_inode.uid = f->uid;
+	raw_inode.gid = f->gid;
+	raw_inode.atime = f->atime;
+	raw_inode.mtime = f->mtime;
+	raw_inode.ctime = f->ctime;
+	raw_inode.dsize = 0;
+	raw_inode.offset = 0;
+	raw_inode.rsize = 0;
+	raw_inode.dsize = 0;
+	raw_inode.nsize = f->nsize;
+	raw_inode.nlink = f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	if (update_all || iattr->ia_valid & ATTR_MODE) {
+		raw_inode.mode = iattr->ia_mode;
+		inode->i_mode = iattr->ia_mode;
+	}
+	if (update_all || iattr->ia_valid & ATTR_UID) {
+		raw_inode.uid = iattr->ia_uid;
+		inode->i_uid = iattr->ia_uid;
+	}
+	if (update_all || iattr->ia_valid & ATTR_GID) {
+		raw_inode.gid = iattr->ia_gid;
+		inode->i_gid = iattr->ia_gid;
+	}
+	if (update_all || iattr->ia_valid & ATTR_SIZE) {
+		int len;
+		D1(printk("jffs_notify_change(): Changing size "
+				"to %lu bytes!\n", (long)iattr->ia_size));
+		raw_inode.offset = iattr->ia_size;
+		
+		/* Calculate how many bytes need to be removed from
+		   the end.  */
+		if (f->size < iattr->ia_size) {
+			len = 0;
+		}
+		else {
+			len = f->size - iattr->ia_size;
+		}
+		
+		raw_inode.rsize = len;
+		
+		/* The updated node will be a removal node, with
+		   base at the new size and size of the nbr of bytes
+		   to be removed.  */
+		new_node->data_offset = iattr->ia_size;
+		new_node->removed_size = len;
+		inode->i_size = iattr->ia_size;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+		
+		if (len) {
+			invalidate_inode_pages(inode);
+		}
+		inode->i_ctime = CURRENT_TIME;
+		inode->i_mtime = inode->i_ctime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_ATIME) {
+		raw_inode.atime = iattr->ia_atime;
+		inode->i_atime = iattr->ia_atime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_MTIME) {
+		raw_inode.mtime = iattr->ia_mtime;
+		inode->i_mtime = iattr->ia_mtime;
+	}
+	if (update_all || iattr->ia_valid & ATTR_CTIME) {
+		raw_inode.ctime = iattr->ia_ctime;
+		inode->i_ctime = iattr->ia_ctime;
+	}
+	
+	/* Write this node to the flash.  */
+	if ((res = jffs_write_node(c, new_node, &raw_inode, f->name, 0, recoverable, f)) < 0) {
+		D(printk("jffs_notify_change(): The write failed!\n"));
+		jffs_free_node(new_node);
+		D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
+		up(&c->fmc->biglock);
+		return res;
+	}
+	
+	jffs_insert_node(c, f, &raw_inode, 0, new_node);
+	
+	mark_inode_dirty(inode);
+	D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return 0;
+} /* jffs_notify_change()  */
+
+
+struct inode *
+jffs_new_inode(const struct inode *dir, struct jffs_raw_inode *raw_inode,
+	int *err)
+{
+	struct super_block *sb;
+	struct inode *inode;
+	struct jffs_control *c;
+	struct jffs_file *f;
+	
+	inode = get_empty_inode();
+	if (!inode) {
+		*err = -ENOMEM;
+		return NULL;
+	}
+	
+	sb = dir->i_sb;
+	c = (struct jffs_control *)sb->u.generic_sbp;
+	
+	inode->i_sb = sb;
+	inode->i_dev = sb->s_dev;
+	inode->i_ino = raw_inode->ino;
+	inode->i_mode = raw_inode->mode;
+	inode->i_nlink = raw_inode->nlink;
+	inode->i_uid = raw_inode->uid;
+	inode->i_gid = raw_inode->gid;
+	inode->i_rdev = 0;
+	inode->i_size = raw_inode->dsize;
+	inode->i_atime = raw_inode->atime;
+	inode->i_mtime = raw_inode->mtime;
+	inode->i_ctime = raw_inode->ctime;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	inode->i_version = 0;
+	inode->i_flags = sb->s_flags;
+	
+	f = jffs_find_file(c, raw_inode->ino);
+
+	inode->u.generic_ip = (void *)f;
+	
+	insert_inode_hash(inode);
+	
+	return inode;
+}
+
+
+/* Get statistics of the file system.  */
+int
+jffs_statfs(struct super_block *sb, struct statfs *buf, int bufsiz)
+{
+	struct statfs tmp;
+	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
+	struct jffs_fmcontrol *fmc = c->fmc;
+	
+	D2(printk("jffs_statfs()\n"));
+	
+	tmp.f_type = JFFS_MAGIC_SB_BITMASK;
+	tmp.f_bsize = PAGE_CACHE_SIZE;
+	tmp.f_blocks = (fmc->flash_size / PAGE_CACHE_SIZE)
+		- (fmc->min_free_size / PAGE_CACHE_SIZE);
+	tmp.f_bfree = (jffs_free_size1(fmc)/PAGE_CACHE_SIZE
+			+ jffs_free_size2(fmc) / PAGE_CACHE_SIZE)
+		- (fmc->min_free_size / PAGE_CACHE_SIZE);
+	tmp.f_bavail =  tmp.f_bfree;
+	
+	/* Find out how many files there are in the filesystem.  */
+	tmp.f_files = jffs_foreach_file(c, jffs_file_count);
+	tmp.f_ffree = tmp.f_bfree;
+	/* tmp.f_fsid = 0; */
+	tmp.f_namelen = JFFS_MAX_NAME_LEN;
+	return copy_to_user(buf, &tmp, bufsiz) ? -EFAULT : 0;
+}
+
+
+/* Rename a file.  */
+int
+jffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+	struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *old_dir_f;
+	struct jffs_file *new_dir_f;
+	struct jffs_file *del_f;
+	struct jffs_file *f;
+	struct jffs_node *node;
+	struct inode *inode;
+	int result = 0;
+	__u32 rename_data = 0;
+	
+	D2(printk("***jffs_rename()\n"));
+	
+	D(printk("jffs_rename(): old_dir: 0x%p, old name: 0x%p, "
+			"new_dir: 0x%p, new name: 0x%p\n",
+			old_dir, old_dentry->d_name.name,
+			new_dir, new_dentry->d_name.name));
+	
+	if (!new_dir->i_nlink) {
+		D(printk("jffs_rename(): new_dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	c = (struct jffs_control *)old_dir->i_sb->u.generic_sbp;
+	ASSERT(if (!c) {
+		printk(KERN_ERR "jffs_rename(): The old_dir inode "
+			"didn't have a reference to a jffs_file struct\n");
+		return -EIO;
+	});
+	
+	result = -ENOTDIR;
+	if (!(old_dir_f = (struct jffs_file *)old_dir->u.generic_ip)) {
+		D(printk("jffs_rename(): Old dir invalid.\n"));
+		goto jffs_rename_end;
+	}
+	
+	/* Try to find the file to move.  */
+	result = -ENOENT;
+	if (!(f = jffs_find_child(old_dir_f, old_dentry->d_name.name,
+					old_dentry->d_name.len))) {
+		goto jffs_rename_end;
+	}
+	
+	/* Find the new directory.  */
+	result = -ENOTDIR;
+	if (!(new_dir_f = (struct jffs_file *)new_dir->u.generic_ip)) {
+		D(printk("jffs_rename(): New dir invalid.\n"));
+		goto jffs_rename_end;
+	}
+	D3(printk (KERN_NOTICE "rename(): down biglock\n"));
+	down(&c->fmc->biglock);
+	/* Create a node and initialize as much as needed.  */
+	result = -ENOMEM;
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_rename(): Allocation failed: node == 0\n"));
+		goto jffs_rename_end;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = f->ino;
+	raw_inode.pino = new_dir_f->ino;
+/*  	raw_inode.version = f->highest_version + 1; */
+	raw_inode.mode = f->mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = current->fsgid;
+#if 0
+	raw_inode.uid = f->uid;
+	raw_inode.gid = f->gid;
+#endif
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = f->ctime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = new_dentry->d_name.len;
+	raw_inode.nlink = f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* See if there already exists a file with the same name as
+	   new_name.  */
+	if ((del_f = jffs_find_child(new_dir_f, new_dentry->d_name.name,
+					new_dentry->d_name.len))) {
+		raw_inode.rename = 1;
+		raw_inode.dsize = sizeof(__u32);
+		rename_data = del_f->ino;
+	}
+	
+	/* Write the new node to the flash memory.  */
+	if ((result = jffs_write_node(c, node, &raw_inode, new_dentry->d_name.name,
+					(unsigned char*)&rename_data, 0, f)) < 0) {
+		D(printk("jffs_rename(): Failed to write node to flash.\n"));
+		jffs_free_node(node);
+		goto jffs_rename_end;
+	}
+	raw_inode.dsize = 0;
+	
+	if (raw_inode.rename) {
+		/* The file with the same name must be deleted.  */
+		//FIXME deadlock	        down(&c->fmc->gclock);
+		if ((result = jffs_remove(new_dir, new_dentry, del_f->mode)) < 0) {
+			/* This is really bad.  */
+			printk(KERN_ERR "JFFS: An error occurred in "
+				"rename().\n");
+		}
+		//		up(&c->fmc->gclock);
+	}
+	
+	if (old_dir_f != new_dir_f) {
+		/* Remove the file from its old position in the
+		   filesystem tree.  */
+		jffs_unlink_file_from_tree(f);
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((result = jffs_insert_node(c, f, &raw_inode,
+					new_dentry->d_name.name, node)) < 0) {
+		D(printk(KERN_ERR "jffs_rename(): jffs_insert_node() "
+				"failed!\n"));
+	}
+	
+	if (old_dir_f != new_dir_f) {
+		/* Insert the file to its new position in the
+		   file system.  */
+		jffs_insert_file_into_tree(f);
+	}
+	
+	/* This is a kind of update of the inode we're about to make
+	   here.  This is what they do in ext2fs.  Kind of.  */
+	if ((inode = iget(new_dir->i_sb, f->ino))) {
+		inode->i_ctime = CURRENT_TIME;
+		mark_inode_dirty(inode);
+		iput(inode);
+	}
+	
+	jffs_rename_end:
+	D3(printk (KERN_NOTICE "rename(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_rename()  */
+
+
+/* Read the contents of a directory.  Used by programs like `ls'
+   for instance.  */
+static int
+jffs_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct jffs_file *f;
+	struct dentry *dentry = filp->f_dentry;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	int j;
+	int ddino;
+	
+	D3(printk (KERN_NOTICE "readdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	D2(printk("jffs_readdir(): inode: 0x%p, filp: 0x%p\n", inode, filp));
+	if (filp->f_pos == 0) {
+		D3(printk("jffs_readdir(): \".\" %lu\n", inode->i_ino));
+		if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos = 1;
+	}
+	if (filp->f_pos == 1) {
+		if (inode->i_ino == JFFS_MIN_INO) {
+			ddino = JFFS_MIN_INO;
+		}
+		else {
+			ddino = ((struct jffs_file *)inode->u.generic_ip)->pino;
+		}
+		D3(printk("jffs_readdir(): \"..\" %u\n", ddino));
+		if (filldir(dirent, "..", 2, filp->f_pos, ddino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos++;
+	}
+	f = ((struct jffs_file *)inode->u.generic_ip)->children;
+	
+	j=2;
+	while(f && (f->deleted || j++ < filp->f_pos )) {
+		f = f->sibling_next;
+	}
+	
+	while (f) {
+		D3(printk("jffs_readdir(): \"%s\" ino: %u\n",
+				(f->name ? f->name : ""), f->ino));
+		if (filldir(dirent, f->name, f->nsize,
+				filp->f_pos , f->ino) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			up(&c->fmc->biglock);
+			return 0;
+		}
+		filp->f_pos++;
+		do {
+			f = f->sibling_next;
+		} while(f && f->deleted);
+	}
+	D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return filp->f_pos;
+} /* jffs_readdir()  */
+
+
+/* Find a file in a directory. If the file exists, return its
+   corresponding dentry.  */
+static struct dentry *
+jffs_lookup(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_file *d;
+	struct jffs_file *f;
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int len;
+	int r = 0;
+	const char *name;
+	struct inode *inode = NULL;
+	
+	len = dentry->d_name.len;
+	name = dentry->d_name.name;
+	
+	D3({
+		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
+		memcpy(s, name, len);
+		s[len] = '\0';
+		printk("jffs_lookup(): dir: 0x%p, name: \"%s\"\n", dir, s);
+		kfree(s);
+	});
+	
+	D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	r = -ENAMETOOLONG;
+	if (len > JFFS_MAX_NAME_LEN) {
+		goto jffs_lookup_end;
+	}
+	
+	r = -EACCES;
+	if (!(d = (struct jffs_file *)dir->u.generic_ip)) {
+		D(printk("jffs_lookup(): No such inode! (%lu)\n",
+			 dir->i_ino));
+		goto jffs_lookup_end;
+	}
+	
+	/* Get the corresponding inode to the file.  */
+	
+	/* iget calls jffs_read_inode, so we need to drop the biglock
+	   before calling iget.  Unfortunately, the GC has a tendency
+	   to sneak in here, because iget sometimes calls schedule ().
+	*/
+
+	if ((len == 1) && (name[0] == '.')) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, d->ino))) {
+			D(printk("jffs_lookup(): . iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else if ((len == 2) && (name[0] == '.') && (name[1] == '.')) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, d->pino))) {
+			D(printk("jffs_lookup(): .. iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else if ((f = jffs_find_child(d, name, len))) {
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		up(&c->fmc->biglock);
+		if (!(inode = iget(dir->i_sb, f->ino))) {
+			D(printk("jffs_lookup(): iget() ==> NULL\n"));
+			goto jffs_lookup_end_no_biglock;
+		}
+		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
+		down(&c->fmc->biglock);
+	} else {
+		D3(printk("jffs_lookup(): Couldn't find the file. "
+			  "f = 0x%p, name = \"%s\", d = 0x%p, d->ino = %u\n",
+			  f, name, d, d->ino));
+		inode = NULL;
+	}
+	
+	d_add(dentry, inode);
+	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return NULL;
+	
+ jffs_lookup_end:
+	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+ jffs_lookup_end_no_biglock:
+	return ERR_PTR(r);
+} /* jffs_lookup()  */
+
+
+/* Try to read a page of data from a file.  */
+static int
+jffs_readpage(struct file *file, struct page *page)
+{
+	unsigned long buf;
+	unsigned long read_len;
+	int result = -EIO;
+	struct dentry *dentry = file->f_dentry;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_file *f = (struct jffs_file *)inode->u.generic_ip;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	int r;
+	
+	D2(printk("***jffs_readpage(): file = \"%s\", page->offset = %lu\n",
+			(f->name ? f->name : ""), page->offset));
+	
+	atomic_inc(&page->count);
+	set_bit(PG_locked, &page->flags);
+	set_bit(PG_free_after, &page->flags);
+	
+	buf = page_address(page);
+	clear_bit(PG_uptodate, &page->flags);
+	clear_bit(PG_error, &page->flags);
+	D3(printk (KERN_NOTICE "readpage(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	if (page->offset < inode->i_size) {
+		read_len = jffs_min(inode->i_size - page->offset, PAGE_SIZE);
+		r = jffs_read_data(f, (char *)buf, page->offset, read_len);
+		if (r == read_len) {
+			if (read_len < PAGE_SIZE) {
+				memset((void *)(buf + read_len), 0,
+					PAGE_SIZE - read_len);
+			}
+			set_bit(PG_uptodate, &page->flags);
+			result = 0;
+		}
+		D(else {
+			printk("***jffs_readpage(): Read error! "
+				"Wanted to read %lu bytes but only "
+				"read %d bytes.\n", read_len, r);
+		});
+	}
+	D3(printk (KERN_NOTICE "readpage(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (result) {
+		set_bit(PG_error, &page->flags);
+		memset((void *)buf, 0, PAGE_SIZE);
+	}
+	clear_bit(PG_locked, &page->flags);
+	wake_up(&page->wait);
+	free_page(buf);
+	
+	D3(printk("jffs_readpage(): Leaving...\n"));
+	
+	return result;
+} /* jffs_readpage()  */
+
+
+/* Create a new directory.  */
+static int
+jffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_node *node;
+	struct jffs_file *dir_f;
+	struct inode *inode;
+	int dir_mode;
+	int result = 0;
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
+		memcpy(_name, dentry->d_name.name, len);
+		_name[len] = '\0';
+		printk("***jffs_mkdir(): dir = 0x%p, name = \"%s\", "
+		       "len = %d, mode = 0x%08x\n", dir, _name, len, mode);
+		kfree(_name);
+	});
+	
+	if (!dir->i_nlink) {
+		D(printk("jffs_mkdir(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+		
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_mkdir(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+	
+	c = dir_f->c;
+	D3(printk (KERN_NOTICE "mkdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	dir_mode = S_IFDIR | (mode & (S_IRWXUGO|S_ISVTX)
+			      & ~current->fs->umask);
+	if (dir->i_mode & S_ISGID) {
+		dir_mode |= S_ISGID;
+	}
+	
+	/* Create a node and initialize it as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_mkdir(): Allocation failed: node == 0\n"));
+		result = -ENOMEM;
+		goto jffs_mkdir_end;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = dir_mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	/*	raw_inode.gid = current->fsgid; */
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* Write the new node to the flash.  */
+	if ((result = jffs_write_node(c, node, &raw_inode,
+				      dentry->d_name.name, 0, 0, NULL)) < 0) {
+		D(printk("jffs_mkdir(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_mkdir_end;
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((result = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+				       node)) < 0) {
+		goto jffs_mkdir_end;
+	}
+	
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		result = err;
+		goto jffs_mkdir_end;
+	}
+	
+	inode->i_op = &jffs_dir_inode_operations;
+	inode->i_op->default_file_ops = &jffs_dir_operations;
+	
+	mark_inode_dirty(dir);
+	d_instantiate(dentry, inode);
+	
+	result = 0;
+ jffs_mkdir_end:
+	D3(printk (KERN_NOTICE "mkdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_mkdir()  */
+
+
+/* Remove a directory.  */
+static int
+jffs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int ret;
+	D3(printk("***jffs_rmdir()\n"));
+	D3(printk (KERN_NOTICE "rmdir(): down biglock\n"));
+	down(&c->fmc->biglock);
+	ret = jffs_remove(dir, dentry, S_IFDIR);
+	D3(printk (KERN_NOTICE "rmdir(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+}
+
+
+/* Remove any kind of file except for directories.  */
+static int
+jffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
+	int ret;
+	
+	D3(printk("***jffs_unlink()\n"));
+	D3(printk (KERN_NOTICE "unlink(): down biglock\n"));
+	down(&c->fmc->biglock);
+	ret = jffs_remove(dir, dentry, 0);
+	D3(printk (KERN_NOTICE "unlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+}
+
+
+/* Remove a JFFS entry, i.e. plain files, directories, etc.  Here we
+   shouldn't test for free space on the device.  */
+static int
+jffs_remove(struct inode *dir, struct dentry *dentry, int type)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *dir_f; /* The file-to-remove's parent.  */
+	struct jffs_file *del_f; /* The file to remove.  */
+	struct jffs_node *del_node;
+	struct inode *inode = 0;
+	int result = 0;
+	
+	D1({
+		int len = dentry->d_name.len;
+		const char *name = dentry->d_name.name;
+		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
+		memcpy(_name, name, len);
+		_name[len] = '\0';
+		printk("***jffs_remove(): file = \"%s\", ino = %ld\n", _name, dentry->d_inode->i_ino);
+		kfree(_name);
+	});
+	
+	dir_f = (struct jffs_file *) dir->u.generic_ip;
+	c = dir_f->c;
+	
+	result = -ENOENT;
+	if (!(del_f = jffs_find_child(dir_f, dentry->d_name.name,
+				      dentry->d_name.len))) {
+		D(printk("jffs_remove(): jffs_find_child() failed.\n"));
+		goto jffs_remove_end;
+	}
+	
+	if (S_ISDIR(type)) {
+		struct jffs_file *child = del_f->children;
+		
+		result = -ENOTDIR;
+		if (!S_ISDIR(del_f->mode)) { /* Is this really needed for 2.2? */
+			D(printk("jffs_remove(): S_ISDIR but isn't\n"));
+			goto jffs_remove_end;
+		}
+		
+		while(child) {
+			if( !child->deleted ) {
+				result = -ENOTEMPTY;
+				goto jffs_remove_end;
+			}
+			child = child->sibling_next;
+		}
+	}
+	else if (S_ISDIR(del_f->mode)) {
+		D(printk("jffs_remove(): node is a directory "
+			 "but it shouldn't be.\n"));
+		result = -EPERM;
+		goto jffs_remove_end;
+	}
+	
+	inode = dentry->d_inode;
+	
+	result = -EIO;
+	if (del_f->ino != inode->i_ino) {
+		D(printk("jffs_remove(): wrong inodes\n"));
+		goto jffs_remove_end;
+	}
+	
+	if (!inode->i_nlink) {
+		printk("Deleting nonexistent file inode: %lu, nlink: %d\n",
+		       inode->i_ino, inode->i_nlink);
+		inode->i_nlink=1;
+	}
+	
+	/* Create a node for the deletion.  */
+	result = -ENOMEM;
+	if (!(del_node = jffs_alloc_node())) {
+		D(printk("jffs_remove(): Allocation failed!\n"));
+		goto jffs_remove_end;
+	}
+	del_node->data_offset = 0;
+	del_node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = del_f->ino;
+	raw_inode.pino = del_f->pino;
+	/*  	raw_inode.version = del_f->highest_version + 1; */
+	raw_inode.mode = del_f->mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = del_f->mtime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = 0;
+	raw_inode.nlink = del_f->nlink;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 1;
+
+	/* Write the new node to the flash memory.  */
+	if (jffs_write_node(c, del_node, &raw_inode, 0, 0, 1, del_f) < 0) {
+		jffs_free_node(del_node);
+		result = -EIO;
+		goto jffs_remove_end;
+	}
+
+	/* Update the file.  This operation will make the file disappear
+	   from the in-memory file system structures.  */
+	jffs_insert_node(c, del_f, &raw_inode, 0, del_node);
+
+	dir->i_version = ++global_event;
+	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
+	mark_inode_dirty(dir);
+	inode->i_nlink--;
+	inode->i_ctime = dir->i_ctime;
+	mark_inode_dirty(inode);
+
+	d_delete(dentry);	/* This also frees the inode */
+
+	result = 0;
+ jffs_remove_end:
+	return result;
+} /* jffs_remove()  */
+
+
+static int
+jffs_mknod(struct inode *dir, struct dentry *dentry, int mode, int rdev)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_file *dir_f;
+	struct jffs_node *node = 0;
+	struct jffs_control *c;
+	struct inode *inode;
+	int result = 0;
+	kdev_t dev = to_kdev_t(rdev);
+	int err;
+	
+	D1(printk("***jffs_mknod()\n"));
+	
+	if (!dir->i_nlink) {
+		D(printk("jffs_mknod(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	c = dir_f->c;
+	
+	D3(printk (KERN_NOTICE "mknod(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	/* Create and initialize a new node.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_mknod(): Allocation failed!\n"));
+		result = -ENOMEM;
+		goto jffs_mknod_err;
+	}
+	node->data_offset = 0;
+	node->removed_size = 0;
+	
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	/*	raw_inode.gid = current->fsgid; */
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = sizeof(kdev_t);
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+	
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
+					(unsigned char *)&dev, 0, NULL)) < 0) {
+		D(printk("jffs_mknod(): jffs_write_node() failed.\n"));
+		result = err;
+		goto jffs_mknod_err;
+	}
+	
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+					node)) < 0) {
+		result = err;
+		goto jffs_mknod_end;
+	}
+	
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		result = err;
+		goto jffs_mknod_end;
+	}
+	
+	inode->i_mode = mode;
+	if (S_ISREG(mode))
+		inode->i_op = &jffs_file_inode_operations;
+	if (S_ISCHR(mode)) {
+		inode->i_op = &chrdev_inode_operations;
+		inode->i_rdev = to_kdev_t(rdev);
+	}
+	else if (S_ISBLK(mode)) {
+		inode->i_op = &blkdev_inode_operations;
+		inode->i_rdev = to_kdev_t(rdev);
+	}
+	else if (S_ISFIFO(mode))
+		init_fifo(inode);
+	else if (S_ISSOCK(mode))
+		;
+	else
+		printk(KERN_DEBUG "jffs_mknod: bogus imode (%o)\n", mode);
+	
+	d_instantiate(dentry, inode);
+	
+	goto jffs_mknod_end;
+	
+	jffs_mknod_err:
+	if (node) {
+		jffs_free_node(node);
+	}
+	
+	jffs_mknod_end:
+	D3(printk (KERN_NOTICE "mknod(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return result;
+} /* jffs_mknod()  */
+
+
+static int
+jffs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *dir_f;
+	struct jffs_node *node;
+	struct inode *inode;
+	
+	int symname_len = strlen(symname);
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *_name = (char *)kmalloc(len + 1, GFP_KERNEL);
+		char *_symname = (char *)kmalloc(symname_len + 1, GFP_KERNEL);
+		memcpy(_name, dentry->d_name.name, len);
+		_name[len] = '\0';
+		memcpy(_symname, symname, symname_len);
+		_symname[symname_len] = '\0';
+		printk("***jffs_symlink(): dir = 0x%p, "
+		       "dentry->dname.name = \"%s\", "
+		       "symname = \"%s\"\n", dir, _name, _symname);
+		kfree(_name);
+		kfree(_symname);
+	});
+
+	if (!dir->i_nlink) {
+		D(printk("jffs_symlink(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_symlink(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+
+	c = dir_f->c;
+
+	/* Create a node and initialize it as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_symlink(): Allocation failed: node = NULL\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "symlink(): down biglock\n"));
+	down(&c->fmc->biglock);
+
+	node->data_offset = 0;
+	node->removed_size = 0;
+
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = S_IFLNK | S_IRWXUGO;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = symname_len;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
+				   (const unsigned char *)symname, 0, NULL)) < 0) {
+		D(printk("jffs_symlink(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_symlink_end;
+	}
+
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
+				    node)) < 0) {
+		goto jffs_symlink_end;
+	}
+
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		goto jffs_symlink_end;
+	}
+	err = 0;
+
+	inode->i_mode = S_IFLNK | S_IRWXUGO;
+	inode->i_op = &jffs_symlink_inode_operations;
+
+	d_instantiate(dentry, inode);
+
+ jffs_symlink_end:
+	D3(printk (KERN_NOTICE "symlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+
+	return err;
+} /* jffs_symlink()  */
+
+
+/* Shamelessly stolen from kernel 2.3.99-pre8 */
+static int
+vfs_readlink(struct dentry *dentry, char *buffer, int buflen,
+	const char *link)
+{
+	int len;
+	
+	len = PTR_ERR(link);
+	if (IS_ERR(link))
+		goto out;
+	
+	len = strlen(link);
+	if (len > (unsigned) buflen)
+		len = buflen;
+	if (copy_to_user(buffer, link, len))
+		len = -EFAULT;
+	out:
+	return len;
+}
+
+
+/* Read the path that a symbolic link is referring to.  */
+static int
+jffs_readlink(struct dentry *dentry, char *buffer, int buflen)
+{
+	struct jffs_file *f;
+	struct inode *inode = dentry->d_inode;
+	char *link;
+	int result;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	
+	D(printk("***jffs_readlink()\n"));
+	
+	/* Continue only if the file is a symbolic link.  */
+	if (!S_ISLNK(inode->i_mode)) {
+		//		iput(inode);
+		return -EINVAL;
+	}
+	
+	f = (struct jffs_file *)inode->u.generic_ip;
+	ASSERT(if (!f) {
+		printk(KERN_ERR "jffs_readlink(): No reference to a "
+			"jffs_file struct in inode.\n");
+		return -EIO;
+	});
+	if (!(link = (char *)kmalloc(f->size + 1, GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "readlink(): down biglock\n"));
+	
+	down(&c->fmc->biglock);
+	
+	result = jffs_read_data(f, link, 0, f->size);
+	
+	D3(printk (KERN_NOTICE "readlink(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (result < 0) {
+		kfree(link);
+		return result;
+	}
+	link[result] = '\0';
+	/*	for (i = 0; (i < buflen) && (i < result); i++) {
+		put_user(link[i], buffer++);
+	}
+	UPDATE_ATIME(inode);*/
+	result = vfs_readlink(dentry, buffer, buflen, link);
+	kfree(link);
+	
+	D(printk("jffs_readlink:   Leaving...\n"));
+	return result;
+} /* jffs_readlink()  */
+
+
+static struct dentry *
+jffs_follow_link(struct dentry *dentry, struct dentry *base,
+	unsigned int flags)
+{
+	struct jffs_file *f;
+	struct inode *inode = dentry->d_inode;
+	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	struct dentry *res;
+	char *link;
+	int r;
+	
+	D(printk("jffs_follow_link(): "
+			"dentry = 0x%p, inode = 0x%p, flag = 0x%08x\n",
+			dentry, inode, flags));
+	
+	f = (struct jffs_file *)inode->u.generic_ip;
+	
+	if (!(link = (char *)kmalloc(f->size + 1, GFP_KERNEL))) {
+		return ERR_PTR(-ENOMEM);
+	}
+	D3(printk (KERN_NOTICE "follow_link(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	r = jffs_read_data(f, link, 0, f->size);
+	D3(printk (KERN_NOTICE "follow_link(): up biglock\n"));
+	up(&c->fmc->biglock);
+	
+	if (r < f->size) {
+		D(printk("jffs_follow_link(): Failed to read symname.\n"));
+		kfree(link);
+		return ERR_PTR(-EIO);
+	}
+	link[r] = '\0';
+	
+	UPDATE_ATIME(dentry->d_inode);
+	
+	if (IS_ERR(link)) {
+		dput(base);
+		res = (struct dentry *)link;
+	}
+	
+	else {
+		res = lookup_dentry(link, base, flags);
+	}
+	
+	kfree(link);
+	
+	D(printk("jffs_follow_link:   Leaving...\n"));
+	return res;
+} /* jffs_follow_link()  */
+
+/* Create an inode inside a JFFS directory (dir) and return it.
+ *
+ * By the time this is called, we already have created
+ * the directory cache entry for the new file, but it
+ * is so far negative - it has no inode.
+ *
+ * If the create succeeds, we fill in the inode information
+ * with d_instantiate().
+ */
+static int
+jffs_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_node *node;
+	struct jffs_file *dir_f; /* JFFS representation of the directory.  */
+	struct inode *inode;
+	int err;
+	
+	D1({
+		int len = dentry->d_name.len;
+		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
+		memcpy(s, dentry->d_name.name, len);
+		s[len] = '\0';
+		printk("jffs_create(): dir: 0x%p, name: \"%s\"\n", dir, s);
+		kfree(s);
+	});
+
+	if (!dir->i_nlink) {
+		D(printk("jffs_create(): dir->i_nlink is zero\n"));
+		return -ENOENT;
+	}
+
+	dir_f = (struct jffs_file *)dir->u.generic_ip;
+	ASSERT(if (!dir_f) {
+		printk(KERN_ERR "jffs_create(): No reference to a "
+		       "jffs_file struct in inode.\n");
+		return -EIO;
+	});
+
+	c = dir_f->c;
+
+	/* Create a node and initialize as much as needed.  */
+	if (!(node = jffs_alloc_node())) {
+		D(printk("jffs_create(): Allocation failed: node == 0\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "create(): down biglock\n"));
+	down(&c->fmc->biglock);
+
+	node->data_offset = 0;
+	node->removed_size = 0;
+
+	/* Initialize the raw inode.  */
+	raw_inode.magic = JFFS_MAGIC_BITMASK;
+	raw_inode.ino = c->next_ino++;
+	raw_inode.pino = dir_f->ino;
+	raw_inode.version = 1;
+	raw_inode.mode = mode;
+	raw_inode.uid = current->fsuid;
+	raw_inode.gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	raw_inode.atime = CURRENT_TIME;
+	raw_inode.mtime = raw_inode.atime;
+	raw_inode.ctime = raw_inode.atime;
+	raw_inode.offset = 0;
+	raw_inode.dsize = 0;
+	raw_inode.rsize = 0;
+	raw_inode.nsize = dentry->d_name.len;
+	raw_inode.nlink = 1;
+	raw_inode.spare = 0;
+	raw_inode.rename = 0;
+	raw_inode.deleted = 0;
+
+	/* Write the new node to the flash.  */
+	if ((err = jffs_write_node(c, node, &raw_inode,
+				   dentry->d_name.name, 0, 0, NULL)) < 0) {
+		D(printk("jffs_create(): jffs_write_node() failed.\n"));
+		jffs_free_node(node);
+		goto jffs_create_end;
+	}
+
+	/* Insert the new node into the file system.  */
+	if ((err = jffs_insert_node(c, 0, &raw_inode,
+				    dentry->d_name.name, node)) < 0) {
+		goto jffs_create_end;
+	}
+
+	/* Initialize an inode.  */
+	inode = jffs_new_inode(dir, &raw_inode, &err);
+	if (inode == NULL) {
+		goto jffs_create_end;
+	}
+	err = 0;
+	inode->i_op = &jffs_file_inode_operations;
+	inode->i_op->default_file_ops = &jffs_file_operations;
+	inode->i_nrpages = 0;
+
+	d_instantiate(dentry, inode);
+
+ jffs_create_end:
+	D3(printk (KERN_NOTICE "create(): up biglock\n"));
+	up(&c->fmc->biglock);
+
+	return err;
+} /* jffs_create()  */
+
+
+/* Write, append or rewrite data to an existing file.  */
+static ssize_t
+jffs_file_write(struct file *filp, const char *buf, size_t count,
+	loff_t *ppos)
+{
+	struct jffs_raw_inode raw_inode;
+	struct jffs_control *c;
+	struct jffs_file *f;
+	struct jffs_node *node;
+	struct inode *inode = filp->f_dentry->d_inode;
+	unsigned char *vbuf;
+	int recoverable = 0;
+	size_t written = 0;
+	__u32 thiscount = count;
+	loff_t pos;
+	int err = 0;
+	
+	D2(printk("***jffs_file_write(): inode: 0x%p (ino: %lu), "
+			"filp: 0x%p, buf: 0x%p, count: %d\n",
+			inode, inode->i_ino, filp, buf, count));
+	
+	if (!inode) {
+		D(printk("jffs_file_write(): inode == NULL\n"));
+		return -EINVAL;
+	}
+	
+	if (inode->i_sb->s_flags & MS_RDONLY) {
+		D(printk("jffs_file_write(): MS_RDONLY\n"));
+		return -EROFS;
+	}
+	
+	if (!S_ISREG(inode->i_mode)) {
+		D(printk("jffs_file_write(): inode->i_mode == 0x%08x\n",
+				inode->i_mode));
+		return -EINVAL;
+	}
+	
+	if (!(f = (struct jffs_file *)inode->u.generic_ip)) {
+		D(printk("jffs_file_write(): inode->u.generic_ip = 0x%p\n",
+				inode->u.generic_ip));
+		return -EINVAL;
+	}
+	
+	c = f->c;
+	
+	if (filp->f_flags & O_APPEND) {
+		pos = inode->i_size;
+	}
+	else {
+		pos = *ppos;
+	}
+	
+	thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
+	
+	if (!(vbuf = kmalloc(thiscount, GFP_KERNEL))) {
+		D(printk("jffs_file_write(): failed to allocate bounce buffer. Fix me to use page cache\n"));
+		return -ENOMEM;
+	}
+	D3(printk (KERN_NOTICE "file_write(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	/* Urgh. POSIX says we can do short writes if we feel like it.
+	 * In practice, we can't. Nothing will cope. So we loop until
+	 * we're done.
+	 *
+	 * <_Anarchy_> posix and reality are not interconnected on this issue
+	 */
+	while (count) {
+		/* FIXME: This is entirely gratuitous use of bounce buffers.
+		   Get a clue and use the page cache.
+		   /me wanders off to get a crash course on Linux VFS
+		   dwmw2
+		*/
+		if (copy_from_user(vbuf, buf, thiscount)) {
+			err = -EFAULT;
+			goto out;
+		}
+		
+		/* Things are going to be written so we could allocate and
+		   initialize the necessary data structures now.  */
+		if (!(node = jffs_alloc_node())) {
+			D(printk("jffs_file_write(): node == 0\n"));
+			err = -ENOMEM;
+			goto out;
+		}
+		
+		node->data_offset = pos;
+		node->removed_size = 0;
+		
+		/* Initialize the raw inode.  */
+		raw_inode.magic = JFFS_MAGIC_BITMASK;
+		raw_inode.ino = f->ino;
+		raw_inode.pino = f->pino;
+/*  		raw_inode.version = f->highest_version + 1; */
+		raw_inode.mode = f->mode;
+		
+		raw_inode.uid = f->uid;
+		raw_inode.gid = f->gid;
+		raw_inode.atime = CURRENT_TIME;
+		raw_inode.mtime = raw_inode.atime;
+		raw_inode.ctime = f->ctime;
+		raw_inode.offset = pos;
+		raw_inode.dsize = thiscount;
+		raw_inode.rsize = 0;
+		raw_inode.nsize = f->nsize;
+		raw_inode.nlink = f->nlink;
+		raw_inode.spare = 0;
+		raw_inode.rename = 0;
+		raw_inode.deleted = 0;
+		
+		if (pos < f->size) {
+			node->removed_size = raw_inode.rsize = jffs_min(thiscount, f->size - pos);
+			
+			/* If this node is going entirely over the top of old data,
+			   we can allow it to go into the reserved space, because
+			   we can that GC can reclaim the space later.
+			*/
+			if (pos + thiscount < f->size) {
+				/* If all the data we're overwriting are _real_,
+				   not just holes, then:
+				   recoverable = 1;
+				*/
+			}
+		}
+		
+		/* Write the new node to the flash.  */
+		/* NOTE: We would be quite happy if jffs_write_node() wrote a
+		   smaller node than we were expecting. There's no need for it
+		   to waste the space at the end of the flash just because it's
+		   a little smaller than what we asked for. But that's a whole
+		   new can of worms which I'm not going to open this week. dwmw2.
+		*/
+		if ((err = jffs_write_node (c, node, &raw_inode, f->name,
+						(const unsigned char *)vbuf,
+						recoverable, f)) < 0) {
+			D(printk("jffs_file_write(): jffs_write_node() failed.\n"));
+			jffs_free_node(node);
+			goto out;
+		}
+		
+		written += err;
+		buf += err;
+		count -= err;
+		pos += err;
+		
+		/* Insert the new node into the file system.  */
+		if ((err = jffs_insert_node(c, f, &raw_inode, 0, node)) < 0) {
+			goto out;
+		}
+		
+		D3(printk("jffs_file_write(): new f_pos %ld.\n", (long)pos));
+		
+		thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
+	}
+	out:
+	D3(printk (KERN_NOTICE "file_write(): up biglock\n"));
+	up(&c->fmc->biglock);
+	*ppos = pos;
+	kfree(vbuf);
+	
+	/* Fix things in the real inode.  */
+	if (pos > inode->i_size) {
+		inode->i_size = pos;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+	}
+	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+	mark_inode_dirty(inode);
+	invalidate_inode_pages(inode);
+	
+	/* What if there was an error, _and_ we've written some data. */
+	if (written)
+		return written;
+	else
+		return err;
+} /* jffs_file_write()  */
+
+
+/* This is our ioctl() routine.  */
+static int
+jffs_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	struct jffs_control *c;
+	int ret = 0;
+	
+	D2(printk("***jffs_ioctl(): cmd = 0x%08x, arg = 0x%08lx\n",
+			cmd, arg));
+	
+	if (!(c = (struct jffs_control *)inode->i_sb->u.generic_sbp)) {
+		printk(KERN_ERR "JFFS: Bad inode in ioctl() call. "
+			"(cmd = 0x%08x)\n", cmd);
+		return -EIO;
+	}
+	D3(printk (KERN_NOTICE "ioctl(): down biglock\n"));
+	down(&c->fmc->biglock);
+	
+	switch (cmd) {
+		case JFFS_PRINT_HASH:
+			jffs_print_hash_table(c);
+			break;
+		case JFFS_PRINT_TREE:
+			jffs_print_tree(c->root, 0);
+			break;
+		case JFFS_GET_STATUS:
+			{
+				struct jffs_flash_status fst;
+				struct jffs_fmcontrol *fmc = c->fmc;
+				printk("Flash status -- ");
+				if (!access_ok(VERIFY_WRITE,
+						(struct jffs_flash_status *)arg,
+						sizeof(struct jffs_flash_status))) {
+					D(printk("jffs_ioctl(): Bad arg in "
+							"JFFS_GET_STATUS ioctl!\n"));
+					ret = -EFAULT;
+					break;
+				}
+				fst.size = fmc->flash_size;
+				fst.used = fmc->used_size;
+				fst.dirty = fmc->dirty_size;
+				fst.begin = fmc->head->offset;
+				fst.end = fmc->tail->offset + fmc->tail->size;
+				printk("size: %d, used: %d, dirty: %d, "
+					"begin: %d, end: %d\n",
+					fst.size, fst.used, fst.dirty,
+					fst.begin, fst.end);
+				if (copy_to_user((struct jffs_flash_status *)arg,
+						&fst, sizeof(struct jffs_flash_status))) {
+					ret = -EFAULT;
+				}
+			}
+			break;
+		default:
+			ret = -ENOTTY;
+	}
+	D3(printk (KERN_NOTICE "ioctl(): up biglock\n"));
+	up(&c->fmc->biglock);
+	return ret;
+} /* jffs_ioctl()  */
+
+
+static int jffs_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	/* Don't allow shared writable mmaps - we don't handle them correctly */
+	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
+		return -EINVAL;
+	
+	return generic_file_mmap(file, vma);
+} /* jffs_file_mmap() */
+
+static int jffs_fsync(struct file *f, struct dentry *d)
+{
+	/* We currently have O_SYNC operations at all times.
+	   Do nothing.
+	*/
+	return 0;
+}
+
+static struct file_operations jffs_file_operations =
+{
+	read:  generic_file_read,    /* read */
+	write: jffs_file_write,      /* write */
+	ioctl: jffs_ioctl,           /* ioctl */
+	mmap:  jffs_file_mmap,    /* mmap */
+	fsync: jffs_fsync,
+};
+
+
+static struct inode_operations jffs_file_inode_operations =
+{
+	&jffs_file_operations,
+	lookup:  jffs_lookup,          /* lookup */
+	readpage: jffs_readpage,
+};
+
+
+static struct file_operations jffs_dir_operations =
+{
+	readdir: jffs_readdir,
+};
+
+
+static struct inode_operations jffs_dir_inode_operations =
+{
+	&jffs_dir_operations,
+	create:   jffs_create,
+	lookup:   jffs_lookup,
+	unlink:   jffs_unlink,
+	symlink:  jffs_symlink,
+	mkdir:    jffs_mkdir,
+	rmdir:    jffs_rmdir,
+	mknod:    jffs_mknod,
+	rename:   jffs_rename,
+};
+
+
+static struct inode_operations jffs_symlink_inode_operations =
+{
+	readlink:    jffs_readlink,
+	follow_link: jffs_follow_link,
+};
+
+
+/* Initialize an inode for the VFS.  */
+static void
+jffs_read_inode(struct inode *inode)
+{
+	struct jffs_file *f;
+	struct jffs_control *c;
+	
+	D3(printk("jffs_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
+	
+	if (!inode->i_sb) {
+		D(printk("jffs_read_inode(): !inode->i_sb ==> "
+				"No super block!\n"));
+		return;
+	}
+	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
+	D3(printk (KERN_NOTICE "read_inode(): down biglock\n"));
+	down(&c->fmc->biglock);
+	if (!(f = jffs_find_file(c, inode->i_ino))) {
+		D(printk("jffs_read_inode(): No such inode (%lu).\n",
+				inode->i_ino));
+		D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
+		up(&c->fmc->biglock);
+		return;
+	}
+	inode->u.generic_ip = (void *)f;
+	inode->i_mode = f->mode;
+	inode->i_nlink = f->nlink;
+	inode->i_uid = f->uid;
+	inode->i_gid = f->gid;
+	inode->i_size = f->size;
+	inode->i_atime = f->atime;
+	inode->i_mtime = f->mtime;
+	inode->i_ctime = f->ctime;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &jffs_file_inode_operations;
+		inode->i_op->default_file_ops = &jffs_file_operations;
+	}
+	else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &jffs_dir_inode_operations;
+		inode->i_op->default_file_ops = &jffs_dir_operations;
+	}
+	else if (S_ISLNK(inode->i_mode)) {
+		inode->i_op = &jffs_symlink_inode_operations;
+	} else if (S_ISCHR(inode->i_mode)) {
+		inode->i_op = &chrdev_inode_operations;
+	} else if (S_ISBLK(inode->i_mode)) {
+		inode->i_op = &blkdev_inode_operations;
+	} else if (S_ISFIFO(inode->i_mode)) {
+		init_fifo(inode);
+	}
+	
+	/* If the node is a device of some sort, then the number of the
+	   device should be read from the flash memory and then added
+	   to the inode's i_rdev member.  */
+	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {
+		kdev_t rdev;
+		jffs_read_data(f, (char *)&rdev, 0, sizeof(kdev_t));
+		inode->i_rdev = kdev_t_to_nr(rdev);
+	}
+
+	D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
+	up(&c->fmc->biglock);
+}
+
+
+void
+jffs_delete_inode(struct inode *inode)
+{
+	struct jffs_file *f;
+	struct jffs_control *c;
+	D3(printk("jffs_delete_inode(): inode->i_ino == %lu\n",
+			inode->i_ino));
+	
+	lock_kernel();
+	
+	inode->i_size = 0;
+	inode->i_blocks = 0;
+	clear_inode(inode);
+	if (inode->i_nlink == 0) {
+		c = (struct jffs_control *) inode->i_sb->u.generic_sbp;
+		f = (struct jffs_file *) jffs_find_file (c, inode->i_ino);
+		jffs_possibly_delete_file(f);
+	}
+	
+	unlock_kernel();
+}
+
+
+void
+jffs_write_super(struct super_block *sb)
+{
+	struct jffs_control *c = (struct jffs_control *)sb->u.generic_sbp;
+	
+	jffs_garbage_collect_trigger(c);
+}
+
+
+static struct super_operations jffs_ops =
+{
+	read_inode:    jffs_read_inode,
+	delete_inode:  jffs_delete_inode,
+	put_super:     jffs_put_super,
+	write_super:   jffs_write_super,
+	statfs:        jffs_statfs,
+	notify_change: jffs_notify_change,
+};
+
+
+static struct file_system_type jffs_fs_type =
+{
+	"jffs",
+	FS_REQUIRES_DEV,
+	jffs_read_super,
+	NULL
+};
+
+#ifdef MODULE
+EXPORT_NO_SYMBOLS;
+#define init_jffs_fs init_module
+#endif
+
+int
+init_jffs_fs(void)
+{
+	printk("JFFS version " JFFS_VERSION_STRING ", (C) 1999, 2000 "
+		"Axis Communications AB\n");
+	
+#ifdef CONFIG_JFFS_PROC_FS
+#ifdef KERNEL_VERSION /* Not defined for kernel 2.0.*.  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,0)
+	jffs_proc_root = create_proc_entry ("jffs",
+			S_IFDIR | S_IRUGO | S_IXUGO, &proc_root_fs);
+#else
+	proc_register_dynamic(&proc_root_fs, &jffs_proc_root);
+#endif /* Linux version.  */
+#else
+	proc_register_dynamic(&proc_root_fs, &jffs_proc_root);
+#endif /* KERNEL_VERSION  */
+#endif /* CONFIG_JFFS_PROC_FS  */
+	
+	fm_cache = kmem_cache_create("jffs_fm", sizeof(struct jffs_fm),
+				     0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	node_cache = kmem_cache_create("jffs_node",sizeof(struct jffs_node),
+			0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	
+	return register_filesystem(&jffs_fs_type);
+}
+
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	unregister_filesystem(&jffs_fs_type);
+	kmem_cache_destroy(fm_cache);
+	kmem_cache_destroy(node_cache);
+}
+#endif
diff -Naur linux-2.4.2.orig/fs/jffs/inode-v23.c linux-2.4.2/fs/jffs/inode-v23.c
--- linux-2.4.2.orig/fs/jffs/inode-v23.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/inode-v23.c	Thu Jan 10 18:30:48 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: inode-v23.c,v 1.43 2000/08/22 08:00:22 dwmw2 Exp $
+ * $Id: inode-v23.c,v 1.61 2001/02/22 20:19:09 vipin Exp $
  *
  *
  * Ported to Linux 2.3.x and MTD:
@@ -39,7 +39,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/jffs.h>
 #include <linux/fs.h>
 #include <linux/locks.h>
@@ -51,8 +51,12 @@
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 #include <asm/uaccess.h>
+
 #include "jffs_fm.h"
 #include "intrep.h"
+#if CONFIG_JFFS_PROC_FS
+#include "jffs_proc.h"
+#endif
 
 static int jffs_remove(struct inode *dir, struct dentry *dentry, int type);
 
@@ -63,6 +67,8 @@
 static struct inode_operations jffs_dir_inode_operations;
 static struct address_space_operations jffs_address_operations;
 
+kmem_cache_t     *node_cache = NULL;
+kmem_cache_t     *fm_cache = NULL;
 
 /* Called by the VFS at mount time to initialize the whole file system.  */
 static struct super_block *
@@ -71,73 +77,82 @@
 	kdev_t dev = sb->s_dev;
 	struct inode *root_inode;
 	struct jffs_control *c;
-
+	
 	D1(printk(KERN_NOTICE "JFFS: Trying to mount device %s.\n",
-		  kdevname(dev)));
-
+			kdevname(dev)));
+	
 	if (MAJOR(dev) != MTD_BLOCK_MAJOR) {
 		printk(KERN_WARNING "JFFS: Trying to mount a "
-		       "non-mtd device.\n");
+			"non-mtd device.\n");
 		return 0;
 	}
-
+	
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->u.generic_sbp = (void *) 0;
-
+	
 	/* Build the file system.  */
 	if (jffs_build_fs(sb) < 0) {
 		goto jffs_sb_err1;
 	}
-
+	
 	/*
 	 * set up enough so that we can read an inode
 	 */
 	sb->s_magic = JFFS_MAGIC_SB_BITMASK;
 	sb->s_op = &jffs_ops;
-
+	
 	root_inode = iget(sb, JFFS_MIN_INO);
 	if (!root_inode)
-	        goto jffs_sb_err2;
-
+		goto jffs_sb_err2;
+	
 	/* Get the root directory of this file system.  */
 	if (!(sb->s_root = d_alloc_root(root_inode))) {
 		goto jffs_sb_err3;
 	}
-
+	
 	c = (struct jffs_control *) sb->u.generic_sbp;
-
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	/* Set up the jffs proc file system.  */
+	if (jffs_register_jffs_proc_dir(dev, c) < 0) {
+		printk(KERN_WARNING "JFFS: Failed to initialize the JFFS "
+			"proc file system for device %s.\n",
+			kdevname(dev));
+	}
+#endif
+	
 	/* Set the Garbage Collection thresholds */
-
+	
 	/* GC if free space goes below 5% of the total size */
 	c->gc_minfree_threshold = c->fmc->flash_size / 20;
-
+	
 	if (c->gc_minfree_threshold < c->fmc->sector_size)
 		c->gc_minfree_threshold = c->fmc->sector_size;
-
+	
 	/* GC if dirty space exceeds 33% of the total size. */
 	c->gc_maxdirty_threshold = c->fmc->flash_size / 3;
-
+	
 	if (c->gc_maxdirty_threshold < c->fmc->sector_size)
 		c->gc_maxdirty_threshold = c->fmc->sector_size;
-
-
-	c->thread_pid = kernel_thread (jffs_garbage_collect_thread, 
-				        (void *) c, 
-				        CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+	
+	
+	c->thread_pid = kernel_thread (jffs_garbage_collect_thread,
+			(void *) c,
+			CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
 	D1(printk(KERN_NOTICE "JFFS: GC thread pid=%d.\n", (int) c->thread_pid));
-
+	
 	D1(printk(KERN_NOTICE "JFFS: Successfully mounted device %s.\n",
-	       kdevname(dev)));
+			kdevname(dev)));
 	return sb;
-
-jffs_sb_err3:
+	
+	jffs_sb_err3:
 	iput(root_inode);
-jffs_sb_err2:
+	jffs_sb_err2:
 	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
-jffs_sb_err1:
+	jffs_sb_err1:
 	printk(KERN_WARNING "JFFS: Failed to mount device %s.\n",
-	       kdevname(dev));
+		kdevname(dev));
 	return 0;
 }
 
@@ -148,21 +163,25 @@
 {
 	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
 	D1(kdev_t dev = sb->s_dev);
-
+	
 	D2(printk("jffs_put_super()\n"));
-
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_unregister_jffs_proc_dir(c);
+#endif
+	
 	if (c->gc_task) {
 		D1(printk (KERN_NOTICE "jffs_put_super(): Telling gc thread to die.\n"));
 		send_sig(SIGKILL, c->gc_task, 1);
 	}
 	down (&c->gc_thread_sem);
-
+	
 	D1(printk (KERN_NOTICE "jffs_put_super(): Successfully waited on thread.\n"));
-
+	
 	sb->s_dev = 0;
 	jffs_cleanup_control((struct jffs_control *)sb->u.generic_sbp);
 	D1(printk(KERN_NOTICE "JFFS: Successfully unmounted device %s.\n",
-	       kdevname(dev)));
+			kdevname(dev)));
 }
 
 
@@ -181,48 +200,46 @@
 	int update_all;
 	int res;
 	int recoverable = 0;
-
+	
 	if ((res = inode_change_ok(inode, iattr)))
 		return res;
-
+	
 	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
 	fmc = c->fmc;
-
+	
 	D3(printk (KERN_NOTICE "notify_change(): down biglock\n"));
 	down(&fmc->biglock);
-
+	
 	f = jffs_find_file(c, inode->i_ino);
-
+	
 	ASSERT(if (!f) {
 		printk("jffs_setattr(): Invalid inode number: %lu\n",
-		       inode->i_ino);
+			inode->i_ino);
 		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
 		up(&fmc->biglock);
 		return -EINVAL;
 	});
-
+	
 	D1(printk("***jffs_setattr(): file: \"%s\", ino: %u\n",
-		  f->name, f->ino));
-
+			f->name, f->ino));
+	
 	update_all = iattr->ia_valid & ATTR_FORCE;
-
+	
 	if ( (update_all || iattr->ia_valid & ATTR_SIZE)
-	     && (iattr->ia_size + 128 < f->size) ) {
+		&& (iattr->ia_size + 128 < f->size) ) {
 		/* We're shrinking the file by more than 128 bytes.
 		   We'll be able to GC and recover this space, so
 		   allow it to go into the reserved space. */
 		recoverable = 1;
-        }
-
-	if (!(new_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	}
+	
+	if (!(new_node = jffs_alloc_node())) {
 		D(printk("jffs_setattr(): Allocation failed!\n"));
 		D3(printk (KERN_NOTICE "notify_change(): up biglock\n"));
 		up(&fmc->biglock);
 		return -ENOMEM;
 	}
-
-	DJM(no_jffs_node++);
+	
 	new_node->data_offset = 0;
 	new_node->removed_size = 0;
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
@@ -243,7 +260,7 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	if (update_all || iattr->ia_valid & ATTR_MODE) {
 		raw_inode.mode = iattr->ia_mode;
 		inode->i_mode = iattr->ia_mode;
@@ -259,9 +276,9 @@
 	if (update_all || iattr->ia_valid & ATTR_SIZE) {
 		int len;
 		D1(printk("jffs_notify_change(): Changing size "
-			  "to %lu bytes!\n", (long)iattr->ia_size));
+				"to %lu bytes!\n", (long)iattr->ia_size));
 		raw_inode.offset = iattr->ia_size;
-
+		
 		/* Calculate how many bytes need to be removed from
 		   the end.  */
 		if (f->size < iattr->ia_size) {
@@ -270,9 +287,9 @@
 		else {
 			len = f->size - iattr->ia_size;
 		}
-
+		
 		raw_inode.rsize = len;
-
+		
 		/* The updated node will be a removal node, with
 		   base at the new size and size of the nbr of bytes
 		   to be removed.  */
@@ -280,7 +297,7 @@
 		new_node->removed_size = len;
 		inode->i_size = iattr->ia_size;
 		inode->i_blocks = (inode->i_size + 511) >> 9;
-
+		
 		if (len) {
 			invalidate_inode_pages(inode);
 		}
@@ -299,19 +316,18 @@
 		raw_inode.ctime = iattr->ia_ctime;
 		inode->i_ctime = iattr->ia_ctime;
 	}
-
+	
 	/* Write this node to the flash.  */
 	if ((res = jffs_write_node(c, new_node, &raw_inode, f->name, 0, recoverable, f)) < 0) {
 		D(printk("jffs_notify_change(): The write failed!\n"));
-		kfree(new_node);
-		DJM(no_jffs_node--);
+		jffs_free_node(new_node);
 		D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
 		up(&c->fmc->biglock);
 		return res;
 	}
-
+	
 	jffs_insert_node(c, f, &raw_inode, 0, new_node);
-
+	
 	mark_inode_dirty(inode);
 	D3(printk (KERN_NOTICE "n_c(): up biglock\n"));
 	up(&c->fmc->biglock);
@@ -321,21 +337,22 @@
 
 struct inode *
 jffs_new_inode(const struct inode * dir, struct jffs_raw_inode *raw_inode,
-	       int * err)
+	int * err)
 {
 	struct super_block * sb;
 	struct inode * inode;
 	struct jffs_control *c;
-
+	struct jffs_file *f;
+	
 	sb = dir->i_sb;
 	inode = new_inode(sb);
 	if (!inode) {
 		*err = -ENOMEM;
 		return NULL;
 	}
-
+	
 	c = (struct jffs_control *)sb->u.generic_sbp;
-
+	
 	inode->i_ino = raw_inode->ino;
 	inode->i_mode = raw_inode->mode;
 	inode->i_nlink = raw_inode->nlink;
@@ -349,10 +366,12 @@
 	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = (inode->i_size + 511) >> 9;
 	inode->i_version = 0;
-	inode->u.generic_ip = (void *)jffs_find_file(c, raw_inode->ino);
-
+	
+	f = jffs_find_file(c, raw_inode->ino);
+	
+	inode->u.generic_ip = (void *)f;
 	insert_inode_hash(inode);
-
+	
 	return inode;
 }
 
@@ -362,18 +381,18 @@
 {
 	struct jffs_control *c = (struct jffs_control *) sb->u.generic_sbp;
 	struct jffs_fmcontrol *fmc = c->fmc;
-
+	
 	D2(printk("jffs_statfs()\n"));
-
+	
 	buf->f_type = JFFS_MAGIC_SB_BITMASK;
 	buf->f_bsize = PAGE_CACHE_SIZE;
 	buf->f_blocks = (fmc->flash_size / PAGE_CACHE_SIZE)
-		       - (fmc->min_free_size / PAGE_CACHE_SIZE);
+		- (fmc->min_free_size / PAGE_CACHE_SIZE);
 	buf->f_bfree = (jffs_free_size1(fmc) / PAGE_CACHE_SIZE
-		       + jffs_free_size2(fmc) / PAGE_CACHE_SIZE)
-		      - (fmc->min_free_size / PAGE_CACHE_SIZE);
+			+ jffs_free_size2(fmc) / PAGE_CACHE_SIZE)
+		- (fmc->min_free_size / PAGE_CACHE_SIZE);
 	buf->f_bavail = buf->f_bfree;
-
+	
 	/* Find out how many files there are in the filesystem.  */
 	buf->f_files = jffs_foreach_file(c, jffs_file_count);
 	buf->f_ffree = buf->f_bfree;
@@ -386,7 +405,7 @@
 /* Rename a file.  */
 int
 jffs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	    struct inode *new_dir, struct dentry *new_dentry)
+	struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct jffs_raw_inode raw_inode;
 	struct jffs_control *c;
@@ -398,34 +417,34 @@
 	struct inode *inode;
 	int result = 0;
 	__u32 rename_data = 0;
-
+	
 	D2(printk("***jffs_rename()\n"));
 	
 	D(printk("jffs_rename(): old_dir: 0x%p, old name: 0x%p, "
-		 "new_dir: 0x%p, new name: 0x%p\n",
-		 old_dir, old_dentry->d_name.name,
-		 new_dir, new_dentry->d_name.name));
-
+			"new_dir: 0x%p, new name: 0x%p\n",
+			old_dir, old_dentry->d_name.name,
+			new_dir, new_dentry->d_name.name));
+	
 	c = (struct jffs_control *)old_dir->i_sb->u.generic_sbp;
 	ASSERT(if (!c) {
 		printk(KERN_ERR "jffs_rename(): The old_dir inode "
-		       "didn't have a reference to a jffs_file struct\n");
+			"didn't have a reference to a jffs_file struct\n");
 		return -EIO;
 	});
-
+	
 	result = -ENOTDIR;
 	if (!(old_dir_f = (struct jffs_file *)old_dir->u.generic_ip)) {
 		D(printk("jffs_rename(): Old dir invalid.\n"));
 		goto jffs_rename_end;
 	}
-
+	
 	/* Try to find the file to move.  */
 	result = -ENOENT;
 	if (!(f = jffs_find_child(old_dir_f, old_dentry->d_name.name,
-				  old_dentry->d_name.len))) {
+					old_dentry->d_name.len))) {
 		goto jffs_rename_end;
 	}
-
+	
 	/* Find the new directory.  */
 	result = -ENOTDIR;
 	if (!(new_dir_f = (struct jffs_file *)new_dir->u.generic_ip)) {
@@ -436,15 +455,13 @@
 	down(&c->fmc->biglock);
 	/* Create a node and initialize as much as needed.  */
 	result = -ENOMEM;
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_rename(): Allocation failed: node == 0\n"));
 		goto jffs_rename_end;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = f->ino;
@@ -468,58 +485,57 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	/* See if there already exists a file with the same name as
 	   new_name.  */
 	if ((del_f = jffs_find_child(new_dir_f, new_dentry->d_name.name,
-				     new_dentry->d_name.len))) {
+					new_dentry->d_name.len))) {
 		raw_inode.rename = 1;
 		raw_inode.dsize = sizeof(__u32);
 		rename_data = del_f->ino;
 	}
-
+	
 	/* Write the new node to the flash memory.  */
 	if ((result = jffs_write_node(c, node, &raw_inode,
-				      new_dentry->d_name.name,
-				      (unsigned char*)&rename_data, 0, f)) < 0) {
+					new_dentry->d_name.name,
+					(unsigned char*)&rename_data, 0, f)) < 0) {
 		D(printk("jffs_rename(): Failed to write node to flash.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_rename_end;
 	}
 	raw_inode.dsize = 0;
-
+	
 	if (raw_inode.rename) {
 		/* The file with the same name must be deleted.  */
 		//FIXME deadlock	        down(&c->fmc->gclock);
 		if ((result = jffs_remove(new_dir, new_dentry,
-					  del_f->mode)) < 0) {
+						del_f->mode)) < 0) {
 			/* This is really bad.  */
 			printk(KERN_ERR "JFFS: An error occurred in "
-			       "rename().\n");
+				"rename().\n");
 		}
 		//		up(&c->fmc->gclock);
 	}
-
+	
 	if (old_dir_f != new_dir_f) {
 		/* Remove the file from its old position in the
 		   filesystem tree.  */
 		jffs_unlink_file_from_tree(f);
 	}
-
+	
 	/* Insert the new node into the file system.  */
 	if ((result = jffs_insert_node(c, f, &raw_inode,
-				       new_dentry->d_name.name, node)) < 0) {
+					new_dentry->d_name.name, node)) < 0) {
 		D(printk(KERN_ERR "jffs_rename(): jffs_insert_node() "
-			 "failed!\n"));
+				"failed!\n"));
 	}
-
+	
 	if (old_dir_f != new_dir_f) {
 		/* Insert the file to its new position in the
 		   file system.  */
 		jffs_insert_file_into_tree(f);
 	}
-
+	
 	/* This is a kind of update of the inode we're about to make
 	   here.  This is what they do in ext2fs.  Kind of.  */
 	if ((inode = iget(new_dir->i_sb, f->ino))) {
@@ -527,8 +543,8 @@
 		mark_inode_dirty(inode);
 		iput(inode);
 	}
-
-jffs_rename_end:
+	
+	jffs_rename_end:
 	D3(printk (KERN_NOTICE "rename(): up biglock\n"));
 	up(&c->fmc->biglock);
 	return result;
@@ -548,12 +564,12 @@
 	int ddino;
 	D3(printk (KERN_NOTICE "readdir(): down biglock\n"));
 	down(&c->fmc->biglock);
-
+	
 	D2(printk("jffs_readdir(): inode: 0x%p, filp: 0x%p\n", inode, filp));
 	if (filp->f_pos == 0) {
 		D3(printk("jffs_readdir(): \".\" %lu\n", inode->i_ino));
 		if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino, DT_DIR) < 0) {
-		  D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 			up(&c->fmc->biglock);
 			return 0;
 		}
@@ -565,30 +581,36 @@
 		}
 		else {
 			ddino = ((struct jffs_file *)
-				 inode->u.generic_ip)->pino;
+					inode->u.generic_ip)->pino;
 		}
 		D3(printk("jffs_readdir(): \"..\" %u\n", ddino));
 		if (filldir(dirent, "..", 2, filp->f_pos, ddino, DT_DIR) < 0) {
-		  D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 			up(&c->fmc->biglock);
 			return 0;
 		}
 		filp->f_pos++;
 	}
 	f = ((struct jffs_file *)inode->u.generic_ip)->children;
-	for (j = 2; (j < filp->f_pos) && f; j++) {
-	        f = f->sibling_next;
+	
+	j=2;
+	while(f && (f->deleted || j++ < filp->f_pos )) {
+		f = f->sibling_next;
 	}
-	for (; f ; f = f->sibling_next) {
+	
+	while (f) {
 		D3(printk("jffs_readdir(): \"%s\" ino: %u\n",
-			  (f->name ? f->name : ""), f->ino));
+				(f->name ? f->name : ""), f->ino));
 		if (filldir(dirent, f->name, f->nsize,
-			    filp->f_pos , f->ino, DT_UNKNOWN) < 0) {
-		        D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
+				filp->f_pos , f->ino, DT_UNKNOWN) < 0) {
+			D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 			up(&c->fmc->biglock);
 			return 0;
 		}
 		filp->f_pos++;
+		do {
+			f = f->sibling_next;
+		} while(f && f->deleted);
 	}
 	D3(printk (KERN_NOTICE "readdir(): up biglock\n"));
 	up(&c->fmc->biglock);
@@ -608,10 +630,10 @@
 	int r = 0;
 	const char *name;
 	struct inode *inode = NULL;
-
+	
 	len = dentry->d_name.len;
 	name = dentry->d_name.name;
-
+	
 	D3({
 		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
 		memcpy(s, name, len);
@@ -619,31 +641,31 @@
 		printk("jffs_lookup(): dir: 0x%p, name: \"%s\"\n", dir, s);
 		kfree(s);
 	});
-
+	
 	D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
 	down(&c->fmc->biglock);
-
+	
 	r = -ENAMETOOLONG;
 	if (len > JFFS_MAX_NAME_LEN) {
 		goto jffs_lookup_end;
 	}
-
+	
 	r = -EACCES;
 	if (!(d = (struct jffs_file *)dir->u.generic_ip)) {
 		D(printk("jffs_lookup(): No such inode! (%lu)\n",
 			 dir->i_ino));
 		goto jffs_lookup_end;
 	}
-
+	
 	/* Get the corresponding inode to the file.  */
-
+	
 	/* iget calls jffs_read_inode, so we need to drop the biglock
            before calling iget.  Unfortunately, the GC has a tendency
-           to sneak in here, because iget sometimes calls schedule (). 
-         */
-
+           to sneak in here, because iget sometimes calls schedule ().
+	*/
+	
 	if ((len == 1) && (name[0] == '.')) {
-                D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 		up(&c->fmc->biglock);
 		if (!(inode = iget(dir->i_sb, d->ino))) {
 			D(printk("jffs_lookup(): . iget() ==> NULL\n"));
@@ -652,16 +674,16 @@
 		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
 		down(&c->fmc->biglock);
 	} else if ((len == 2) && (name[0] == '.') && (name[1] == '.')) {
-	        D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 		up(&c->fmc->biglock);
- 		if (!(inode = iget(dir->i_sb, d->pino))) {
+		if (!(inode = iget(dir->i_sb, d->pino))) {
 			D(printk("jffs_lookup(): .. iget() ==> NULL\n"));
 			goto jffs_lookup_end_no_biglock;
 		}
 		D3(printk (KERN_NOTICE "lookup(): down biglock\n"));
 		down(&c->fmc->biglock);
 	} else if ((f = jffs_find_child(d, name, len))) {
-	        D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
+		D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 		up(&c->fmc->biglock);
 		if (!(inode = iget(dir->i_sb, f->ino))) {
 			D(printk("jffs_lookup(): iget() ==> NULL\n"));
@@ -675,83 +697,94 @@
 			  f, name, d, d->ino));
 		inode = NULL;
 	}
-
+	
 	d_add(dentry, inode);
 	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 	up(&c->fmc->biglock);
 	return NULL;
-
-jffs_lookup_end:
+	
+ jffs_lookup_end:
 	D3(printk (KERN_NOTICE "lookup(): up biglock\n"));
 	up(&c->fmc->biglock);
-
-jffs_lookup_end_no_biglock:
+	
+ jffs_lookup_end_no_biglock:
 	return ERR_PTR(r);
 } /* jffs_lookup()  */
 
 
 /* Try to read a page of data from a file.  */
 static int
-jffs_readpage(struct file *file, struct page *page)
+jffs_do_readpage_nolock(struct file *file, struct page *page)
 {
 	void *buf;
 	unsigned long read_len;
-	int result = -EIO;
-	struct inode *inode = page->mapping->host;
+	int result;
+	struct inode *inode = (struct inode*)page->mapping->host;
 	struct jffs_file *f = (struct jffs_file *)inode->u.generic_ip;
 	struct jffs_control *c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
 	int r;
 	loff_t offset;
-
+	
 	D2(printk("***jffs_readpage(): file = \"%s\", page->index = %lu\n",
-		  (f->name ? f->name : ""), (long)page->index));
-
+			(f->name ? f->name : ""), (long)page->index));
+	
 	get_page(page);
 	/* Don't LockPage(page), should be locked already */
 	buf = page_address(page);
 	ClearPageUptodate(page);
 	ClearPageError(page);
-
+	
 	D3(printk (KERN_NOTICE "readpage(): down biglock\n"));
 	down(&c->fmc->biglock);
+	
+	read_len = 0;
+	result = 0;
 
 	offset = page->index << PAGE_CACHE_SHIFT;
 	if (offset < inode->i_size) {
 		read_len = jffs_min(inode->i_size - offset, PAGE_SIZE);
 		r = jffs_read_data(f, buf, offset, read_len);
-		if (r == read_len) {
-			if (read_len < PAGE_SIZE) {
-				memset(buf + read_len, 0,
-				       PAGE_SIZE - read_len);
-			}
-			SetPageUptodate(page);
-			result = 0;
+		if (r != read_len) {
+			result = -EIO;
+			D(
+			        printk("***jffs_readpage(): Read error! "
+				       "Wanted to read %lu bytes but only "
+				       "read %d bytes.\n", read_len, r);
+			  );
 		}
-		D(else {
-			printk("***jffs_readpage(): Read error! "
-			       "Wanted to read %lu bytes but only "
-			       "read %d bytes.\n", read_len, r);
-		});
+
+	}
+
+	/* This handles the case of partial or no read in above */
+	if(read_len < PAGE_SIZE){
+	        memset(buf + read_len, 0,
+		       PAGE_SIZE - read_len);	        
 	}
 
 	D3(printk (KERN_NOTICE "readpage(): up biglock\n"));
 	up(&c->fmc->biglock);
-	
+
 	if (result) {
-		memset(buf, 0, PAGE_SIZE);
-	        SetPageError(page);
+		SetPageError(page);
+	}else {
+	        SetPageUptodate(page);	        
 	}
-	flush_dcache_page(page);
-
-	UnlockPage(page);
 
+	flush_dcache_page(page);
+	
 	put_page(page);
-
+	
 	D3(printk("jffs_readpage(): Leaving...\n"));
-
+	
 	return result;
-} /* jffs_readpage()  */
+} /* jffs_do_readpage_nolock()  */
 
+static int jffs_readpage(struct file *file, struct page *page)
+{
+	int ret = jffs_do_readpage_nolock(file, page);
+	UnlockPage(page);
+	return ret;
+}
 
 /* Create a new directory.  */
 static int
@@ -765,9 +798,9 @@
 	int dir_mode;
 	int result = 0;
 	int err;
-
+	
 	D1({
-	        int len = dentry->d_name.len;
+		int len = dentry->d_name.len;
 		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
 		memcpy(_name, dentry->d_name.name, len);
 		_name[len] = '\0';
@@ -775,36 +808,34 @@
 		       "len = %d, mode = 0x%08x\n", dir, _name, len, mode);
 		kfree(_name);
 	});
-
+	
 	dir_f = (struct jffs_file *)dir->u.generic_ip;
-
+	
 	ASSERT(if (!dir_f) {
 		printk(KERN_ERR "jffs_mkdir(): No reference to a "
 		       "jffs_file struct in inode.\n");
 		return -EIO;
 	});
-
+	
 	c = dir_f->c;
 	D3(printk (KERN_NOTICE "mkdir(): down biglock\n"));
 	down(&c->fmc->biglock);
-
+	
 	dir_mode = S_IFDIR | (mode & (S_IRWXUGO|S_ISVTX)
 			      & ~current->fs->umask);
 	if (dir->i_mode & S_ISGID) {
 		dir_mode |= S_ISGID;
 	}
-
+	
 	/* Create a node and initialize it as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_mkdir(): Allocation failed: node == 0\n"));
 		result = -ENOMEM;
 		goto jffs_mkdir_end;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = c->next_ino++;
@@ -825,36 +856,35 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	/* Write the new node to the flash.  */
 	if ((result = jffs_write_node(c, node, &raw_inode,
 				      dentry->d_name.name, 0, 0, NULL)) < 0) {
 		D(printk("jffs_mkdir(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_mkdir_end;
 	}
-
+	
 	/* Insert the new node into the file system.  */
 	if ((result = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
 				       node)) < 0) {
 		goto jffs_mkdir_end;
 	}
-
+	
 	inode = jffs_new_inode(dir, &raw_inode, &err);
 	if (inode == NULL) {
 		result = err;
 		goto jffs_mkdir_end;
 	}
-
+	
 	inode->i_op = &jffs_dir_inode_operations;
 	inode->i_fop = &jffs_dir_operations;
-
+	
 	mark_inode_dirty(dir);
 	d_instantiate(dentry, inode);
-
+	
 	result = 0;
-jffs_mkdir_end:
+ jffs_mkdir_end:
 	D3(printk (KERN_NOTICE "mkdir(): up biglock\n"));
 	up(&c->fmc->biglock);
 	return result;
@@ -882,8 +912,8 @@
 jffs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct jffs_control *c = (struct jffs_control *)dir->i_sb->u.generic_sbp;
-	int ret; 
-
+	int ret;
+	
 	D3(printk("***jffs_unlink()\n"));
 	D3(printk (KERN_NOTICE "unlink(): down biglock\n"));
 	down(&c->fmc->biglock);
@@ -906,68 +936,70 @@
 	struct jffs_node *del_node;
 	struct inode *inode = 0;
 	int result = 0;
-
+	
 	D1({
-	        int len = dentry->d_name.len;
-	        const char *name = dentry->d_name.name;
+		int len = dentry->d_name.len;
+		const char *name = dentry->d_name.name;
 		char *_name = (char *) kmalloc(len + 1, GFP_KERNEL);
 		memcpy(_name, name, len);
 		_name[len] = '\0';
 		printk("***jffs_remove(): file = \"%s\", ino = %ld\n", _name, dentry->d_inode->i_ino);
 		kfree(_name);
 	});
-
+	
 	dir_f = (struct jffs_file *) dir->u.generic_ip;
 	c = dir_f->c;
-
+	
 	result = -ENOENT;
 	if (!(del_f = jffs_find_child(dir_f, dentry->d_name.name,
 				      dentry->d_name.len))) {
 		D(printk("jffs_remove(): jffs_find_child() failed.\n"));
 		goto jffs_remove_end;
 	}
-
+	
 	if (S_ISDIR(type)) {
-		if (del_f->children) {
-			result = -ENOTEMPTY;
-			goto jffs_remove_end;
+		struct jffs_file *child = del_f->children;
+		while(child) {
+			if( !child->deleted ) {
+				result = -ENOTEMPTY;
+				goto jffs_remove_end;
+			}
+			child = child->sibling_next;
 		}
-	}
+	}            
 	else if (S_ISDIR(del_f->mode)) {
 		D(printk("jffs_remove(): node is a directory "
 			 "but it shouldn't be.\n"));
 		result = -EPERM;
 		goto jffs_remove_end;
 	}
-
+	
 	inode = dentry->d_inode;
-
+	
 	result = -EIO;
 	if (del_f->ino != inode->i_ino)
 		goto jffs_remove_end;
-
+	
 	if (!inode->i_nlink) {
 		printk("Deleting nonexistent file inode: %lu, nlink: %d\n",
 		       inode->i_ino, inode->i_nlink);
 		inode->i_nlink=1;
 	}
-
+	
 	/* Create a node for the deletion.  */
 	result = -ENOMEM;
-	if (!(del_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	if (!(del_node = jffs_alloc_node())) {
 		D(printk("jffs_remove(): Allocation failed!\n"));
 		goto jffs_remove_end;
 	}
-	DJM(no_jffs_node++);
 	del_node->data_offset = 0;
 	del_node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = del_f->ino;
 	raw_inode.pino = del_f->pino;
-/*  	raw_inode.version = del_f->highest_version + 1; */
+	/*  	raw_inode.version = del_f->highest_version + 1; */
 	raw_inode.mode = del_f->mode;
 	raw_inode.uid = current->fsuid;
 	raw_inode.gid = current->fsgid;
@@ -982,11 +1014,10 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 1;
-
+	
 	/* Write the new node to the flash memory.  */
 	if (jffs_write_node(c, del_node, &raw_inode, 0, 0, 1, del_f) < 0) {
-		kfree(del_node);
-		DJM(no_jffs_node--);
+		jffs_free_node(del_node);
 		result = -EIO;
 		goto jffs_remove_end;
 	}
@@ -994,21 +1025,18 @@
 	/* Update the file.  This operation will make the file disappear
 	   from the in-memory file system structures.  */
 	jffs_insert_node(c, del_f, &raw_inode, 0, del_node);
-
+	
 	dir->i_version = ++event;
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	mark_inode_dirty(dir);
 	inode->i_nlink--;
-	if (inode->i_nlink == 0) {
-		inode->u.generic_ip = 0;
-	}
 	inode->i_ctime = dir->i_ctime;
 	mark_inode_dirty(inode);
-
+	
 	d_delete(dentry);	/* This also frees the inode */
-
+	
 	result = 0;
-jffs_remove_end:
+ jffs_remove_end:
 	return result;
 } /* jffs_remove()  */
 
@@ -1024,26 +1052,24 @@
 	int result = 0;
 	kdev_t dev = to_kdev_t(rdev);
 	int err;
-
+	
 	D1(printk("***jffs_mknod()\n"));
-
+	
 	dir_f = (struct jffs_file *)dir->u.generic_ip;
 	c = dir_f->c;
-
+	
 	D3(printk (KERN_NOTICE "mknod(): down biglock\n"));
 	down(&c->fmc->biglock);
-
+	
 	/* Create and initialize a new node.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_mknod(): Allocation failed!\n"));
 		result = -ENOMEM;
 		goto jffs_mknod_err;
 	}
-	DJM(no_jffs_node++);
 	node->data_offset = 0;
 	node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = c->next_ino++;
@@ -1064,41 +1090,40 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	/* Write the new node to the flash.  */
 	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
-				  (unsigned char *)&dev, 0, NULL)) < 0) {
+					(unsigned char *)&dev, 0, NULL)) < 0) {
 		D(printk("jffs_mknod(): jffs_write_node() failed.\n"));
 		result = err;
 		goto jffs_mknod_err;
 	}
-
+	
 	/* Insert the new node into the file system.  */
 	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
-				    node)) < 0) {
+					node)) < 0) {
 		result = err;
 		goto jffs_mknod_end;
 	}
-
+	
 	inode = jffs_new_inode(dir, &raw_inode, &err);
 	if (inode == NULL) {
 		result = err;
 		goto jffs_mknod_end;
 	}
-
+	
 	init_special_inode(inode, mode, rdev);
-
+	
 	d_instantiate(dentry, inode);
-
+	
 	goto jffs_mknod_end;
-
-jffs_mknod_err:
+	
+	jffs_mknod_err:
 	if (node) {
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 	}
-
-jffs_mknod_end:
+	
+	jffs_mknod_end:
 	D3(printk (KERN_NOTICE "mknod(): up biglock\n"));
 	up(&c->fmc->biglock);
 	return result;
@@ -1113,12 +1138,12 @@
 	struct jffs_file *dir_f;
 	struct jffs_node *node;
 	struct inode *inode;
-
+	
 	int symname_len = strlen(symname);
 	int err;
-
+	
 	D1({
-	        int len = dentry->d_name.len;
+		int len = dentry->d_name.len;
 		char *_name = (char *)kmalloc(len + 1, GFP_KERNEL);
 		char *_symname = (char *)kmalloc(symname_len + 1, GFP_KERNEL);
 		memcpy(_name, dentry->d_name.name, len);
@@ -1131,29 +1156,27 @@
 		kfree(_name);
 		kfree(_symname);
 	});
-
+	
 	dir_f = (struct jffs_file *)dir->u.generic_ip;
 	ASSERT(if (!dir_f) {
 		printk(KERN_ERR "jffs_symlink(): No reference to a "
 		       "jffs_file struct in inode.\n");
 		return -EIO;
 	});
-
+	
 	c = dir_f->c;
-
+	
 	/* Create a node and initialize it as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_symlink(): Allocation failed: node = NULL\n"));
 		return -ENOMEM;
 	}
 	D3(printk (KERN_NOTICE "symlink(): down biglock\n"));
 	down(&c->fmc->biglock);
-
-	DJM(no_jffs_node++);
+	
 	node->data_offset = 0;
 	node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = c->next_ino++;
@@ -1173,22 +1196,21 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	/* Write the new node to the flash.  */
 	if ((err = jffs_write_node(c, node, &raw_inode, dentry->d_name.name,
 				   (const unsigned char *)symname, 0, NULL)) < 0) {
 		D(printk("jffs_symlink(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_symlink_end;
 	}
-
+	
 	/* Insert the new node into the file system.  */
 	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
 				    node)) < 0) {
 		goto jffs_symlink_end;
 	}
-
+	
 	inode = jffs_new_inode(dir, &raw_inode, &err);
 	if (inode == NULL) {
 		goto jffs_symlink_end;
@@ -1196,7 +1218,7 @@
 	err = 0;
 	inode->i_op = &page_symlink_inode_operations;
 	inode->i_mapping->a_ops = &jffs_address_operations;
-
+	
 	d_instantiate(dentry, inode);
  jffs_symlink_end:
 	D3(printk (KERN_NOTICE "symlink(): up biglock\n"));
@@ -1223,38 +1245,36 @@
 	struct jffs_file *dir_f; /* JFFS representation of the directory.  */
 	struct inode *inode;
 	int err;
-
+	
 	D1({
-	        int len = dentry->d_name.len;
+		int len = dentry->d_name.len;
 		char *s = (char *)kmalloc(len + 1, GFP_KERNEL);
 		memcpy(s, dentry->d_name.name, len);
 		s[len] = '\0';
 		printk("jffs_create(): dir: 0x%p, name: \"%s\"\n", dir, s);
 		kfree(s);
 	});
-
+	
 	dir_f = (struct jffs_file *)dir->u.generic_ip;
 	ASSERT(if (!dir_f) {
 		printk(KERN_ERR "jffs_create(): No reference to a "
 		       "jffs_file struct in inode.\n");
 		return -EIO;
 	});
-
+	
 	c = dir_f->c;
-
+	
 	/* Create a node and initialize as much as needed.  */
-	if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-						  GFP_KERNEL))) {
+	if (!(node = jffs_alloc_node())) {
 		D(printk("jffs_create(): Allocation failed: node == 0\n"));
 		return -ENOMEM;
 	}
 	D3(printk (KERN_NOTICE "create(): down biglock\n"));
 	down(&c->fmc->biglock);
-
-	DJM(no_jffs_node++);
+	
 	node->data_offset = 0;
 	node->removed_size = 0;
-
+	
 	/* Initialize the raw inode.  */
 	raw_inode.magic = JFFS_MAGIC_BITMASK;
 	raw_inode.ino = c->next_ino++;
@@ -1274,22 +1294,21 @@
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
 	raw_inode.deleted = 0;
-
+	
 	/* Write the new node to the flash.  */
 	if ((err = jffs_write_node(c, node, &raw_inode,
 				   dentry->d_name.name, 0, 0, NULL)) < 0) {
 		D(printk("jffs_create(): jffs_write_node() failed.\n"));
-		kfree(node);
-		DJM(no_jffs_node--);
+		jffs_free_node(node);
 		goto jffs_create_end;
 	}
-
+	
 	/* Insert the new node into the file system.  */
 	if ((err = jffs_insert_node(c, 0, &raw_inode, dentry->d_name.name,
 				    node)) < 0) {
 		goto jffs_create_end;
 	}
-
+	
 	/* Initialize an inode.  */
 	inode = jffs_new_inode(dir, &raw_inode, &err);
 	if (inode == NULL) {
@@ -1300,7 +1319,7 @@
 	inode->i_fop = &jffs_file_operations;
 	inode->i_mapping->a_ops = &jffs_address_operations;
 	inode->i_mapping->nrpages = 0;
-
+	
 	d_instantiate(dentry, inode);
  jffs_create_end:
 	D3(printk (KERN_NOTICE "create(): up biglock\n"));
@@ -1320,96 +1339,68 @@
 	struct jffs_node *node;
 	struct dentry *dentry = filp->f_dentry;
 	struct inode *inode = dentry->d_inode;
-	unsigned char *vbuf;
 	int recoverable = 0;
 	size_t written = 0;
 	__u32 thiscount = count;
-	loff_t pos;
+	loff_t pos = *ppos;
 	int err;
-
+	
 	inode = filp->f_dentry->d_inode;
-
+	
 	D2(printk("***jffs_file_write(): inode: 0x%p (ino: %lu), "
-		  "filp: 0x%p, buf: 0x%p, count: %d\n",
-		  inode, inode->i_ino, filp, buf, count));
-
-	err = filp->f_error;
-	if (err) {
-		filp->f_error = 0;
-		return err;
-	}
-
-	down(&inode->i_sem);
-
+			"filp: 0x%p, buf: 0x%p, count: %d\n",
+			inode, inode->i_ino, filp, buf, count));
+	
+#if 0
 	if (inode->i_sb->s_flags & MS_RDONLY) {
 		D(printk("jffs_file_write(): MS_RDONLY\n"));
 		err = -EROFS;
 		goto out_isem;
 	}
-
+#endif	
 	err = -EINVAL;
-
+	
 	if (!S_ISREG(inode->i_mode)) {
 		D(printk("jffs_file_write(): inode->i_mode == 0x%08x\n",
-			 inode->i_mode));
+				inode->i_mode));
 		goto out_isem;
 	}
-
+	
 	if (!(f = (struct jffs_file *)inode->u.generic_ip)) {
 		D(printk("jffs_file_write(): inode->u.generic_ip = 0x%p\n",
-			 inode->u.generic_ip));
+				inode->u.generic_ip));
 		goto out_isem;
 	}
-
-	c = f->c;
-
-	if (filp->f_flags & O_APPEND)
-		pos = inode->i_size;
-	else
-		pos = *ppos;
 	
-	if (pos < 0) {
-		goto out_isem;
-	}
+	c = f->c;
 	
+       /*
+	* This will never trigger with sane page sizes.  leave it in anyway,
+        * since I'm thinking about how to merge larger writes (the current idea
+        * is to poke a thread that does the actual I/O and starts by doing a
+        * down(&inode->i_sem).  then we would need to get the page cache pages
+        * and have a list of I/O requests and do write-merging here.
+	* -- prumpf
+        */
 	thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
-
-	if (!(vbuf = kmalloc(thiscount, GFP_KERNEL))) {
-		D(printk("jffs_file_write(): failed to allocate bounce buffer. Fix me to use page cache\n"));
-		err = -ENOMEM;
-		goto out_isem;
-	}
-
+	
 	D3(printk (KERN_NOTICE "file_write(): down biglock\n"));
 	down(&c->fmc->biglock);
-
-	/* Urgh. POSIX says we can do short writes if we feel like it. 
+	
+	/* Urgh. POSIX says we can do short writes if we feel like it.
 	 * In practice, we can't. Nothing will cope. So we loop until
 	 * we're done.
 	 *
 	 * <_Anarchy_> posix and reality are not interconnected on this issue
 	 */
 	while (count) {
-
-		/* FIXME: This is entirely gratuitous use of bounce buffers.
-		   Get a clue and use the page cache. 
-		   /me wanders off to get a crash course on Linux VFS
-		   dwmw2
-		*/
-		if (copy_from_user(vbuf, buf, thiscount)) {
-			err = -EFAULT;
-			goto out;
-		}
-		
 		/* Things are going to be written so we could allocate and
 		   initialize the necessary data structures now.  */
-		if (!(node = (struct jffs_node *) kmalloc(sizeof(struct jffs_node),
-							  GFP_KERNEL))) {
+		if (!(node = jffs_alloc_node())) {
 			D(printk("jffs_file_write(): node == 0\n"));
 			err = -ENOMEM;
 			goto out;
 		}
-		DJM(no_jffs_node++);
 		
 		node->data_offset = pos;
 		node->removed_size = 0;
@@ -1418,7 +1409,7 @@
 		raw_inode.magic = JFFS_MAGIC_BITMASK;
 		raw_inode.ino = f->ino;
 		raw_inode.pino = f->pino;
-
+		
 		raw_inode.mode = f->mode;
 		
 		raw_inode.uid = f->uid;
@@ -1438,8 +1429,8 @@
 		if (pos < f->size) {
 			node->removed_size = raw_inode.rsize = jffs_min(thiscount, f->size - pos);
 			
-			/* If this node is going entirely over the top of old data, 
-			   we can allow it to go into the reserved space, because 
+			/* If this node is going entirely over the top of old data,
+			   we can allow it to go into the reserved space, because
 			   we can that GC can reclaim the space later.
 			*/
 			if (pos + thiscount < f->size) {
@@ -1451,41 +1442,39 @@
 		}
 		
 		/* Write the new node to the flash.  */
-		/* NOTE: We would be quite happy if jffs_write_node() wrote a 
-		   smaller node than we were expecting. There's no need for it 
-		   to waste the space at the end of the flash just because it's 
+		/* NOTE: We would be quite happy if jffs_write_node() wrote a
+		   smaller node than we were expecting. There's no need for it
+		   to waste the space at the end of the flash just because it's
 		   a little smaller than what we asked for. But that's a whole
-		   new can of worms which I'm not going to open this week. dwmw2.
+		   new can of worms which I'm not going to open this week. 
+		   -- dwmw2.
 		*/
 		if ((err = jffs_write_node(c, node, &raw_inode, f->name,
-					   (const unsigned char *)vbuf,
-					   recoverable, f)) < 0) {
+						(const unsigned char *)buf,
+						recoverable, f)) < 0) {
 			D(printk("jffs_file_write(): jffs_write_node() failed.\n"));
-			kfree(node);
-			DJM(no_jffs_node--);
+			jffs_free_node(node);
 			goto out;
 		}
-
+		
 		written += err;
 		buf += err;
 		count -= err;
 		pos += err;
-
+		
 		/* Insert the new node into the file system.  */
 		if ((err = jffs_insert_node(c, f, &raw_inode, 0, node)) < 0) {
 			goto out;
 		}
-
+		
 		D3(printk("jffs_file_write(): new f_pos %ld.\n", (long)pos));
-
+		
 		thiscount = jffs_min(c->fmc->max_chunk_size - sizeof(struct jffs_raw_inode), count);
 	}
- out:
+	out:
 	D3(printk (KERN_NOTICE "file_write(): up biglock\n"));
 	up(&c->fmc->biglock);
-	*ppos = pos;
-	kfree(vbuf);
-
+	
 	/* Fix things in the real inode.  */
 	if (pos > inode->i_size) {
 		inode->i_size = pos;
@@ -1494,75 +1483,92 @@
 	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
 	mark_inode_dirty(inode);
 	invalidate_inode_pages(inode);
-
- out_isem:
-	up(&inode->i_sem);
 	
-	/* What if there was an error, _and_ we've written some data. */
-	if (written)
-		return written;
-	else
-		return err;
+ out_isem:
+	return err;
 } /* jffs_file_write()  */
 
+static ssize_t
+jffs_prepare_write(struct file *filp, struct page *page,
+                  unsigned from, unsigned to)
+{
+	/* FIXME: we should detect some error conditions here */
+	
+	/* Bugger that. We should make sure the page is uptodate */
+	if (!Page_Uptodate(page) && (from || to < PAGE_CACHE_SIZE))
+		return jffs_do_readpage_nolock(filp, page);
+
+	return 0;
+} /* jffs_prepare_write() */
+
+static ssize_t
+jffs_commit_write(struct file *filp, struct page *page,
+                 unsigned from, unsigned to)
+{
+       void *addr = page_address(page) + from;
+       /* XXX: PAGE_CACHE_SHIFT or PAGE_SHIFT */
+       loff_t pos = (page->index<<PAGE_CACHE_SHIFT) + from;
+
+       return jffs_file_write(filp, addr, to-from, &pos);
+} /* jffs_commit_write() */
 
 /* This is our ioctl() routine.  */
 static int
 jffs_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
-	   unsigned long arg)
+	unsigned long arg)
 {
 	struct jffs_control *c;
 	int ret = 0;
-
+	
 	D2(printk("***jffs_ioctl(): cmd = 0x%08x, arg = 0x%08lx\n",
-		  cmd, arg));
-
+			cmd, arg));
+	
 	if (!(c = (struct jffs_control *)inode->i_sb->u.generic_sbp)) {
 		printk(KERN_ERR "JFFS: Bad inode in ioctl() call. "
-		       "(cmd = 0x%08x)\n", cmd);
+			"(cmd = 0x%08x)\n", cmd);
 		return -EIO;
 	}
 	D3(printk (KERN_NOTICE "ioctl(): down biglock\n"));
 	down(&c->fmc->biglock);
-
+	
 	switch (cmd) {
-	case JFFS_PRINT_HASH:
-		jffs_print_hash_table(c);
-		break;
-	case JFFS_PRINT_TREE:
-		jffs_print_tree(c->root, 0);
-		break;
-	case JFFS_GET_STATUS:
-		{
-			struct jffs_flash_status fst;
-			struct jffs_fmcontrol *fmc = c->fmc;
-			printk("Flash status -- ");
-			if (!access_ok(VERIFY_WRITE,
-				       (struct jffs_flash_status *)arg,
-				       sizeof(struct jffs_flash_status))) {
-				D(printk("jffs_ioctl(): Bad arg in "
-					 "JFFS_GET_STATUS ioctl!\n"));
-				ret = -EFAULT;
-				break;
-			}
-			fst.size = fmc->flash_size;
-			fst.used = fmc->used_size;
-			fst.dirty = fmc->dirty_size;
-			fst.begin = fmc->head->offset;
-			fst.end = fmc->tail->offset + fmc->tail->size;
-			printk("size: %d, used: %d, dirty: %d, "
-			       "begin: %d, end: %d\n",
-			       fst.size, fst.used, fst.dirty,
-			       fst.begin, fst.end);
-			if (copy_to_user((struct jffs_flash_status *)arg,
-					 &fst,
-					 sizeof(struct jffs_flash_status))) {
-			  ret = -EFAULT;
+		case JFFS_PRINT_HASH:
+			jffs_print_hash_table(c);
+			break;
+		case JFFS_PRINT_TREE:
+			jffs_print_tree(c->root, 0);
+			break;
+		case JFFS_GET_STATUS:
+			{
+				struct jffs_flash_status fst;
+				struct jffs_fmcontrol *fmc = c->fmc;
+				printk("Flash status -- ");
+				if (!access_ok(VERIFY_WRITE,
+						(struct jffs_flash_status *)arg,
+						sizeof(struct jffs_flash_status))) {
+					D(printk("jffs_ioctl(): Bad arg in "
+							"JFFS_GET_STATUS ioctl!\n"));
+					ret = -EFAULT;
+					break;
+				}
+				fst.size = fmc->flash_size;
+				fst.used = fmc->used_size;
+				fst.dirty = fmc->dirty_size;
+				fst.begin = fmc->head->offset;
+				fst.end = fmc->tail->offset + fmc->tail->size;
+				printk("size: %d, used: %d, dirty: %d, "
+					"begin: %d, end: %d\n",
+					fst.size, fst.used, fst.dirty,
+					fst.begin, fst.end);
+				if (copy_to_user((struct jffs_flash_status *)arg,
+						&fst,
+						sizeof(struct jffs_flash_status))) {
+					ret = -EFAULT;
+				}
 			}
-		}
-		break;
-	default:
-		ret = -ENOTTY;
+			break;
+		default:
+			ret = -ENOTTY;
 	}
 	D3(printk (KERN_NOTICE "ioctl(): up biglock\n"));
 	up(&c->fmc->biglock);
@@ -1572,12 +1578,14 @@
 
 static struct address_space_operations jffs_address_operations = {
 	readpage: jffs_readpage,
+	prepare_write: jffs_prepare_write,
+	commit_write: jffs_commit_write,
 };
 
 static int jffs_fsync(struct file *f, struct dentry *d, int datasync)
 {
-	/* We currently have O_SYNC operations at all times. 
-	   Do nothing
+	/* We currently have O_SYNC operations at all times.
+	   Do nothing.
 	*/
 	return 0;
 }
@@ -1586,7 +1594,7 @@
 static struct file_operations jffs_file_operations =
 {
 	read:  generic_file_read,    /* read */
-	write: jffs_file_write,      /* write */
+	write: generic_file_write,   /* write */
 	ioctl: jffs_ioctl,           /* ioctl */
 	mmap:  generic_file_mmap,    /* mmap */
 	fsync: jffs_fsync,
@@ -1626,12 +1634,12 @@
 {
 	struct jffs_file *f;
 	struct jffs_control *c;
-
+	
 	D3(printk("jffs_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
-
+	
 	if (!inode->i_sb) {
 		D(printk("jffs_read_inode(): !inode->i_sb ==> "
-			 "No super block!\n"));
+				"No super block!\n"));
 		return;
 	}
 	c = (struct jffs_control *)inode->i_sb->u.generic_sbp;
@@ -1639,7 +1647,7 @@
 	down(&c->fmc->biglock);
 	if (!(f = jffs_find_file(c, inode->i_ino))) {
 		D(printk("jffs_read_inode(): No such inode (%lu).\n",
-			 inode->i_ino));
+				inode->i_ino));
 		D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
 		up(&c->fmc->biglock);
 		return;
@@ -1676,6 +1684,7 @@
 		jffs_read_data(f, (char *)&rdev, 0, sizeof(kdev_t));
 		init_special_inode(inode, inode->i_mode, kdev_t_to_nr(rdev));
 	}
+
 	D3(printk (KERN_NOTICE "read_inode(): up biglock\n"));
 	up(&c->fmc->biglock);
 }
@@ -1684,13 +1693,23 @@
 void
 jffs_delete_inode(struct inode *inode)
 {
+	struct jffs_file *f;
+	struct jffs_control *c;
 	D3(printk("jffs_delete_inode(): inode->i_ino == %lu\n",
-		  inode->i_ino));
-
+			inode->i_ino));
+	
 	lock_kernel();
+	
 	inode->i_size = 0;
 	inode->i_blocks = 0;
+	inode->u.generic_ip = 0;
 	clear_inode(inode);
+	if (inode->i_nlink == 0) {
+		c = (struct jffs_control *) inode->i_sb->u.generic_sbp;
+		f = (struct jffs_file *) jffs_find_file (c, inode->i_ino);
+		jffs_possibly_delete_file(f);
+	}
+	
 	unlock_kernel();
 }
 
@@ -1699,11 +1718,10 @@
 jffs_write_super(struct super_block *sb)
 {
 	struct jffs_control *c = (struct jffs_control *)sb->u.generic_sbp;
-
+	
 	jffs_garbage_collect_trigger(c);
 }
 
-
 static struct super_operations jffs_ops =
 {
 	read_inode:   jffs_read_inode,
@@ -1720,8 +1738,16 @@
 init_jffs_fs(void)
 {
 	printk("JFFS version "
-	       JFFS_VERSION_STRING
-	       ", (C) 1999, 2000  Axis Communications AB\n");
+		JFFS_VERSION_STRING
+		", (C) 1999, 2000  Axis Communications AB\n");
+	
+#ifdef CONFIG_JFFS_PROC_FS
+	jffs_proc_root = proc_mkdir("jffs", proc_root_fs);
+#endif
+	fm_cache = kmem_cache_create("jffs_fm", sizeof(struct jffs_fm),
+				     0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	node_cache = kmem_cache_create("jffs_node",sizeof(struct jffs_node),
+				       0, SLAB_HWCACHE_ALIGN, NULL, NULL);
 	return register_filesystem(&jffs_fs_type);
 }
 
@@ -1729,9 +1755,11 @@
 exit_jffs_fs(void)
 {
 	unregister_filesystem(&jffs_fs_type);
+	kmem_cache_destroy(fm_cache);
+	kmem_cache_destroy(node_cache);
 }
 
 EXPORT_NO_SYMBOLS;
 
-module_init(init_jffs_fs)
-module_exit(exit_jffs_fs)
+module_init(init_jffs_fs);
+module_exit(exit_jffs_fs);
diff -Naur linux-2.4.2.orig/fs/jffs/intrep.c linux-2.4.2/fs/jffs/intrep.c
--- linux-2.4.2.orig/fs/jffs/intrep.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/intrep.c	Thu Jan 10 18:30:48 2002
@@ -10,8 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * - Based on Id: intrep.c,v 1.71 2000/10/27 16:51:29 dwmw2 Exp
- * - With the ctype() changes from v1.77.
+ * $Id: intrep.c,v 1.93 2001/01/29 11:29:37 smunton Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -58,7 +57,7 @@
 
 #define __NO_VERSION__
 #include <linux/types.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/jffs.h>
 #include <linux/fs.h>
 #include <linux/stat.h>
@@ -74,9 +73,9 @@
 #include "intrep.h"
 #include "jffs_fm.h"
 
-#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
-long no_jffs_file = 0;
 long no_jffs_node = 0;
+long no_jffs_file = 0;
+#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
 long no_jffs_control = 0;
 long no_jffs_raw_inode = 0;
 long no_jffs_node_ref = 0;
@@ -150,7 +149,7 @@
 	int res;
 
 	D3(printk(KERN_NOTICE "flash_safe_read(%p, %08x, %p, %08x)\n",
-		  mtd, from, buf, count));
+		  mtd, (unsigned int) from, buf, count));
 
 	res = MTD_READ(mtd, from, count, &retlen, buf);
 	if (retlen != count) {
@@ -201,6 +200,9 @@
 	size_t retlen;
 	int res;
 
+	D3(printk(KERN_NOTICE "flash_safe_write(%p, %08x, %p, %08x)\n",
+		  mtd, (unsigned int) to, buf, count));
+
 	res = MTD_WRITE(mtd, to, count, &retlen, buf);
 	if (retlen != count) {
 		printk("Didn't write all bytes in flash_safe_write(). Returned %d\n", res);
@@ -210,23 +212,62 @@
 
 
 static int
+flash_safe_writev(struct mtd_info *mtd, const struct iovec *vecs,
+			unsigned long iovec_cnt, loff_t to)
+{
+	size_t retlen, retlen_a;
+	int i;
+	int res;
+
+	D3(printk(KERN_NOTICE "flash_safe_writev(%p, %08x, %p)\n",
+		  mtd, (unsigned int) to, vecs));
+	
+	if (mtd->writev) {
+		res = MTD_WRITEV(mtd, vecs, iovec_cnt, to, &retlen);
+		return res ? res : retlen;
+	}
+	/* Not implemented writev. Repeatedly use write - on the not so
+	   unreasonable assumption that the mtd driver doesn't care how
+	   many write cycles we use. */
+	res=0;
+	retlen=0;
+
+	for (i=0; !res && i<iovec_cnt; i++) {
+		res = MTD_WRITE(mtd, to, vecs[i].iov_len, &retlen_a, vecs[i].iov_base);
+		if (retlen_a != vecs[i].iov_len) {
+			printk("Didn't write all bytes in flash_safe_writev(). Returned %d\n", res);
+			if (i != iovec_cnt-1)
+				return -EIO;
+		}
+		/* If res is non-zero, retlen_a is undefined, but we don't
+		   care because in that case it's not going to be 
+		   returned anyway.
+		*/
+		to += retlen_a;
+		retlen += retlen_a;
+	}
+	return res?res:retlen;
+}
+
+
+static int
 flash_memset(struct mtd_info *mtd, loff_t to,
 	     const u_char c, size_t size)
 {
-	static unsigned char pattern[16];
+	static unsigned char pattern[64];
 	int i;
 
 	/* fill up pattern */
 
-	for(i = 0; i < 16; i++)
+	for(i = 0; i < 64; i++)
 		pattern[i] = c;
 
-	/* write as many 16-byte chunks as we can */
+	/* write as many 64-byte chunks as we can */
 
-	while (size >= 16) {
-		flash_safe_write(mtd, to, pattern, 16);
-		size -= 16;
-		to += 16;
+	while (size >= 64) {
+		flash_safe_write(mtd, to, pattern, 64);
+		size -= 64;
+		to += 64;
 	}
 
 	/* and the rest */
@@ -383,7 +424,7 @@
 		D(printk("jffs_create_file(): Failed!\n"));
 		return 0;
 	}
-	DJM(no_jffs_file++);
+	no_jffs_file++;
 	memset(f, 0, sizeof(struct jffs_file));
 	f->ino = raw_inode->ino;
 	f->pino = raw_inode->pino;
@@ -487,11 +528,10 @@
 						 GFP_KERNEL))) {
 		return -ENOMEM;
 	}
-	DJM(no_jffs_file++);
-	if (!(node = (struct jffs_node *)kmalloc(sizeof(struct jffs_node),
-						 GFP_KERNEL))) {
+	no_jffs_file++;
+	if (!(node = jffs_alloc_node())) {
 		kfree(root);
-		DJM(no_jffs_file--);
+		no_jffs_file--;
 		return -ENOMEM;
 	}
 	DJM(no_jffs_node++);
@@ -593,9 +633,9 @@
 	__u8 tmp_accurate;
 	__u16 tmp_chksum;
 	__u32 deleted_file;
-	loff_t pos = fmc->flash_start;
+	loff_t pos = 0;
 	loff_t start;
-	loff_t end = fmc->flash_start + fmc->flash_size;
+	loff_t end = fmc->flash_size;
 	__u8 *read_buf;
 	int i, len, retlen;
 
@@ -655,10 +695,10 @@
 				   (or from start) 
 				*/
 				if (start < (pos & ~(fmc->sector_size-1))) {
-					D1(printk("Reducing start to 0x%x from 0x%x\n", pos & ~(fmc->sector_size-1), start));
+					D1(printk("Reducing start to 0x%x from 0x%x\n", (unsigned int) (pos & ~(fmc->sector_size-1)), (unsigned int) start));
 					start = pos & ~(fmc->sector_size-1);
 				}
-				D1(printk("Dirty space: 0x%x for 0x%x bytes\n", start, (pos - start)));
+				D1(printk("Dirty space: 0x%x for 0x%x bytes\n", (unsigned int) start, (unsigned int) (pos - start)));
 				jffs_fmalloced(fmc, (__u32) start,
 					       (__u32) (pos - start), 0);
 			}
@@ -750,9 +790,7 @@
 		/* We have found the beginning of an inode.  Create a
 		   node for it unless there already is one available.  */
 		if (!node) {
-			if (!(node = (struct jffs_node *)
-				     kmalloc(sizeof(struct jffs_node),
-					     GFP_KERNEL))) {
+			if (!(node = jffs_alloc_node())) {
 				/* Free read buffer */
 				kfree (read_buf);
 
@@ -901,7 +939,7 @@
 						  node);
 			if (!node->fm) {
 				D(printk("jffs_scan_flash(): !node->fm\n"));
-				kfree(node);
+				jffs_free_node(node);
 				DJM(no_jffs_node--);
 
 				/* Free read buffer */
@@ -925,7 +963,7 @@
 					  GFP_KERNEL);
 				if (!dl) {
 					D(printk("jffs_scan_flash: !dl\n"));
-					kfree(node);
+					jffs_free_node(node);
 					DJM(no_jffs_node--);
 
 					/* Release the flash device */
@@ -954,7 +992,7 @@
 	}
 
 	if (node) {
-		kfree(node);
+		jffs_free_node(node);
 		DJM(no_jffs_node--);
 	}
 	jffs_build_end(fmc);
@@ -1018,12 +1056,11 @@
 		f->atime = raw_inode->atime;
 		f->mtime = raw_inode->mtime;
 		f->ctime = raw_inode->ctime;
-		f->deleted = raw_inode->deleted;
 	}
 	else if ((f->highest_version < node->version)
 		 || (node->version == 0)) {
 		/* Insert at the end of the list.  I.e. this node is the
-		   oldest one so far.  */
+		   newest one so far.  */
 		node->version_prev = f->version_tail;
 		node->version_next = 0;
 		f->version_tail->version_next = node;
@@ -1037,7 +1074,6 @@
 		f->atime = raw_inode->atime;
 		f->mtime = raw_inode->mtime;
 		f->ctime = raw_inode->ctime;
-		f->deleted = raw_inode->deleted;
 	}
 	else if (f->version_head->version > node->version) {
 		/* Insert at the bottom of the list.  */
@@ -1048,9 +1084,6 @@
 		if (!f->name) {
 			update_name = 1;
 		}
-		if (raw_inode->deleted) {
-			f->deleted = raw_inode->deleted;
-		}
 	}
 	else {
 		struct jffs_node *n;
@@ -1074,6 +1107,11 @@
 		}
 	}
 
+	/* Deletion is irreversible. If any 'deleted' node is ever
+	   written, the file is deleted */
+	if (raw_inode->deleted)
+		f->deleted = raw_inode->deleted;
+
 	/* Perhaps update the name.  */
 	if (raw_inode->nsize && update_name && name && *name && (name != f->name)) {
 		if (f->name) {
@@ -1098,16 +1136,15 @@
 		if (insert_into_tree) {
 			jffs_insert_file_into_tree(f);
 		}
-		if (f->deleted) {
-			/* Mark all versions of the node as obsolete.  */
-			jffs_possibly_delete_file(f);
-		}
-		else {
-			if (node->data_size || node->removed_size) {
-				jffs_update_file(f, node);
-			}
-			jffs_remove_redundant_nodes(f);
+		/* Once upon a time, we would call jffs_possibly_delete_file()
+		   here. That causes an oops if someone's still got the file
+		   open, so now we only do it in jffs_delete_inode()
+		   -- dwmw2
+		*/
+		if (node->data_size || node->removed_size) {
+			jffs_update_file(f, node);
 		}
+		jffs_remove_redundant_nodes(f);
 
 		jffs_garbage_collect_trigger(c);
 
@@ -1216,7 +1253,7 @@
 				  mod_type));
 			jffs_unlink_node_from_version_list(f, cur);
 			jffs_fmfree(f->c->fmc, cur->fm, cur);
-			kfree(cur);
+			jffs_free_node(cur);
 			DJM(no_jffs_node--);
 		}
 		else {
@@ -1346,7 +1383,7 @@
 	D3(printk("jffs_find_child()\n"));
 
 	for (f = dir->children; f; f = f->sibling_next) {
-		if (f->name
+		if (!f->deleted && f->name
 		    && !strncmp(f->name, name, len)
 		    && f->name[len] == '\0') {
 			break;
@@ -1436,7 +1473,10 @@
 		struct jffs_file *f)
 {
 	struct jffs_fmcontrol *fmc = c->fmc;
-	struct jffs_fm *fm = NULL;
+	struct jffs_fm *fm;
+	struct iovec node_iovec[4];
+	unsigned long iovec_cnt;
+
 	__u32 pos;
 	int err;
 	__u32 slack = 0;
@@ -1475,6 +1515,9 @@
 
 	jffs_fm_write_lock(fmc);
 
+retry:
+	fm = NULL;
+	err = 0;
 	while (!fm) {
 
 		/* Deadlocks suck. */
@@ -1544,6 +1587,10 @@
 	if (f) {
 		raw_inode->version = f->highest_version + 1;
 		D1(printk (KERN_NOTICE "jffs_write_node(): setting version of %s to %d\n", f->name, raw_inode->version));
+
+		/* if the file was deleted, set the deleted bit in the raw inode */
+		if (f->deleted)
+			raw_inode->deleted = 1;
 	}
 
 	/* Compute the checksum for the data and name chunks.  */
@@ -1562,44 +1609,48 @@
 		  "flash at pos 0x%lx:\n", (long)pos));
 	D3(jffs_print_raw_inode(raw_inode));
 
-	/* Step 1: Write the raw jffs inode to the flash.  */
-	if ((err = flash_safe_write(fmc->mtd, pos,
-				    (u_char *)raw_inode,
-				    sizeof(struct jffs_raw_inode))) < 0) {
-		jffs_fmfree_partly(fmc, fm,
-				   total_name_size + total_data_size);
-		jffs_fm_write_unlock(fmc);
-		printk(KERN_ERR "JFFS: jffs_write_node: Failed to write "
-		       "raw_inode.\n");
-		return err;
-	}
-	pos += sizeof(struct jffs_raw_inode);
+	/* The actual raw JFFS node */
+	node_iovec[0].iov_base = (void *) raw_inode;
+	node_iovec[0].iov_len = (size_t) sizeof(struct jffs_raw_inode);
+	iovec_cnt = 1;
 
-	/* Step 2: Write the name, if there is any.  */
+	/* Get name and size if there is one */
 	if (raw_inode->nsize) {
-		if ((err = flash_safe_write(fmc->mtd, pos,
-					    (u_char *)name,
-					    raw_inode->nsize)) < 0) {
-			jffs_fmfree_partly(fmc, fm, total_data_size);
-			jffs_fm_write_unlock(fmc);
-			printk(KERN_ERR "JFFS: jffs_write_node: Failed to "
-                              "write the name.\n");
-			return err;
+		node_iovec[iovec_cnt].iov_base = (void *) name;
+		node_iovec[iovec_cnt].iov_len = (size_t) raw_inode->nsize;
+		iovec_cnt++;
+
+		if (JFFS_GET_PAD_BYTES(raw_inode->nsize)) {
+			static char allff[3]={255,255,255};
+			/* Add some extra padding if necessary */
+			node_iovec[iovec_cnt].iov_base = allff;
+			node_iovec[iovec_cnt].iov_len =
+				JFFS_GET_PAD_BYTES(raw_inode->nsize);
+			iovec_cnt++;
 		}
-		pos += total_name_size;
 	}
 
-	/* Step 3: Append the actual data, if any.  */
+	/* Get data and size if there is any */
 	if (raw_inode->dsize) {
-		if ((err = flash_safe_write(fmc->mtd, pos, data,
-					    raw_inode->dsize)) < 0) {
-			jffs_fmfree_partly(fmc, fm, 0);
-			jffs_fm_write_unlock(fmc);
-			printk(KERN_ERR "JFFS: jffs_write_node: Failed to "
-			       "write the data.\n");
-			return err;
-		}
+		node_iovec[iovec_cnt].iov_base = (void *) data;
+		node_iovec[iovec_cnt].iov_len = (size_t) raw_inode->dsize;
+		iovec_cnt++;
+		/* No need to pad this because we're not actually putting
+		   anything after it.
+		*/
+	}
+
+	if ((err = flash_safe_writev(fmc->mtd, node_iovec, iovec_cnt,
+				    pos) < 0)) {
+		jffs_fmfree_partly(fmc, fm, 0);
+		jffs_fm_write_unlock(fmc);
+		printk(KERN_ERR "JFFS: jffs_write_node: Failed to write, "
+		       "requested %i, wrote %i\n", total_size, err);
+		goto retry;
 	}
+	if (raw_inode->deleted)
+		f->deleted = 1;
+
 	jffs_fm_write_unlock(fmc);
 	D3(printk("jffs_write_node(): Leaving...\n"));
 	return raw_inode->dsize;
@@ -1735,7 +1786,7 @@
 	while (node) {
 		p = node;
 		node = node->version_next;
-		kfree(p);
+		jffs_free_node(p);
 		DJM(no_jffs_node--);
 	}
 	return 0;
@@ -1754,10 +1805,15 @@
 		DJM(no_name--);
 	}
 	kfree(f);
-	DJM(no_jffs_file--);
+	no_jffs_file--;
 	return 0;
 }
 
+long
+jffs_get_file_count(void)
+{
+	return no_jffs_file;
+}
 
 /* See if a file is deleted. If so, mark that file's nodes as obsolete.  */
 int
@@ -1871,9 +1927,7 @@
 			D3(printk("jffs_delete_data(): Split node with "
 				  "version number %u.\n", n->version));
 
-			if (!(new_node = (struct jffs_node *)
-					 kmalloc(sizeof(struct jffs_node),
-						 GFP_KERNEL))) {
+			if (!(new_node = jffs_alloc_node())) {
 				D(printk("jffs_delete_data(): -ENOMEM\n"));
 				return -ENOMEM;
 			}
@@ -1942,7 +1996,7 @@
 			}
 			jffs_unlink_node_from_range_list(f, p);
 			jffs_unlink_node_from_version_list(f, p);
-			kfree(p);
+			jffs_free_node(p);
 			DJM(no_jffs_node--);
 		}
 		else {
@@ -2058,9 +2112,7 @@
 		   front of this insertion.  This "virtual node" will not
 		   be associated with any space on the flash device.  */
 		struct jffs_node *virtual_node;
-		if (!(virtual_node = (struct jffs_node *)
-				     kmalloc(sizeof(struct jffs_node),
-					     GFP_KERNEL))) {
+		if (!(virtual_node = jffs_alloc_node())) {
 			return -ENOMEM;
 		}
 
@@ -2358,8 +2410,7 @@
 		  f->ino, (f->name ? f->name : "(null)"), size));
 
 	/* Create and initialize the new node.  */
-	if (!(new_node = (struct jffs_node *)
-			 kmalloc(sizeof(struct jffs_node), GFP_KERNEL))) {
+	if (!(new_node = jffs_alloc_node())) {
 		D(printk("jffs_rewrite_data(): "
 			 "Failed to allocate node.\n"));
 		return -ENOMEM;
@@ -2374,13 +2425,15 @@
 	new_node->fm_offset = sizeof(struct jffs_raw_inode)
 			      + total_name_size;
 
+retry:
 	jffs_fm_write_lock(fmc);
+	err = 0;
 
 	if ((err = jffs_fmalloc(fmc, total_size, new_node, &fm)) < 0) {
 		DJM(no_jffs_node--);
 		jffs_fm_write_unlock(fmc);
 		D(printk("jffs_rewrite_data(): Failed to allocate fm.\n"));
-		kfree(new_node);
+		jffs_free_node(new_node);
 		return err;
 	}
 	else if (!fm->nodes) {
@@ -2420,7 +2473,7 @@
 	raw_inode.nlink = f->nlink;
 	raw_inode.spare = 0;
 	raw_inode.rename = 0;
-	raw_inode.deleted = 0;
+	raw_inode.deleted = f->deleted;
 	raw_inode.accurate = 0xff;
 	raw_inode.dchksum = 0;
 	raw_inode.nchksum = 0;
@@ -2441,23 +2494,27 @@
 				   total_name_size + total_data_size);
 		jffs_fm_write_unlock(fmc);
 		printk(KERN_ERR "JFFS: jffs_rewrite_data: Write error during "
-		       "rewrite. (raw inode)\n");
-		return err;
+			"rewrite. (raw inode)\n");
+		printk(KERN_ERR "JFFS: jffs_rewrite_data: Now retrying "
+			"rewrite. (raw inode)\n");
+		goto retry;
 	}
 	pos += sizeof(struct jffs_raw_inode);
 
 	/* Write the name to the flash memory.  */
 	if (f->nsize) {
 		D3(printk("jffs_rewrite_data(): Writing name \"%s\" to "
-			  "pos 0x%ul.\n", f->name, (long)pos));
+			  "pos 0x%ul.\n", f->name, (unsigned int) pos));
 		if ((err = flash_safe_write(fmc->mtd, pos,
 					    (u_char *)f->name,
 					    f->nsize)) < 0) {
 			jffs_fmfree_partly(fmc, fm, total_data_size);
 			jffs_fm_write_unlock(fmc);
 			printk(KERN_ERR "JFFS: jffs_rewrite_data: Write "
-			       "error during rewrite. (name)\n");
-			return err;
+				"error during rewrite. (name)\n");
+			printk(KERN_ERR "JFFS: jffs_rewrite_data: Now retrying "
+				"rewrite. (name)\n");
+			goto retry;
 		}
 		pos += total_name_size;
 		raw_inode.nchksum = jffs_checksum(f->name, f->nsize);
@@ -2494,7 +2551,7 @@
 				printk(KERN_ERR "JFFS: jffs_rewrite_data: "
 				       "Write error during rewrite. "
 				       "(data)\n");
-				return err;
+				goto retry;
 			}
 			pos += r;
 			size -= r;
@@ -2521,7 +2578,7 @@
 		jffs_fm_write_unlock(fmc);
 		printk(KERN_ERR "JFFS: jffs_rewrite_data: Write error during "
 		       "rewrite. (checksum)\n");
-		return err;
+		goto retry;
 	}
 
 	/* Now make the file system aware of the newly written node.  */
@@ -2671,8 +2728,8 @@
 	    sizeof(struct jffs_raw_inode) + extra_available) {
 		D1(printk("Reducing size of new node from %d to %ld to avoid "
 		       "catching our tail\n", size, 
-			  JFFS_PAD(node->data_size) + JFFS_PAD(node->name_size) + 
-			  sizeof(struct jffs_raw_inode) + extra_available));
+			  (long) (JFFS_PAD(node->data_size) + JFFS_PAD(node->name_size) + 
+			  sizeof(struct jffs_raw_inode) + extra_available)));
 		D1(printk("space_needed = %d, extra_available = %d\n", 
 			  space_needed, extra_available));
 
@@ -2804,7 +2861,7 @@
 		return err;
 	}
 
-	offset = fmc->head->offset - fmc->flash_start;
+	offset = fmc->head->offset;
 
 	/* Now, let's try to do the erase.  */
 	if ((err = flash_erase_region(fmc->mtd,
@@ -2962,17 +3019,31 @@
 		   c->fmc->free_size, c->fmc->dirty_size, c->fmc->sector_size));
 
 	/* If there's not enough dirty space to free a block, there's no point. */
-	if (c->fmc->dirty_size < c->fmc->sector_size)
+	if (c->fmc->dirty_size < c->fmc->sector_size) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Not waking. Insufficient dirty space\n"));
 		return 0;
-
+	}
+#if 1
+	/* If there is too much RAM used by the various structures, GC */
+	if (jffs_get_node_inuse() > (c->fmc->used_size/c->fmc->max_chunk_size * 5 + jffs_get_file_count() * 2 + 50)) {
+		/* FIXME: Provide proof that this test can be satisfied. We
+		   don't want a filesystem doing endless GC just because this
+		   condition cannot ever be false.
+		*/
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to number of nodes\n"));
+		return 1;
+	}
+#endif
 	/* If there are fewer free bytes than the threshold, GC */
-	if (c->fmc->dirty_size < c->gc_minfree_threshold)
+	if (c->fmc->free_size < c->gc_minfree_threshold) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to insufficent free space\n"));
 		return 1;
-
+	}
 	/* If there are more dirty bytes than the threshold, GC */
-	if (c->fmc->dirty_size > c->gc_maxdirty_threshold)
+	if (c->fmc->dirty_size > c->gc_maxdirty_threshold) {
+		D2(printk(KERN_NOTICE "thread_should_wake(): Waking due to excessive dirty space\n"));
 		return 1;
-	
+	}	
 	/* FIXME: What about the "There are many versions of a node" condition? */
 
 	return 0;
@@ -3054,18 +3125,14 @@
 			case SIGKILL:
 				D1(printk("jffs_garbage_collect_thread(): SIGKILL received.\n"));
 				c->gc_task = NULL;
+				up(&c->gc_thread_sem);
 				unlock_kernel();
-				up_and_exit(&c->gc_thread_sem, 0);
+				return(0);
 			}
 		}
 
 
 		D1(printk (KERN_NOTICE "jffs_garbage_collect_thread(): collecting.\n"));
-
-		if (fmc->dirty_size < fmc->sector_size) {
-			D1(printk(KERN_WARNING "jffs_garbage_collect_thread with insufficient dirty space (0x%x)\n", fmc->dirty_size));
-			continue;
-		}
 
 		D3(printk (KERN_NOTICE "g_c_thread(): down biglock\n"));
 		down(&fmc->biglock);
diff -Naur linux-2.4.2.orig/fs/jffs/intrep.h linux-2.4.2/fs/jffs/intrep.h
--- linux-2.4.2.orig/fs/jffs/intrep.h	Mon Dec 11 22:26:54 2000
+++ linux-2.4.2/fs/jffs/intrep.h	Thu Jan 10 18:30:48 2002
@@ -10,13 +10,18 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: intrep.h,v 1.11 2000/08/17 22:46:46 bmatthews Exp $
+ * $Id: intrep.h,v 1.13 2001/01/26 12:29:30 smunton Exp $
  *
  */
 
 #ifndef __LINUX_JFFS_INTREP_H__
 #define __LINUX_JFFS_INTREP_H__
 #include "jffs_fm.h"
+struct jffs_node *jffs_alloc_node(void);
+void jffs_free_node(struct jffs_node *n);
+int jffs_get_node_inuse(void);
+long jffs_get_file_count(void);
+
 inline int jffs_min(int a, int b);
 inline int jffs_max(int a, int b);
 __u32 jffs_checksum(const void *data, int size);
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_fm.c linux-2.4.2/fs/jffs/jffs_fm.c
--- linux-2.4.2.orig/fs/jffs/jffs_fm.c	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/fs/jffs/jffs_fm.c	Thu Jan 10 18:30:48 2002
@@ -10,14 +10,14 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs_fm.c,v 1.18 2000/08/21 10:41:45 dwmw2 Exp $
+ * $Id: jffs_fm.c,v 1.23 2001/02/21 09:19:51 dwmw2 Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
  *
  */
 #define __NO_VERSION__
-#include <linux/slab.h>
+#include <linux/malloc.h>
 #include <linux/blkdev.h>
 #include <linux/jffs.h>
 #include "jffs_fm.h"
@@ -26,6 +26,8 @@
 static int jffs_mark_obsolete(struct jffs_fmcontrol *fmc, __u32 fm_offset);
 #endif
 
+extern kmem_cache_t     *fm_cache;
+extern kmem_cache_t     *node_cache;
 
 /* This function creates a new shiny flash memory control structure.  */
 struct jffs_fmcontrol *
@@ -50,9 +52,7 @@
 		return NULL;
 	
 	/* Retrieve the size of the flash memory.  */
-	fmc->flash_start = 0;
 	fmc->flash_size = mtd->size;
-	D3(printk("  fmc->flash_start = 0x%08x\n", fmc->flash_start));
 	D3(printk("  fmc->flash_size = %d bytes\n", fmc->flash_size));
 
 	fmc->used_size = 0;
@@ -68,8 +68,11 @@
 		   to write out larger nodes than the ones it's obsoleting.
 		   We should fix it so it doesn't have to write the name
 		   _every_ time. Later.
+	   + another 2 sectors because people keep getting GC stuck and
+	           we don't know why. This scares me - I want formal proof
+		   of correctness of whatever number we put here. dwmw2.
 	*/
-	fmc->min_free_size = fmc->sector_size << 1;
+	fmc->min_free_size = fmc->sector_size << 2;
 	fmc->mtd = mtd;
 	fmc->c = c;
 	fmc->head = 0;
@@ -114,8 +117,7 @@
 
 		while ((cur = next)) {
 			next = next->next;
-			kfree(cur);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(cur);
 		}
 		put_mtd_device(fmc->mtd);
 		kfree(fmc);
@@ -132,7 +134,7 @@
 {
 	__u32 head;
 	__u32 tail;
-	__u32 end = fmc->flash_start + fmc->flash_size;
+	__u32 end = fmc->flash_size;
 
 	if (!fmc->head) {
 		/* There is nothing on the flash.  */
@@ -143,11 +145,11 @@
 	head = fmc->head->offset;
 	tail = fmc->tail->offset + fmc->tail->size;
 	if (tail == end) {
-		tail = fmc->flash_start;
+		tail = 0;
 	}
 	ASSERT(else if (tail > end) {
 		printk(KERN_WARNING "jffs_free_size1(): tail > end\n");
-		tail = fmc->flash_start;
+		tail = 0;
 	});
 
 	if (head <= tail) {
@@ -175,12 +177,12 @@
 	if (fmc->head) {
 		__u32 head = fmc->head->offset;
 		__u32 tail = fmc->tail->offset + fmc->tail->size;
-		if (tail == fmc->flash_start + fmc->flash_size) {
-			tail = fmc->flash_start;
+		if (tail == fmc->flash_size) {
+			tail = 0;
 		}
 
 		if (tail >= head) {
-			return head - fmc->flash_start;
+			return head;
 		}
 	}
 	return 0;
@@ -203,12 +205,10 @@
 
 	*result = 0;
 
-	if (!(fm = (struct jffs_fm*)kmalloc(sizeof(struct jffs_fm),
-					    GFP_KERNEL))) {
+	if (!(fm = jffs_alloc_fm())) {
 		D(printk("jffs_fmalloc(): kmalloc() failed! (fm)\n"));
 		return -ENOMEM;
 	}
-	DJM(no_jffs_fm++);
 
 	free_chunk_size1 = jffs_free_size1(fmc);
 	free_chunk_size2 = jffs_free_size2(fmc);
@@ -227,8 +227,7 @@
 					  GFP_KERNEL))) {
 			D(printk("jffs_fmalloc(): kmalloc() failed! "
 				 "(node_ref)\n"));
-			kfree(fm);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(fm);
 			return -ENOMEM;
 		}
 		DJM(no_jffs_node_ref++);
@@ -236,22 +235,19 @@
 		fm->nodes->next = 0;
 		if (fmc->tail) {
 			fm->offset = fmc->tail->offset + fmc->tail->size;
-			if (fm->offset
-			    == fmc->flash_start + fmc->flash_size) {
-				fm->offset = fmc->flash_start;
+			if (fm->offset == fmc->flash_size) {
+				fm->offset = 0;
 			}
-			ASSERT(else if (fm->offset
-					> fmc->flash_start
-					  + fmc->flash_size) {
+			ASSERT(else if (fm->offset > fmc->flash_size) {
 				printk(KERN_WARNING "jffs_fmalloc(): "
 				       "offset > flash_end\n");
-				fm->offset = fmc->flash_start;
+				fm->offset = 0;
 			});
 		}
 		else {
 			/* There don't have to be files in the file
 			   system yet.  */
-			fm->offset = fmc->flash_start;
+			fm->offset = 0;
 		}
 		fm->size = size;
 		fmc->free_size -= size;
@@ -260,8 +256,7 @@
 	else if (size > free_chunk_size2) {
 		printk(KERN_WARNING "JFFS: Tried to allocate a too "
 		       "large flash memory chunk. (size = %u)\n", size);
-		kfree(fm);
-		DJM(no_jffs_fm--);
+		jffs_free_fm(fm);
 		return -ENOSPC;
 	}
 	else {
@@ -369,13 +364,11 @@
 
 	D3(printk("jffs_fmalloced()\n"));
 
-	if (!(fm = (struct jffs_fm *)kmalloc(sizeof(struct jffs_fm),
-					     GFP_KERNEL))) {
+	if (!(fm = jffs_alloc_fm())) {
 		D(printk("jffs_fmalloced(0x%p, %u, %u, 0x%p): failed!\n",
 			 fmc, offset, size, node));
 		return 0;
 	}
-	DJM(no_jffs_fm++);
 	fm->offset = offset;
 	fm->size = size;
 	fm->prev = 0;
@@ -388,8 +381,7 @@
 				  kmalloc(sizeof(struct jffs_node_ref),
 					  GFP_KERNEL))) {
 			D(printk("jffs_fmalloced(): !fm->nodes\n"));
-			kfree(fm);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(fm);
 			return 0;
 		}
 		DJM(no_jffs_node_ref++);
@@ -466,6 +458,7 @@
 	fmc->used_size -= fm->size;
 	if (fm == fmc->tail) {
 		fm->size -= size;
+		fmc->free_size += size;
 	}
 	fmc->dirty_size += fm->size;
 }
@@ -532,8 +525,7 @@
 			fm = fm->next;
 			fm->prev = 0;
 			fmc->head = fm;
-			kfree(del);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(del);
 		}
 		else {
 			fm->size -= erased_size;
@@ -661,7 +653,7 @@
 
 	/* Calculate how much space that is dirty.  */
 	for (fm = fmc->head; fm && !fm->nodes; fm = fm->next) {
-		if (size && fm->offset == fmc->flash_start) {
+		if (size && fm->offset == 0) {
 			/* We have reached the beginning of the flash.  */
 			break;
 		}
@@ -671,14 +663,13 @@
 	/* Someone's signature contained this:
 	   There's a fine line between fishing and just standing on
 	   the shore like an idiot...  */
-	ret = jffs_flash_erasable_size(fmc->mtd,
-				       fmc->head->offset - fmc->flash_start, size);
+	ret = jffs_flash_erasable_size(fmc->mtd, fmc->head->offset, size);
 
 	ASSERT(if (ret < 0) {
 		printk("jffs_erasable_size: flash_erasable_size() "
 		       "returned something less than zero (%ld).\n", ret);
 		printk("jffs_erasable_size: offset = 0x%08x\n",
-		       fmc->head->offset - fmc->flash_start);
+		       fmc->head->offset);
 	});
 
 	/* If there is dirt on the flash (which is the reason to why
@@ -702,21 +693,58 @@
 			if (del->next) {
 				del->next->prev = head;
 			}
-			kfree(del);
-			DJM(no_jffs_fm--);
+			jffs_free_fm(del);
 		}
 	}
 
 	return (ret >= 0 ? ret : 0);
 }
 
+struct jffs_fm *jffs_alloc_fm(void)
+{
+	struct jffs_fm *fm;
+
+	fm = kmem_cache_alloc(fm_cache,GFP_KERNEL);
+	DJM(if (fm) no_jffs_fm++;);
+	
+	return fm;
+}
+
+void jffs_free_fm(struct jffs_fm *n)
+{
+	kmem_cache_free(fm_cache,n);
+	DJM(no_jffs_fm--);
+}
+
+
+
+struct jffs_node *jffs_alloc_node(void)
+{
+	struct jffs_node *n;
+
+	n = (struct jffs_node *)kmem_cache_alloc(node_cache,GFP_KERNEL);
+	if(n != NULL)
+		no_jffs_node++;
+	return n;
+}
+
+void jffs_free_node(struct jffs_node *n)
+{
+	kmem_cache_free(node_cache,n);
+	no_jffs_node--;
+}
+
+
+int jffs_get_node_inuse(void)
+{
+	return no_jffs_node;
+}
 
 void
 jffs_print_fmcontrol(struct jffs_fmcontrol *fmc)
 {
 	D(printk("struct jffs_fmcontrol: 0x%p\n", fmc));
 	D(printk("{\n"));
-	D(printk("        0x%08x, /* flash_start  */\n", fmc->flash_start));
 	D(printk("        %u, /* flash_size  */\n", fmc->flash_size));
 	D(printk("        %u, /* used_size  */\n", fmc->used_size));
 	D(printk("        %u, /* dirty_size  */\n", fmc->dirty_size));
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_fm.h linux-2.4.2/fs/jffs/jffs_fm.h
--- linux-2.4.2.orig/fs/jffs/jffs_fm.h	Mon Dec 11 22:26:54 2000
+++ linux-2.4.2/fs/jffs/jffs_fm.h	Thu Jan 10 18:30:48 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs_fm.h,v 1.10 2000/08/17 15:42:44 dwmw2 Exp $
+ * $Id: jffs_fm.h,v 1.13 2001/01/11 12:03:25 dwmw2 Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -59,10 +59,15 @@
 
 /* How many padding bytes should be inserted between two chunks of data
    on the flash?  */
-#define JFFS_GET_PAD_BYTES(size) ((JFFS_ALIGN_SIZE                     \
-				  - ((__u32)(size) % JFFS_ALIGN_SIZE)) \
-				  % JFFS_ALIGN_SIZE)
+#define JFFS_GET_PAD_BYTES(size) ( (JFFS_ALIGN_SIZE-1) & -(__u32)(size) )
 #define JFFS_PAD(size) ( (size + (JFFS_ALIGN_SIZE-1)) & ~(JFFS_ALIGN_SIZE-1) )
+
+
+
+void jffs_free_fm(struct jffs_fm *n);
+struct jffs_fm *jffs_alloc_fm(void);
+
+
 struct jffs_node_ref
 {
 	struct jffs_node *node;
@@ -82,7 +87,6 @@
 
 struct jffs_fmcontrol
 {
-	__u32 flash_start;
 	__u32 flash_size;
 	__u32 used_size;
 	__u32 dirty_size;
@@ -115,6 +119,7 @@
    the scan is completed, the two lists are merged together. The jffs_fm
    struct that head_extra references is the logical beginning of the
    flash memory so it will be referenced by the head member.  */
+
 
 
 struct jffs_fmcontrol *jffs_build_begin(struct jffs_control *c, kdev_t dev);
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_proc.c linux-2.4.2/fs/jffs/jffs_proc.c
--- linux-2.4.2.orig/fs/jffs/jffs_proc.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/jffs_proc.c	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,269 @@
+/*
+ * JFFS -- Journaling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 2000  Axis Communications AB.
+ *
+ * Created by Simon Kagstrom <simonk@axis.com>.
+ *
+ * $Id: jffs_proc.c,v 1.4 2001/01/11 12:03:25 dwmw2 Exp $
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  Overview:
+ *   This file defines JFFS partition entries in the proc file system.
+ *
+ *  TODO:
+ *   Create some more proc files for different kinds of info, i.e. statistics
+ *   about written and read bytes, number of calls to different routines,
+ *   reports about failures.
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/jffs.h>
+#include <linux/malloc.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include "jffs_fm.h"
+#include "jffs_proc.h"
+
+/*
+ * Structure for a JFFS partition in the system
+ */
+struct jffs_partition_dir {
+	struct jffs_control *c;
+	struct proc_dir_entry *part_root;
+	struct proc_dir_entry *part_info;
+	struct proc_dir_entry *part_layout;
+	struct jffs_partition_dir *next;
+};
+
+/*
+ * Structure for top-level entry in '/proc/fs' directory
+ */
+struct proc_dir_entry *jffs_proc_root;
+
+/*
+ * Linked list of 'jffs_partition_dirs' to help us track
+ * the mounted JFFS partitions in the system
+ */
+static struct jffs_partition_dir *jffs_part_dirs = 0;
+
+/*
+ * Read functions for entries
+ */
+static int jffs_proc_info_read(char *page, char **start, off_t off,
+		int count, int *eof, void *data);
+static int jffs_proc_layout_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data);
+
+
+/*
+ * Register a JFFS partition directory (called upon mount)
+ */
+int jffs_register_jffs_proc_dir(kdev_t dev, struct jffs_control *c)
+{
+	struct jffs_partition_dir *part_dir;
+	struct proc_dir_entry *part_info = 0;
+	struct proc_dir_entry *part_layout = 0;
+	struct proc_dir_entry *part_root = 0;
+
+	/* Allocate structure for local JFFS partition table */
+	if (!(part_dir = (struct jffs_partition_dir *)
+		kmalloc (sizeof (struct jffs_partition_dir), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	/* Create entry for this partition */
+	if ((part_root = create_proc_entry (kdevname(dev),
+		S_IFDIR | S_IRUGO | S_IXUGO, jffs_proc_root))) {
+		part_root->read_proc = jffs_proc_info_read;
+		part_root->data = (void *) c;
+	}
+	else {
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Create entry for 'info' file */
+	if ((part_info = create_proc_entry ("info", 0, part_root))) {
+		part_info->read_proc = jffs_proc_info_read;
+		part_info->data = (void *) c;
+	}
+	else {
+		remove_proc_entry (part_root->name, jffs_proc_root);
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Create entry for 'layout' file */
+	if ((part_layout = create_proc_entry ("layout", 0, part_root))) {
+		part_layout->read_proc = jffs_proc_layout_read;
+		part_layout->data = (void *) c;
+	}
+	else {
+		remove_proc_entry (part_info->name, part_root);
+		remove_proc_entry (part_root->name, jffs_proc_root);
+		kfree (part_dir);
+		return -ENOMEM;
+	}
+
+	/* Fill in structure for table and insert in the list */
+	part_dir->c = c;
+	part_dir->part_root = part_root;
+	part_dir->part_info = part_info;
+	part_dir->part_layout = part_layout;
+	part_dir->next = jffs_part_dirs;
+	jffs_part_dirs = part_dir;
+
+	/* Return happy */
+	return 0;
+}
+
+
+/*
+ * Unregister a JFFS partition directory (called at umount)
+ */
+int jffs_unregister_jffs_proc_dir(struct jffs_control *c)
+{
+	struct jffs_partition_dir *part_dir = jffs_part_dirs;
+	struct jffs_partition_dir *prev_part_dir = 0;
+
+	while (part_dir) {
+		if (part_dir->c == c) {
+			/* Remove entries for partition */
+			remove_proc_entry (part_dir->part_info->name,
+				part_dir->part_root);
+			remove_proc_entry (part_dir->part_layout->name,
+				part_dir->part_root);
+			remove_proc_entry (part_dir->part_root->name,
+				jffs_proc_root);
+
+			/* Remove entry from list */
+			if (prev_part_dir)
+				prev_part_dir->next = part_dir->next;
+			else
+				jffs_part_dirs = part_dir->next;
+
+			/*
+			 * Check to see if this is the last one
+			 * and remove the entry from '/proc/fs'
+			 * if it is.
+			 */
+			if (jffs_part_dirs == part_dir->next)
+#if LINUX_VERSION_CODE < 0x020300
+				remove_proc_entry ("jffs", &proc_root_fs);
+#else
+				remove_proc_entry ("jffs", proc_root_fs);
+#endif
+
+			/* Free memory for entry */
+			kfree(part_dir);
+
+			/* Return happy */
+			return 0;
+		}
+
+		/* Move to next entry */
+		prev_part_dir = part_dir;
+		part_dir = part_dir->next;
+	}
+
+	/* Return unhappy */
+	return -1;
+}
+
+
+/*
+ * Read a JFFS partition's `info' file
+ */
+static int jffs_proc_info_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	struct jffs_control *c = (struct jffs_control *) data;
+	int len = 0;
+
+	/* Get information on the parition */
+	len += sprintf (page,
+		"partition size:     %08lX (%u)\n"
+		"sector size:        %08lX (%u)\n"
+		"used size:          %08lX (%u)\n"
+		"dirty size:         %08lX (%u)\n"
+		"free size:          %08lX (%u)\n\n",
+		(unsigned long) c->fmc->flash_size, c->fmc->flash_size,
+		(unsigned long) c->fmc->sector_size, c->fmc->sector_size,
+		(unsigned long) c->fmc->used_size, c->fmc->used_size,
+		(unsigned long) c->fmc->dirty_size, c->fmc->dirty_size,
+		(unsigned long) (c->fmc->flash_size -
+			(c->fmc->used_size + c->fmc->dirty_size)),
+		c->fmc->flash_size - (c->fmc->used_size + c->fmc->dirty_size));
+
+	/* We're done */
+	*eof = 1;
+
+	/* Return length */
+	return len;
+}
+
+
+/*
+ * Read a JFFS partition's `layout' file
+ */
+static int jffs_proc_layout_read (char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	struct jffs_control *c = (struct jffs_control *) data;
+	struct jffs_fm *fm = 0;
+	struct jffs_fm *last_fm = 0;
+	int len = 0;
+
+	/* Get the first item in the list */
+ 	fm = c->fmc->head;
+
+	/* Print free space */
+	if (fm && fm->offset) {
+		len += sprintf (page, "00000000 %08lX free\n",
+			(unsigned long) fm->offset);
+	}
+
+	/* Loop through all of the flash control structures */
+	while (fm && (len < (off + count))) {
+		if (fm->nodes) {
+			len += sprintf (page + len,
+				"%08lX %08lX ino=%08lX, ver=%08lX\n",
+				(unsigned long) fm->offset,
+				(unsigned long) fm->size,
+				(unsigned long) fm->nodes->node->ino,
+				(unsigned long) fm->nodes->node->version);
+		}
+		else {
+			len += sprintf (page + len,
+				"%08lX %08lX dirty\n",
+				(unsigned long) fm->offset,
+				(unsigned long) fm->size);
+		}
+		last_fm = fm;
+		fm = fm->next;
+	}
+
+	/* Print free space */
+	if ((len < (off + count)) && last_fm
+	    && (last_fm->offset < c->fmc->flash_size)) {
+		len += sprintf (page + len,
+			       "%08lX %08lX free\n",
+			       (unsigned long) last_fm->offset + 
+				last_fm->size,
+			       (unsigned long) (c->fmc->flash_size -
+						    (last_fm->offset + last_fm->size)));
+	}
+
+	/* We're done */
+	*eof = 1;
+
+	/* Return length */
+	return len;
+}
diff -Naur linux-2.4.2.orig/fs/jffs/jffs_proc.h linux-2.4.2/fs/jffs/jffs_proc.h
--- linux-2.4.2.orig/fs/jffs/jffs_proc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/fs/jffs/jffs_proc.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,28 @@
+/*
+ * JFFS -- Journaling Flash File System, Linux implementation.
+ *
+ * Copyright (C) 2000  Axis Communications AB.
+ *
+ * Created by Simon Kagstrom <simonk@axis.com>.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * $Id: jffs_proc.h,v 1.2 2000/11/15 22:04:12 sjhill Exp $
+ */
+
+/* jffs_proc.h defines a structure for inclusion in the proc-file system.  */
+#ifndef __LINUX_JFFS_PROC_H__
+#define __LINUX_JFFS_PROC_H__
+
+#include <linux/proc_fs.h>
+
+/* The proc_dir_entry for jffs (defined in jffs_proc.c).  */
+extern struct proc_dir_entry *jffs_proc_root;
+
+int jffs_register_jffs_proc_dir(kdev_t dev, struct jffs_control *c);
+int jffs_unregister_jffs_proc_dir(struct jffs_control *c);
+
+#endif /* __LINUX_JFFS_PROC_H__ */
diff -Naur linux-2.4.2.orig/include/asm-ppc/8xx_rtc.h linux-2.4.2/include/asm-ppc/8xx_rtc.h
--- linux-2.4.2.orig/include/asm-ppc/8xx_rtc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/asm-ppc/8xx_rtc.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,30 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifdef __KERNEL__
+#ifndef __ASM_PPC_8XX_RTC_H
+#define __ASM_PPC_8XX_RTC_H
+
+#include <asm/io.h>
+
+#ifndef RTC_ALWAYS_BCD
+#define RTC_ALWAYS_BCD	0	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#define RTC_IRQ 9
+
+#endif /* __ASM_PPC_8XXRTC_H */
+#endif /* __KERNEL__ */
diff -Naur linux-2.4.2.orig/include/asm-ppc/bitops.h linux-2.4.2/include/asm-ppc/bitops.h
--- linux-2.4.2.orig/include/asm-ppc/bitops.h	Sun Nov 12 03:23:10 2000
+++ linux-2.4.2/include/asm-ppc/bitops.h	Thu Jan 10 18:30:48 2002
@@ -35,10 +35,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 	
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	or	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	or	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -68,10 +68,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	andc	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	andc	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -84,10 +84,10 @@
 	unsigned long mask = 1 << (nr & 0x1f);
 	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
 
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	xor	%0,%0,%2
-	stwcx.	%0,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	xor	%0,%0,%2\n\
+	stwcx.	%0,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=m" (*p)
 	: "r" (mask), "r" (p), "m" (*p)
@@ -104,9 +104,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	or	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	or	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
@@ -136,9 +136,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	andc	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	andc	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
@@ -168,9 +168,9 @@
 	volatile unsigned int *p = ((volatile unsigned int *)addr) + (nr >> 5);
 
 	__asm__ __volatile__(SMP_WMB "\
-1:	lwarx	%0,0,%4
-	xor	%1,%0,%3
-	stwcx.	%1,0,%4
+1:	lwarx	%0,0,%4\n\
+	xor	%1,%0,%3\n\
+	stwcx.	%1,0,%4\n\
 	bne	1b"
 	SMP_MB
 	: "=&r" (old), "=&r" (t), "=m" (*p)
diff -Naur linux-2.4.2.orig/include/asm-ppc/checksum.h linux-2.4.2/include/asm-ppc/checksum.h
--- linux-2.4.2.orig/include/asm-ppc/checksum.h	Sun Nov 12 03:23:10 2000
+++ linux-2.4.2/include/asm-ppc/checksum.h	Thu Jan 10 18:30:48 2002
@@ -83,11 +83,11 @@
 						   unsigned short proto,
 						   unsigned int sum) 
 {
-    __asm__("
-	addc %0,%0,%1
-	adde %0,%0,%2
-	adde %0,%0,%3
-	addze %0,%0
+    __asm__("\n\
+	addc %0,%0,%1\n\
+	adde %0,%0,%2\n\
+	adde %0,%0,%3\n\
+	addze %0,%0\n\
 	"
 	: "=r" (sum)
 	: "r" (daddr), "r"(saddr), "r"((proto<<16)+len), "0"(sum));
diff -Naur linux-2.4.2.orig/include/asm-ppc/pgtable.h linux-2.4.2/include/asm-ppc/pgtable.h
--- linux-2.4.2.orig/include/asm-ppc/pgtable.h	Tue Jan 23 00:41:15 2001
+++ linux-2.4.2/include/asm-ppc/pgtable.h	Thu Jan 10 18:30:48 2002
@@ -418,11 +418,11 @@
 {
 	unsigned long old, tmp;
 	
-	__asm__ __volatile__("\
-1:	lwarx	%0,0,%3
-	andc	%1,%0,%4
-	or	%1,%1,%5
-	stwcx.	%1,0,%3
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3\n\
+	andc	%1,%0,%4\n\
+	or	%1,%1,%5\n\
+	stwcx.	%1,0,%3\n\
 	bne-	1b"
 	: "=&r" (old), "=&r" (tmp), "=m" (*p)
 	: "r" (p), "r" (clr), "r" (set), "m" (*p)
diff -Naur linux-2.4.2.orig/include/asm-ppc/system.h linux-2.4.2/include/asm-ppc/system.h
--- linux-2.4.2.orig/include/asm-ppc/system.h	Sun Nov 12 03:23:11 2000
+++ linux-2.4.2/include/asm-ppc/system.h	Thu Jan 10 18:30:48 2002
@@ -131,9 +131,9 @@
 {
 	unsigned long prev;
 
-	__asm__ __volatile__ ("
-1:	lwarx	%0,0,%2
-	stwcx.	%3,0,%2
+	__asm__ __volatile__ ("\n\
+1:	lwarx	%0,0,%2\n\
+	stwcx.	%3,0,%2\n\
 	bne-	1b"
 	: "=&r" (prev), "=m" (*(volatile unsigned long *)p)
 	: "r" (p), "r" (val), "m" (*(volatile unsigned long *)p)
@@ -180,11 +180,11 @@
 {
 	int prev;
 
-	__asm__ __volatile__ ("
-1:	lwarx	%0,0,%2
-	cmpw	0,%0,%3
-	bne	2f
-	stwcx.	%4,0,%2
+	__asm__ __volatile__ ("\n\
+1:	lwarx	%0,0,%2\n\
+	cmpw	0,%0,%3\n\
+	bne	2f\n\
+	stwcx.	%4,0,%2\n\
 	bne-	1b\n"
 #ifdef CONFIG_SMP
 "	sync\n"
diff -Naur linux-2.4.2.orig/include/asm-ppc/tqm8xxL.h linux-2.4.2/include/asm-ppc/tqm8xxL.h
--- linux-2.4.2.orig/include/asm-ppc/tqm8xxL.h	Sun Nov 12 03:23:11 2000
+++ linux-2.4.2/include/asm-ppc/tqm8xxL.h	Thu Jan 10 18:36:39 2002
@@ -39,9 +39,17 @@
 /* Configuration options for TQ Systems TQM850L mini module
  */
 
+#ifdef CONFIG_DBOX2 
+#define	TQM_RESET_ADDR	0x00000100	/* Monitor Reset Entry */
+#else
 #define	TQM_RESET_ADDR	0x40000100	/* Monitor Reset Entry */
+#endif
 
+#ifdef CONFIG_DBOX2
+#define	TQM_IMMR_BASE	0xFF000000	/* phys. addr of IMMR */
+#else
 #define	TQM_IMMR_BASE	0xFFF00000	/* phys. addr of IMMR */
+#endif
 #define	TQM_IMAP_SIZE	(64 * 1024)	/* size of mapped area */
 
 #define	TQM_CLOCKRATE	50		/* 50 MHz Clock */
diff -Naur linux-2.4.2.orig/include/linux/8xx_rtc.h linux-2.4.2/include/linux/8xx_rtc.h
--- linux-2.4.2.orig/include/linux/8xx_rtc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/8xx_rtc.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,90 @@
+#ifndef _PPC_8XX_RTC_H
+#define _PPC_8XX_RTC_H
+
+#include <asm/io.h>
+#include <linux/rtc.h>			/* get the user-level API */
+#include <asm/8xx_rtc.h>		/* register access macros */
+
+extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
+
+/**********************************************************************
+ * register summary
+ **********************************************************************/
+#define RTC_SECONDS		0
+#define RTC_SECONDS_ALARM	1
+#define RTC_MINUTES		2
+#define RTC_MINUTES_ALARM	3
+#define RTC_HOURS		4
+#define RTC_HOURS_ALARM		5
+/* RTC_*_alarm is always true if 2 MSBs are set */
+# define RTC_ALARM_DONT_CARE 	0xC0
+
+#define RTC_DAY_OF_WEEK		6
+#define RTC_DAY_OF_MONTH	7
+#define RTC_MONTH		8
+#define RTC_YEAR		9
+
+/* control registers - Moto names
+ */
+#define RTC_REG_A		10
+#define RTC_REG_B		11
+#define RTC_REG_C		12
+#define RTC_REG_D		13
+
+/**********************************************************************
+ * register details
+ **********************************************************************/
+#define RTC_FREQ_SELECT	RTC_REG_A
+
+/* update-in-progress  - set to "1" 244 microsecs before RTC goes off the bus,
+ * reset after update (may take 1.984ms @ 32768Hz RefClock) is complete,
+ * totalling to a max high interval of 2.228 ms.
+ */
+# define RTC_UIP		0x80
+# define RTC_DIV_CTL		0x70
+   /* divider control: refclock values 4.194 / 1.049 MHz / 32.768 kHz */
+#  define RTC_REF_CLCK_4MHZ	0x00
+#  define RTC_REF_CLCK_1MHZ	0x10
+#  define RTC_REF_CLCK_32KHZ	0x20
+   /* 2 values for divider stage reset, others for "testing purposes only" */
+#  define RTC_DIV_RESET1	0x60
+#  define RTC_DIV_RESET2	0x70
+  /* Periodic intr. / Square wave rate select. 0=none, 1=32.8kHz,... 15=2Hz */
+# define RTC_RATE_SELECT 	0x0F
+
+/**********************************************************************/
+#define RTC_CONTROL	RTC_REG_B
+# define RTC_SET 0x80		/* disable updates for clock setting */
+# define RTC_PIE 0x40		/* periodic interrupt enable */
+# define RTC_AIE 0x20		/* alarm interrupt enable */
+# define RTC_UIE 0x10		/* update-finished interrupt enable */
+# define RTC_SQWE 0x08		/* enable square-wave output */
+# define RTC_DM_BINARY 0x04	/* all time/date values are BCD if clear */
+# define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
+# define RTC_DST_EN 0x01	/* auto switch DST - works f. USA only */
+
+/**********************************************************************/
+#define RTC_INTR_FLAGS	RTC_REG_C
+/* caution - cleared by read */
+# define RTC_IRQF 0x80		/* any of the following 3 is active */
+# define RTC_PF 0x40
+# define RTC_AF 0x20
+# define RTC_UF 0x10
+
+/**********************************************************************/
+#define RTC_VALID	RTC_REG_D
+# define RTC_VRT 0x80		/* valid RAM and time */
+/**********************************************************************/
+
+/* example: !(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) 
+ * determines if the following two #defines are needed
+ */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#endif /* _MC146818RTC_H */
diff -Naur linux-2.4.2.orig/include/linux/jffs.h linux-2.4.2/include/linux/jffs.h
--- linux-2.4.2.orig/include/linux/jffs.h	Wed Aug  9 23:06:12 2000
+++ linux-2.4.2/include/linux/jffs.h	Thu Jan 10 18:30:48 2002
@@ -10,7 +10,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * $Id: jffs.h,v 1.11 2000/08/04 12:46:34 dwmw2 Exp $
+ * $Id: jffs.h,v 1.19 2001/01/26 12:29:30 smunton Exp $
  *
  * Ported to Linux 2.3.x and MTD:
  * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB
@@ -204,9 +204,9 @@
 /* This stuff could be used for finding memory leaks.  */
 #define JFFS_MEMORY_DEBUG 0
 
-#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
-extern long no_jffs_file;
 extern long no_jffs_node;
+extern long no_jffs_file;
+#if defined(JFFS_MEMORY_DEBUG) && JFFS_MEMORY_DEBUG
 extern long no_jffs_control;
 extern long no_jffs_raw_inode;
 extern long no_jffs_node_ref;
diff -Naur linux-2.4.2.orig/include/linux/jffs2.h linux-2.4.2/include/linux/jffs2.h
--- linux-2.4.2.orig/include/linux/jffs2.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,164 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: jffs2.h,v 1.18 2001/03/25 22:36:12 dwmw2 Exp $
+ *
+ */
+
+#ifndef __LINUX_JFFS2_H__
+#define __LINUX_JFFS2_H__
+
+#include <asm/types.h>
+#define JFFS2_SUPER_MAGIC 0x72b6
+
+/* Values we may expect to find in the 'magic' field */
+#define JFFS2_OLD_MAGIC_BITMASK 0x1984
+#define JFFS2_MAGIC_BITMASK 0x1985
+#define KSAMTIB_CIGAM_2SFFJ 0x5981 /* For detecting wrong-endian fs */
+#define JFFS2_EMPTY_BITMASK 0xffff
+#define JFFS2_DIRTY_BITMASK 0x0000
+
+/* We only allow a single char for length, and 0xFF is empty flash so
+   we don't want it confused with a real length. Hence max 254.
+*/
+#define JFFS2_MAX_NAME_LEN 254
+
+/* How small can we sensibly write nodes? */
+#define JFFS2_MIN_DATA_LEN 128
+
+#define JFFS2_COMPR_NONE	0x00
+#define JFFS2_COMPR_ZERO	0x01
+#define JFFS2_COMPR_RTIME	0x02
+#define JFFS2_COMPR_RUBINMIPS	0x03
+#define JFFS2_COMPR_COPY	0x04
+#define JFFS2_COMPR_DYNRUBIN	0x05
+#define JFFS2_COMPR_ZLIB	0x06
+/* Compatibility flags. */
+#define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+#define JFFS2_NODE_ACCURATE 0x2000
+/* INCOMPAT: Fail to mount the filesystem */
+#define JFFS2_FEATURE_INCOMPAT 0xc000
+/* ROCOMPAT: Mount read-only */
+#define JFFS2_FEATURE_ROCOMPAT 0x8000
+/* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_COPY 0x4000
+/* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_DELETE 0x0000
+
+#define JFFS2_NODETYPE_DIRENT (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1)
+#define JFFS2_NODETYPE_INODE (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2)
+#define JFFS2_NODETYPE_CLEANMARKER (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+
+// Maybe later...
+//#define JFFS2_NODETYPE_CHECKPOINT (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+//#define JFFS2_NODETYPE_OPTIONS (JFFS2_FEATURE_RWCOMPAT_COPY | JFFS2_NODE_ACCURATE | 4)
+
+/* Same as the non_ECC versions, but with extra space for real 
+ * ECC instead of just the checksum. For use on NAND flash 
+ */
+//#define JFFS2_NODETYPE_DIRENT_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 5)
+//#define JFFS2_NODETYPE_INODE_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 6)
+
+#define JFFS2_INO_FLAG_PREREAD	  1	/* Do read_inode() for this one at 
+					   mount time, don't wait for it to 
+					   happen later */
+#define JFFS2_INO_FLAG_USERCOMPR  2	/* User has requested a specific 
+					   compression type */
+
+
+struct jffs2_unknown_node
+{
+	/* All start like this */
+	__u16 magic;
+	__u16 nodetype;
+	__u32 totlen; /* So we can skip over nodes we don't grok */
+	__u32 hdr_crc;
+};
+
+struct jffs2_raw_dirent
+{
+	__u16 magic;
+	__u16 nodetype;	/* == JFFS_NODETYPE_DIRENT */
+	__u32 totlen;
+	__u32 hdr_crc;
+	__u32 pino;
+	__u32 version;
+	__u32 ino; /* == zero for unlink */
+	__u32 mctime;
+	__u8 nsize;
+	__u8 type;
+	__u8 unused[2];
+	__u32 node_crc;
+	__u32 name_crc;
+	__u8 name[0];
+};
+
+/* The JFFS2 raw inode structure: Used for storage on physical media.  */
+/* The uid, gid, atime, mtime and ctime members could be longer, but 
+   are left like this for space efficiency. If and when people decide
+   they really need them extended, it's simple enough to add support for
+   a new type of raw node.
+*/
+struct jffs2_raw_inode
+{
+	__u16 magic;      /* A constant magic number.  */
+	__u16 nodetype;   /* == JFFS_NODETYPE_INODE */
+	__u32 totlen;     /* Total length of this node (inc data, etc.) */
+	__u32 hdr_crc;
+	__u32 ino;        /* Inode number.  */
+	__u32 version;    /* Version number.  */
+	__u32 mode;       /* The file's type or mode.  */
+	__u16 uid;        /* The file's owner.  */
+	__u16 gid;        /* The file's group.  */
+	__u32 isize;      /* Total resultant size of this inode (used for truncations)  */
+	__u32 atime;      /* Last access time.  */
+	__u32 mtime;      /* Last modification time.  */
+	__u32 ctime;      /* Change time.  */
+	__u32 offset;     /* Where to begin to write.  */
+	__u32 csize;      /* (Compressed) data size */
+	__u32 dsize;	  /* Size of the node's data. (after decompression) */
+	__u8 compr;       /* Compression algorithm used */
+	__u8 usercompr;	  /* Compression algorithm requested by the user */
+	__u16 flags;	  /* See JFFS2_INO_FLAG_* */
+	__u32 data_crc;   /* CRC for the (compressed) data.  */
+	__u32 node_crc;   /* CRC for the raw inode (excluding data)  */
+//	__u8 data[dsize];
+};
+
+union jffs2_node_union {
+	struct jffs2_raw_inode i;
+	struct jffs2_raw_dirent d;
+	struct jffs2_unknown_node u;
+};
+
+#endif /* __LINUX_JFFS2_H__ */
diff -Naur linux-2.4.2.orig/include/linux/jffs2_fs_i.h linux-2.4.2/include/linux/jffs2_fs_i.h
--- linux-2.4.2.orig/include/linux/jffs2_fs_i.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2_fs_i.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,58 @@
+/* $Id: jffs2_fs_i.h,v 1.7 2001/03/25 22:36:12 dwmw2 Exp $ */
+
+#ifndef _JFFS2_FS_I
+#define _JFFS2_FS_I
+
+/* Include the pipe_inode_info at the beginning so that we can still
+   use the storage space in the inode when we have a pipe inode.
+   This sucks.
+*/
+
+#undef THISSUCKS /* Only for 2.2 */
+#ifdef THISSUCKS
+#include <linux/pipe_fs_i.h>
+#endif
+
+struct jffs2_inode_info {
+#ifdef THISSUCKS
+        struct pipe_inode_info pipecrap;
+#endif
+	/* We need an internal semaphore similar to inode->i_sem.
+	   Unfortunately, we can't used the existing one, because
+	   either the GC would deadlock, or we'd have to release it
+	   before letting GC proceed. Or we'd have to put ugliness
+	   into the GC code so it didn't attempt to obtain the i_sem
+	   for the inode(s) which are already locked */
+	struct semaphore sem;
+
+	/* The highest (datanode) version number used for this ino */
+	__u32 highest_version;
+
+	/* List of data fragments which make up the file */
+	struct jffs2_node_frag *fraglist;
+
+	/* There may be one datanode which isn't referenced by any of the
+	   above fragments, if it contains a metadata update but no actual
+	   data - or if this is a directory inode */
+	/* This also holds the _only_ dnode for symlinks/device nodes, 
+	   etc. */
+	struct jffs2_full_dnode *metadata;
+
+	/* Directory entries */
+	struct jffs2_full_dirent *dents;
+
+	/* Some stuff we just have to keep in-core at all times, for each inode. */
+	struct jffs2_inode_cache *inocache;
+
+	/* Keep a pointer to the last physical node in the list. We don't 
+	   use the doubly-linked lists because we don't want to increase
+	   the memory usage that much. This is simpler */
+	//	struct jffs2_raw_node_ref *lastnode;
+	__u16 flags;
+	__u8 usercompr;
+};
+
+#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
+
+#endif /* _JFFS2_FS_I */
+
diff -Naur linux-2.4.2.orig/include/linux/jffs2_fs_sb.h linux-2.4.2/include/linux/jffs2_fs_sb.h
--- linux-2.4.2.orig/include/linux/jffs2_fs_sb.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/jffs2_fs_sb.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,75 @@
+/* $Id: jffs2_fs_sb.h,v 1.13 2001/03/20 17:43:56 dwmw2 Exp $ */
+
+#ifndef _JFFS2_FS_SB
+#define _JFFS2_FS_SB
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <asm/semaphore.h>
+#include <linux/list.h>
+
+#define INOCACHE_HASHSIZE 1
+
+#define JFFS2_SB_FLAG_RO 1
+
+/* A struct for the overall file system control.  Pointers to
+   jffs2_sb_info structs are named `c' in the source code.  
+   Nee jffs_control
+*/
+struct jffs2_sb_info {
+	struct mtd_info *mtd;
+
+	__u32 highest_ino;
+	unsigned int flags;
+	spinlock_t nodelist_lock;
+
+	//	pid_t thread_pid;		/* GC thread's PID */
+	struct task_struct *gc_task;	/* GC task struct */
+	struct semaphore gc_thread_sem; /* GC thread exit mutex */
+
+	//	__u32 gc_minfree_threshold;	/* GC trigger thresholds */
+	//	__u32 gc_maxdirty_threshold;
+
+	struct semaphore alloc_sem;	/* Used to protect all the following 
+					   fields, and also to protect against
+					   out-of-order writing of nodes */
+	struct semaphore gc_sem;
+	__u32 flash_size;
+	__u32 used_size;
+	__u32 dirty_size;
+	__u32 free_size;
+	__u32 erasing_size;
+	__u32 bad_size;
+	__u32 sector_size;
+	//	__u32 min_free_size;
+	//	__u32 max_chunk_size;
+
+	__u32 nr_free_blocks;
+	__u32 nr_erasing_blocks;
+
+	__u32 nr_blocks;
+	struct jffs2_eraseblock *blocks;	/* The whole array of blocks. Used for getting blocks 
+						 * from the offset (blocks[ofs / sector_size]) */
+	struct jffs2_eraseblock *nextblock;	/* The block we're currently filling */
+
+	struct jffs2_eraseblock *gcblock;	/* The block we're currently garbage-collecting */
+
+	struct list_head clean_list;		/* Blocks 100% full of clean data */
+	struct list_head dirty_list;		/* Blocks with some dirty space */
+	struct list_head erasing_list;		/* Blocks which are currently erasing */
+	struct list_head erase_pending_list;	/* Blocks which need erasing */
+	struct list_head erase_complete_list;	/* Blocks which are erased and need the clean marker written to them */
+	struct list_head free_list;		/* Blocks which are free and ready to be used */
+	struct list_head bad_list;		/* Bad blocks. */
+	struct list_head bad_used_list;		/* Bad blocks with valid data in. */
+
+	spinlock_t erase_completion_lock;	/* Protect free_list and erasing_list 
+						   against erase completion handler */
+	wait_queue_head_t erase_wait;		/* For waiting for erases to complete */
+	struct jffs2_inode_cache *inocache_list[INOCACHE_HASHSIZE];
+	spinlock_t inocache_lock;
+};
+
+#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
+#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
+#endif /* _JFFS2_FB_SB */
diff -Naur linux-2.4.2.orig/include/linux/mtd/cfi.h linux-2.4.2/include/linux/mtd/cfi.h
--- linux-2.4.2.orig/include/linux/mtd/cfi.h	Mon Dec 11 22:16:46 2000
+++ linux-2.4.2/include/linux/mtd/cfi.h	Thu Jan 10 18:30:48 2002
@@ -1,14 +1,160 @@
 
 /* Common Flash Interface structures 
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id: cfi.h,v 1.6 2000/07/03 13:29:16 dwmw2 Exp $
+ * $Id: cfi.h,v 1.19 2001/03/20 10:27:12 eauth Exp $
  */
 
 #ifndef __MTD_CFI_H__
 #define __MTD_CFI_H__
 
+#include <linux/config.h>
+#include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/mtd/flashchip.h>
+#include <linux/mtd/cfi_endian.h>
+
+/*
+ * You can optimize the code size and performance by defining only 
+ * the geometry(ies) available on your hardware.
+ * CFIDEV_INTERLEAVE_n, where  represents the interleave (number of chips to fill the bus width)
+ * CFIDEV_BUSWIDTH_n, where n is the bus width in bytes (1, 2 or 4 bytes)
+ *
+ * By default, all (known) geometries are supported.
+ */
+
+#ifndef CONFIG_MTD_CFI_GEOMETRY
+
+#define CFIDEV_INTERLEAVE_1 (1)
+#define CFIDEV_INTERLEAVE_2 (2)
+#define CFIDEV_INTERLEAVE_4 (4)
+
+#define CFIDEV_BUSWIDTH_1 (1)
+#define CFIDEV_BUSWIDTH_2 (2)
+#define CFIDEV_BUSWIDTH_4 (4)
+
+#else
+
+#ifdef CONFIG_MTD_CFI_I1
+#define CFIDEV_INTERLEAVE_1 (1)
+#endif
+#ifdef CONFIG_MTD_CFI_I2
+#define CFIDEV_INTERLEAVE_2 (2)
+#endif
+#ifdef CONFIG_MTD_CFI_I4
+#define CFIDEV_INTERLEAVE_4 (4)
+#endif
+
+#ifdef CONFIG_MTD_CFI_B1
+#define CFIDEV_BUSWIDTH_1 (1)
+#endif
+#ifdef CONFIG_MTD_CFI_B2
+#define CFIDEV_BUSWIDTH_2 (2)
+#endif
+#ifdef CONFIG_MTD_CFI_B4
+#define CFIDEV_BUSWIDTH_4 (4)
+#endif
+
+#endif
+
+/*
+ * The following macros are used to select the code to execute:
+ *   cfi_buswidth_is_*()
+ *   cfi_interleave_is_*()
+ *   [where * is either 1, 2 or 4]
+ * Those macros should be used with 'if' statements.  If only one of few
+ * geometry arrangements are selected, they expand to constants thus allowing
+ * the compiler (most of them being 0) to optimize away all the unneeded code,
+ * while still validating the syntax (which is not possible with embedded 
+ * #if ... #endif constructs).
+ */
+
+#ifdef CFIDEV_INTERLEAVE_1
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE (interleave)
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_1
+# endif
+# define cfi_interleave_is_1() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_1)
+#else
+# define cfi_interleave_is_1() (0)
+#endif
+
+#ifdef CFIDEV_INTERLEAVE_2
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE interleave
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_2
+# endif
+# define cfi_interleave_is_2() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_2)
+#else
+# define cfi_interleave_is_2() (0)
+#endif
+
+#ifdef CFIDEV_INTERLEAVE_4
+# ifdef CFIDEV_INTERLEAVE
+#  undef CFIDEV_INTERLEAVE
+#  define CFIDEV_INTERLEAVE interleave
+# else
+#  define CFIDEV_INTERLEAVE CFIDEV_INTERLEAVE_4
+# endif
+# define cfi_interleave_is_4() (CFIDEV_INTERLEAVE == CFIDEV_INTERLEAVE_4)
+#else
+# define cfi_interleave_is_4() (0)
+#endif
+
+#ifndef CFIDEV_INTERLEAVE
+#error You must define at least one interleave to support!
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_1
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_1
+# endif
+# define cfi_buswidth_is_1() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_1)
+#else
+# define cfi_buswidth_is_1() (0)
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_2
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_2
+# endif
+# define cfi_buswidth_is_2() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_2)
+#else
+# define cfi_buswidth_is_2() (0)
+#endif
+
+#ifdef CFIDEV_BUSWIDTH_4
+# ifdef CFIDEV_BUSWIDTH
+#  undef CFIDEV_BUSWIDTH
+#  define CFIDEV_BUSWIDTH (map->buswidth)
+# else
+#  define CFIDEV_BUSWIDTH CFIDEV_BUSWIDTH_4
+# endif
+# define cfi_buswidth_is_4() (CFIDEV_BUSWIDTH == CFIDEV_BUSWIDTH_4)
+#else
+# define cfi_buswidth_is_4() (0)
+#endif
+
+#ifndef CFIDEV_BUSWIDTH
+#error You must define at least one bus width to support!
+#endif
+
+/* NB: these values must represents the number of bytes needed to meet the 
+ *     device type (x8, x16, x32).  Eg. a 32 bit device is 4 x 8 bytes. 
+ *     These numbers are used in calculations.
+ */
+#define CFI_DEVICETYPE_X8  (8 / 8)
+#define CFI_DEVICETYPE_X16 (16 / 8)
+#define CFI_DEVICETYPE_X32 (32 / 8)
 
 /* NB: We keep these structures in memory in HOST byteorder, except
  * where individually noted.
@@ -37,7 +183,7 @@
   __u16 InterfaceDesc;
   __u16 MaxBufWriteSize;
   __u8  NumEraseRegions;
-  __u32 EraseRegionInfo[1]; /* Not host ordered */
+  __u32 EraseRegionInfo[0]; /* Not host ordered */
 } __attribute__((packed));
 
 /* Extended Query Structure for both PRI and ALT */
@@ -86,16 +232,156 @@
 	__u16 cmdset;
 	void *cmdset_priv;
 	int interleave;
+	int device_type;
+	int cfi_mode;
+	int addr_unlock1;
+	int addr_unlock2;
+	int fast_prog;
 	struct mtd_info *(*cmdset_setup)(struct map_info *);
-	struct cfi_ident cfiq; /* For now only one. We insist that all devs
+	struct cfi_ident *cfiq; /* For now only one. We insist that all devs
 				  must be of the same type. */
+	__u8 mfr, id;
 	int numchips;
 	unsigned long chipshift; /* Because they're of the same type */
 	const char *im_name;	 /* inter_module name for cmdset_setup */
 	struct flchip chips[0];  /* per-chip data structure for each chip */
-	/* do not add extra fields after "chips" */
 };
 
 #define MAX_CFI_CHIPS 8 /* Entirely arbitrary to avoid realloc() */
+
+/*
+ * Returns the command address according to the given geometry.
+ */
+static inline __u32 cfi_build_cmd_addr(__u32 cmd_ofs, int interleave, int type)
+{
+	return (cmd_ofs * type) * interleave;
+}
+
+/*
+ * Transforms the CFI command for the given geometry (bus width & interleave.
+ */
+static inline __u32 cfi_build_cmd(u_char cmd, struct map_info *map, int interleave)
+{
+	__u32 val = 0;
+
+	if (cfi_buswidth_is_1()) {
+		/* 1 x8 device */
+		val = cmd;
+	} else if (cfi_buswidth_is_2()) {
+		if (cfi_interleave_is_1()) {
+			/* 1 x16 device in x16 mode */
+			val = cpu_to_cfi16(cmd);
+		} else if (cfi_interleave_is_2()) {
+			/* 2 (x8, x16 or x32) devices in x8 mode */
+			val = cpu_to_cfi16((cmd << 8) | cmd);
+		}
+	} else if (cfi_buswidth_is_4()) {
+		if (cfi_interleave_is_1()) {
+			/* 1 x32 device in x32 mode */
+			val = cpu_to_cfi32(cmd);
+		} else if (cfi_interleave_is_2()) {
+			/* 2 x16 device in x16 mode */
+			val = cpu_to_cfi32((cmd << 16) | cmd);
+		} else if (cfi_interleave_is_4()) {
+			/* 4 (x8, x16 or x32) devices in x8 mode */
+			val = (cmd << 16) | cmd;
+			val = cpu_to_cfi32((val << 8) | val);
+		}
+	}
+	return val;
+}
+#define CMD(x)  cfi_build_cmd((x), map, cfi->interleave)
+
+/*
+ * Read a value according to the bus width.
+ */
+
+static inline __u32 cfi_read(struct map_info *map, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		return map->read8(map, addr);
+	} else if (cfi_buswidth_is_2()) {
+		return map->read16(map, addr);
+	} else if (cfi_buswidth_is_4()) {
+		return map->read32(map, addr);
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * Write a value according to the bus width.
+ */
+
+static inline void cfi_write(struct map_info *map, __u32 val, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		map->write8(map, val, addr);
+	} else if (cfi_buswidth_is_2()) {
+		map->write16(map, val, addr);
+	} else if (cfi_buswidth_is_4()) {
+		map->write32(map, val, addr);
+	}
+}
+
+/*
+ * Sends a CFI command to a bank of flash for the given geometry.
+ *
+ * Returns the offset in flash where the command was written.
+ * If prev_val is non-null, it will be set to the value at the command address,
+ * before the command was written.
+ */
+static inline __u32 cfi_send_gen_cmd(u_char cmd, __u32 cmd_addr, __u32 base, struct map_info *map,
+					 int interleave, int type, __u32 *prev_val)
+{
+	__u32 val;
+	__u32 addr = base + cfi_build_cmd_addr(cmd_addr, interleave, type);
+
+	val = cfi_build_cmd(cmd, map, interleave);
+
+	if (prev_val)
+		*prev_val = cfi_read(map, addr);
+
+	cfi_write(map, val, addr);
+
+	return addr - base;
+}
+
+static inline __u8 cfi_read_query(struct map_info *map, __u32 addr)
+{
+	if (cfi_buswidth_is_1()) {
+		return map->read8(map, addr);
+	} else if (cfi_buswidth_is_2()) {
+		return cfi16_to_cpu(map->read16(map, addr));
+	} else if (cfi_buswidth_is_4()) {
+		return cfi32_to_cpu(map->read32(map, addr));
+	} else {
+		return 0;
+	}
+}
+
+#ifndef min
+#define min(x,y) ( (x)<(y)?(x):(y) )
+#endif
+
+static inline void cfi_udelay(int us)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
+	if (current->need_resched)
+		schedule();
+	else
+#endif
+		udelay(us);
+}
+static inline void cfi_spin_lock(spinlock_t *mutex)
+{
+	spin_lock_bh(mutex);
+}
+
+static inline void cfi_spin_unlock(spinlock_t *mutex)
+{
+	spin_unlock_bh(mutex);
+}
+
 
 #endif /* __MTD_CFI_H__ */
diff -Naur linux-2.4.2.orig/include/linux/mtd/cfi_endian.h linux-2.4.2/include/linux/mtd/cfi_endian.h
--- linux-2.4.2.orig/include/linux/mtd/cfi_endian.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/cfi_endian.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,132 @@
+/*
+ * $Id: cfi_endian.h,v 1.8 2001/03/16 23:48:48 ahennessy Exp $
+ *
+ * It seems that some helpful people decided to make life easier
+ * for software engineers who aren't capable of dealing with the 
+ * concept of byteswapping, and advise engineers to swap the bytes
+ * by wiring the data lines up to flash chips from BE hosts backwards.
+ *
+ * So we have ugly stuff here to disable the byteswapping where necessary.
+ * I'm not going to try to do this dynamically.
+ *
+ * At first I thought these guys were on crack, but then I discovered the
+ * LART. 
+ *
+ */
+
+#include <asm/byteorder.h>
+
+#ifndef CONFIG_MTD_CFI_ADV_OPTIONS
+
+#define CFI_HOST_ENDIAN
+
+#else
+
+#ifdef CONFIG_MTD_CFI_NOSWAP
+#define CFI_HOST_ENDIAN
+#endif
+
+#ifdef CONFIG_MTD_CFI_LE_BYTE_SWAP
+#define CFI_LITTLE_ENDIAN
+#endif
+
+#ifdef CONFIG_MTD_CFI_BE_BYTE_SWAP
+#define CFI_BIG_ENDIAN
+#endif
+
+#ifdef CONFIG_MTD_CFI_LART_BIT_SWAP
+#define CFI_LART_ENDIAN
+#endif
+
+#endif
+
+#if defined(CFI_LITTLE_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) cpu_to_le16(x)
+#define cpu_to_cfi32(x) cpu_to_le32(x)
+#define cfi16_to_cpu(x) le16_to_cpu(x)
+#define cfi32_to_cpu(x) le32_to_cpu(x)
+#elif defined (CFI_BIG_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) cpu_to_be16(x)
+#define cpu_to_cfi32(x) cpu_to_be32(x)
+#define cfi16_to_cpu(x) be16_to_cpu(x)
+#define cfi32_to_cpu(x) be32_to_cpu(x)
+#elif defined (CFI_HOST_ENDIAN)
+#define cpu_to_cfi8(x) (x)
+#define cfi8_to_cpu(x) (x)
+#define cpu_to_cfi16(x) (x)
+#define cpu_to_cfi32(x) (x)
+#define cfi16_to_cpu(x) (x)
+#define cfi32_to_cpu(x) (x)
+#elif defined (CFI_LART_ENDIAN)
+/* 
+   Fuck me backwards. The data line mapping on LART is as follows:
+
+	U2	CPU	|	U3	CPU
+	 0	20	|	0	12
+	 1	22	|	1	14
+	 2	19	|	2	11
+	 3	17	|	3	9
+	 4	24	|	4	0
+	 5	26	|	5	2
+	 6	31	|	6	7
+	 7	29	|	7	5
+	 8	21	|	8	13
+	 9	23	|	9	15
+	 10	18	|	10	10
+	 11	16	|	11	8
+	 12	25	|	12	1
+	 13	27	|	13	3
+	 14	30	|	14	6
+	 15	28	|	15	4
+*/
+#define cpu_to_cfi16(x) NOT NEEDED?
+#define cfi16_to_cpu(x) NOT NEEDED?
+static inline cfi32_to_cpu(__u32 x)
+{
+	__u32 ret;
+
+	ret =  (x & 0x08009000) >> 11;
+	ret |= (x & 0x00002000) >> 10;
+	ret |= (x & 0x04004000) >> 8;
+	ret |= (x & 0x00000010) >> 4;
+	ret |= (x & 0x91000820) >> 3;
+	ret |= (x & 0x22080080) >> 2;
+	ret |= (x & 0x40000400);
+	ret |= (x & 0x00040040) << 1;
+	ret |= (x & 0x00110000) << 4;
+	ret |= (x & 0x00220100) << 5;
+	ret |= (x & 0x00800208) << 6;
+	ret |= (x & 0x00400004) << 9;
+	ret |= (x & 0x00000001) << 12;
+	ret |= (x & 0x00000002) << 13;
+
+	return ret;
+}
+static inline cpu_to_cfi32(__u32 x)
+{
+	__u32 ret;
+
+	ret =  (x & 0x00010012) << 11;
+	ret |= (x & 0x00000008) << 10;
+	ret |= (x & 0x00040040) << 8;
+	ret |= (x & 0x00000001) << 4;
+	ret |= (x & 0x12200104) << 3;
+	ret |= (x & 0x08820020) << 2;
+	ret |= (x & 0x40000400);
+	ret |= (x & 0x00080080) >> 1;
+	ret |= (x & 0x01100000) >> 4;
+	ret |= (x & 0x04402000) >> 5;
+	ret |= (x & 0x20008200) >> 6;
+	ret |= (x & 0x80000800) >> 9;
+	ret |= (x & 0x00001000) >> 12;
+	ret |= (x & 0x00004000) >> 13;
+
+	return ret;
+}
+#else
+#error No CFI endianness defined
+#endif
diff -Naur linux-2.4.2.orig/include/linux/mtd/compatmac.h linux-2.4.2/include/linux/mtd/compatmac.h
--- linux-2.4.2.orig/include/linux/mtd/compatmac.h	Mon Dec 11 22:16:42 2000
+++ linux-2.4.2/include/linux/mtd/compatmac.h	Thu Jan 10 18:30:48 2002
@@ -2,7 +2,7 @@
 /*
  * mtd/include/compatmac.h
  *
- * $Id: compatmac.h,v 1.4 2000/07/03 10:01:38 dwmw2 Exp $
+ * $Id: compatmac.h,v 1.15 2001/03/20 10:25:10 eauth Exp $
  *
  * Extensions and omissions from the normal 'linux/compatmac.h'
  * files. hopefully this will end up empty as the 'real' one 
@@ -17,21 +17,157 @@
 #ifndef __LINUX_MTD_COMPATMAC_H__
 #define __LINUX_MTD_COMPATMAC_H__
 
-#include <linux/compatmac.h>
-#include <linux/types.h> /* used later in this header */
+#include <linux/config.h>
 #include <linux/module.h>
 #ifndef LINUX_VERSION_CODE
 #include <linux/version.h>
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
-#include <linux/vmalloc.h>
+#ifndef VERSION_CODE
+#  define VERSION_CODE(vers,rel,seq) ( ((vers)<<16) | ((rel)<<8) | (seq) )
+#endif
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(a,b,c) VERSION_CODE(a,b,c)
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,0,0)
 #  error "This kernel is too old: not supported by this file"
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+#include <linux/types.h> /* used later in this header */
+
+#define memcpy_fromio(a,b,c)    memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)      memcpy((void *)(a),(b),(c))
+
+typedef struct wait_queue * wait_queue_head_t;
+
+#define DECLARE_WAITQUEUE(x,y) struct wait_queue x = {y,NULL}
+#define DECLARE_WAIT_QUEUE_HEAD(x) struct wait_queue *x = NULL
+#define init_waitqueue_head init_waitqueue
+#define DECLARE_MUTEX(x) struct semaphore x = MUTEX;
+
+/* from sysdep-2.1.h */
+#  include <asm/segment.h>
+#  define access_ok(t,a,sz)           (verify_area((t),(a),(sz)) ? 0 : 1)
+#  define verify_area_20              verify_area
+#  define copy_to_user(t,f,n)         (memcpy_tofs(t,f,n), 0)
+#  define __copy_to_user(t,f,n)       copy_to_user((t),(f),(n))
+#  define copy_to_user_ret(t,f,n,r)   copy_to_user((t),(f),(n))
+#  define copy_from_user(t,f,n)       (memcpy_fromfs((t),(f),(n)), 0)
+#  define __copy_from_user(t,f,n)     copy_from_user((t),(f),(n))
+#  define copy_from_user_ret(t,f,n,r) copy_from_user((t),(f),(n))
+//xxx #  define PUT_USER(val,add)           (put_user((val),(add)), 0)
+#  define Put_user(val,add)           (put_user((val),(add)), 0)
+#  define __PUT_USER(val,add)         PUT_USER((val),(add))
+#  define PUT_USER_RET(val,add,ret)   PUT_USER((val),(add))
+#  define GET_USER(dest,add)          ((dest)=get_user((add)), 0)
+#  define __GET_USER(dest,add)        GET_USER((dest),(add))
+#  define GET_USER_RET(dest,add,ret)  GET_USER((dest),(add))
+
+#define ioremap(offset,size) vremap(offset,size)
+#define iounmap(adr)	/* */
+
+#define EXPORT_SYMBOL(s) /* */
+#define EXPORT_SYMBOL_NOVERS(s) /* */
+
+/* 2.1.10 and 2.1.43 introduced new functions. They are worth using */
+
+#if LINUX_VERSION_CODE < VERSION_CODE(2,1,10)
+
+#  include <asm/byteorder.h>
+#  ifdef __LITTLE_ENDIAN
+#    define cpu_to_le16(x) (x)
+#    define cpu_to_le32(x) (x)
+#    define cpu_to_be16(x) htons((x))
+#    define cpu_to_be32(x) htonl((x))
+#  else
+#    define cpu_to_be16(x) (x)
+#    define cpu_to_be32(x) (x)
+     extern inline __u16 cpu_to_le16(__u16 x) { return (x<<8) | (x>>8);}
+     extern inline __u32 cpu_to_le32(__u32 x) { return((x>>24) |
+             ((x>>8)&0xff00) | ((x<<8)&0xff0000) | (x<<24));}
+#  endif
+
+#  define le16_to_cpu(x)  cpu_to_le16(x)
+#  define le32_to_cpu(x)  cpu_to_le32(x)
+#  define be16_to_cpu(x)  cpu_to_be16(x)
+#  define be32_to_cpu(x)  cpu_to_be32(x)
+
+#endif
+
+#if LINUX_VERSION_CODE < VERSION_CODE(2,1,43)
+#  define cpu_to_le16p(addr) (cpu_to_le16(*(addr)))
+#  define cpu_to_le32p(addr) (cpu_to_le32(*(addr)))
+#  define cpu_to_be16p(addr) (cpu_to_be16(*(addr)))
+#  define cpu_to_be32p(addr) (cpu_to_be32(*(addr)))
+
+   extern inline void cpu_to_le16s(__u16 *a) {*a = cpu_to_le16(*a);}
+   extern inline void cpu_to_le32s(__u16 *a) {*a = cpu_to_le32(*a);}
+   extern inline void cpu_to_be16s(__u16 *a) {*a = cpu_to_be16(*a);}
+   extern inline void cpu_to_be32s(__u16 *a) {*a = cpu_to_be32(*a);}
+
+#  define le16_to_cpup(x) cpu_to_le16p(x)
+#  define le32_to_cpup(x) cpu_to_le32p(x)
+#  define be16_to_cpup(x) cpu_to_be16p(x)
+#  define be32_to_cpup(x) cpu_to_be32p(x)
+
+#  define le16_to_cpus(x) cpu_to_le16s(x)
+#  define le32_to_cpus(x) cpu_to_le32s(x)
+#  define be16_to_cpus(x) cpu_to_be16s(x)
+#  define be32_to_cpus(x) cpu_to_be32s(x)
+#endif
+
+// from 2.2, linux/types.h
+#ifndef __BIT_TYPES_DEFINED__
+#define __BIT_TYPES_DEFINED__
+
+typedef         __u8            u_int8_t;
+typedef         __s8            int8_t;
+typedef         __u16           u_int16_t;
+typedef         __s16           int16_t;
+typedef         __u32           u_int32_t;
+typedef         __s32           int32_t;
+
+#endif /* !(__BIT_TYPES_DEFINED__) */
+
+#if (__GNUC__ > 2) || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)
+  typedef struct { } spinlock_t;
+  #define SPIN_LOCK_UNLOCKED (spinlock_t) { }
+#else
+  typedef struct { int gcc_is_buggy; } spinlock_t;
+  #define SPIN_LOCK_UNLOCKED (spinlock_t) { 0 }
+#endif
+
+#define spin_lock_init(lock)    do { } while(0)
+#define spin_lock(lock)         (void)(lock) /* Not "unused variable". */
+#define spin_trylock(lock)      (1)
+#define spin_unlock_wait(lock)  do { } while(0)
+#define spin_unlock(lock)       do { } while(0)
+#define spin_lock_irq(lock)     cli()
+#define spin_unlock_irq(lock)   sti()
+
+#define spin_lock_irqsave(lock, flags) \
+        do { save_flags(flags); cli(); } while (0)
+#define spin_unlock_irqrestore(lock, flags) \
+        restore_flags(flags)
+
+// Doesn't work when tqueue.h is included. 
+// #define queue_task                   queue_task_irq_off
+#define tty_flip_buffer_push(tty)    queue_task_irq_off(&tty->flip.tqueue, &tq_timer)
+#define signal_pending(current)      (current->signal & ~current->blocked)
+#define schedule_timeout(to)         do {current->timeout = jiffies + (to);schedule ();} while (0)
+#define time_after(t1,t2)            (((long)t1-t2) > 0)
+
+#else
+  #include <linux/compatmac.h>
+#endif  // LINUX_VERSION_CODE < 0x020100
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#include <linux/vmalloc.h>
+#endif
+
 /* Modularization issues */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,18)
 #  define __USE_OLD_SYMTAB__
@@ -88,8 +224,10 @@
 #  define release_return(x) return (x)
 #endif
 
-#if LINUX_VERSION_CODE < 0x20300
+#if LINUX_VERSION_CODE < 0x20212
 #define __exit
+#define module_init(x) /* */
+#define module_exit(x) /* */
 #endif
 #if LINUX_VERSION_CODE < 0x20200
 #define __init
@@ -97,8 +235,12 @@
 #include <linux/init.h>
 #endif
 
-#if LINUX_VERSION_CODE < 0x20300
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 #define init_MUTEX(x) do {*(x) = MUTEX;} while (0)
+#define init_MUTEX_LOCKED(x) do {*(x) = MUTEX_LOCKED;} while (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #define RQFUNC_ARG void
 #define blkdev_dequeue_request(req) do {CURRENT = req->next;} while (0)
 #else
@@ -106,23 +248,41 @@
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,0)
+#ifdef CONFIG_MODULES
 #define __MOD_INC_USE_COUNT(mod)                                        \
         (atomic_inc(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED|MOD_USED_ONCE)
 #define __MOD_DEC_USE_COUNT(mod)                                        \
         (atomic_dec(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED)
+#else
+#define __MOD_INC_USE_COUNT(mod)
+#define __MOD_DEC_USE_COUNT(mod)
+#endif
 #endif
 
 
+#ifndef HAVE_INTER_MODULE
+static inline void *inter_module_get(char *x) {return NULL;}
+static inline void *inter_module_get_request(char *x, char *y) {return NULL;}
+static inline void inter_module_put(const char *x) {}
+static inline void inter_module_register(const char *x, struct module *y, const void *z) {}
+static inline void inter_module_unregister(const char *x) {}
+#endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 
 #define DECLARE_WAIT_QUEUE_HEAD(x) struct wait_queue *x = NULL
 #define init_waitqueue_head init_waitqueue
 
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+
 static inline int try_inc_mod_count(struct module *mod)
 {
+#ifdef CONFIG_MODULES
 	if (mod)
 		__MOD_INC_USE_COUNT(mod);
+#endif
 	return 1;
 }
 #endif
@@ -197,6 +357,9 @@
 #include <linux/spinlock.h>
 #endif
 
-#endif /* __LINUX_MTD_COMPATMAC_H__ */
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
+#define set_current_state(state_value)                        \
+        do { current->state = (state_value); } while (0)
+#endif
 
+#endif /* __LINUX_MTD_COMPATMAC_H__ */
diff -Naur linux-2.4.2.orig/include/linux/mtd/flashchip.h linux-2.4.2/include/linux/mtd/flashchip.h
--- linux-2.4.2.orig/include/linux/mtd/flashchip.h	Mon Dec 11 22:16:46 2000
+++ linux-2.4.2/include/linux/mtd/flashchip.h	Thu Jan 10 18:30:48 2002
@@ -6,7 +6,7 @@
  *
  * (C) 2000 Red Hat. GPLd.
  *
- * $Id: flashchip.h,v 1.4 2000/07/03 12:58:41 dwmw2 Exp $
+ * $Id: flashchip.h,v 1.7 2001/01/18 03:52:36 nico Exp $
  *
  */
 
@@ -25,12 +25,17 @@
 	FL_CFI_QUERY,
 	FL_JEDEC_QUERY,
 	FL_ERASING,
+	FL_ERASE_SUSPENDING,
 	FL_ERASE_SUSPENDED,
 	FL_WRITING,
+	FL_WRITING_TO_BUFFER,
+	FL_WRITE_SUSPENDING,
 	FL_WRITE_SUSPENDED,
 	FL_PM_SUSPENDED,
 	FL_SYNCING,
 	FL_UNLOADING,
+	FL_LOCKING,
+	FL_UNLOCKING,
 	FL_UNKNOWN
 } flstate_t;
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/ftl.h linux-2.4.2/include/linux/mtd/ftl.h
--- linux-2.4.2.orig/include/linux/mtd/ftl.h	Sun Feb  4 19:05:30 2001
+++ linux-2.4.2/include/linux/mtd/ftl.h	Thu Jan 10 18:30:48 2002
@@ -1,4 +1,7 @@
 /*
+ * $Id: ftl.h,v 1.4 2000/11/13 18:01:54 dwmw2 Exp $
+ * 
+ * Derived from (and probably identical to):
  * ftl.h 1.7 1999/10/25 20:23:17
  *
  * The contents of this file are subject to the Mozilla Public License
@@ -16,7 +19,7 @@
  * are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
  *
  * Alternatively, the contents of this file may be used under the
- * terms of the GNU General Public License version 2 (the "GPL"), in which
+ * terms of the GNU Public License version 2 (the "GPL"), in which
  * case the provisions of the GPL are applicable instead of the
  * above.  If you wish to allow the use of your version of this file
  * only under the terms of the GPL and not to allow others to use
diff -Naur linux-2.4.2.orig/include/linux/mtd/iflash.h linux-2.4.2/include/linux/mtd/iflash.h
--- linux-2.4.2.orig/include/linux/mtd/iflash.h	Tue Jul  4 19:10:52 2000
+++ linux-2.4.2/include/linux/mtd/iflash.h	Thu Jan 10 18:30:48 2002
@@ -1,4 +1,4 @@
-/* iflash.h $revision$ $date$ (David Hinds) */
+/* $Id: iflash.h,v 1.2 2000/11/13 18:01:54 dwmw2 Exp $ */
 
 #ifndef __MTD_IFLASH_H__
 #define __MTD_IFLASH_H__
diff -Naur linux-2.4.2.orig/include/linux/mtd/list.h linux-2.4.2/include/linux/mtd/list.h
--- linux-2.4.2.orig/include/linux/mtd/list.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/list.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,154 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#ifdef __KERNEL__
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_add(struct list_head * new,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static __inline__ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static __inline__ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static __inline__ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static __inline__ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Naur linux-2.4.2.orig/include/linux/mtd/map.h linux-2.4.2/include/linux/mtd/map.h
--- linux-2.4.2.orig/include/linux/mtd/map.h	Fri Feb  9 20:29:44 2001
+++ linux-2.4.2/include/linux/mtd/map.h	Thu Jan 10 18:30:48 2002
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.10.2.2 2001/01/09 00:44:51 dwmw2 Exp $ */
+/* $Id: map.h,v 1.20 2001/03/14 22:00:00 dwmw2 Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -8,7 +8,7 @@
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/mtd/mtd.h>
-#include <linux/slab.h>
+#include <linux/malloc.h>
 
 /* The map stuff is very simple. You fill in your struct map_info with
    a handful of routines for accessing the device, making sure they handle
@@ -57,44 +57,77 @@
 	const char *im_name;
 };
 
-#ifdef CONFIG_MODULES
+typedef struct mtd_info *map_probe_fn_t(struct map_info *);
+
 /* 
  * Probe for the contents of a map device and make an MTD structure
  * if anything is recognised. Doesn't register it because the calling
  * map driver needs to set the 'module' field first.
  */
-static inline struct mtd_info *do_map_probe(struct map_info *map, const char *funcname, const char *modname)
-{
-	struct mtd_info *(*probe_p)(struct map_info *);
-	struct mtd_info *mtd = NULL;
 
-	if ((probe_p = inter_module_get_request(modname, funcname)))
-		mtd = (*probe_p)(map);	/* map->im_name is set by probe */
-
-	return mtd;
+/* Define inline function for finding a probe function. This would be
+ * _so_ much nicer if weak symbols actually worked. 
+ */
+#ifdef HAVE_INTER_MODULE
+#define DECLARE_MAP_PROBE(funcname, modname) \
+static inline struct mtd_info *do_##funcname(struct map_info *map) \
+{ \
+	map_probe_fn_t *probe_p;\
+	struct mtd_info *mtd = NULL; \
+\
+	if ((probe_p = inter_module_get_request(modname, #funcname))) { \
+		map->im_name = #funcname; \
+		mtd = (*probe_p)(map); \
+		} \
+\
+	return mtd; \
 }
+#else
+/* Empty version for kernels without the inter_module_xxx stuff */
+#define DECLARE_MAP_PROBE(funcname, modname) \
+static inline struct mtd_info *do_##funcname (struct map_info *map) \
+{ \
+	return NULL; \
+}
+#endif
 
+#ifdef CONFIG_MTD_CFI
+extern struct mtd_info *cfi_probe(struct map_info *);
+#define do_cfi_probe(map) cfi_probe(map)
+#else
+DECLARE_MAP_PROBE(cfi_probe, "cfi_probe")
+#endif
 
-/* 
- * Commonly-used probe functions for different types of chip.
- */
-#define do_cfi_probe(x) do_map_probe(x, "cfi_probe", "cfi_probe")
-#define do_jedec_probe(x) do_map_probe(x, "jedec_probe", "jedec_probe")
-#define do_ram_probe(x) do_map_probe(x, "map_ram_probe", "map_ram")
-#define do_rom_probe(x) do_map_probe(x, "map_rom_probe", "map_rom")
+#ifdef CONFIG_MTD_ROM
+extern struct mtd_info *map_rom_probe(struct map_info *);
+#define do_map_rom_probe(map) map_rom_probe(map)
 #else
-	/* without module support, call probe function directly */
-extern struct mtd_info *cfi_probe(struct map_info *);
-extern struct mtd_info *jedec_probe(struct map_info *);
+DECLARE_MAP_PROBE(map_rom_probe, "map_rom")
+#endif
+
+#ifdef CONFIG_MTD_RAM
 extern struct mtd_info *map_ram_probe(struct map_info *);
-extern struct mtd_info *map_rom_probe(struct map_info *);
+#define do_map_ram_probe(map) map_ram_probe(map)
+#else
+DECLARE_MAP_PROBE(map_ram_probe, "map_ram")
+#endif
 
-#define do_cfi_probe(x) cfi_probe(x)
-#define do_jedec_probe(x) jedec_probe(x)
-#define do_ram_probe(x) map_ram_probe(x)
-#define do_rom_probe(x) map_rom_probe(x)
+#ifdef CONFIG_MTD_JEDEC
+extern struct mtd_info *jedec_probe(struct map_info *);
+#define do_jedec_probe(map) jedec_probe(map)
+#else
+DECLARE_MAP_PROBE(jedec_probe, "jedec")
+#endif
+
+#ifdef CONFIG_MTD_AMDSTD
+extern struct mtd_info *amd_flash_probe(struct map_info *);
+#define do_amd_flash_probe(map) amd_flash_probe(map)
+#else
+DECLARE_MAP_PROBE(amd_flash_probe, "amd_flash")
 #endif
 
+#undef DECLARE_MAP_PROBE
+
 /*
  * Destroy an MTD device which was created for a map device.
  * Make sure the MTD device is already unregistered before calling this
@@ -104,7 +137,8 @@
 	struct map_info *map = mtd->priv;
 
 	map->fldrv_destroy(mtd);
-	inter_module_put(map->im_name);
+	if (map->im_name)
+		inter_module_put(map->im_name);
 	kfree(mtd);
 }
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/mtd.h linux-2.4.2/include/linux/mtd/mtd.h
--- linux-2.4.2.orig/include/linux/mtd/mtd.h	Fri Dec 29 23:07:24 2000
+++ linux-2.4.2/include/linux/mtd/mtd.h	Thu Jan 10 18:30:48 2002
@@ -1,5 +1,5 @@
 
-/* $Id: mtd.h,v 1.26 2000/10/30 17:18:04 sjhill Exp $ */
+/* $Id: mtd.h,v 1.30 2001/03/23 23:09:48 kd Exp $ */
 
 #ifndef __MTD_MTD_H__
 #define __MTD_MTD_H__
@@ -16,13 +16,13 @@
 #endif /* __KERNEL__ */
 
 struct erase_info_user {
-	unsigned long start;
-	unsigned long length;
+	u_int32_t start;
+	u_int32_t length;
 };
 
 struct mtd_oob_buf {
-	loff_t start;
-	ssize_t length;
+	u_int32_t start;
+	u_int32_t length;
 	unsigned char *ptr;
 };
 
@@ -68,13 +68,20 @@
 
 struct mtd_info_user {
 	u_char type;
-	u_long flags;
-	u_long size;	 // Total size of the MTD
-	u_long erasesize;
-	u_long oobblock;  // Size of OOB blocks (e.g. 512)
-	u_long oobsize;   // Amount of OOB data per block (e.g. 16)
-        u_long ecctype;
-        u_long eccsize;
+	u_int32_t flags;
+	u_int32_t size;	 // Total size of the MTD
+	u_int32_t erasesize;
+	u_int32_t oobblock;  // Size of OOB blocks (e.g. 512)
+	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+        u_int32_t ecctype;
+        u_int32_t eccsize;
+};
+
+struct region_info_user {
+	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
+	u_int32_t erasesize;		/* For this region */
+	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
+	u_int32_t regionindex;
 };
 
 #define MEMGETINFO              _IOR('M', 1, struct mtd_info_user)
@@ -83,11 +90,14 @@
 #define MEMREADOOB              _IOWR('M', 4, struct mtd_oob_buf)
 #define MEMLOCK                 _IOW('M', 5, struct erase_info_user)
 #define MEMUNLOCK               _IOW('M', 6, struct erase_info_user)
+#define MEMGETREGIONCOUNT	_IOW('M', 7, int)
+#define MEMGETREGIONINFO	_IOW('M', 8, struct region_info_user)
 
 #ifndef __KERNEL__
 
 typedef struct mtd_info_user mtd_info_t;
 typedef struct erase_info_user erase_info_t;
+typedef struct region_info_user region_info_t;
 
 	/* User-space ioctl definitions */
 
@@ -103,8 +113,8 @@
 
 struct erase_info {
 	struct mtd_info *mtd;
-	u_long addr;
-	u_long len;
+	u_int32_t addr;
+	u_int32_t len;
 	u_long time;
 	u_long retries;
 	u_int dev;
@@ -115,22 +125,38 @@
 	struct erase_info *next;
 };
 
+struct mtd_erase_region_info {
+	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
+	u_int32_t erasesize;		/* For this region */
+	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
+};
 
 struct mtd_info {
 	u_char type;
-	u_long flags;
-	u_long size;	 // Total size of the MTD
-	u_long erasesize;
-	u_long oobblock;  // Size of OOB blocks (e.g. 512)
-	u_long oobsize;   // Amount of OOB data per block (e.g. 16)
-        u_long ecctype;
-        u_long eccsize;
+	u_int32_t flags;
+	u_int32_t size;	 // Total size of the MTD
+
+	/* "Major" erase size for the device. Nave users may take this
+	 * to be the only erase size available, or may use the more detailed
+	 * information below if they desire
+	 */
+	u_int32_t erasesize;
+
+	u_int32_t oobblock;  // Size of OOB blocks (e.g. 512)
+	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+        u_int32_t ecctype;
+        u_int32_t eccsize;
 
 	// Kernel-only stuff starts here.
 	char *name;
 	int index;
+	u_int32_t bank_size;
+
+	/* Data for variable erase regions. If numeraseregions is zero, it means that
+	 * the whole device has erasesize as given above. */
+	int numeraseregions;
+	struct mtd_erase_region_info *eraseregions; 
 
-	u_long bank_size;
 
 	struct module *module;
 	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
@@ -140,7 +166,6 @@
 
 	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
 	void (*unpoint) (struct mtd_info *mtd, u_char * addr);
-
 
 	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
diff -Naur linux-2.4.2.orig/include/linux/mtd/nand_ecc.h linux-2.4.2/include/linux/mtd/nand_ecc.h
--- linux-2.4.2.orig/include/linux/mtd/nand_ecc.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.2/include/linux/mtd/nand_ecc.h	Thu Jan 10 18:30:48 2002
@@ -0,0 +1,28 @@
+/*
+ *  drivers/mtd/nand_ecc.h
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * $Id: nand_ecc.h,v 1.1 2000/10/12 00:57:15 sjhill Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file is the header for the ECC algorithm.
+ */
+
+/*
+ * Creates non-inverted ECC code from line parity
+ */
+void nand_trans_result(u_char reg2, u_char reg3, u_char *ecc_code);
+
+/*
+ * Calculate 3 byte ECC code for 256 byte block
+ */
+void nand_calculate_ecc (const u_char *dat, u_char *ecc_code);
+
+/*
+ * Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc);
diff -Naur linux-2.4.2.orig/include/linux/mtd/nftl.h linux-2.4.2/include/linux/mtd/nftl.h
--- linux-2.4.2.orig/include/linux/mtd/nftl.h	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/include/linux/mtd/nftl.h	Thu Jan 10 18:30:48 2002
@@ -2,7 +2,7 @@
 /* Defines for NAND Flash Translation Layer  */
 /* (c) 1999 Machine Vision Holdings, Inc.    */
 /* Author: David Woodhouse <dwmw2@mvhi.com>  */
-/* $Id: nftl.h,v 1.9 2000/11/07 05:48:49 ollie Exp $ */
+/* $Id: nftl.h,v 1.10 2000/12/29 00:25:38 dwmw2 Exp $ */
 
 #ifndef __MTD_NFTL_H__
 #define __MTD_NFTL_H__
@@ -115,6 +115,7 @@
 
 #define MAX_NFTLS 16
 #define MAX_SECTORS_PER_UNIT 32
+#define NFTL_PARTN_BITS 4
 
 #endif /* __KERNEL__ */
 
diff -Naur linux-2.4.2.orig/include/linux/mtd/partitions.h linux-2.4.2/include/linux/mtd/partitions.h
--- linux-2.4.2.orig/include/linux/mtd/partitions.h	Mon Dec 11 23:57:58 2000
+++ linux-2.4.2/include/linux/mtd/partitions.h	Thu Jan 10 18:30:48 2002
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: partitions.h,v 1.3 2000/11/10 23:35:12 nico Exp $
+ * $Id: partitions.h,v 1.6 2001/03/17 17:10:21 dwmw2 Exp $
  */
 
 #ifndef MTD_PARTITIONS_H
@@ -22,10 +22,11 @@
  *
  * For each partition, these fields are available:
  * name: string that will be used to label the partition's MTD device.
- * size: the partition size; if 0, the partition will extend to the end of the 
- * 	master MTD device.
- * offset: absolute starting position within the master MTD device; if 0,
- * 	partition will start where the previous one ended.
+ * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition 
+ * 	will extend to the end of the master MTD device.
+ * offset: absolute starting position within the master MTD device; if 
+ * 	defined as MTDPART_OFS_APPEND, the partition will start where the 
+ * 	previous one ended.
  * mask_flags: contains flags that have to be masked (removed) from the 
  * 	master MTD flag set for the corresponding MTD partition.
  * 	For example, to force a read-only partition, simply adding 
@@ -37,10 +38,13 @@
 
 struct mtd_partition {
 	char *name;		/* identifier string */
-	u_long size;		/* partition size */
-	u_long offset;		/* offset within the master MTD space */
-	u_long mask_flags;	/* master MTD flags to mask out for this partition */
+	u_int32_t size;		/* partition size */
+	u_int32_t offset;		/* offset within the master MTD space */
+	u_int32_t mask_flags;	/* master MTD flags to mask out for this partition */
 };
+
+#define MTDPART_OFS_APPEND	(-1)
+#define MTDPART_SIZ_FULL	(0)
 
 
 int add_mtd_partitions(struct mtd_info *, struct mtd_partition *, int);
diff -Naur linux-2.4.2.orig/include/linux/sched.h linux-2.4.2/include/linux/sched.h
--- linux-2.4.2.orig/include/linux/sched.h	Thu Feb 22 01:09:58 2001
+++ linux-2.4.2/include/linux/sched.h	Thu Jan 10 18:30:48 2002
@@ -534,7 +534,8 @@
 extern unsigned long volatile jiffies;
 extern unsigned long itimer_ticks;
 extern unsigned long itimer_next;
-extern struct timeval xtime;
+/* extern struct timeval xtime; */
+extern volatile struct timeval xtime __attribute__ ((aligned (16)));
 extern void do_timer(struct pt_regs *);
 
 extern unsigned int * prof_buffer;
