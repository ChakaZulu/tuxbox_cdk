diff -r -u -N procps-old/Makefile procps-010114/Makefile
--- procps-old/Makefile	Sat Jan 13 12:00:48 2001
+++ procps-010114/Makefile	Tue Mar 19 14:35:09 2002
@@ -32,16 +32,16 @@
 SUBDIRS    =  ps # sub-packages to build/install
 
 # easy to command-line override
-export INCDIRS    =  -I/usr/include/ncurses -I/usr/X11R6/include
+#export INCDIRS    =  -I/usr/include/ncurses -I/usr/X11R6/include
 
-export CC         =  gcc #-ggdb # this gets compiling and linking :-)
+#export CC         =  gcc #-ggdb # this gets compiling and linking :-)
 export OPT        =  -O2
-export CFLAGS     =  -D_GNU_SOURCE $(OPT) -I$(shell pwd) $(INCDIRS) -W -Wall -Wstrict-prototypes -Wshadow -Wcast-align -Wmissing-prototypes
+#export CFLAGS     =  -D_GNU_SOURCE $(OPT) -I$(shell pwd) $(INCDIRS) -W -Wall -Wstrict-prototypes -Wshadow -Wcast-align -Wmissing-prototypes
 
-export SHARED     =  1# build/install both a static and ELF shared library
-export SHLIBDIR   =  $(DESTDIR)/lib# where to install the shared library
+#export SHARED     =  1# build/install both a static and ELF shared library
+#export SHLIBDIR   =  $(DESTDIR)/lib# where to install the shared library
 
-export LDFLAGS    =  -Wl,-warn-common #-s	recommended for ELF systems
+#export LDFLAGS    =  -Wl,-warn-common #-s	recommended for ELF systems
 #LDFLAGS    =  -qmagic -s#		recommended for a.out systems
 #LDFLAGS    =  -Xlinker -qmagic -s#	older a.out systems may need this
 #LDFLAGS    =  -N -s#			still older a.out systems use this
diff -r -u -N procps-old/proc/proc/compare.h procps-010114/proc/proc/compare.h
--- procps-old/proc/proc/compare.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/compare.h	Tue Sep  7 23:33:45 1999
@@ -0,0 +1,9 @@
+typedef int (*cmp_t)(void*,void*);       /* for function pointer casts */
+
+extern void register_sort_function (int dir, cmp_t func);
+extern void reset_sort_options(void);
+extern int mult_lvl_cmp(void* a, void* b);
+extern int node_mult_lvl_cmp(void* a, void* b);
+extern const char *parse_sort_opt(const char* opt);
+extern const char *parse_long_sort(const char* opt);
+
diff -r -u -N procps-old/proc/proc/devname.h procps-010114/proc/proc/devname.h
--- procps-old/proc/proc/devname.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/devname.h	Sun Aug  2 12:39:09 1998
@@ -0,0 +1,7 @@
+#define ABBREV_DEV  1     /* remove /dev/         */
+#define ABBREV_TTY  2     /* remove tty           */
+#define ABBREV_PTS  4     /* remove pts/          */
+
+int dev_to_tty(char *ret, int chop, int dev, int pid, unsigned int flags);
+
+int tty_to_dev(char *name);
diff -r -u -N procps-old/proc/proc/procps.h procps-010114/proc/proc/procps.h
--- procps-old/proc/proc/procps.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/procps.h	Sat Jan 13 10:15:59 2001
@@ -0,0 +1,27 @@
+/* The shadow of the original with only common prototypes now. */
+#include <stdio.h>
+#include <sys/types.h>
+
+/* The HZ constant from <asm/param.h> is replaced by the Hertz variable
+ * available from "proc/sysinfo.h".
+ */
+
+/* get page info */
+#include <asm/page.h>
+
+void *xrealloc(void *oldp, unsigned int size);
+void *xmalloc(unsigned int size);
+void *xcalloc(void *pointer, int size);
+       
+int   mult_lvl_cmp(void* a, void* b);
+int   node_mult_lvl_cmp(void* a, void* b);
+       
+char *user_from_uid(uid_t uid);
+char *group_from_gid(gid_t gid);
+
+const char * wchan(unsigned long address);
+int   open_psdb(const char *override);
+int   open_psdb_message(const char *override, void (*message)(const char *, ...));
+
+unsigned print_str    (FILE* file, char *s, unsigned max);
+unsigned print_strlist(FILE* file, char **strs, char* sep, unsigned max);
diff -r -u -N procps-old/proc/proc/readproc.h procps-010114/proc/proc/readproc.h
--- procps-old/proc/proc/readproc.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/readproc.h	Mon Feb 21 16:35:57 2000
@@ -0,0 +1,200 @@
+#ifndef PROCPS_PROC_READPROC_H
+#define PROCPS_PROC_READPROC_H
+/*
+ * New Interface to Process Table -- PROCTAB Stream (a la Directory streams)
+ * Copyright (C) 1996 Charles L. Blake.
+ * Copyright (C) 1998 Michael K. Johnson
+ * May be distributed under the terms of the
+ * GNU Library General Public License, a copy of which is provided
+ * in the file COPYING
+ */
+
+
+#define SIGNAL_STRING
+
+
+/*
+ ld	cutime, cstime, priority, nice, timeout, it_real_value, rss,
+ c	state,
+ d	ppid, pgrp, session, tty, tpgid,
+ s	signal, blocked, sigignore, sigcatch,
+ lu	flags, min_flt, cmin_flt, maj_flt, cmaj_flt, utime, stime,
+ lu	rss_rlim, start_code, end_code, start_stack, kstk_esp, kstk_eip,
+ lu	start_time, vsize, wchan, nswap, cnswap,
+*/
+
+/* Basic data structure which holds all information we can get about a process.
+ * (unless otherwise specified, fields are read from /proc/#/stat)
+ *
+ * Most of it comes from task_struct in linux/sched.h
+ */
+typedef struct proc_s {
+#ifdef SIGNAL_STRING
+    char
+	/* Linux 2.1.7x and up have more signals. This handles 88. */
+	signal[24],	/* mask of pending signals */
+	blocked[24],	/* mask of blocked signals */
+	sigignore[24],	/* mask of ignored signals */
+	sigcatch[24];	/* mask of caught  signals */
+#else
+    long long
+	/* Linux 2.1.7x and up have more signals. This handles 64. */
+	signal,		/* mask of pending signals */
+	blocked,	/* mask of blocked signals */
+	sigignore,	/* mask of ignored signals */
+	sigcatch;	/* mask of caught  signals */
+#endif
+    long
+	cutime,		/* cumulative utime of process and reaped children */
+	cstime,		/* cumulative stime of process and reaped children */
+	priority,	/* kernel scheduling priority */
+	timeout,	/* ? */
+	nice,		/* standard unix nice level of process */
+	rss,		/* resident set size from /proc/#/stat (pages) */
+	it_real_value,	/* ? */
+    /* the next 7 members come from /proc/#/statm */
+	size,		/* total # of pages of memory */
+	resident,	/* number of resident set (non-swapped) pages (4k) */
+	share,		/* number of pages of shared (mmap'd) memory */
+	trs,		/* text resident set size */
+	lrs,		/* shared-lib resident set size */
+	drs,		/* data resident set size */
+	dt;		/* dirty pages */
+    unsigned long
+	/* FIXME: are these longs? Maybe when the alpha does PCI bounce buffers */
+	vm_size,        /* same as vsize in kb */
+	vm_lock,        /* locked pages in kb */
+	vm_rss,         /* same as rss in kb */
+	vm_data,        /* data size */
+	vm_stack,       /* stack size */
+	vm_exe,         /* executable size */
+	vm_lib,         /* library size (all pages, not just used ones) */
+	vsize,		/* number of pages of virtual memory ... */
+	rss_rlim,	/* resident set size limit? */
+	flags,		/* kernel flags for the process */
+	min_flt,	/* number of minor page faults since process start */
+	maj_flt,	/* number of major page faults since process start */
+	cmin_flt,	/* cumulative min_flt of process and child processes */
+	cmaj_flt,	/* cumulative maj_flt of process and child processes */
+	nswap,		/* ? */
+	cnswap,		/* cumulative nswap ? */
+	utime,		/* user-mode CPU time accumulated by process */
+	stime,		/* kernel-mode CPU time accumulated by process */
+	start_code,	/* address of beginning of code segment */
+	end_code,	/* address of end of code segment */
+	start_stack,	/* address of the bottom of stack for the process */
+	kstk_esp,	/* kernel stack pointer */
+	kstk_eip,	/* kernel instruction pointer */
+	start_time,	/* start time of process -- seconds since 1-1-70 */
+	wchan;		/* address of kernel wait channel proc is sleeping in */
+    struct proc_s *l,	/* ptrs for building arbitrary linked structs */
+                  *r;	/* (i.e. singly/doubly-linked lists and trees */
+    char
+	**environ,	/* environment string vector (/proc/#/environ) */
+	**cmdline;	/* command line string vector (/proc/#/cmdline) */
+    char
+	/* Be compatible: Digital allows 16 and NT allows 14 ??? */
+    	ruser[16],	/* real user name */
+    	euser[16],	/* effective user name */
+    	suser[16],	/* saved user name */
+    	fuser[16],	/* filesystem user name */
+    	rgroup[16],	/* real group name */
+    	egroup[16],	/* effective group name */
+    	sgroup[16],	/* saved group name */
+    	fgroup[16],	/* filesystem group name */
+    	cmd[16];	/* basename of executable file in call to exec(2) */
+    int
+        ruid, rgid,     /* real      */
+        euid, egid,     /* effective */
+        suid, sgid,     /* saved     */
+        fuid, fgid,     /* fs (used for file access only) */
+    	pid,		/* process id */
+    	ppid,		/* pid of parent process */
+	pgrp,		/* process group id */
+	session,	/* session id */
+	tty,		/* full device number of controlling terminal */
+	tpgid,		/* terminal process group id */
+	exit_signal,	/* might not be SIGCHLD */
+	processor;      /* current (or most recent?) CPU */
+    unsigned
+        pcpu;           /* %CPU usage (is not filled in by readproc!!!) */
+    char
+    	state;		/* single-char code for process state (S=sleeping) */
+} proc_t;
+
+/* PROCTAB: data structure holding the persistent information readproc needs
+ * from openproc().  The setup is intentionally similar to the dirent interface
+ * and other system table interfaces (utmp+wtmp come to mind).
+ */
+#include <sys/types.h>
+#include <dirent.h>
+#include <unistd.h>
+typedef struct {
+    DIR*	procfs;
+    int		flags;
+    pid_t*	pids;	/* pids of the procs */
+    dev_t*	ttys;	/* devnos of the cttys */
+    uid_t*	uids;	/* uids of procs */
+    int		nuid;	/* cannot really sentinel-terminate unsigned short[] */
+    char*	stats;	/* status chars (actually output into /proc//stat) */
+} PROCTAB;
+
+/* initialize a PROCTAB structure holding needed call-to-call persistent data
+ */
+PROCTAB* openproc(int flags, ... /* pid_t*|uid_t*|dev_t*|char* [, int n] */ );
+
+
+/* Convenient wrapper around openproc and readproc to slurp in the whole process
+ * table subset satisfying the constraints of flags and the optional PID list.
+ * Free allocated memory with freeproctab().  Access via tab[N]->member.  The
+ * pointer list is NULL terminated.
+ */
+proc_t** readproctab(int flags, ... /* same as openproc */ );
+
+/* clean-up open files, etc from the openproc()
+ */
+void closeproc(PROCTAB* PT);
+
+/* retrieve the next process matching the criteria set by the openproc()
+ */
+proc_t* readproc(PROCTAB* PT, proc_t* return_buf);
+proc_t* ps_readproc(PROCTAB* PT, proc_t* return_buf);
+
+void look_up_our_self(proc_t *p);
+
+/* deallocate space allocated by readproc
+ */
+void freeproc(proc_t* p);
+
+/* openproc/readproctab:
+ *   
+ * Return PROCTAB* / *proc_t[] or NULL on error ((probably) "/proc" cannot be
+ * opened.)  By default readproc will consider all processes as valid to parse
+ * and return, but not actually fill in the cmdline, environ, and /proc/#/statm
+ * derived memory fields.
+ *
+ * `flags' (a bitwise-or of PROC_* below) modifies the default behavior.  The
+ * "fill" options will cause more of the proc_t to be filled in.  The "filter"
+ * options all use the second argument as the pointer to a list of objects:
+ * process status', process id's, user id's, and tty device numbers.  The third
+ * argument is the length of the list (currently only used for lists of user
+ * id's since unsigned short[] supports no convenient termination sentinel.)
+ */
+#define PROC_FILLANY    0x00 /* either stat or status will do */
+#define PROC_FILLMEM    0x01 /* read statm into the appropriate proc_t entries */
+#define PROC_FILLCMD    0x02 /* alloc and fill in `cmdline' part of proc_t */
+#define PROC_FILLENV    0x04 /* alloc and fill in `environ' part of proc_t */
+#define PROC_FILLUSR    0x08 /* resolve user id number -> user name via passwd */
+#define PROC_FILLSTATUS 0x10
+#define PROC_FILLSTAT   0x20
+#define PROC_FILLBUG    0x3f    /* No idea what we need */
+
+
+/* Obsolete, consider only processes with one of the passed: */
+#define PROC_PID     0x0100  /* process id numbers ( 0   terminated) */
+#define PROC_TTY     0x0200  /* ctty device nos.   ( 0   terminated) */
+#define PROC_UID     0x0400  /* user id numbers    ( length needed ) */
+#define PROC_STAT    0x0800  /* status fields      ('\0' terminated) */
+#define PROC_ANYTTY  0x1000  /* proc must have a controlling terminal */
+
+#endif
diff -r -u -N procps-old/proc/proc/sig.h procps-010114/proc/proc/sig.h
--- procps-old/proc/proc/sig.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/sig.h	Wed Sep  8 21:45:25 1999
@@ -0,0 +1,19 @@
+/*
+ * Copyright 1998 by Albert Cahalan; all rights resered.
+ * This file may be used subject to the terms and conditions of the
+ * GNU Library General Public License Version 2, or any later version
+ * at your option, as published by the Free Software Foundation.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Library General Public License for more details.
+ */
+
+/* return -1 on failure */
+extern int signal_name_to_number(char *name);
+
+extern int print_given_signals(int argc, char *argv[], int max_line);
+
+extern void pretty_print_signals(void);
+
+extern void unix_print_signals(void);
diff -r -u -N procps-old/proc/proc/status.h procps-010114/proc/proc/status.h
--- procps-old/proc/proc/status.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/status.h	Sat Aug 14 18:19:53 1999
@@ -0,0 +1,4 @@
+#ifndef __PROC_STATUS_H
+#define __PROC_STATUS_H
+extern char *status(proc_t* task);
+#endif
diff -r -u -N procps-old/proc/proc/sysinfo.h procps-010114/proc/proc/sysinfo.h
--- procps-old/proc/proc/sysinfo.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/sysinfo.h	Sat Jan 13 10:00:03 2001
@@ -0,0 +1,40 @@
+#ifndef SYSINFO_H
+#define SYSINFO_H
+
+extern unsigned long Hertz;   /* clock tick frequency */
+extern long smp_num_cpus;     /* number of CPUs */
+
+#define JT double
+extern void four_cpu_numbers(JT *uret, JT *nret, JT *sret, JT *iret);
+#undef JT
+
+extern int        uptime (double *uptime_secs, double *idle_secs);
+extern void       loadavg(double *av1, double *av5, double *av15);
+
+
+/* obsolete */
+extern unsigned kb_main_shared;
+/* old but still kicking -- the important stuff */
+extern unsigned kb_main_buffers;
+extern unsigned kb_main_cached;
+extern unsigned kb_main_free;
+extern unsigned kb_main_total;
+extern unsigned kb_swap_free;
+extern unsigned kb_swap_total;
+/* recently introduced */
+extern unsigned kb_high_free;
+extern unsigned kb_high_total;
+extern unsigned kb_low_free;
+extern unsigned kb_low_total;
+/* 2.4.xx era */
+extern unsigned kb_active;
+extern unsigned kb_inact_dirty;
+extern unsigned kb_inact_clean;
+extern unsigned kb_inact_target;
+/* derived values */
+extern unsigned kb_swap_used;
+extern unsigned kb_main_used;
+
+extern void meminfo(void);
+
+#endif /* SYSINFO_H */
diff -r -u -N procps-old/proc/proc/tree.h procps-010114/proc/proc/tree.h
--- procps-old/proc/proc/tree.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/tree.h	Sat Aug 14 18:05:54 1999
@@ -0,0 +1,15 @@
+/* for oldps.c and proc/compare.c */
+struct tree_node {
+    proc_t *proc;
+    pid_t pid;
+    pid_t ppid;
+    char *line;
+    char *cmd;
+    char **cmdline;
+    char **environ;
+    int children;
+    int maxchildren;
+    int *child;
+    int have_parent;
+};
+
diff -r -u -N procps-old/proc/proc/version.h procps-010114/proc/proc/version.h
--- procps-old/proc/proc/version.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/version.h	Fri Mar  5 22:10:25 1999
@@ -0,0 +1,23 @@
+#ifndef PROC_VERSION_H
+#define PROC_VERSION_H
+
+/* Suite version information for procps utilities
+ * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
+ * Linux kernel version information for procps utilities
+ * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
+ * Distributable under the terms of the GNU Library General Public License
+ */
+
+extern void display_version(void);	/* display suite version */
+extern char procps_version[];		/* global buf for suite version */
+
+extern int linux_version_code;		/* runtime version of LINUX_VERSION_CODE
+					   in /usr/include/linux/version.h */
+
+/* Convenience macros for composing/decomposing version codes */
+#define LINUX_VERSION(x,y,z)   (0x10000*(x) + 0x100*(y) + z)
+#define LINUX_VERSION_MAJOR(x) (((x)>>16) & 0xFF)
+#define LINUX_VERSION_MINOR(x) (((x)>> 8) & 0xFF)
+#define LINUX_VERSION_PATCH(x) ( (x)      & 0xFF)
+
+#endif	/* PROC_VERSION_H */
diff -r -u -N procps-old/proc/proc/whattime.h procps-010114/proc/proc/whattime.h
--- procps-old/proc/proc/whattime.h	Thu Jan  1 01:00:00 1970
+++ procps-010114/proc/proc/whattime.h	Fri Jul 10 23:04:00 1998
@@ -0,0 +1,9 @@
+/* whattime.h --- see whattime.c for explanation */
+
+#ifndef __WHATTIME_H
+#define __WHATTIME_H
+
+extern void print_uptime(void);
+extern char *sprint_uptime(void);
+
+#endif
