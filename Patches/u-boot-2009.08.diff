diff -uNr u-boot-2009.08-rc1.org/common/cmd_bootm.c u-boot-2009.08-rc1/common/cmd_bootm.c
--- u-boot-2009.08-rc1.org/common/cmd_bootm.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_bootm.c	2009-07-27 15:48:23.000000000 +0200
@@ -701,7 +701,7 @@
 	image_header_t *hdr = (image_header_t *)img_addr;
 
 	if (!image_check_magic(hdr)) {
-		puts ("Bad Magic Number\n");
+		puts ("u-boot: Bad Magic Number *** THIS IS NOT THE FAMOUS dbox2 'Bad Magic' ***\n");
 		show_boot_progress (-1);
 		return NULL;
 	}
diff -uNr u-boot-2009.08-rc1.org/common/cmd_flash.c u-boot-2009.08-rc1/common/cmd_flash.c
--- u-boot-2009.08-rc1.org/common/cmd_flash.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_flash.c	2009-07-27 15:48:23.000000000 +0200
@@ -491,6 +491,8 @@
 		p = 0;
 	} else if (strcmp(argv[1], "on") == 0) {
 		p = 1;
+	} else if (strcmp(argv[1], "ld") == 0) {
+		p = 2;
 	} else {
 		cmd_usage(cmdtp);
 		return 1;
diff -uNr u-boot-2009.08-rc1.org/common/cmd_fs.c u-boot-2009.08-rc1/common/cmd_fs.c
--- u-boot-2009.08-rc1.org/common/cmd_fs.c	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_fs.c	2009-07-27 15:48:23.000000000 +0200
@@ -32,43 +32,43 @@
 #include <s_record.h>
 #include <net.h>
 
-#if (CONFIG_COMMANDS & CFG_FS_CRAMFS) || (CONFIG_FS & CFG_FS_CRAMFS)
+#if defined(CONFIG_CMD_CRAMFS)
 int cramfs_load (char *loadoffset, struct part_info *info, char *filename);
 int cramfs_ls (struct part_info *info, char *filename);
 int cramfs_info (struct part_info *info);
 #endif
-#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) || (CONFIG_FS & CFG_FS_JFFS2)
+#if defined(CONFIG_CMD_JFFS2)
 #include <jffs2/jffs2.h>
 #endif
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
+#if defined(CONFIG_CMD_SQUASHFS)
 #include <squashfs/squashfs_fs.h>
 #endif
 
 
-#define MK_FS_PART_TBL_ENTRY(type,offset,size)				\
-	{ type, offset, size }
+#define MK_FS_PART_TBL_ENTRY(type,offset,size,sector_size)				\
+	{ type, offset, size, sector_size }
 
 static part_info_t part_info[] =
 {
 #ifdef CFG_FS_PART0_TYPE
-	MK_FS_PART_TBL_ENTRY(CFG_FS_PART0_TYPE,CFG_FS_PART0_OFFSET,CFG_FS_PART0_SIZE),
+	MK_FS_PART_TBL_ENTRY(CFG_FS_PART0_TYPE,CFG_FS_PART0_OFFSET,CFG_FS_PART0_SIZE, 0x20000),
 #else
-	{ 0, 0, 0 },
+	{ 0, 0, 0, 0 },
 #endif
 #ifdef CFG_FS_PART1_TYPE
-	MK_FS_PART_TBL_ENTRY(CFG_FS_PART1_TYPE,CFG_FS_PART1_OFFSET,CFG_FS_PART1_SIZE),
+	MK_FS_PART_TBL_ENTRY(CFG_FS_PART1_TYPE,CFG_FS_PART1_OFFSET,CFG_FS_PART1_SIZE, 0x20000),
 #else
-	{ 0, 0, 0 },
+	{ 0, 0, 0, 0 },
 #endif
 #ifdef CFG_FS_PART2_TYPE
-	MK_FS_PART_TBL_ENTRY(CFG_FS_PART2_TYPE,CFG_FS_PART2_OFFSET,CFG_FS_PART2_SIZE),
+	MK_FS_PART_TBL_ENTRY(CFG_FS_PART2_TYPE,CFG_FS_PART2_OFFSET,CFG_FS_PART2_SIZE, 0x20000),
 #else
-	{ 0, 0, 0 },
+	{ 0, 0, 0, 0 },
 #endif
 #ifdef CFG_FS_PART3_TYPE
-	MK_FS_PART_TBL_ENTRY(CFG_FS_PART3_TYPE,CFG_FS_PART3_OFFSET,CFG_FS_PART3_SIZE),
+	MK_FS_PART_TBL_ENTRY(CFG_FS_PART3_TYPE,CFG_FS_PART3_OFFSET,CFG_FS_PART3_SIZE, 0x20000),
 #else
-	{ 0, 0, 0 },
+	{ 0, 0, 0, 0 },
 #endif
 };
 
@@ -76,7 +76,7 @@
 {
 	part_info_t *part = part_info;
 	char *filename = "vmlinuz";
-	ulong offset = CFG_LOAD_ADDR;
+	ulong offset = CONFIG_SYS_LOAD_ADDR;
 	int size, i;
 
 	if (argc >= 2)
@@ -100,20 +100,20 @@
 
 	switch (part -> type)
 	{
-#if (CONFIG_FS & CFG_FS_JFFS2)
-		case CFG_FS_JFFS2:
+#if defined(CONFIG_CMD_JFFS2)
+		case CONFIG_FS_JFFS2:
 			printf ("### FS (jffs2) loading '%s' to 0x%lx\n", filename, offset);
 			size = jffs2_1pass_load ((char *) offset, part, filename);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_CRAMFS)
-		case CFG_FS_CRAMFS:
+#if defined(CONFIG_CMD_CRAMFS)
+		case CONFIG_FS_CRAMFS:
 			printf ("### FS (cramfs) loading '%s' to 0x%lx\n", filename, offset);
 			size = cramfs_load ((char *) offset, part, filename);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
-		case CFG_FS_SQUASHFS:
+#if defined(CONFIG_CMD_SQUASHFS)
+		case CONFIG_FS_SQUASHFS:
 			printf ("### FS (squashfs) loading '%s' to 0x%lx\n", filename, offset);
 			size = squashfs_load ((char *) offset, part, filename);
 			break;
@@ -156,18 +156,18 @@
 
 	switch (part -> type)
 	{
-#if (CONFIG_FS & CFG_FS_JFFS2)
-		case CFG_FS_JFFS2:
+#if defined(CONFIG_CMD_JFFS2)
+		case CONFIG_FS_JFFS2:
 			ret = jffs2_1pass_ls (part, filename);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_CRAMFS)
-		case CFG_FS_CRAMFS:
+#if defined(CONFIG_CMD_CRAMFS)
+		case CONFIG_FS_CRAMFS:
 			ret = cramfs_ls (part, filename);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
-		case CFG_FS_SQUASHFS:
+#if defined(CONFIG_CMD_SQUASHFS)
+		case CONFIG_FS_SQUASHFS:
 			ret = squashfs_ls (part, filename);
 			break;
 #endif
@@ -184,21 +184,21 @@
 	printf ("Partition # %d: ", number);
 	switch (part_info[number].type)
 	{
-		case CFG_FS_JFFS2:
+		case CONFIG_FS_JFFS2:
 			puts ("jffs2");
-#if !(CONFIG_FS & CFG_FS_JFFS2)
+#if !defined(CONFIG_CMD_JFFS2)
 			puts (" (unsupported)");
 #endif
 			break;
-		case CFG_FS_CRAMFS:
+		case CONFIG_FS_CRAMFS:
 			puts ("cramfs");
-#if !(CONFIG_FS & CFG_FS_CRAMFS)
+#if !defined(CONFIG_CMD_CRAMFS)
 			puts (" (unsupported)");
 #endif
 			break;
-		case CFG_FS_SQUASHFS:
+		case CONFIG_FS_SQUASHFS:
 			puts ("squashfs");
-#if !(CONFIG_FS & CFG_FS_SQUASHFS)
+#if !defined(CONFIG_CMD_SQUASHFS)
 			puts (" (unsupported)");
 #endif
 			break;
@@ -229,18 +229,18 @@
 	if (part)
 		switch (part -> type)
 		{
-#if (CONFIG_FS & CFG_FS_JFFS2)
-			case CFG_FS_JFFS2:
+#if defined(CONFIG_CMD_JFFS2)
+			case CONFIG_FS_JFFS2:
 				ret = jffs2_1pass_info (part);
 				break;
 #endif
-#if (CONFIG_FS & CFG_FS_CRAMFS)
-			case CFG_FS_CRAMFS:
+#if defined(CONFIG_CMD_CRAMFS)
+			case CONFIG_FS_CRAMFS:
 				ret = cramfs_info (part);
 				break;
 #endif
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
-			case CFG_FS_SQUASHFS:
+#if defined(CONFIG_CMD_SQUASHFS)
+			case CONFIG_FS_SQUASHFS:
 				ret = squashfs_info (part);
 				break;
 #endif
@@ -278,18 +278,18 @@
 
 	switch (part -> type)
 	{
-#if (CONFIG_FS & CFG_FS_JFFS2)
-		case CFG_FS_JFFS2:
+#if defined(CONFIG_CMD_JFFS2)
+		case CONFIG_FS_JFFS2:
 			size = jffs2_1pass_load ((char *) offset, part, temp);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_CRAMFS)
-		case CFG_FS_CRAMFS:
+#if defined(CONFIG_CMD_CRAMFS)
+		case CONFIG_FS_CRAMFS:
 			size = cramfs_load ((char *) offset, part, temp);
 			break;
 #endif
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
-		case CFG_FS_SQUASHFS:
+#if defined(CONFIG_CMD_SQUASHFS)
+		case CONFIG_FS_SQUASHFS:
 			size = squashfs_load ((char *) offset, part, temp);
 			break;
 #endif
diff -uNr u-boot-2009.08-rc1.org/common/cmd_ide.c u-boot-2009.08-rc1/common/cmd_ide.c
--- u-boot-2009.08-rc1.org/common/cmd_ide.c	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_ide.c	2009-07-27 15:48:23.000000000 +0200
@@ -31,33 +31,33 @@
 #include <command.h>
 #include <image.h>
 #include <asm/byteorder.h>
+#include <asm/io.h>
+
 #if defined(CONFIG_IDE_8xx_DIRECT) || defined(CONFIG_IDE_PCMCIA)
 # include <pcmcia.h>
 #endif
+
 #ifdef CONFIG_8xx
 # include <mpc8xx.h>
 #endif
+
 #ifdef CONFIG_MPC5xxx
 #include <mpc5xxx.h>
 #endif
+
 #include <ide.h>
 #include <ata.h>
+
 #ifdef CONFIG_STATUS_LED
 # include <status_led.h>
 #endif
+
 #ifndef __PPC__
 #include <asm/io.h>
-#ifdef __MIPS__
-/* Macros depend on this variable */
-unsigned long mips_io_port_base = 0;
-#endif
 #endif
 
-#ifdef CONFIG_SHOW_BOOT_PROGRESS
-# include <status_led.h>
-# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
-#else
-# define SHOW_BOOT_PROGRESS(arg)
+#ifdef CONFIG_IDE_8xx_DIRECT
+DECLARE_GLOBAL_DATA_PTR;
 #endif
 
 #ifdef __PPC__
@@ -68,8 +68,6 @@
 # define SYNC		/* nothing */
 #endif
 
-#if (CONFIG_COMMANDS & CFG_CMD_IDE)
-
 #ifdef CONFIG_IDE_8xx_DIRECT
 /* Timings for IDE Interface
  *
@@ -98,10 +96,10 @@
 
 static pio_config_t pio_config_clk [IDE_MAX_PIO_MODE+1];
 
-#ifndef	CFG_PIO_MODE
-#define	CFG_PIO_MODE	0		/* use a relaxed default */
+#ifndef	CONFIG_SYS_PIO_MODE
+#define	CONFIG_SYS_PIO_MODE	0		/* use a relaxed default */
 #endif
-static int pio_mode = CFG_PIO_MODE;
+static int pio_mode = CONFIG_SYS_PIO_MODE;
 
 /* Make clock cycles and always round up */
 
@@ -115,25 +113,23 @@
 static int curr_device = -1;
 
 /* Current offset for IDE0 / IDE1 bus access	*/
-ulong ide_bus_offset[CFG_IDE_MAXBUS] = {
-#if defined(CFG_ATA_IDE0_OFFSET)
-	CFG_ATA_IDE0_OFFSET,
+ulong ide_bus_offset[CONFIG_SYS_IDE_MAXBUS] = {
+#if defined(CONFIG_SYS_ATA_IDE0_OFFSET)
+	CONFIG_SYS_ATA_IDE0_OFFSET,
 #endif
-#if defined(CFG_ATA_IDE1_OFFSET) && (CFG_IDE_MAXBUS > 1)
-	CFG_ATA_IDE1_OFFSET,
+#if defined(CONFIG_SYS_ATA_IDE1_OFFSET) && (CONFIG_SYS_IDE_MAXBUS > 1)
+	CONFIG_SYS_ATA_IDE1_OFFSET,
 #endif
 };
 
 
-#define	ATA_CURR_BASE(dev)	(CFG_ATA_BASE_ADDR+ide_bus_offset[IDE_BUS(dev)])
-
 #ifndef CONFIG_AMIGAONEG3SE
-static int ide_bus_ok[CFG_IDE_MAXBUS];
+static int ide_bus_ok[CONFIG_SYS_IDE_MAXBUS];
 #else
-static int ide_bus_ok[CFG_IDE_MAXBUS] = {0,};
+static int ide_bus_ok[CONFIG_SYS_IDE_MAXBUS] = {0,};
 #endif
 
-block_dev_desc_t ide_dev_desc[CFG_IDE_MAXDEVICE];
+block_dev_desc_t ide_dev_desc[CONFIG_SYS_IDE_MAXDEVICE];
 /* ------------------------------------------------------------------------- */
 
 #ifdef CONFIG_IDE_LED
@@ -182,10 +178,13 @@
 #endif
 static void ident_cpy (unsigned char *dest, unsigned char *src, unsigned int len);
 
+#ifndef CONFIG_SYS_ATA_PORT_ADDR
+#define CONFIG_SYS_ATA_PORT_ADDR(port) (port)
+#endif
 
 #ifdef CONFIG_ATAPI
 static void	atapi_inquiry(block_dev_desc_t *dev_desc);
-ulong atapi_read (int device, lbaint_t blknr, ulong blkcnt, ulong *buffer);
+ulong atapi_read (int device, lbaint_t blknr, ulong blkcnt, void *buffer);
 #endif
 
 
@@ -219,7 +218,7 @@
 
 		putc ('\n');
 
-		for (i=0; i<CFG_IDE_MAXDEVICE; ++i) {
+		for (i=0; i<CONFIG_SYS_IDE_MAXDEVICE; ++i) {
 			if (ide_dev_desc[i].type==DEV_TYPE_UNKNOWN)
 				continue; /* list only known devices */
 			printf ("IDE device %d: ", i);
@@ -228,7 +227,7 @@
 		return 0;
 
 	} else if (strncmp(argv[1],"dev",3) == 0) {
-		if ((curr_device < 0) || (curr_device >= CFG_IDE_MAXDEVICE)) {
+		if ((curr_device < 0) || (curr_device >= CONFIG_SYS_IDE_MAXDEVICE)) {
 			puts ("\nno IDE devices available\n");
 			return 1;
 		}
@@ -238,7 +237,7 @@
 	} else if (strncmp(argv[1],"part",4) == 0) {
 		int dev, ok;
 
-		for (ok=0, dev=0; dev<CFG_IDE_MAXDEVICE; ++dev) {
+		for (ok=0, dev=0; dev<CONFIG_SYS_IDE_MAXDEVICE; ++dev) {
 			if (ide_dev_desc[dev].part_type!=PART_TYPE_UNKNOWN) {
 				++ok;
 				if (dev)
@@ -259,7 +258,7 @@
 		int dev = (int)simple_strtoul(argv[2], NULL, 10);
 
 		printf ("\nIDE device %d: ", dev);
-		if (dev >= CFG_IDE_MAXDEVICE) {
+		if (dev >= CONFIG_SYS_IDE_MAXDEVICE) {
 			puts ("unknown device\n");
 			return 1;
 		}
@@ -310,7 +309,7 @@
 		ulong addr = simple_strtoul(argv[2], NULL, 16);
 		ulong cnt  = simple_strtoul(argv[4], NULL, 16);
 		ulong n;
-#ifdef CFG_64BIT_STRTOUL
+#ifdef CONFIG_SYS_64BIT_LBA
 		lbaint_t blk  = simple_strtoull(argv[3], NULL, 16);
 
 		printf ("\nIDE read: device %d block # %qd, count %ld ... ",
@@ -339,7 +338,7 @@
 		ulong addr = simple_strtoul(argv[2], NULL, 16);
 		ulong cnt  = simple_strtoul(argv[4], NULL, 16);
 		ulong n;
-#ifdef CFG_64BIT_STRTOUL
+#ifdef CONFIG_SYS_64BIT_LBA
 		lbaint_t blk  = simple_strtoull(argv[3], NULL, 16);
 
 		printf ("\nIDE write: device %d block # %qd, count %ld ... ",
@@ -374,14 +373,18 @@
 	char *boot_device = NULL;
 	char *ep;
 	int dev, part = 0;
-	ulong addr, cnt, checksum;
+	ulong addr, cnt;
 	disk_partition_t info;
 	image_header_t *hdr;
 	int rcode = 0;
+#if defined(CONFIG_FIT)
+	const void *fit_hdr = NULL;
+#endif
 
+	show_boot_progress (41);
 	switch (argc) {
 	case 1:
-		addr = CFG_LOAD_ADDR;
+		addr = CONFIG_SYS_LOAD_ADDR;
 		boot_device = getenv ("bootdevice");
 		break;
 	case 2:
@@ -394,44 +397,50 @@
 		break;
 	default:
 		printf ("Usage:\n%s\n", cmdtp->usage);
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-42);
 		return 1;
 	}
+	show_boot_progress (42);
 
 	if (!boot_device) {
 		puts ("\n** No boot device **\n");
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-43);
 		return 1;
 	}
+	show_boot_progress (43);
 
 	dev = simple_strtoul(boot_device, &ep, 16);
 
 	if (ide_dev_desc[dev].type==DEV_TYPE_UNKNOWN) {
 		printf ("\n** Device %d not available\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-44);
 		return 1;
 	}
+	show_boot_progress (44);
 
 	if (*ep) {
 		if (*ep != ':') {
 			puts ("\n** Invalid boot device, use `dev[:part]' **\n");
-			SHOW_BOOT_PROGRESS (-1);
+			show_boot_progress (-45);
 			return 1;
 		}
 		part = simple_strtoul(++ep, NULL, 16);
 	}
-	if (get_partition_info (ide_dev_desc, part, &info)) {
-		SHOW_BOOT_PROGRESS (-1);
+	show_boot_progress (45);
+	if (get_partition_info (&ide_dev_desc[dev], part, &info)) {
+		show_boot_progress (-46);
 		return 1;
 	}
+	show_boot_progress (46);
 	if ((strncmp((char *)info.type, BOOT_PART_TYPE, sizeof(info.type)) != 0) &&
 	    (strncmp((char *)info.type, BOOT_PART_COMP, sizeof(info.type)) != 0)) {
 		printf ("\n** Invalid partition type \"%.32s\""
 			" (expect \"" BOOT_PART_TYPE "\")\n",
 			info.type);
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-47);
 		return 1;
 	}
+	show_boot_progress (47);
 
 	printf ("\nLoading from IDE device %d, partition %d: "
 		"Name: %.32s  Type: %.32s\n",
@@ -442,31 +451,42 @@
 
 	if (ide_dev_desc[dev].block_read (dev, info.start, 1, (ulong *)addr) != 1) {
 		printf ("** Read error on %d:%d\n", dev, part);
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-48);
 		return 1;
 	}
+	show_boot_progress (48);
 
-	hdr = (image_header_t *)addr;
+	switch (genimg_get_format ((void *)addr)) {
+	case IMAGE_FORMAT_LEGACY:
+		hdr = (image_header_t *)addr;
 
-	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
-		printf("\n** Bad Magic Number **\n");
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
+		show_boot_progress (49);
+
+		if (!image_check_hcrc (hdr)) {
+			puts ("\n** Bad Header Checksum **\n");
+			show_boot_progress (-50);
+			return 1;
+		}
+		show_boot_progress (50);
 
-	checksum = ntohl(hdr->ih_hcrc);
-	hdr->ih_hcrc = 0;
+		image_print_contents (hdr);
 
-	if (crc32 (0, (uchar *)hdr, sizeof(image_header_t)) != checksum) {
-		puts ("\n** Bad Header Checksum **\n");
-		SHOW_BOOT_PROGRESS (-2);
+		cnt = image_get_image_size (hdr);
+		break;
+#if defined(CONFIG_FIT)
+	case IMAGE_FORMAT_FIT:
+		fit_hdr = (const void *)addr;
+		puts ("Fit image detected...\n");
+
+		cnt = fit_get_size (fit_hdr);
+		break;
+#endif
+	default:
+		show_boot_progress (-49);
+		puts ("** Unknown image type\n");
 		return 1;
 	}
-	hdr->ih_hcrc = htonl(checksum); /* restore checksum for later use */
-
-	print_image_hdr (hdr);
 
-	cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
 	cnt += info.blksz - 1;
 	cnt /= info.blksz;
 	cnt -= 1;
@@ -474,10 +494,23 @@
 	if (ide_dev_desc[dev].block_read (dev, info.start+1, cnt,
 		      (ulong *)(addr+info.blksz)) != cnt) {
 		printf ("** Read error on %d:%d\n", dev, part);
-		SHOW_BOOT_PROGRESS (-1);
+		show_boot_progress (-51);
 		return 1;
 	}
+	show_boot_progress (51);
 
+#if defined(CONFIG_FIT)
+	/* This cannot be done earlier, we need complete FIT image in RAM first */
+	if (genimg_get_format ((void *)addr) == IMAGE_FORMAT_FIT) {
+		if (!fit_check_format (fit_hdr)) {
+			show_boot_progress (-140);
+			puts ("** Bad FIT image format\n");
+			return 1;
+		}
+		show_boot_progress (141);
+		fit_print_contents (fit_hdr);
+	}
+#endif
 
 	/* Loading ok, update default load address */
 
@@ -501,20 +534,55 @@
 
 /* ------------------------------------------------------------------------- */
 
+#ifndef CONFIG_EXTERN_IDE_CODE
+void inline
+__ide_outb(int dev, int port, unsigned char val)
+{
+	debug ("ide_outb (dev= %d, port= 0x%x, val= 0x%02x) : @ 0x%08lx\n",
+		dev, port, val, (ATA_CURR_BASE(dev)+CONFIG_SYS_ATA_PORT_ADDR(port)));
+	outb(val, (ATA_CURR_BASE(dev)+CONFIG_SYS_ATA_PORT_ADDR(port)));
+}
+void inline ide_outb (int dev, int port, unsigned char val)
+		__attribute__((weak, alias("__ide_outb")));
+
+unsigned char inline
+__ide_inb(int dev, int port)
+{
+	uchar val;
+	val = inb((ATA_CURR_BASE(dev)+CONFIG_SYS_ATA_PORT_ADDR(port)));
+	debug ("ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x\n",
+		dev, port, (ATA_CURR_BASE(dev)+CONFIG_SYS_ATA_PORT_ADDR(port)), val);
+	return val;
+}
+unsigned char inline ide_inb(int dev, int port)
+			__attribute__((weak, alias("__ide_inb")));
+#endif
+
+#ifdef CONFIG_TUNE_PIO
+int inline
+__ide_set_piomode(int pio_mode)
+{
+	return 0;
+}
+int inline ide_set_piomode(int pio_mode)
+			__attribute__((weak, alias("__ide_set_piomode")));
+#endif
+
 void ide_init (void)
 {
 
 #ifdef CONFIG_IDE_8xx_DIRECT
-	DECLARE_GLOBAL_DATA_PTR;
-	volatile immap_t *immr = (immap_t *)CFG_IMMR;
+	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
 	volatile pcmconf8xx_t *pcmp = &(immr->im_pcmcia);
 #endif
 	unsigned char c;
 	int i, bus;
+#if defined(CONFIG_AMIGAONEG3SE) || defined(CONFIG_SC3)
+	unsigned int ata_reset_time = ATA_RESET_TIME;
+	char *s;
+#endif
 #ifdef CONFIG_AMIGAONEG3SE
 	unsigned int max_bus_scan;
-	unsigned int ata_reset_time;
-	char *s;
 #endif
 #ifdef CONFIG_IDE_8xx_PCCARD
 	extern int pcmcia_on (void);
@@ -586,17 +654,17 @@
 	 * According to spec, this can take up to 31 seconds!
 	 */
 #ifndef CONFIG_AMIGAONEG3SE
-	for (bus=0; bus<CFG_IDE_MAXBUS; ++bus) {
-		int dev = bus * (CFG_IDE_MAXDEVICE / CFG_IDE_MAXBUS);
+	for (bus=0; bus<CONFIG_SYS_IDE_MAXBUS; ++bus) {
+		int dev = bus * (CONFIG_SYS_IDE_MAXDEVICE / CONFIG_SYS_IDE_MAXBUS);
 #else
 	s = getenv("ide_maxbus");
 	if (s)
 		max_bus_scan = simple_strtol(s, NULL, 10);
 	else
-		max_bus_scan = CFG_IDE_MAXBUS;
+		max_bus_scan = CONFIG_SYS_IDE_MAXBUS;
 
 	for (bus=0; bus<max_bus_scan; ++bus) {
-		int dev = bus * (CFG_IDE_MAXDEVICE / max_bus_scan);
+		int dev = bus * (CONFIG_SYS_IDE_MAXDEVICE / max_bus_scan);
 #endif
 
 #ifdef CONFIG_IDE_8xx_PCCARD
@@ -615,10 +683,9 @@
 		udelay (100000);		/* 100 ms */
 		ide_outb (dev, ATA_DEV_HD, ATA_LBA | ATA_DEVICE(dev));
 		udelay (100000);		/* 100 ms */
-#ifdef CONFIG_AMIGAONEG3SE
-		ata_reset_time = ATA_RESET_TIME;
-		s = getenv("ide_reset_timeout");
-		if (s) ata_reset_time = 2*simple_strtol(s, NULL, 10);
+#if defined(CONFIG_AMIGAONEG3SE) || defined(CONFIG_SC3)
+		if ((s = getenv("ide_reset_timeout")) != NULL)
+			ata_reset_time = simple_strtol(s, NULL, 10);
 #endif
 		i = 0;
 		do {
@@ -626,7 +693,7 @@
 
 			c = ide_inb (dev, ATA_STATUS);
 			i++;
-#ifdef CONFIG_AMIGAONEG3SE
+#if defined(CONFIG_AMIGAONEG3SE) || defined(CONFIG_SC3)
 			if (i > (ata_reset_time * 100)) {
 #else
 			if (i > (ATA_RESET_TIME * 100)) {
@@ -670,7 +737,7 @@
 	ide_led ((LED_IDE1 | LED_IDE2), 0);	/* LED's off	*/
 
 	curr_device = -1;
-	for (i=0; i<CFG_IDE_MAXDEVICE; ++i) {
+	for (i=0; i<CONFIG_SYS_IDE_MAXDEVICE; ++i) {
 #ifdef CONFIG_IDE_LED
 		int led = (IDE_BUS(i) == 0) ? LED_IDE1 : LED_IDE2;
 #endif
@@ -701,7 +768,7 @@
 
 block_dev_desc_t * ide_get_dev(int dev)
 {
-	return ((block_dev_desc_t *)&ide_dev_desc[dev]);
+	return (dev < CONFIG_SYS_IDE_MAXDEVICE) ? &ide_dev_desc[dev] : NULL;
 }
 
 
@@ -710,7 +777,7 @@
 static void
 set_pcmcia_timing (int pmode)
 {
-	volatile immap_t *immr = (immap_t *)CFG_IMMR;
+	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
 	volatile pcmconf8xx_t *pcmp = &(immr->im_pcmcia);
 	ulong timings;
 
@@ -723,33 +790,33 @@
 
 	/* IDE 0
 	 */
-	pcmp->pcmc_pbr0 = CFG_PCMCIA_PBR0;
-	pcmp->pcmc_por0 = CFG_PCMCIA_POR0
-#if (CFG_PCMCIA_POR0 != 0)
+	pcmp->pcmc_pbr0 = CONFIG_SYS_PCMCIA_PBR0;
+	pcmp->pcmc_por0 = CONFIG_SYS_PCMCIA_POR0
+#if (CONFIG_SYS_PCMCIA_POR0 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR0: %08x  POR0: %08x\n", pcmp->pcmc_pbr0, pcmp->pcmc_por0);
 
-	pcmp->pcmc_pbr1 = CFG_PCMCIA_PBR1;
-	pcmp->pcmc_por1 = CFG_PCMCIA_POR1
-#if (CFG_PCMCIA_POR1 != 0)
+	pcmp->pcmc_pbr1 = CONFIG_SYS_PCMCIA_PBR1;
+	pcmp->pcmc_por1 = CONFIG_SYS_PCMCIA_POR1
+#if (CONFIG_SYS_PCMCIA_POR1 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR1: %08x  POR1: %08x\n", pcmp->pcmc_pbr1, pcmp->pcmc_por1);
 
-	pcmp->pcmc_pbr2 = CFG_PCMCIA_PBR2;
-	pcmp->pcmc_por2 = CFG_PCMCIA_POR2
-#if (CFG_PCMCIA_POR2 != 0)
+	pcmp->pcmc_pbr2 = CONFIG_SYS_PCMCIA_PBR2;
+	pcmp->pcmc_por2 = CONFIG_SYS_PCMCIA_POR2
+#if (CONFIG_SYS_PCMCIA_POR2 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR2: %08x  POR2: %08x\n", pcmp->pcmc_pbr2, pcmp->pcmc_por2);
 
-	pcmp->pcmc_pbr3 = CFG_PCMCIA_PBR3;
-	pcmp->pcmc_por3 = CFG_PCMCIA_POR3
-#if (CFG_PCMCIA_POR3 != 0)
+	pcmp->pcmc_pbr3 = CONFIG_SYS_PCMCIA_PBR3;
+	pcmp->pcmc_por3 = CONFIG_SYS_PCMCIA_POR3
+#if (CONFIG_SYS_PCMCIA_POR3 != 0)
 			| timings
 #endif
 			;
@@ -757,33 +824,33 @@
 
 	/* IDE 1
 	 */
-	pcmp->pcmc_pbr4 = CFG_PCMCIA_PBR4;
-	pcmp->pcmc_por4 = CFG_PCMCIA_POR4
-#if (CFG_PCMCIA_POR4 != 0)
+	pcmp->pcmc_pbr4 = CONFIG_SYS_PCMCIA_PBR4;
+	pcmp->pcmc_por4 = CONFIG_SYS_PCMCIA_POR4
+#if (CONFIG_SYS_PCMCIA_POR4 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR4: %08x  POR4: %08x\n", pcmp->pcmc_pbr4, pcmp->pcmc_por4);
 
-	pcmp->pcmc_pbr5 = CFG_PCMCIA_PBR5;
-	pcmp->pcmc_por5 = CFG_PCMCIA_POR5
-#if (CFG_PCMCIA_POR5 != 0)
+	pcmp->pcmc_pbr5 = CONFIG_SYS_PCMCIA_PBR5;
+	pcmp->pcmc_por5 = CONFIG_SYS_PCMCIA_POR5
+#if (CONFIG_SYS_PCMCIA_POR5 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR5: %08x  POR5: %08x\n", pcmp->pcmc_pbr5, pcmp->pcmc_por5);
 
-	pcmp->pcmc_pbr6 = CFG_PCMCIA_PBR6;
-	pcmp->pcmc_por6 = CFG_PCMCIA_POR6
-#if (CFG_PCMCIA_POR6 != 0)
+	pcmp->pcmc_pbr6 = CONFIG_SYS_PCMCIA_PBR6;
+	pcmp->pcmc_por6 = CONFIG_SYS_PCMCIA_POR6
+#if (CONFIG_SYS_PCMCIA_POR6 != 0)
 			| timings
 #endif
 			;
 	debug ("PBR6: %08x  POR6: %08x\n", pcmp->pcmc_pbr6, pcmp->pcmc_por6);
 
-	pcmp->pcmc_pbr7 = CFG_PCMCIA_PBR7;
-	pcmp->pcmc_por7 = CFG_PCMCIA_POR7
-#if (CFG_PCMCIA_POR7 != 0)
+	pcmp->pcmc_pbr7 = CONFIG_SYS_PCMCIA_PBR7;
+	pcmp->pcmc_por7 = CONFIG_SYS_PCMCIA_POR7
+#if (CONFIG_SYS_PCMCIA_POR7 != 0)
 			| timings
 #endif
 			;
@@ -795,52 +862,6 @@
 
 /* ------------------------------------------------------------------------- */
 
-#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA)
-
-#ifndef CONFIG_EXTERN_IDE_CODE
-static void __inline__
-ide_outb(int dev, int port, unsigned char val)
-{
-	debug ("ide_outb (dev= %d, port= 0x%x, val= 0x%02x) : @ 0x%08lx\n",
-		dev, port, val, (ATA_CURR_BASE(dev)+port));
-
-	/* Ensure I/O operations complete */
-	EIEIO;
-	*((uchar *)(ATA_CURR_BASE(dev)+port)) = val;
-}
-#endif
-
-#else	/* ! __PPC__ */
-static void __inline__
-ide_outb(int dev, int port, unsigned char val)
-{
-	outb(val, ATA_CURR_BASE(dev)+port);
-}
-#endif	/* __PPC__ */
-
-
-#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA)
-#ifndef CONFIG_EXTERN_IDE_CODE
-static unsigned char __inline__
-ide_inb(int dev, int port)
-{
-	uchar val;
-	/* Ensure I/O operations complete */
-	EIEIO;
-	val = *((uchar *)(ATA_CURR_BASE(dev)+port));
-	debug ("ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x\n",
-		dev, port, (ATA_CURR_BASE(dev)+port), val);
-	return (val);
-}
-#endif
-#else	/* ! __PPC__ */
-static unsigned char __inline__
-ide_inb(int dev, int port)
-{
-  return inb(ATA_CURR_BASE(dev)+port);
-}
-#endif	/* __PPC__ */
-
 #ifdef __PPC__
 # ifdef CONFIG_AMIGAONEG3SE
 static void
@@ -865,7 +886,7 @@
 
 /* We only need to swap data if we are running on a big endian cpu. */
 /* But Au1x00 cpu:s already swaps data in big endian mode! */
-#if defined(__LITTLE_ENDIAN) || defined(CONFIG_AU1X00)
+#if defined(__LITTLE_ENDIAN) || ( defined(CONFIG_AU1X00) && !defined(CONFIG_GTH2) )
 #define input_swap_data(x,y,z) input_data(x,y,z)
 #else
 #ifdef CONFIG_EXTERN_IDE_CODE
@@ -895,8 +916,16 @@
 	debug("in input swap data base for read is %lx\n", (unsigned long) pbuf);
 
 	while (words--) {
+#ifdef __MIPS__
+		*dbuf++ = swab16p((u16*)pbuf);
+		*dbuf++ = swab16p((u16*)pbuf);
+#elif defined(CONFIG_PCS440EP)
+		*dbuf++ = *pbuf;
+		*dbuf++ = *pbuf;
+#else
 		*dbuf++ = ld_le16(pbuf);
 		*dbuf++ = ld_le16(pbuf);
+#endif /* !MIPS */
 	}
 #endif
 }
@@ -904,7 +933,7 @@
 #endif	/* __LITTLE_ENDIAN || CONFIG_AU1X00 */
 
 
-#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA)
+#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA) || defined(CONFIG_SH)
 #ifndef CONFIG_EXTERN_IDE_CODE
 static void
 output_data(int dev, ulong *sect_buf, int words)
@@ -934,10 +963,18 @@
 	pbuf = (ushort *)(ATA_CURR_BASE(dev)+ATA_DATA_REG);
 	dbuf = (ushort *)sect_buf;
 	while (words--) {
+#if defined(CONFIG_PCS440EP)
+		/* not tested, because CF was write protected */
+		EIEIO;
+		*pbuf = ld_le16(dbuf++);
+		EIEIO;
+		*pbuf = ld_le16(dbuf++);
+#else
 		EIEIO;
 		*pbuf = *dbuf++;
 		EIEIO;
 		*pbuf = *dbuf++;
+#endif
 	}
 #endif
 }
@@ -950,7 +987,7 @@
 }
 #endif	/* __PPC__ */
 
-#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA)
+#if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA) || defined(CONFIG_SH)
 #ifndef CONFIG_EXTERN_IDE_CODE
 static void
 input_data(int dev, ulong *sect_buf, int words)
@@ -987,10 +1024,17 @@
 	debug("in input data base for read is %lx\n", (unsigned long) pbuf);
 
 	while (words--) {
+#if defined(CONFIG_PCS440EP)
+		EIEIO;
+		*dbuf++ = ld_le16(pbuf);
+		EIEIO;
+		*dbuf++ = ld_le16(pbuf);
+#else
 		EIEIO;
 		*dbuf++ = *pbuf;
 		EIEIO;
 		*dbuf++ = *pbuf;
+#endif
 	}
 #endif
 }
@@ -1043,6 +1087,10 @@
 	int do_retry = 0;
 #endif
 
+#ifdef CONFIG_TUNE_PIO
+	int pio_mode;
+#endif
+
 #if 0
 	int mode, cycle_time;
 #endif
@@ -1055,7 +1103,7 @@
 	if (s) {
 		max_bus_scan = simple_strtol(s, NULL, 10);
 	} else {
-		max_bus_scan = CFG_IDE_MAXBUS;
+		max_bus_scan = CONFIG_SYS_IDE_MAXBUS;
 	}
 	if (device >= max_bus_scan*2) {
 		dev_desc->type=DEV_TYPE_UNKNOWN;
@@ -1137,20 +1185,21 @@
 
 	input_swap_data (device, iobuf, ATA_SECTORWORDS);
 
-	ident_cpy (dev_desc->revision, iop->fw_rev, sizeof(dev_desc->revision));
-	ident_cpy (dev_desc->vendor, iop->model, sizeof(dev_desc->vendor));
-	ident_cpy (dev_desc->product, iop->serial_no, sizeof(dev_desc->product));
+	ident_cpy ((unsigned char*)dev_desc->revision, iop->fw_rev, sizeof(dev_desc->revision));
+	ident_cpy ((unsigned char*)dev_desc->vendor, iop->model, sizeof(dev_desc->vendor));
+	ident_cpy ((unsigned char*)dev_desc->product, iop->serial_no, sizeof(dev_desc->product));
 #ifdef __LITTLE_ENDIAN
 	/*
-	 * firmware revision and model number have Big Endian Byte
-	 * order in Word. Convert both to little endian.
+	 * firmware revision, model, and serial number have Big Endian Byte
+	 * order in Word. Convert all three to little endian.
 	 *
 	 * See CF+ and CompactFlash Specification Revision 2.0:
-	 * 6.2.1.6: Identfy Drive, Table 39 for more details
+	 * 6.2.1.6: Identify Drive, Table 39 for more details
 	 */
 
 	strswab (dev_desc->revision);
 	strswab (dev_desc->vendor);
+	strswab (dev_desc->product);
 #endif /* __LITTLE_ENDIAN */
 
 	if ((iop->config & 0x0080)==0x0080)
@@ -1158,6 +1207,38 @@
 	else
 		dev_desc->removable = 0;
 
+#ifdef CONFIG_TUNE_PIO
+	/* Mode 0 - 2 only, are directly determined by word 51. */
+	pio_mode = iop->tPIO;
+	if (pio_mode > 2) {
+		printf("WARNING: Invalid PIO (word 51 = %d).\n", pio_mode);
+		pio_mode = 0; /* Force it to dead slow, and hope for the best... */
+	}
+
+	/* Any CompactFlash Storage Card that supports PIO mode 3 or above
+	 * shall set bit 1 of word 53 to one and support the fields contained
+	 * in words 64 through 70.
+	 */
+	if (iop->field_valid & 0x02) {
+		/* Mode 3 and above are possible.  Check in order from slow
+		 * to fast, so we wind up with the highest mode allowed.
+		 */
+		if (iop->eide_pio_modes & 0x01)
+			pio_mode = 3;
+		if (iop->eide_pio_modes & 0x02)
+			pio_mode = 4;
+		if (ata_id_is_cfa((u16 *)iop)) {
+			if ((iop->cf_advanced_caps & 0x07) == 0x01)
+				pio_mode = 5;
+			if ((iop->cf_advanced_caps & 0x07) == 0x02)
+				pio_mode = 6;
+		}
+	}
+
+	/* System-specific, depends on bus speeds, etc. */
+	ide_set_piomode(pio_mode);
+#endif /* CONFIG_TUNE_PIO */
+
 #if 0
 	/*
 	 * Drive PIO mode autoselection
@@ -1222,7 +1303,7 @@
 	dev_desc->blksz=ATA_BLOCKSIZE;
 	dev_desc->lun=0; /* just to fill something in... */
 
-#if 0 	/* only used to test the powersaving mode,
+#if 0	/* only used to test the powersaving mode,
 	 * if enabled, the drive goes after 5 sec
 	 * in standby mode */
 	ide_outb (device, ATA_DEV_HD, ATA_LBA | ATA_DEVICE(device));
@@ -1241,7 +1322,7 @@
 
 /* ------------------------------------------------------------------------- */
 
-ulong ide_read (int device, lbaint_t blknr, ulong blkcnt, ulong *buffer)
+ulong ide_read (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 {
 	ulong n = 0;
 	unsigned char c;
@@ -1249,7 +1330,7 @@
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & 0x0000fffff0000000ULL) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1303,8 +1384,13 @@
 			/* write high bits */
 			ide_outb (device, ATA_SECT_CNT, 0);
 			ide_outb (device, ATA_LBA_LOW,	(blknr >> 24) & 0xFF);
+#ifdef CONFIG_SYS_64BIT_LBA
 			ide_outb (device, ATA_LBA_MID,	(blknr >> 32) & 0xFF);
 			ide_outb (device, ATA_LBA_HIGH, (blknr >> 40) & 0xFF);
+#else
+			ide_outb (device, ATA_LBA_MID,	0);
+			ide_outb (device, ATA_LBA_HIGH, 0);
+#endif
 		}
 #endif
 		ide_outb (device, ATA_SECT_CNT, 1);
@@ -1336,7 +1422,7 @@
 		}
 
 		if ((c&(ATA_STAT_DRQ|ATA_STAT_BUSY|ATA_STAT_ERR)) != ATA_STAT_DRQ) {
-#if defined(CFG_64BIT_LBA) && defined(CFG_64BIT_VSPRINTF)
+#if defined(CONFIG_SYS_64BIT_LBA) && defined(CONFIG_SYS_64BIT_VSPRINTF)
 			printf ("Error (no IRQ) dev %d blk %qd: status 0x%02x\n",
 				device, blknr, c);
 #else
@@ -1351,7 +1437,7 @@
 
 		++n;
 		++blknr;
-		buffer += ATA_SECTORWORDS;
+		buffer += ATA_BLOCKSIZE;
 	}
 IDE_READ_E:
 	ide_led (DEVICE_LED(device), 0);	/* LED off	*/
@@ -1361,14 +1447,14 @@
 /* ------------------------------------------------------------------------- */
 
 
-ulong ide_write (int device, lbaint_t blknr, ulong blkcnt, ulong *buffer)
+ulong ide_write (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 {
 	ulong n = 0;
 	unsigned char c;
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & 0x0000fffff0000000ULL) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1393,8 +1479,13 @@
 			/* write high bits */
 			ide_outb (device, ATA_SECT_CNT, 0);
 			ide_outb (device, ATA_LBA_LOW,	(blknr >> 24) & 0xFF);
+#ifdef CONFIG_SYS_64BIT_LBA
 			ide_outb (device, ATA_LBA_MID,	(blknr >> 32) & 0xFF);
 			ide_outb (device, ATA_LBA_HIGH, (blknr >> 40) & 0xFF);
+#else
+			ide_outb (device, ATA_LBA_MID,	0);
+			ide_outb (device, ATA_LBA_HIGH, 0);
+#endif
 		}
 #endif
 		ide_outb (device, ATA_SECT_CNT, 1);
@@ -1421,7 +1512,7 @@
 		c = ide_wait (device, IDE_TIME_OUT);	/* can't take over 500 ms */
 
 		if ((c&(ATA_STAT_DRQ|ATA_STAT_BUSY|ATA_STAT_ERR)) != ATA_STAT_DRQ) {
-#if defined(CFG_64BIT_LBA) && defined(CFG_64BIT_VSPRINTF)
+#if defined(CONFIG_SYS_64BIT_LBA) && defined(CONFIG_SYS_64BIT_VSPRINTF)
 			printf ("Error (no IRQ) dev %d blk %qd: status 0x%02x\n",
 				device, blknr, c);
 #else
@@ -1435,7 +1526,7 @@
 		c = ide_inb (device, ATA_STATUS);	/* clear IRQ */
 		++n;
 		++blknr;
-		buffer += ATA_SECTORWORDS;
+		buffer += ATA_BLOCKSIZE;
 	}
 WR_OUT:
 	ide_led (DEVICE_LED(device), 0);	/* LED off	*/
@@ -1501,26 +1592,29 @@
 
 static void ide_reset (void)
 {
-#if defined(CFG_PB_12V_ENABLE) || defined(CFG_PB_IDE_MOTOR)
-	volatile immap_t *immr = (immap_t *)CFG_IMMR;
+#if defined(CONFIG_SYS_PB_12V_ENABLE) || defined(CONFIG_SYS_PB_IDE_MOTOR)
+	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
 #endif
 	int i;
 
 	curr_device = -1;
-	for (i=0; i<CFG_IDE_MAXBUS; ++i)
+	for (i=0; i<CONFIG_SYS_IDE_MAXBUS; ++i)
 		ide_bus_ok[i] = 0;
-	for (i=0; i<CFG_IDE_MAXDEVICE; ++i)
+	for (i=0; i<CONFIG_SYS_IDE_MAXDEVICE; ++i)
 		ide_dev_desc[i].type = DEV_TYPE_UNKNOWN;
 
 	ide_set_reset (1); /* assert reset */
 
+	/* the reset signal shall be asserted for et least 25 us */
+	udelay(25);
+
 	WATCHDOG_RESET();
 
-#ifdef CFG_PB_12V_ENABLE
-	immr->im_cpm.cp_pbdat &= ~(CFG_PB_12V_ENABLE);	/* 12V Enable output OFF */
-	immr->im_cpm.cp_pbpar &= ~(CFG_PB_12V_ENABLE);
-	immr->im_cpm.cp_pbodr &= ~(CFG_PB_12V_ENABLE);
-	immr->im_cpm.cp_pbdir |=   CFG_PB_12V_ENABLE;
+#ifdef CONFIG_SYS_PB_12V_ENABLE
+	immr->im_cpm.cp_pbdat &= ~(CONFIG_SYS_PB_12V_ENABLE);	/* 12V Enable output OFF */
+	immr->im_cpm.cp_pbpar &= ~(CONFIG_SYS_PB_12V_ENABLE);
+	immr->im_cpm.cp_pbodr &= ~(CONFIG_SYS_PB_12V_ENABLE);
+	immr->im_cpm.cp_pbdir |=   CONFIG_SYS_PB_12V_ENABLE;
 
 	/* wait 500 ms for the voltage to stabilize
 	 */
@@ -1528,19 +1622,19 @@
 		udelay (1000);
 	}
 
-	immr->im_cpm.cp_pbdat |=   CFG_PB_12V_ENABLE;	/* 12V Enable output ON */
-#endif	/* CFG_PB_12V_ENABLE */
+	immr->im_cpm.cp_pbdat |=   CONFIG_SYS_PB_12V_ENABLE;	/* 12V Enable output ON */
+#endif	/* CONFIG_SYS_PB_12V_ENABLE */
 
-#ifdef CFG_PB_IDE_MOTOR
+#ifdef CONFIG_SYS_PB_IDE_MOTOR
 	/* configure IDE Motor voltage monitor pin as input */
-	immr->im_cpm.cp_pbpar &= ~(CFG_PB_IDE_MOTOR);
-	immr->im_cpm.cp_pbodr &= ~(CFG_PB_IDE_MOTOR);
-	immr->im_cpm.cp_pbdir &= ~(CFG_PB_IDE_MOTOR);
+	immr->im_cpm.cp_pbpar &= ~(CONFIG_SYS_PB_IDE_MOTOR);
+	immr->im_cpm.cp_pbodr &= ~(CONFIG_SYS_PB_IDE_MOTOR);
+	immr->im_cpm.cp_pbdir &= ~(CONFIG_SYS_PB_IDE_MOTOR);
 
 	/* wait up to 1 s for the motor voltage to stabilize
 	 */
 	for (i=0; i<1000; ++i) {
-		if ((immr->im_cpm.cp_pbdat & CFG_PB_IDE_MOTOR) != 0) {
+		if ((immr->im_cpm.cp_pbdat & CONFIG_SYS_PB_IDE_MOTOR) != 0) {
 			break;
 		}
 		udelay (1000);
@@ -1557,7 +1651,7 @@
 #  endif
 # endif	/* CONFIG_STATUS_LED */
 	}
-#endif	/* CFG_PB_IDE_MOTOR */
+#endif	/* CONFIG_SYS_PB_IDE_MOTOR */
 
 	WATCHDOG_RESET();
 
@@ -1753,13 +1847,13 @@
 	c = atapi_wait_mask(device,ATAPI_TIME_OUT,mask,res);
 
 	if ((c & mask) != res) { /* DRQ must be 1, BSY 0 */
-		printf ("ATTAPI_ISSUE: Error (no IRQ) before sending ccb dev %d status 0x%02x\n",device,c);
+		printf ("ATAPI_ISSUE: Error (no IRQ) before sending ccb dev %d status 0x%02x\n",device,c);
 		err=0xFF;
 		goto AI_OUT;
 	}
 
 	output_data_shorts (device, (unsigned short *)ccb,ccblen/2); /* write command block */
- 	/* ATAPI Command written wait for completition */
+	/* ATAPI Command written wait for completition */
 	udelay (5000); /* device must set bsy */
 
 	mask = ATA_STAT_DRQ|ATA_STAT_BUSY|ATA_STAT_ERR;
@@ -1774,7 +1868,7 @@
 			err=(ide_inb(device,ATA_ERROR_REG))>>4;
 			debug ("atapi_issue 1 returned sense key %X status %02X\n",err,c);
 		} else {
-			printf ("ATTAPI_ISSUE: (no DRQ) after sending ccb (%x)  status 0x%02x\n", ccb[0],c);
+			printf ("ATAPI_ISSUE: (no DRQ) after sending ccb (%x)  status 0x%02x\n", ccb[0],c);
 			err=0xFF;
 		}
 		goto AI_OUT;
@@ -1828,7 +1922,7 @@
  * returns, an request_sense will be issued
  */
 
-#define ATAPI_DRIVE_NOT_READY 	100
+#define ATAPI_DRIVE_NOT_READY	100
 #define ATAPI_UNIT_ATTN		10
 
 unsigned char atapi_issue_autoreq (int device,
@@ -1954,9 +2048,9 @@
 		return;
 
 	/* copy device ident strings */
-	ident_cpy(dev_desc->vendor,&iobuf[8],8);
-	ident_cpy(dev_desc->product,&iobuf[16],16);
-	ident_cpy(dev_desc->revision,&iobuf[32],5);
+	ident_cpy((unsigned char*)dev_desc->vendor,&iobuf[8],8);
+	ident_cpy((unsigned char*)dev_desc->product,&iobuf[16],16);
+	ident_cpy((unsigned char*)dev_desc->revision,&iobuf[32],5);
 
 	dev_desc->lun=0;
 	dev_desc->lba=0;
@@ -2023,7 +2117,7 @@
 #define ATAPI_READ_BLOCK_SIZE	2048	/* assuming CD part */
 #define ATAPI_READ_MAX_BLOCK ATAPI_READ_MAX_BYTES/ATAPI_READ_BLOCK_SIZE	/* max blocks */
 
-ulong atapi_read (int device, lbaint_t blknr, ulong blkcnt, ulong *buffer)
+ulong atapi_read (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 {
 	ulong n = 0;
 	unsigned char ccb[12]; /* Command descriptor block */
@@ -2059,7 +2153,7 @@
 		n+=cnt;
 		blkcnt-=cnt;
 		blknr+=cnt;
-		buffer+=cnt*(ATAPI_READ_BLOCK_SIZE/4); /* ulong blocksize in ulong */
+		buffer+=(cnt*ATAPI_READ_BLOCK_SIZE);
 	} while (blkcnt > 0);
 	return (n);
 }
@@ -2086,5 +2180,3 @@
 	"diskboot- boot from IDE device\n",
 	"loadAddr dev:part\n"
 );
-
-#endif	/* CONFIG_COMMANDS & CFG_CMD_IDE */
diff -uNr u-boot-2009.08-rc1.org/common/cmd_jffs2.c u-boot-2009.08-rc1/common/cmd_jffs2.c
--- u-boot-2009.08-rc1.org/common/cmd_jffs2.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_jffs2.c	2009-07-27 15:48:23.000000000 +0200
@@ -95,6 +95,8 @@
 #include <linux/ctype.h>
 #include <cramfs/cramfs_fs.h>
 
+#if !defined(CONFIG_CMD_FS)
+
 #if defined(CONFIG_CMD_NAND)
 #include <linux/mtd/nand.h>
 #include <nand.h>
@@ -635,3 +637,4 @@
 	""
 );
 /***************************************************/
+#endif /* !defined(CONFIG_CMD_FS) */
diff -uNr u-boot-2009.08-rc1.org/common/cmd_net.c u-boot-2009.08-rc1/common/cmd_net.c
--- u-boot-2009.08-rc1.org/common/cmd_net.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_net.c	2009-07-27 15:48:23.000000000 +0200
@@ -91,7 +91,10 @@
 );
 #endif
 
-static void netboot_update_env (void)
+#ifndef CONFIG_TUXBOX_NETWORK
+static
+#endif
+void netboot_update_env (void)
 {
 	char tmp[22];
 
diff -uNr u-boot-2009.08-rc1.org/common/cmd_nvedit.c u-boot-2009.08-rc1/common/cmd_nvedit.c
--- u-boot-2009.08-rc1.org/common/cmd_nvedit.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/cmd_nvedit.c	2009-07-27 15:48:23.000000000 +0200
@@ -177,6 +177,7 @@
 	uchar *env, *nxt = NULL;
 	char *name;
 	bd_t *bd = gd->bd;
+	int br_nowait = 0;
 
 	uchar *env_data = env_get_addr(0);
 
@@ -185,6 +186,16 @@
 
 	name = argv[1];
 
+	/*
+	 * this is an ugly hack, to set the baudrate at boot without asking for
+	 * confirmation, use "setenv baudrate_now 38400"
+	 */
+	if (strcmp(name, "baudrate_now") == 0) {
+		br_nowait = 1;
+		/* execute the "baudrate" setenv routine */
+		strcpy(name, "baudrate");
+	}
+
 	if (strchr(name, '=')) {
 		printf ("## Error: illegal character '=' in variable name \"%s\"\n", name);
 		return 1;
@@ -275,8 +286,9 @@
 					baudrate);
 				return 1;
 			}
-			printf ("## Switch baudrate to %d bps and press ENTER ...\n",
-				baudrate);
+			if (!br_nowait)
+				printf ("## Switch baudrate to %d bps and press ENTER ...\n",
+					baudrate);
 			udelay(50000);
 			gd->baudrate = baudrate;
 #if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
@@ -285,9 +297,11 @@
 
 			serial_setbrg ();
 			udelay(50000);
-			for (;;) {
-				if (getc() == '\r')
-				      break;
+			if (!br_nowait) {
+				for (;;) {
+					if (getc() == '\r')
+					      break;
+				}
 			}
 		}
 
diff -uNr u-boot-2009.08-rc1.org/common/env_common.c u-boot-2009.08-rc1/common/env_common.c
--- u-boot-2009.08-rc1.org/common/env_common.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/env_common.c	2009-07-27 15:48:23.000000000 +0200
@@ -37,6 +37,10 @@
 	extern void disable_nvram(void);
 #endif
 
+#ifdef CONFIG_DBOX2_ENV_READ_FS
+void load_env_fs (void);
+#endif /* CONFIG_DBOX2_ENV_READ_FS */
+
 #undef DEBUG_ENV
 #ifdef DEBUG_ENV
 #define DEBUGF(fmt,args...) printf(fmt ,##args)
@@ -252,8 +256,10 @@
 #endif
 
 	if (gd->env_valid == 0) {
-#if defined(CONFIG_GTH)	|| defined(CONFIG_ENV_IS_NOWHERE)	/* Environment not changable */
-		puts ("Using default environment\n\n");
+#if defined(CONFIG_ENV_IS_NOWHERE) /* we have no environment */
+#elif defined (CONFIG_GTH)	/* environment not changeable */
+ 		puts ("Using default environment\n\n");
+#elif defined (CONFIG_DBOX2_ENV_READ_FS)
 #else
 		puts ("*** Warning - bad CRC, using default environment\n\n");
 		show_boot_progress (-60);
@@ -268,6 +274,10 @@
 #ifdef CONFIG_AMIGAONEG3SE
 	disable_nvram();
 #endif
+
+#ifdef CONFIG_DBOX2_ENV_READ_FS
+	load_env_fs ();
+#endif /* CONFIG_DBOX2_ENV_READ_FS */
 }
 
 #ifdef CONFIG_AUTO_COMPLETE
diff -uNr u-boot-2009.08-rc1.org/common/main.c u-boot-2009.08-rc1/common/main.c
--- u-boot-2009.08-rc1.org/common/main.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/main.c	2009-07-27 15:48:23.000000000 +0200
@@ -44,6 +44,12 @@
 DECLARE_GLOBAL_DATA_PTR;
 #endif
 
+#ifdef CONFIG_DBOX2_LCD_INFO
+#include <lcd.h>
+#include <version.h>
+#endif /* CONFIG_DBOX2_LCD_INFO */
+
+
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
@@ -215,11 +221,38 @@
 {
 	int abort = 0;
 
+#ifdef CONFIG_AUTOBOOT_SELECT
+	char option = CONFIG_AUTOBOOT_SELECT_AUTOBOOT;
+	puts("\nOptions:\n");
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 1
+	printf("  1: " CONFIG_AUTOBOOT_SELECT_1_TEXT "\n");
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 1 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 2
+	printf("  2: " CONFIG_AUTOBOOT_SELECT_2_TEXT "\n");
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 2 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 3
+	printf("  3: " CONFIG_AUTOBOOT_SELECT_3_TEXT "\n");
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 3 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 4
+	printf("  4: " CONFIG_AUTOBOOT_SELECT_4_TEXT "\n");
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 4 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 5
+	printf("  5: " CONFIG_AUTOBOOT_SELECT_5_TEXT "\n");
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 5 */
+	printf("Select option (1-%d), other keys to stop autoboot: %2d ",
+		CONFIG_AUTOBOOT_SELECT_NUMBER, bootdelay);
+#else /* CONFIG_AUTOBOOT_SELECT */
+
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
 	printf("Hit any key to stop autoboot: %2d ", bootdelay);
 #endif
+#endif /* CONFIG_AUTOBOOT_SELECT */
+
+#ifdef CONFIG_DBOX2_LCD_INFO
+	lcd_printf ("\nautoboot: %2d", bootdelay);
+#endif /* CONFIG_DBOX2_LCD_INFO */
 
 #if defined CONFIG_ZERO_BOOTDELAY_CHECK
 	/*
@@ -230,6 +263,9 @@
 		if (tstc()) {	/* we got a key press	*/
 			(void) getc();  /* consume input	*/
 			puts ("\b\b\b 0");
+#ifdef CONFIG_DBOX2_LCD_INFO
+			lcd_printf ("\b\b 0");
+#endif /* CONFIG_DBOX2_LCD_INFO */
 			abort = 1;	/* don't auto boot	*/
 		}
 	}
@@ -242,23 +278,72 @@
 		/* delay 100 * 10ms */
 		for (i=0; !abort && i<100; ++i) {
 			if (tstc()) {	/* we got a key press	*/
+#ifdef CONFIG_AUTOBOOT_SELECT
+				option = getc();
+#ifdef CONFIG_AUTOBOOT_SELECT_AUTOBOOT
+				if (option < '1' || option > CONFIG_AUTOBOOT_SELECT_NUMBER + '0')
+#endif /* CONFIG_AUTOBOOT_SELECT_AUTOBOOT */
+#endif /* CONFIG_AUTOBOOT_SELECT */
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
+#ifndef CONFIG_AUTOBOOT_SELECT
 # ifdef CONFIG_MENUKEY
 				menukey = getc();
 # else
 				(void) getc();  /* consume input	*/
 # endif
+#endif /* CONFIG_AUTOBOOT_SELECT */
 				break;
 			}
 			udelay(10000);
 		}
 
 		printf("\b\b\b%2d ", bootdelay);
+#ifdef CONFIG_DBOX2_LCD_INFO
+		lcd_printf("\b\b%2d", bootdelay);
+#endif /* CONFIG_DBOX2_LCD_INFO */
+	}
+
+#ifdef CONFIG_AUTOBOOT_SELECT
+	switch ( option ){
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 1
+	case '1':
+		run_command (CONFIG_AUTOBOOT_SELECT_1_COMMAND, 0);
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 1 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 2
+	case '2':
+		run_command (CONFIG_AUTOBOOT_SELECT_2_COMMAND, 0);
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 2 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 3
+	case '3':
+		run_command (CONFIG_AUTOBOOT_SELECT_3_COMMAND, 0);
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 3 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 4
+	case '4':
+		run_command (CONFIG_AUTOBOOT_SELECT_4_COMMAND, 0);
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 4 */
+#if CONFIG_AUTOBOOT_SELECT_NUMBER >= 5
+	case '5':
+		run_command (CONFIG_AUTOBOOT_SELECT_5_COMMAND, 0);
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_NUMBER >= 5 */
+#ifndef CONFIG_AUTOBOOT_SELECT_AUTOBOOT
+	default:
+		abort = 1;
+		break;
+#endif /* CONFIG_AUTOBOOT_SELECT_AUTOBOOT */
 	}
-
+#endif /* CONFIG_AUTOBOOT_SELECT */
 	putc('\n');
 
+#ifdef CONFIG_DBOX2_LCD_INFO
+	lcd_puts ("\n\n" U_BOOT_VERSION_SHORT "\n");
+#endif /* CONFIG_DBOX2_LCD_INFO */
+
 #ifdef CONFIG_SILENT_CONSOLE
 	if (abort)
 		gd->flags &= ~GD_FLG_SILENT;
@@ -356,6 +441,14 @@
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
 # endif
 
+#ifdef CONFIG_DBOX2_LCD_INFO
+	#ifndef DBOXFLASHER
+	lcd_puts ("\n\nloading kernel");
+	#else /* DBOXFLASHER */
+	lcd_puts ("\n\nflashing image");
+	#endif /* DBOXFLASHER */
+#endif /* CONFIG_DBOX2_LCD_INFO */
+
 # ifndef CONFIG_SYS_HUSH_PARSER
 		run_command (p, 0);
 # else
diff -uNr u-boot-2009.08-rc1.org/common/Makefile u-boot-2009.08-rc1/common/Makefile
--- u-boot-2009.08-rc1.org/common/Makefile	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/Makefile	2009-07-27 15:48:23.000000000 +0200
@@ -62,6 +62,7 @@
 COBJS-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
 COBJS-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 COBJS-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
+COBJS-$(CONFIG_ENV_IS_NOWHERE) += env_embedded.o
 
 # command
 COBJS-$(CONFIG_CMD_AMBAPP) += cmd_ambapp.o
@@ -96,6 +97,7 @@
 ifdef CONFIG_FPGA
 COBJS-$(CONFIG_CMD_FPGA) += cmd_fpga.o
 endif
+COBJS-$(CONFIG_CMD_FS) += cmd_fs.o
 COBJS-$(CONFIG_CMD_I2C) += cmd_i2c.o
 COBJS-$(CONFIG_CMD_IDE) += cmd_ide.o
 COBJS-$(CONFIG_CMD_IMMAP) += cmd_immap.o
diff -uNr u-boot-2009.08-rc1.org/common/stdio.c u-boot-2009.08-rc1/common/stdio.c
--- u-boot-2009.08-rc1.org/common/stdio.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/common/stdio.c	2009-07-27 15:48:23.000000000 +0200
@@ -233,6 +233,9 @@
 #ifdef CONFIG_LOGBUFFER
 	drv_logbuff_init ();
 #endif
+#ifdef CONFIG_DBOX2
+	drv_dbox2_init();
+#endif
 	drv_system_init ();
 #ifdef CONFIG_SERIAL_MULTI
 	serial_stdio_init ();
diff -uNr u-boot-2009.08-rc1.org/cpu/mpc8xx/cpu_init.c u-boot-2009.08-rc1/cpu/mpc8xx/cpu_init.c
--- u-boot-2009.08-rc1.org/cpu/mpc8xx/cpu_init.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/cpu/mpc8xx/cpu_init.c	2009-07-27 15:48:23.000000000 +0200
@@ -115,6 +115,7 @@
 	immr->im_clkrst.car_plprcr = reg;
 #endif
 
+#ifndef CONFIG_SECONDSTAGE
 	/*
 	 * Memory Controller:
 	 */
@@ -221,7 +222,9 @@
 	memctl->memc_br7 = CONFIG_SYS_BR7_PRELIM;
 #endif
 
+#endif /* ! CONFIG_SECONDSTAGE */
 #endif /* ! CONFIG_MBX */
+#ifndef CONFIG_SECONDSTAGE
 
 	/*
 	 * Reset CPM
@@ -231,6 +234,7 @@
 		__asm__ ("eieio");
 	} while (immr->im_cpm.cp_cpcr & CPM_CR_FLG);
 
+#endif /* ! coNFIG_SECONDSTAGE */
 #ifdef CONFIG_MBX
 	/*
 	 * on the MBX, things are a little bit different:
diff -uNr u-boot-2009.08-rc1.org/cpu/mpc8xx/start.S u-boot-2009.08-rc1/cpu/mpc8xx/start.S
--- u-boot-2009.08-rc1.org/cpu/mpc8xx/start.S	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/cpu/mpc8xx/start.S	2009-07-27 15:48:23.000000000 +0200
@@ -84,6 +84,9 @@
  * r4 - 2nd arg to board_init(): boot flag
  */
 	.text
+#ifdef CONFIG_SECONDSTAGE
+	bl EXC_OFF_SYS_RESET
+#endif
 	.long	0x27051956		/* U-Boot Magic Number			*/
 	.globl	version_string
 version_string:
diff -uNr u-boot-2009.08-rc1.org/fs/cramfs/cramfs.c u-boot-2009.08-rc1/fs/cramfs/cramfs.c
--- u-boot-2009.08-rc1.org/fs/cramfs/cramfs.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/fs/cramfs/cramfs.c	2009-07-27 15:48:23.000000000 +0200
@@ -42,7 +42,11 @@
 /* CPU address space offset calculation macro, struct part_info offset is
  * device address space offset, so we need to shift it by a device start address. */
 extern flash_info_t flash_info[];
+#if defined(CONFIG_CMD_FS)
+#define PART_OFFSET(x)	(x->offset)
+#else
 #define PART_OFFSET(x)	(x->offset + flash_info[x->dev->id->num].start[0])
+#endif
 
 static int cramfs_read_super (struct part_info *info)
 {
@@ -328,8 +332,10 @@
 {
 	struct cramfs_super *sb;
 
+#if !defined(CONFIG_CMD_FS)
 	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
 		return 0;
+#endif
 
 	sb = (struct cramfs_super *) PART_OFFSET(info);
 	if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC)) {
diff -uNr u-boot-2009.08-rc1.org/fs/jffs2/jffs2_1pass.c u-boot-2009.08-rc1/fs/jffs2/jffs2_1pass.c
--- u-boot-2009.08-rc1.org/fs/jffs2/jffs2_1pass.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/fs/jffs2/jffs2_1pass.c	2009-07-27 15:48:31.000000000 +0200
@@ -92,7 +92,7 @@
  * - implemented fragment sorting to ensure that the newest data is copied
  *   if there are multiple copies of fragments for a certain file offset.
  *
- * The fragment sorting feature must be enabled by CONFIG_SYS_JFFS2_SORT_FRAGMENTS.
+ * The fragment sorting feature must be enabled by CFG_JFFS2_SORT_FRAGMENTS.
  * Sorting is done while adding fragments to the lists, which is more or less a
  * bubble sort. This takes a lot of time, and is most probably not an issue if
  * the boot filesystem is always mounted readonly.
@@ -119,8 +119,6 @@
 #include <watchdog.h>
 #include <jffs2/jffs2.h>
 #include <jffs2/jffs2_1pass.h>
-#include <linux/mtd/compat.h>
-#include <asm/errno.h>
 
 #include "jffs2_private.h"
 
@@ -139,8 +138,6 @@
 # define DEBUGF(fmt,args...)
 #endif
 
-#include "summary.h"
-
 /* keeps pointer to currentlu processed partition */
 static struct part_info *current_part;
 
@@ -228,7 +225,7 @@
 	return buf;
 }
 
-static void *get_node_mem_nand(u32 off, void *ext_buf)
+static void *get_node_mem_nand(u32 off)
 {
 	struct jffs2_unknown_node node;
 	void *ret = NULL;
@@ -238,7 +235,7 @@
 
 	if (!(ret = get_fl_mem_nand(off, node.magic ==
 			       JFFS2_MAGIC_BITMASK ? node.totlen : sizeof(node),
-			       ext_buf))) {
+			       NULL))) {
 		printf("off = %#x magic %#x type %#x node.totlen = %d\n",
 		       off, node.magic, node.nodetype, node.totlen);
 	}
@@ -327,7 +324,7 @@
 	return buf;
 }
 
-static void *get_node_mem_onenand(u32 off, void *ext_buf)
+static void *get_node_mem_onenand(u32 off)
 {
 	struct jffs2_unknown_node node;
 	void *ret = NULL;
@@ -337,7 +334,7 @@
 
 	ret = get_fl_mem_onenand(off, node.magic ==
 			JFFS2_MAGIC_BITMASK ? node.totlen : sizeof(node),
-			ext_buf);
+			NULL);
 	if (!ret) {
 		printf("off = %#x magic %#x type %#x node.totlen = %d\n",
 		       off, node.magic, node.nodetype, node.totlen);
@@ -360,7 +357,8 @@
  * NOR flash memory is mapped in processor's address space,
  * just return address.
  */
-static inline void *get_fl_mem_nor(u32 off, u32 size, void *ext_buf)
+#if !defined(CONFIG_CMD_FS)
+static inline void *get_fl_mem_nor(u32 off)
 {
 	u32 addr = off;
 	struct mtdids *id = current_part->dev->id;
@@ -369,23 +367,14 @@
 	flash_info_t *flash = &flash_info[id->num];
 
 	addr += flash->start[0];
-	if (ext_buf) {
-		memcpy(ext_buf, (void *)addr, size);
-		return ext_buf;
-	}
 	return (void*)addr;
 }
 
-static inline void *get_node_mem_nor(u32 off, void *ext_buf)
+static inline void *get_node_mem_nor(u32 off)
 {
-	struct jffs2_unknown_node *pNode;
-
-	/* pNode will point directly to flash - don't provide external buffer
-	   and don't care about size */
-	pNode = get_fl_mem_nor(off, 0, NULL);
-	return (void *)get_fl_mem_nor(off, pNode->magic == JFFS2_MAGIC_BITMASK ?
-			pNode->totlen : sizeof(*pNode), ext_buf);
+	return (void*)get_fl_mem_nor(off);
 }
+#endif /* #if (CONFIG_CMD_FLASH) */
 #endif
 
 
@@ -395,12 +384,12 @@
  */
 static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
 {
+#if !defined(CONFIG_CMD_FS)
 	struct mtdids *id = current_part->dev->id;
 
 #if defined(CONFIG_CMD_FLASH)
-	if (id->type == MTD_DEV_TYPE_NOR) {
-		return get_fl_mem_nor(off, size, ext_buf);
-	}
+	if (id->type == MTD_DEV_TYPE_NOR)
+		return get_fl_mem_nor(off);
 #endif
 
 #if defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)
@@ -414,51 +403,52 @@
 #endif
 
 	printf("get_fl_mem: unknown device type, using raw offset!\n");
+#endif /* !defined(CONFIG_CMD_FS) */
 	return (void*)off;
 }
 
-static inline void *get_node_mem(u32 off, void *ext_buf)
+static inline void *get_node_mem(u32 off)
 {
+#if !defined(CONFIG_CMD_FS)
 	struct mtdids *id = current_part->dev->id;
 
 #if defined(CONFIG_CMD_FLASH)
 	if (id->type == MTD_DEV_TYPE_NOR)
-		return get_node_mem_nor(off, ext_buf);
+		return get_node_mem_nor(off);
 #endif
 
 #if defined(CONFIG_JFFS2_NAND) && \
     defined(CONFIG_CMD_NAND)
 	if (id->type == MTD_DEV_TYPE_NAND)
-		return get_node_mem_nand(off, ext_buf);
+		return get_node_mem_nand(off);
 #endif
 
 #if defined(CONFIG_CMD_ONENAND)
 	if (id->type == MTD_DEV_TYPE_ONENAND)
-		return get_node_mem_onenand(off, ext_buf);
+		return get_node_mem_onenand(off);
 #endif
 
 	printf("get_node_mem: unknown device type, using raw offset!\n");
+#endif /* CONFIG_CMD_FS */
 	return (void*)off;
 }
 
-static inline void put_fl_mem(void *buf, void *ext_buf)
+static inline void put_fl_mem(void *buf)
 {
+#if defined(CONFIG_JFFS2_NAND) && \
+    defined(CONFIG_CMD_NAND)
 	struct mtdids *id = current_part->dev->id;
 
-	/* If buf is the same as ext_buf, it was provided by the caller -
-	   we shouldn't free it then. */
-	if (buf == ext_buf)
-		return;
-	switch (id->type) {
-#if defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)
-	case MTD_DEV_TYPE_NAND:
+	if (id->type == MTD_DEV_TYPE_NAND)
 		return put_fl_mem_nand(buf);
 #endif
+
 #if defined(CONFIG_CMD_ONENAND)
-	case MTD_DEV_TYPE_ONENAND:
+	struct mtdids *id = current_part->dev->id;
+
+	if (id->type == MTD_DEV_TYPE_ONENAND)
 		return put_fl_mem_onenand(buf);
 #endif
-	}
 }
 
 /* Compression names */
@@ -476,6 +466,9 @@
 #endif
 };
 
+/* Spinning wheel */
+static char spinner[] = { '|', '/', '-', '\\' };
+
 /* Memory management */
 struct mem_block {
 	u32	index;
@@ -537,7 +530,7 @@
 insert_node(struct b_list *list, u32 offset)
 {
 	struct b_node *new;
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	struct b_node *b, *prev;
 #endif
 
@@ -547,7 +540,7 @@
 	}
 	new->offset = offset;
 
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	if (list->listTail != NULL && list->listCompare(new, list->listTail))
 		prev = list->listTail;
 	else if (list->listLast != NULL && list->listCompare(new, list->listLast))
@@ -584,7 +577,7 @@
 	return new;
 }
 
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 /* Sort data entries with the latest version last, so that if there
  * is overlapping data the latest version will be used.
  */
@@ -646,6 +639,23 @@
 }
 #endif
 
+static u32
+jffs2_scan_empty(u32 start_offset, struct part_info *part)
+{
+	char *max = (char *)(part->offset + part->size - sizeof(struct jffs2_raw_inode));
+	char *offset = (char *)(part->offset + start_offset);
+	u32 off;
+
+	while (offset < max &&
+	       *(u32*)get_fl_mem((u32)offset, sizeof(u32), &off) == 0xFFFFFFFF) {
+		offset += sizeof(u32);
+		/* return if spinning is due */
+		if (((u32)offset & ((1 << SPIN_BLKSIZE)-1)) == 0) break;
+	}
+
+	return (u32)offset - part->offset;
+}
+
 void
 jffs2_free_cache(struct part_info *part)
 {
@@ -655,7 +665,6 @@
 		pL = (struct b_lists *)part->jffs2_priv;
 		free_nodes(&pL->frag);
 		free_nodes(&pL->dir);
-		free(pL->readbuf);
 		free(pL);
 	}
 }
@@ -671,7 +680,7 @@
 		pL = (struct b_lists *)part->jffs2_priv;
 
 		memset(pL, 0, sizeof(*pL));
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 		pL->dir.listCompare = compare_dirents;
 		pL->frag.listCompare = compare_inodes;
 #endif
@@ -692,7 +701,7 @@
 	long ret;
 	int i;
 	u32 counter = 0;
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	/* Find file size before loading any data, so fragments that
 	 * start past the end of file can be ignored. A fragment
 	 * that is partially in the file is loaded, so extra data may
@@ -702,7 +711,7 @@
 	 */
 	for (b = pL->frag.listHead; b != NULL; b = b->next) {
 		jNode = (struct jffs2_raw_inode *) get_fl_mem(b->offset,
-			sizeof(struct jffs2_raw_inode), pL->readbuf);
+		        sizeof(struct jffs2_raw_inode), NULL);
 		if ((inode == jNode->ino)) {
 			/* get actual file length from the newest node */
 			if (jNode->version >= latestVersion) {
@@ -710,13 +719,12 @@
 				latestVersion = jNode->version;
 			}
 		}
-		put_fl_mem(jNode, pL->readbuf);
+		put_fl_mem(jNode);
 	}
 #endif
 
 	for (b = pL->frag.listHead; b != NULL; b = b->next) {
-		jNode = (struct jffs2_raw_inode *) get_node_mem(b->offset,
-								pL->readbuf);
+		jNode = (struct jffs2_raw_inode *) get_node_mem(b->offset);
 		if ((inode == jNode->ino)) {
 #if 0
 			putLabeledWord("\r\n\r\nread_inode: totlen = ", jNode->totlen);
@@ -731,7 +739,7 @@
 			putLabeledWord("read_inode: flags = ", jNode->flags);
 #endif
 
-#ifndef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifndef CFG_JFFS2_SORT_FRAGMENTS
 			/* get actual file length from the newest node */
 			if (jNode->version >= latestVersion) {
 				totalSize = jNode->isize;
@@ -743,14 +751,7 @@
 				src = ((uchar *) jNode) + sizeof(struct jffs2_raw_inode);
 				/* ignore data behind latest known EOF */
 				if (jNode->offset > totalSize) {
-					put_fl_mem(jNode, pL->readbuf);
-					continue;
-				}
-				if (b->datacrc == CRC_UNKNOWN)
-					b->datacrc = data_crc(jNode) ?
-						CRC_OK : CRC_BAD;
-				if (b->datacrc == CRC_BAD) {
-					put_fl_mem(jNode, pL->readbuf);
+					put_fl_mem(jNode);
 					continue;
 				}
 
@@ -791,7 +792,7 @@
 				default:
 					/* unknown */
 					putLabeledWord("UNKOWN COMPRESSION METHOD = ", jNode->compr);
-					put_fl_mem(jNode, pL->readbuf);
+					put_fl_mem(jNode);
 					return -1;
 					break;
 				}
@@ -803,7 +804,7 @@
 #endif
 		}
 		counter++;
-		put_fl_mem(jNode, pL->readbuf);
+		put_fl_mem(jNode);
 	}
 
 #if 0
@@ -829,13 +830,12 @@
 	counter = 0;
 	/* we need to search all and return the inode with the highest version */
 	for(b = pL->dir.listHead; b; b = b->next, counter++) {
-		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset,
-								pL->readbuf);
+		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
 		if ((pino == jDir->pino) && (len == jDir->nsize) &&
 		    (jDir->ino) &&	/* 0 for unlink */
 		    (!strncmp((char *)jDir->name, name, len))) {	/* a match */
 			if (jDir->version < version) {
-				put_fl_mem(jDir, pL->readbuf);
+				put_fl_mem(jDir);
 				continue;
 			}
 
@@ -857,7 +857,7 @@
 		putLabeledWord("b = ", (u32) b);
 		putLabeledWord("counter = ", counter);
 #endif
-		put_fl_mem(jDir, pL->readbuf);
+		put_fl_mem(jDir);
 	}
 	return inode;
 }
@@ -928,7 +928,9 @@
 	st.st_mtime = i->mtime;
 	st.st_mode = i->mode;
 	st.st_ino = i->ino;
-	st.st_size = i->isize;
+
+	/* neither dsize nor isize help us.. do it the long way */
+	st.st_size = jffs2_1pass_read_inode(pL, i->ino, NULL);
 
 	dump_stat(&st, fname);
 
@@ -951,8 +953,7 @@
 	struct jffs2_raw_dirent *jDir;
 
 	for (b = pL->dir.listHead; b; b = b->next) {
-		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset,
-								pL->readbuf);
+		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
 		if ((pino == jDir->pino) && (jDir->ino)) { /* ino=0 -> unlink */
 			u32 i_version = 0;
 			struct jffs2_raw_inode ojNode;
@@ -963,25 +964,21 @@
 				jNode = (struct jffs2_raw_inode *)
 					get_fl_mem(b2->offset, sizeof(ojNode), &ojNode);
 				if (jNode->ino == jDir->ino && jNode->version >= i_version) {
-					i_version = jNode->version;
 					if (i)
-						put_fl_mem(i, NULL);
+						put_fl_mem(i);
 
 					if (jDir->type == DT_LNK)
-						i = get_node_mem(b2->offset,
-								 NULL);
+						i = get_node_mem(b2->offset);
 					else
-						i = get_fl_mem(b2->offset,
-							       sizeof(*i),
-							       NULL);
+						i = get_fl_mem(b2->offset, sizeof(*i), NULL);
 				}
 				b2 = b2->next;
 			}
 
 			dump_inode(pL, jDir, i);
-			put_fl_mem(i, NULL);
+			put_fl_mem(i);
 		}
-		put_fl_mem(jDir, pL->readbuf);
+		put_fl_mem(jDir);
 	}
 	return pino;
 }
@@ -1059,11 +1056,10 @@
 
 	/* we need to search all and return the inode with the highest version */
 	for(b = pL->dir.listHead; b; b = b->next) {
-		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset,
-								pL->readbuf);
+		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
 		if (ino == jDir->ino) {
 			if (jDir->version < version) {
-				put_fl_mem(jDir, pL->readbuf);
+				put_fl_mem(jDir);
 				continue;
 			}
 
@@ -1080,7 +1076,7 @@
 			jDirFoundPino = jDir->pino;
 			version = jDir->version;
 		}
-		put_fl_mem(jDir, pL->readbuf);
+		put_fl_mem(jDir);
 	}
 	/* now we found the right entry again. (shoulda returned inode*) */
 	if (jDirFoundType != DT_LNK)
@@ -1089,8 +1085,7 @@
 	/* it's a soft link so we follow it again. */
 	b2 = pL->frag.listHead;
 	while (b2) {
-		jNode = (struct jffs2_raw_inode *) get_node_mem(b2->offset,
-								pL->readbuf);
+		jNode = (struct jffs2_raw_inode *) get_node_mem(b2->offset);
 		if (jNode->ino == jDirFoundIno) {
 			src = (unsigned char *)jNode + sizeof(struct jffs2_raw_inode);
 
@@ -1102,11 +1097,11 @@
 #endif
 			strncpy(tmp, (char *)src, jNode->dsize);
 			tmp[jNode->dsize] = '\0';
-			put_fl_mem(jNode, pL->readbuf);
+			put_fl_mem(jNode);
 			break;
 		}
 		b2 = b2->next;
-		put_fl_mem(jNode, pL->readbuf);
+		put_fl_mem(jNode);
 	}
 	/* ok so the name of the new file to find is in tmp */
 	/* if it starts with a slash it is root based else shared dirs */
@@ -1201,167 +1195,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_JFFS2_SUMMARY
-static u32 sum_get_unaligned32(u32 *ptr)
-{
-	u32 val;
-	u8 *p = (u8 *)ptr;
-
-	val = *p | (*(p + 1) << 8) | (*(p + 2) << 16) | (*(p + 3) << 24);
-
-	return __le32_to_cpu(val);
-}
-
-static u16 sum_get_unaligned16(u16 *ptr)
-{
-	u16 val;
-	u8 *p = (u8 *)ptr;
-
-	val = *p | (*(p + 1) << 8);
-
-	return __le16_to_cpu(val);
-}
-
-#define dbg_summary(...) do {} while (0);
-/*
- * Process the stored summary information - helper function for
- * jffs2_sum_scan_sumnode()
- */
-
-static int jffs2_sum_process_sum_data(struct part_info *part, uint32_t offset,
-				struct jffs2_raw_summary *summary,
-				struct b_lists *pL)
-{
-	void *sp;
-	int i, pass;
-	void *ret;
-
-	for (pass = 0; pass < 2; pass++) {
-		sp = summary->sum;
-
-		for (i = 0; i < summary->sum_num; i++) {
-			struct jffs2_sum_unknown_flash *spu = sp;
-			dbg_summary("processing summary index %d\n", i);
-
-			switch (sum_get_unaligned16(&spu->nodetype)) {
-				case JFFS2_NODETYPE_INODE: {
-				struct jffs2_sum_inode_flash *spi;
-					if (pass) {
-						spi = sp;
-
-						ret = insert_node(&pL->frag,
-							(u32)part->offset +
-							offset +
-							sum_get_unaligned32(
-								&spi->offset));
-						if (ret == NULL)
-							return -1;
-					}
-
-					sp += JFFS2_SUMMARY_INODE_SIZE;
-
-					break;
-				}
-				case JFFS2_NODETYPE_DIRENT: {
-					struct jffs2_sum_dirent_flash *spd;
-					spd = sp;
-					if (pass) {
-						ret = insert_node(&pL->dir,
-							(u32) part->offset +
-							offset +
-							sum_get_unaligned32(
-								&spd->offset));
-						if (ret == NULL)
-							return -1;
-					}
-
-					sp += JFFS2_SUMMARY_DIRENT_SIZE(
-							spd->nsize);
-
-					break;
-				}
-				default : {
-					uint16_t nodetype = sum_get_unaligned16(
-								&spu->nodetype);
-					printf("Unsupported node type %x found"
-							" in summary!\n",
-							nodetype);
-					if ((nodetype & JFFS2_COMPAT_MASK) ==
-							JFFS2_FEATURE_INCOMPAT)
-						return -EIO;
-					return -EBADMSG;
-				}
-			}
-		}
-	}
-	return 0;
-}
-
-/* Process the summary node - called from jffs2_scan_eraseblock() */
-int jffs2_sum_scan_sumnode(struct part_info *part, uint32_t offset,
-			   struct jffs2_raw_summary *summary, uint32_t sumsize,
-			   struct b_lists *pL)
-{
-	struct jffs2_unknown_node crcnode;
-	int ret, ofs;
-	uint32_t crc;
-
-	ofs = part->sector_size - sumsize;
-
-	dbg_summary("summary found for 0x%08x at 0x%08x (0x%x bytes)\n",
-		    offset, offset + ofs, sumsize);
-
-	/* OK, now check for node validity and CRC */
-	crcnode.magic = JFFS2_MAGIC_BITMASK;
-	crcnode.nodetype = JFFS2_NODETYPE_SUMMARY;
-	crcnode.totlen = summary->totlen;
-	crc = crc32_no_comp(0, (uchar *)&crcnode, sizeof(crcnode)-4);
-
-	if (summary->hdr_crc != crc) {
-		dbg_summary("Summary node header is corrupt (bad CRC or "
-				"no summary at all)\n");
-		goto crc_err;
-	}
-
-	if (summary->totlen != sumsize) {
-		dbg_summary("Summary node is corrupt (wrong erasesize?)\n");
-		goto crc_err;
-	}
-
-	crc = crc32_no_comp(0, (uchar *)summary,
-			sizeof(struct jffs2_raw_summary)-8);
-
-	if (summary->node_crc != crc) {
-		dbg_summary("Summary node is corrupt (bad CRC)\n");
-		goto crc_err;
-	}
-
-	crc = crc32_no_comp(0, (uchar *)summary->sum,
-			sumsize - sizeof(struct jffs2_raw_summary));
-
-	if (summary->sum_crc != crc) {
-		dbg_summary("Summary node data is corrupt (bad CRC)\n");
-		goto crc_err;
-	}
-
-	if (summary->cln_mkr)
-		dbg_summary("Summary : CLEANMARKER node \n");
-
-	ret = jffs2_sum_process_sum_data(part, offset, summary, pL);
-	if (ret == -EBADMSG)
-		return 0;
-	if (ret)
-		return ret;		/* real error */
-
-	return 1;
-
-crc_err:
-	putstr("Summary node crc error, skipping summary information.\n");
-
-	return 0;
-}
-#endif /* CONFIG_JFFS2_SUMMARY */
-
 #ifdef DEBUG_FRAGMENTS
 static void
 dump_fragments(struct b_lists *pL)
@@ -1367,8 +1236,7 @@
 	putstr("\r\n\r\n******The directory Entries******\r\n");
 	b = pL->dir.listHead;
 	while (b) {
-		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset,
-								pL->readbuf);
+		jDir = (struct jffs2_raw_dirent *) get_node_mem(b->offset);
 		putstr("\r\n");
 		putnstr(jDir->name, jDir->nsize);
 		putLabeledWord("\r\n\tbuild_list: magic = ", jDir->magic);
@@ -1384,34 +1252,22 @@
 		putLabeledWord("\tbuild_list: name_crc = ", jDir->name_crc);
 		putLabeledWord("\tbuild_list: offset = ", b->offset);	/* FIXME: ? [RS] */
 		b = b->next;
-		put_fl_mem(jDir, pL->readbuf);
+		put_fl_mem(jDir);
 	}
 }
 #endif
 
-#define DEFAULT_EMPTY_SCAN_SIZE	4096
-
-static inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size)
-{
-	if (sector_size < DEFAULT_EMPTY_SCAN_SIZE)
-		return sector_size;
-	else
-		return DEFAULT_EMPTY_SCAN_SIZE;
-}
-
 static u32
 jffs2_1pass_build_lists(struct part_info * part)
 {
 	struct b_lists *pL;
 	struct jffs2_unknown_node *node;
-	u32 nr_sectors = part->size/part->sector_size;
-	u32 i;
+	u32 offset, oldoffset = 0;
+	u32 max = part->size - sizeof(struct jffs2_raw_inode);
+	u32 counter = 0;
 	u32 counter4 = 0;
 	u32 counterF = 0;
 	u32 counterN = 0;
-	u32 max_totlen = 0;
-	u32 buf_size = DEFAULT_EMPTY_SCAN_SIZE;
-	char *buf;
 
 	/* turn off the lcd.  Refreshing the lcd adds 50% overhead to the */
 	/* jffs2 list building enterprise nope.  in newer versions the overhead is */
@@ -1457,260 +1277,71 @@
 	/* if we are building a list we need to refresh the cache. */
 	jffs_init_1pass_list(part);
 	pL = (struct b_lists *)part->jffs2_priv;
-	buf = malloc(buf_size);
+	offset = 0;
 	puts ("Scanning JFFS2 FS:   ");
 
 	/* start at the beginning of the partition */
-	for (i = 0; i < nr_sectors; i++) {
-		uint32_t sector_ofs = i * part->sector_size;
-		uint32_t buf_ofs = sector_ofs;
-		uint32_t buf_len;
-		uint32_t ofs, prevofs;
-#ifdef CONFIG_JFFS2_SUMMARY
-		struct jffs2_sum_marker *sm;
-		void *sumptr = NULL;
-		uint32_t sumlen;
-		int ret;
-#endif
-
-		WATCHDOG_RESET();
-
-#ifdef CONFIG_JFFS2_SUMMARY
-		buf_len = sizeof(*sm);
-
-		/* Read as much as we want into the _end_ of the preallocated
-		 * buffer
-		 */
-		get_fl_mem(part->offset + sector_ofs + part->sector_size -
-				buf_len, buf_len, buf + buf_size - buf_len);
-
-		sm = (void *)buf + buf_size - sizeof(*sm);
-		if (sm->magic == JFFS2_SUM_MAGIC) {
-			sumlen = part->sector_size - sm->offset;
-			sumptr = buf + buf_size - sumlen;
-
-			/* Now, make sure the summary itself is available */
-			if (sumlen > buf_size) {
-				/* Need to kmalloc for this. */
-				sumptr = malloc(sumlen);
-				if (!sumptr) {
-					putstr("Can't get memory for summary "
-							"node!\n");
-					free(buf);
-					jffs2_free_cache(part);
-					return 0;
-				}
-				memcpy(sumptr + sumlen - buf_len, buf +
-						buf_size - buf_len, buf_len);
-			}
-			if (buf_len < sumlen) {
-				/* Need to read more so that the entire summary
-				 * node is present
-				 */
-				get_fl_mem(part->offset + sector_ofs +
-						part->sector_size - sumlen,
-						sumlen - buf_len, sumptr);
-			}
-		}
-
-		if (sumptr) {
-			ret = jffs2_sum_scan_sumnode(part, sector_ofs, sumptr,
-					sumlen, pL);
-
-			if (buf_size && sumlen > buf_size)
-				free(sumptr);
-			if (ret < 0) {
-				free(buf);
-				jffs2_free_cache(part);
-				return 0;
-			}
-			if (ret)
-				continue;
-
+	while (offset < max) {
+		if ((oldoffset >> SPIN_BLKSIZE) != (offset >> SPIN_BLKSIZE)) {
+			printf("\b\b%c ", spinner[counter++ % sizeof(spinner)]);
+			oldoffset = offset;
 		}
-#endif /* CONFIG_JFFS2_SUMMARY */
-
-		buf_len = EMPTY_SCAN_SIZE(part->sector_size);
-
-		get_fl_mem((u32)part->offset + buf_ofs, buf_len, buf);
-
-		/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
-		ofs = 0;
-
-		/* Scan only 4KiB of 0xFF before declaring it's empty */
-		while (ofs < EMPTY_SCAN_SIZE(part->sector_size) &&
-				*(uint32_t *)(&buf[ofs]) == 0xFFFFFFFF)
-			ofs += 4;
-
-		if (ofs == EMPTY_SCAN_SIZE(part->sector_size))
-			continue;
-
-		ofs += sector_ofs;
-		prevofs = ofs - 1;
 
-	scan_more:
-		while (ofs < sector_ofs + part->sector_size) {
-			if (ofs == prevofs) {
-				printf("offset %08x already seen, skip\n", ofs);
-				ofs += 4;
-				counter4++;
-				continue;
-			}
-			prevofs = ofs;
-			if (sector_ofs + part->sector_size <
-					ofs + sizeof(*node))
-				break;
-			if (buf_ofs + buf_len < ofs + sizeof(*node)) {
-				buf_len = min_t(uint32_t, buf_size, sector_ofs
-						+ part->sector_size - ofs);
-				get_fl_mem((u32)part->offset + ofs, buf_len,
-					   buf);
-				buf_ofs = ofs;
-			}
-
-			node = (struct jffs2_unknown_node *)&buf[ofs-buf_ofs];
-
-			if (*(uint32_t *)(&buf[ofs-buf_ofs]) == 0xffffffff) {
-				uint32_t inbuf_ofs;
-				uint32_t empty_start, scan_end;
-
-				empty_start = ofs;
-				ofs += 4;
-				scan_end = min_t(uint32_t, EMPTY_SCAN_SIZE(
-							part->sector_size)/8,
-							buf_len);
-			more_empty:
-				inbuf_ofs = ofs - buf_ofs;
-				while (inbuf_ofs < scan_end) {
-					if (*(uint32_t *)(&buf[inbuf_ofs]) !=
-							0xffffffff)
-						goto scan_more;
-
-					inbuf_ofs += 4;
-					ofs += 4;
-				}
-				/* Ran off end. */
+		WATCHDOG_RESET();
 
-				/* See how much more there is to read in this
-				 * eraseblock...
-				 */
-				buf_len = min_t(uint32_t, buf_size,
-						sector_ofs +
-						part->sector_size - ofs);
-				if (!buf_len) {
-					/* No more to read. Break out of main
-					 * loop without marking this range of
-					 * empty space as dirty (because it's
-					 * not)
-					 */
-					break;
-				}
-				scan_end = buf_len;
-				get_fl_mem((u32)part->offset + ofs, buf_len,
-					   buf);
-				buf_ofs = ofs;
-				goto more_empty;
-			}
-			if (node->magic != JFFS2_MAGIC_BITMASK ||
-					!hdr_crc(node)) {
-				ofs += 4;
-				counter4++;
-				continue;
-			}
-			if (ofs + node->totlen >
-					sector_ofs + part->sector_size) {
-				ofs += 4;
-				counter4++;
-				continue;
-			}
+		node = (struct jffs2_unknown_node *) get_node_mem((u32)part->offset + offset);
+		if (node->magic == JFFS2_MAGIC_BITMASK && hdr_crc(node)) {
 			/* if its a fragment add it */
-			switch (node->nodetype) {
-			case JFFS2_NODETYPE_INODE:
-				if (buf_ofs + buf_len < ofs + sizeof(struct
-							jffs2_raw_inode)) {
-					get_fl_mem((u32)part->offset + ofs,
-						   buf_len, buf);
-					buf_ofs = ofs;
-					node = (void *)buf;
-				}
-				if (!inode_crc((struct jffs2_raw_inode *) node))
-				       break;
-
+			if (node->nodetype == JFFS2_NODETYPE_INODE &&
+				    inode_crc((struct jffs2_raw_inode *) node) &&
+				    data_crc((struct jffs2_raw_inode *) node)) {
 				if (insert_node(&pL->frag, (u32) part->offset +
-						ofs) == NULL) {
-					free(buf);
-					jffs2_free_cache(part);
+						offset) == NULL) {
+					put_fl_mem(node);
 					return 0;
 				}
-				if (max_totlen < node->totlen)
-					max_totlen = node->totlen;
-				break;
-			case JFFS2_NODETYPE_DIRENT:
-				if (buf_ofs + buf_len < ofs + sizeof(struct
-							jffs2_raw_dirent) +
-							((struct
-							 jffs2_raw_dirent *)
-							node)->nsize) {
-					get_fl_mem((u32)part->offset + ofs,
-						   buf_len, buf);
-					buf_ofs = ofs;
-					node = (void *)buf;
-				}
-
-				if (!dirent_crc((struct jffs2_raw_dirent *)
-							node) ||
-						!dirent_name_crc(
-							(struct
-							 jffs2_raw_dirent *)
-							node))
-					break;
+			} else if (node->nodetype == JFFS2_NODETYPE_DIRENT &&
+				   dirent_crc((struct jffs2_raw_dirent *) node)  &&
+				   dirent_name_crc((struct jffs2_raw_dirent *) node)) {
 				if (! (counterN%100))
 					puts ("\b\b.  ");
 				if (insert_node(&pL->dir, (u32) part->offset +
-						ofs) == NULL) {
-					free(buf);
-					jffs2_free_cache(part);
+						offset) == NULL) {
+					put_fl_mem(node);
 					return 0;
 				}
-				if (max_totlen < node->totlen)
-					max_totlen = node->totlen;
 				counterN++;
-				break;
-			case JFFS2_NODETYPE_CLEANMARKER:
+			} else if (node->nodetype == JFFS2_NODETYPE_CLEANMARKER) {
 				if (node->totlen != sizeof(struct jffs2_unknown_node))
 					printf("OOPS Cleanmarker has bad size "
 						"%d != %zu\n",
 						node->totlen,
 						sizeof(struct jffs2_unknown_node));
-				break;
-			case JFFS2_NODETYPE_PADDING:
+			} else if (node->nodetype == JFFS2_NODETYPE_PADDING) {
 				if (node->totlen < sizeof(struct jffs2_unknown_node))
 					printf("OOPS Padding has bad size "
 						"%d < %zu\n",
 						node->totlen,
 						sizeof(struct jffs2_unknown_node));
-				break;
-			case JFFS2_NODETYPE_SUMMARY:
-				break;
-			default:
+			} else {
 				printf("Unknown node type: %x len %d offset 0x%x\n",
 					node->nodetype,
-					node->totlen, ofs);
+					node->totlen, offset);
 			}
-			ofs += ((node->totlen + 3) & ~3);
+			offset += ((node->totlen + 3) & ~3);
 			counterF++;
+		} else if (node->magic == JFFS2_EMPTY_BITMASK &&
+			   node->nodetype == JFFS2_EMPTY_BITMASK) {
+			offset = jffs2_scan_empty(offset, part);
+		} else {	/* if we know nothing, we just step and look. */
+			offset += 4;
+			counter4++;
 		}
+/*             printf("unknown node magic %4.4x %4.4x @ %lx\n", node->magic, node->nodetype, (unsigned long)node); */
+		put_fl_mem(node);
 	}
 
-	free(buf);
 	putstr("\b\b done.\r\n");		/* close off the dots */
-
-	/* We don't care if malloc failed - then each read operation will
-	 * allocate its own buffer as necessary (NAND) or will read directly
-	 * from flash (NOR).
-	 */
-	pL->readbuf = malloc(max_totlen);
-
 	/* turn the lcd back on. */
 	/* splash(); */
 
diff -uNr u-boot-2009.08-rc1.org/fs/jffs2/jffs2_nand_1pass.c u-boot-2009.08-rc1/fs/jffs2/jffs2_nand_1pass.c
--- u-boot-2009.08-rc1.org/fs/jffs2/jffs2_nand_1pass.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/fs/jffs2/jffs2_nand_1pass.c	2009-07-27 15:48:31.000000000 +0200
@@ -94,7 +94,7 @@
 static struct b_node *
 insert_node(struct b_list *list, struct b_node *new)
 {
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	struct b_node *b, *prev;
 
 	if (list->listTail != NULL && list->listCompare(new, list->listTail))
@@ -171,7 +171,7 @@
 	return insert_node(list, (struct b_node *)new);
 }
 
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 /* Sort data entries with the latest version last, so that if there
  * is overlapping data the latest version will be used.
  */
@@ -248,7 +248,7 @@
 		pL = (struct b_lists *)part->jffs2_priv;
 
 		memset(pL, 0, sizeof(*pL));
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 		pL->dir.listCompare = compare_dirents;
 		pL->frag.listCompare = compare_inodes;
 #endif
@@ -266,7 +266,7 @@
 	u32 latestVersion = 0;
 	long ret;
 
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	/* Find file size before loading any data, so fragments that
 	 * start past the end of file can be ignored. A fragment
 	 * that is partially in the file is loaded, so extra data may
@@ -288,7 +288,7 @@
 	for (jNode = (struct b_inode *)pL->frag.listHead; jNode; jNode = jNode->next) {
 		if ((ino != jNode->ino))
 			continue;
-#ifndef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifndef CFG_JFFS2_SORT_FRAGMENTS
 		/* get actual file length from the newest node */
 		if (jNode->version >= latestVersion) {
 			totalSize = jNode->isize;
diff -uNr u-boot-2009.08-rc1.org/fs/jffs2/jffs2_private.h u-boot-2009.08-rc1/fs/jffs2/jffs2_private.h
--- u-boot-2009.08-rc1.org/fs/jffs2/jffs2_private.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/fs/jffs2/jffs2_private.h	2009-07-27 15:48:31.000000000 +0200
@@ -7,13 +7,12 @@
 struct b_node {
 	u32 offset;
 	struct b_node *next;
-	enum { CRC_UNKNOWN = 0, CRC_OK, CRC_BAD } datacrc;
 };
 
 struct b_list {
 	struct b_node *listTail;
 	struct b_node *listHead;
-#ifdef CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#ifdef CFG_JFFS2_SORT_FRAGMENTS
 	struct b_node *listLast;
 	int (*listCompare)(struct b_node *new, struct b_node *node);
 	u32 listLoops;
@@ -25,7 +24,7 @@
 struct b_lists {
 	struct b_list dir;
 	struct b_list frag;
-	void *readbuf;
+
 };
 
 struct b_compr_info {
diff -uNr u-boot-2009.08-rc1.org/fs/Makefile u-boot-2009.08-rc1/fs/Makefile
--- u-boot-2009.08-rc1.org/fs/Makefile	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/fs/Makefile	2009-07-27 15:48:23.000000000 +0200
@@ -30,6 +30,7 @@
 subdirs-$(CONFIG_CMD_REISER) += reiserfs
 subdirs-$(CONFIG_YAFFS2) += yaffs2
 subdirs-$(CONFIG_CMD_UBIFS) += ubifs
+subdirs-$(CONFIG_CMD_SQUASHFS) += squashfs
 
 SUBDIRS	:= $(subdirs-y)
 
diff -uNr u-boot-2009.08-rc1.org/fs/squashfs/Makefile u-boot-2009.08-rc1/fs/squashfs/Makefile
--- u-boot-2009.08-rc1.org/fs/squashfs/Makefile	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/fs/squashfs/Makefile	2009-07-27 15:48:23.000000000 +0200
@@ -23,25 +23,29 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= libsquashfs.a
+LIB	= $(obj)libsquashfs.a
 
 AOBJS	=
-COBJS	= squashfs.o uncompress.o
-OBJS	= $(AOBJS) $(COBJS)
+COBJS-$(CONFIG_CMD_SQUASHFS) = squashfs.o uncompress.o
+COBJS-$(CONFIG_SQUASHFS_LZMA) += LzmaDecode.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(AOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS))
 
 #CPPFLAGS +=
 
 all:	$(LIB) $(AOBJS)
 
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 
 #########################################################################
 
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff -uNr u-boot-2009.08-rc1.org/fs/squashfs/squashfs.c u-boot-2009.08-rc1/fs/squashfs/squashfs.c
--- u-boot-2009.08-rc1.org/fs/squashfs/squashfs.c	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/fs/squashfs/squashfs.c	2009-07-27 15:48:23.000000000 +0200
@@ -38,12 +38,12 @@
 
 #include <common.h>
 
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
+#if (CONFIG_FS & CONFIG_FS_SQUASHFS)
 
 #include <linux/types.h>
 #include <squashfs/squashfs_fs.h>
 #include <squashfs/global.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <malloc.h>
 #include <cmd_fs.h>
 
@@ -632,4 +632,4 @@
 	}
 	return size;
 }
-#endif /* (CONFIG_FS & CFG_FS_SQUASHFS) */
+#endif /* (CONFIG_FS & CONFIG_FS_SQUASHFS) */
diff -uNr u-boot-2009.08-rc1.org/fs/squashfs/uncompress.c u-boot-2009.08-rc1/fs/squashfs/uncompress.c
--- u-boot-2009.08-rc1.org/fs/squashfs/uncompress.c	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/fs/squashfs/uncompress.c	2009-07-27 15:48:23.000000000 +0200
@@ -15,14 +15,14 @@
 #include <malloc.h>
 #include <watchdog.h>
 
-#if (CONFIG_FS & CFG_FS_SQUASHFS)
+#if (CONFIG_FS & CONFIG_FS_SQUASHFS)
 
 #ifdef CONFIG_SQUASHFS_LZMA
 #include "LzmaDecode.h"
 #include "LzmaDecode.c"
 static CLzmaDecoderState state;
 #else
-#include <zlib.h>
+#include <u-boot/zlib.h>
 static z_stream stream;
 #endif
 
@@ -121,4 +121,4 @@
 	return 0;
 }
 
-#endif /* CFG_FS_SQUASHFS */
+#endif /* CONFIG_FS_SQUASHFS */
diff -uNr u-boot-2009.08-rc1.org/include/cmd_fs.h u-boot-2009.08-rc1/include/cmd_fs.h
--- u-boot-2009.08-rc1.org/include/cmd_fs.h	2009-07-27 15:46:42.000000000 +0200
+++ u-boot-2009.08-rc1/include/cmd_fs.h	2009-07-27 15:48:23.000000000 +0200
@@ -34,6 +34,7 @@
 	int type;
 	unsigned int offset;
 	unsigned int size;
+	u32 sector_size;		/* size of sector */
 	void *jffs2_priv;
 } part_info_t;
 
diff -uNr u-boot-2009.08-rc1.org/include/commproc.h u-boot-2009.08-rc1/include/commproc.h
--- u-boot-2009.08-rc1.org/include/commproc.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/include/commproc.h	2009-07-27 15:48:23.000000000 +0200
@@ -607,6 +607,27 @@
 
 #endif	/* CONFIG_PCU_E, CONFIG_CCM */
 
+/***  DBOX2  ********************************/
+
+#ifdef CONFIG_DBOX2
+
+#define	PROFF_ENET	PROFF_SCC2
+#define	CPM_CR_ENET	CPM_CR_CH_SCC2
+#define	SCC_ENET	1
+
+#define	PA_ENET_RXD	((ushort)0x0004)	/* PA 13 */
+#define	PA_ENET_TXD	((ushort)0x0008)	/* PA 12 */
+#define	PA_ENET_RCLK	((ushort)0x0200)	/* PA  6 */
+#define	PA_ENET_TCLK	((ushort)0x0800)	/* PA  4 */
+#define	PC_ENET_TENA	((ushort)0x0002)	/* PC 14 */
+#define	PC_ENET_CLSN	((ushort)0x0040)	/* PC  9 */
+#define	PC_ENET_RENA	((ushort)0x0080)	/* PC  8 */
+
+#define	SICR_ENET_MASK	((uint)0x0000ff00)
+#define	SICR_ENET_CLKRT	((uint)0x00003d00)
+
+#endif /* CONFIG_DBOX2 */
+
 /***  ELPT860 *********************************************************/
 
 #ifdef CONFIG_ELPT860
diff -uNr u-boot-2009.08-rc1.org/include/flash.h u-boot-2009.08-rc1/include/flash.h
--- u-boot-2009.08-rc1.org/include/flash.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/include/flash.h	2009-07-27 15:48:23.000000000 +0200
@@ -285,6 +285,7 @@
 #define STM_ID_29W320ET 0x22562256	/* M29W320ET ID (32 M, top boot sector) */
 #define STM_ID_29W320EB 0x22572257	/* M29W320EB ID (32 M, bottom boot sect)*/
 #define STM_ID_29W040B	0x00E300E3	/* M29W040B ID (4M = 512K x 8)	*/
+#define STM_ID_28W320CB	0x88BB88BB	/* M28W320CB ID (32 Mbit (2Mb x16, Boot Block)) */
 #define FLASH_PSD4256GV 0x00E9		/* PSD4256 Flash and CPLD combination	*/
 
 #define INTEL_ID_28F016S    0x66a066a0	/* 28F016S[VS] ID (16M = 512k x 16)	*/
@@ -395,6 +396,7 @@
 #define FLASH_STM320DB	0x00CB		/* STM M29W320DB (4M = 64K x 64, bottom)*/
 #define FLASH_STM800DT	0x00D7		/* STM M29W800DT (1M = 64K x 16, top)	*/
 #define FLASH_STM800DB	0x005B		/* STM M29W800DB (1M = 64K x 16, bottom)*/
+#define FLASH_STM320CB	0x005D		/* M28W320CB ID (32 Mbit (2Mb x16, Boot Block))	*/
 
 #define FLASH_28F400_T	0x0062		/* MT  28F400B3 ID (  4M = 256K x 16 )	*/
 #define FLASH_28F400_B	0x0063		/* MT  28F400B3 ID (  4M = 256K x 16 )	*/
diff -uNr u-boot-2009.08-rc1.org/include/jffs2/load_kernel.h u-boot-2009.08-rc1/include/jffs2/load_kernel.h
--- u-boot-2009.08-rc1.org/include/jffs2/load_kernel.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/include/jffs2/load_kernel.h	2009-07-27 15:48:23.000000000 +0200
@@ -42,6 +42,17 @@
 	struct list_head parts;		/* partitions */
 };
 
+#if defined(CONFIG_CMD_FS)
+	#ifndef _CMD_FS_H
+	struct part_info {
+		int type;
+		unsigned long offset;
+		unsigned long size;
+		u32 sector_size;		/* size of sector */
+		void *jffs2_priv;
+	};
+	#endif
+#else
 struct part_info {
 	struct list_head link;
 	char *name;			/* partition name */
@@ -53,6 +64,7 @@
 	u32 sector_size;		/* size of sector */
 	struct mtd_device *dev;		/* parent device */
 };
+#endif
 
 struct mtdids {
 	struct list_head link;
diff -uNr u-boot-2009.08-rc1.org/include/lcd.h u-boot-2009.08-rc1/include/lcd.h
--- u-boot-2009.08-rc1.org/include/lcd.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/include/lcd.h	2009-07-27 15:48:23.000000000 +0200
@@ -204,6 +204,9 @@
 void	lcd_disable	(void);
 #endif
 
+#ifdef CONFIG_LCD_BOARD
+int	lcd_init	(void);
+#endif /* CONFIG_LCD_BOARD */
 
 /* int	lcd_init	(void *lcdbase); */
 void	lcd_putc	(const char c);
diff -uNr u-boot-2009.08-rc1.org/include/stdio_dev.h u-boot-2009.08-rc1/include/stdio_dev.h
--- u-boot-2009.08-rc1.org/include/stdio_dev.h	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/include/stdio_dev.h	2009-07-27 15:48:23.000000000 +0200
@@ -114,6 +114,9 @@
 #ifdef CONFIG_KEYBOARD
 int	drv_keyboard_init (void);
 #endif
+#ifdef CONFIG_DBOX2
+int	drv_dbox2_init (void);
+#endif /* CONFG_DBOX2 */
 #ifdef CONFIG_USB_TTY
 int	drv_usbtty_init (void);
 #endif
diff -uNr u-boot-2009.08-rc1.org/lib_generic/crc32.c u-boot-2009.08-rc1/lib_generic/crc32.c
--- u-boot-2009.08-rc1.org/lib_generic/crc32.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/lib_generic/crc32.c	2009-07-27 15:48:23.000000000 +0200
@@ -172,7 +172,7 @@
     return crc ^ 0xffffffffL;
 }
 
-#if defined(CONFIG_CMD_JFFS2) || defined(CONFIG_CMD_NAND)
+#if defined(CONFIG_CMD_JFFS2) || (CONFIG_FS & CONFIG_FS_JFFS2)
 
 /* No ones complement version. JFFS2 (and other things ?)
  * don't use ones compliment in their CRC calculations.
diff -uNr u-boot-2009.08-rc1.org/lib_ppc/board.c u-boot-2009.08-rc1/lib_ppc/board.c
--- u-boot-2009.08-rc1.org/lib_ppc/board.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/lib_ppc/board.c	2009-07-27 15:48:23.000000000 +0200
@@ -892,6 +892,11 @@
 	mac_read_from_eeprom();
 #endif
 
+/* needed here to enable kernel to determine the correct MAC address */
+#if defined (CONFIG_DBOX2)
+	misc_init_r ();
+#endif
+
 #ifdef	CONFIG_HERMES
 	if ((gd->board_type >> 16) == 2)
 		bd->bi_ethspeed = gd->board_type & 0xFFFF;
diff -uNr u-boot-2009.08-rc1.org/Makefile u-boot-2009.08-rc1/Makefile
--- u-boot-2009.08-rc1.org/Makefile	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/Makefile	2009-07-27 15:48:23.000000000 +0200
@@ -197,7 +197,7 @@
 endif
 LIBS += lib_$(ARCH)/lib$(ARCH).a
 LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
-	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a fs/yaffs2/libyaffs2.a \
+	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a fs/yaffs2/libyaffs2.a fs/squashfs/libsquashfs.a \
 	fs/ubifs/libubifs.a
 LIBS += net/libnet.a
 LIBS += disk/libdisk.a
@@ -316,6 +316,13 @@
 $(obj)u-boot.sha1:	$(obj)u-boot.bin
 		$(obj)tools/ubsha1 $(obj)u-boot.bin
 
+$(obj)u-boot.stripped: $(obj)u-boot
+		cp $< $@
+		$(STRIP) $@
+
+$(obj)u-boot.treeboot: $(obj)u-boot.stripped
+		./tools/mktree $< $@
+
 $(obj)u-boot.dis:	$(obj)u-boot
 		$(OBJDUMP) -d $< > $@
 
@@ -854,6 +861,9 @@
 cogent_mpc8xx_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc8xx cogent
 
+dbox2_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx dbox2
+
 ELPT860_config:		unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc8xx elpt860 LEOX
 
@@ -1313,6 +1323,9 @@
 DP405_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx dp405 esd
 
+dreambox_config:unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx dreambox
+
 DU405_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx du405 esd
 
@@ -3632,7 +3645,7 @@
 	@rm -f $(obj)examples/api/demo{,.bin}
 	@rm -f $(obj)tools/bmp_logo	   $(obj)tools/easylogo/easylogo  \
 	       $(obj)tools/env/{fw_printenv,fw_setenv}			  \
-	       $(obj)tools/envcrc					  \
+	       $(obj)tools/envcrc	   $(obj)tools/mktree		  \
 	       $(obj)tools/gdb/{astest,gdbcont,gdbsend}			  \
 	       $(obj)tools/gen_eth_addr    $(obj)tools/img2srec		  \
 	       $(obj)tools/mkimage	   $(obj)tools/mpc86x_clk	  \
@@ -3659,7 +3672,7 @@
 		| xargs -0 rm -f
 	@rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS \
 		$(obj)cscope.* $(obj)*.*~
-	@rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	@rm -f $(obj)u-boot $(obj)u-boot.* $(ALL)
 	@rm -f $(obj)tools/{env/crc32.c,inca-swap-bytes}
 	@rm -f $(obj)cpu/mpc824x/bedbug_603e.c
 	@rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
diff -uNr u-boot-2009.08-rc1.org/net/bootp.c u-boot-2009.08-rc1/net/bootp.c
--- u-boot-2009.08-rc1.org/net/bootp.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/net/bootp.c	2009-07-27 15:48:23.000000000 +0200
@@ -351,7 +352,17 @@
 		}
 	}
 
-	TftpStart();
+#ifdef CONFIG_TUXBOX_NETWORK
+	NetState = NETLOOP_SUCCESS;
+#endif /* CONFIG_TUXBOX_NETWORK */
+
+#ifdef CONFIG_TUXBOX_BOOTMANAGER
+	NetOurRootPath[0] = '/';
+	NetOurRootPath[1] = 0;
+	strncpy(NetOurRootPath, BootFile, strrchr(BootFile, '/') - BootFile);
+	NetOurRootPath[strrchr(NetOurRootPath, '/')-NetOurRootPath] = 0;
+#endif /* CONFIG_TUXBOX_BOOTMANAGER */
+
 }
 #endif
 
@@ -564,7 +575,7 @@
 {
 	volatile uchar *pkt, *iphdr;
 	Bootp_t *bp;
-	int ext_len, pktlen, iplen;
+	int pktlen, iplen, ext_len=0;
 
 #if defined(CONFIG_CMD_DHCP)
 	dhcp_state = INIT;
@@ -742,6 +753,8 @@
 			memcpy (&NetOurRootPath, popt + 2, size);
 			NetOurRootPath[size] = 0;
 			break;
+		case 28:	/* Ignore Broadcast Address Option */
+			break;
 #if defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_NTPSERVER)
 		case 42:	/* NTP server IP */
 			NetCopyIP (&NetNtpServerIP, (popt + 2));
@@ -792,7 +805,7 @@
 			if (dhcp_vendorex_proc (popt))
 				break;
 #endif
-			printf ("*** Unhandled DHCP Option in OFFER/ACK: %d\n", *popt);
+			debug("*** Unhandled DHCP Option in OFFER/ACK: %d\n", *popt);
 			break;
 		}
 		popt += oplen + 2;	/* Process next option */
@@ -948,7 +961,20 @@
 #endif
 				}
 			}
+#ifdef CONFIG_TUXBOX_NETWORK
+			NetState = NETLOOP_SUCCESS;
+#endif /* CONFIG_TUXBOX_NETWORK */
+
+#ifdef CONFIG_TUXBOX_BOOTMANAGER
+	NetOurRootPath[0] = '/';
+	NetOurRootPath[1] = 0;
+	strncpy(NetOurRootPath, BootFile, strrchr(BootFile, '/') - BootFile);
+	NetOurRootPath[strrchr(NetOurRootPath, '/')-NetOurRootPath] = 0;
+#endif /* CONFIG_TUXBOX_BOOTMANAGER */
+
+#ifndef CONFIG_BOOTP_NO_AUTOMATIC_TFTP
 			TftpStart();
+#endif
 			return;
 		}
 		break;
diff -uNr u-boot-2009.08-rc1.org/net/net.c u-boot-2009.08-rc1/net/net.c
--- u-boot-2009.08-rc1.org/net/net.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/net/net.c	2009-07-27 15:48:23.000000000 +0200
@@ -201,6 +201,10 @@
 
 static int net_check_prereq (proto_t protocol);
 
+#ifdef CONFIG_TUXBOX_NETWORK
+void netboot_update_env(void);
+#endif /* CONFIG_TUXBOX_NETWORK */
+
 /**********************************************************************/
 
 IPaddr_t	NetArpWaitPacketIP;
diff -uNr u-boot-2009.08-rc1.org/net/tftp.c u-boot-2009.08-rc1/net/tftp.c
--- u-boot-2009.08-rc1.org/net/tftp.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/net/tftp.c	2009-07-27 15:48:23.000000000 +0200
@@ -445,11 +445,15 @@
 	case TFTP_ERROR:
 		printf ("\nTFTP error: '%s' (%d)\n",
 					pkt + 2, ntohs(*(ushort *)pkt));
+#ifdef CONFIG_TUXBOX_NETWORK
+		NetState = NETLOOP_SUCCESS;
+#else /* CONFIG_TUXBOX_NETWORK */
 		puts ("Starting again\n\n");
 #ifdef CONFIG_MCAST_TFTP
 		mcast_cleanup();
 #endif
 		NetStartAgain ();
+#endif /* CONFIG_TUXBOX_NETWORK */
 		break;
 	}
 }
diff -uNr u-boot-2009.08-rc1.org/tools/Makefile u-boot-2009.08-rc1/tools/Makefile
--- u-boot-2009.08-rc1.org/tools/Makefile	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/tools/Makefile	2009-07-27 15:48:23.000000000 +0200
@@ -82,6 +82,7 @@
 BIN_FILES-$(CONFIG_VIDEO_LOGO) += bmp_logo$(SFX)
 BIN_FILES-$(CONFIG_INCA_IP) += inca-swap-bytes$(SFX)
 BIN_FILES-$(CONFIG_NETCONSOLE) += ncb$(SFX)
+BIN_FILES-y += mktree$(SFX)
 
 # Source files which exist outside the tools directory
 EXT_OBJ_FILES-y += common/env_embedded.o
@@ -101,6 +102,7 @@
 OBJ_FILES-$(CONFIG_INCA_IP) += inca-swap-bytes.o
 OBJ_FILES-$(CONFIG_NETCONSOLE) += ncb.o
 OBJ_FILES-y += os_support.o
+OBJ_FILES-y += mktree.o
 
 # Don't build by default
 #ifeq ($(ARCH),ppc)
@@ -191,6 +193,10 @@
 	$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 	$(STRIP) $@
 
+$(obj)mktree$(SFX):	$(obj)mktree.o
+	$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
+	$(STRIP) $@
+
 $(obj)mpc86x_clk$(SFX):	$(obj)mpc86x_clk.o
 	$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 	$(STRIP) $@
diff -uNr u-boot-2009.08-rc1.org/net/nfs.c u-boot-2009.08-rc1/net/nfs.c
--- u-boot-2009.08-rc1.org/net/nfs.c	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/net/nfs.c	2009-07-28 09:17:35.000000000 +0200
@@ -35,7 +35,7 @@
 
 #define HASHES_PER_LINE 65	/* Number of "loading" hashes per line	*/
 #define NFS_RETRY_COUNT 30
-#define NFS_TIMEOUT 2000UL
+#define NFS_TIMEOUT 5000UL
 
 static int fs_mounted = 0;
 static unsigned long rpc_id = 0;
@@ -587,10 +587,12 @@
 static void
 NfsTimeout (void)
 {
+/*
 	if ( NfsTimeoutCount++ < NFS_RETRY_COUNT ) {
 		NfsSend ();
 		return;
 	}
+*/
 	puts ("Timeout\n");
 	NetState = NETLOOP_FAIL;
 	return;
diff -uNr u-boot-2009.08-rc1.org/Makefile u-boot-2009.08-rc1/Makefile
--- u-boot-2009.08-rc1.org/Makefile	2009-07-27 10:37:37.000000000 +0200
+++ u-boot-2009.08-rc1/Makefile	2009-07-30 21:00:11.000000000 +0200
@@ -362,8 +362,8 @@
 		cat $(obj)onenand_ipl/onenand-ipl-4k.bin $(obj)u-boot.bin > $(obj)u-boot-flexonenand.bin
 
 $(VERSION_FILE):
-		@( printf '#define U_BOOT_VERSION "U-Boot %s%s"\n' "$(U_BOOT_VERSION)" \
-		 '$(shell $(TOPDIR)/tools/setlocalversion $(TOPDIR))' ) > $@.tmp
+		@( printf '#define U_BOOT_VERSION "U-Boot %s.%s (Tuxbox)"\n#define U_BOOT_VERSION_SHORT "U-Boot %s.%s"\n' \
+			"$(VERSION)" "$(PATCHLEVEL)" "$(VERSION)" "$(PATCHLEVEL)" ) > $@.tmp
 		@cmp -s $@ $@.tmp && rm -f $@.tmp || mv -f $@.tmp $@
 
 $(TIMESTAMP_FILE):
diff -uNr u-boot.org/fs/jffs2/compr_lzma.c u-boot/fs/jffs2/compr_lzma.c
--- u-boot.org/fs/jffs2/compr_lzma.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/fs/jffs2/compr_lzma.c	2009-07-27 11:38:46.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2008 Nikos Mavrogiannopoulos.
+ *
+ * compr_lzma is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *               
+ * compr_lzma is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *                               
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <common.h>
+#include <config.h>
+#include <jffs2/jffs2.h>
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDec.h>
+#include <malloc.h>
+
+static void *SzAlloc(void *p, size_t size) { p = p; return malloc(size); }
+static void SzFree(void *p, void *address) { p = p; free(address); }
+
+static int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		SizeT srclen, SizeT destlen)
+{
+	int ret;
+	ISzAlloc g_Alloc;
+	SizeT data_out_size = destlen;
+	SizeT data_in_size = srclen - LZMA_PROPS_SIZE;
+	ELzmaStatus state;
+	memset(&state, 0, sizeof(state));
+	
+	if (srclen < LZMA_PROPS_SIZE)
+		return -1;
+	
+	g_Alloc.Alloc = SzAlloc;
+	g_Alloc.Free = SzFree;
+
+	ret = LzmaDecode(
+		cpage_out, &data_out_size, 
+		data_in+LZMA_PROPS_SIZE, &data_in_size, 
+		data_in, LZMA_PROPS_SIZE, 
+		LZMA_FINISH_ANY, &state, &g_Alloc);
+	
+	if (ret != SZ_OK)
+		return -1;
+
+	return 0;
+}
+
+int lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      SizeT srclen, SizeT destlen)
+{
+	return jffs2_lzma_decompress (data_in, cpage_out, srclen, destlen);
+}
diff -uNr u-boot.org/fs/jffs2/jffs2_1pass.c u-boot/fs/jffs2/jffs2_1pass.c
--- u-boot.org/fs/jffs2/jffs2_1pass.c	2009-07-27 09:19:30.000000000 +0200
+++ u-boot/fs/jffs2/jffs2_1pass.c	2009-07-27 09:44:53.000000000 +0200
@@ -781,6 +781,11 @@
 				case JFFS2_COMPR_ZLIB:
 					ret = zlib_decompress(src, lDest, jNode->csize, jNode->dsize);
 					break;
+#if defined(CONFIG_JFFS2_LZMA)
+				case JFFS2_COMPR_LZMA:
+					ret = lzma_decompress(src, lDest, jNode->csize, jNode->dsize);
+					break;
+#endif
 #if defined(CONFIG_JFFS2_LZO_LZARI)
 				case JFFS2_COMPR_LZO:
 					ret = lzo_decompress(src, lDest, jNode->csize, jNode->dsize);
diff -uNr u-boot.org/fs/jffs2/jffs2_nand_1pass.c u-boot/fs/jffs2/jffs2_nand_1pass.c
--- u-boot.org/fs/jffs2/jffs2_nand_1pass.c	2009-07-27 09:19:30.000000000 +0200
+++ u-boot/fs/jffs2/jffs2_nand_1pass.c	2009-07-27 09:46:03.000000000 +0200
@@ -344,6 +344,11 @@
 			case JFFS2_COMPR_ZLIB:
 				ret = zlib_decompress(src, dst, inode->csize, inode->dsize);
 				break;
+#if defined(CONFIG_JFFS2_LZMA)
+			case JFFS2_COMPR_LZMA:
+				ret = lzma_decompress(src, dst, inode->csize, inode->dsize);
+				break;
+#endif
 #if defined(CONFIG_JFFS2_LZO_LZARI)
 			case JFFS2_COMPR_LZO:
 				ret = lzo_decompress(src, dst, inode->csize, inode->dsize);
diff -uNr u-boot.org/fs/jffs2/Makefile u-boot/fs/jffs2/Makefile
--- u-boot.org/fs/jffs2/Makefile	2009-07-27 06:57:57.000000000 +0200
+++ u-boot/fs/jffs2/Makefile	2009-07-27 09:28:35.000000000 +0200
@@ -29,6 +29,7 @@
 ifdef CONFIG_CMD_JFFS2
 COBJS-$(CONFIG_JFFS2_LZO_LZARI) += compr_lzari.o
 COBJS-$(CONFIG_JFFS2_LZO_LZARI) += compr_lzo.o
+COBJS-$(CONFIG_JFFS2_LZMA) += compr_lzma.o
 COBJS-y += compr_rtime.o
 COBJS-y += compr_rubin.o
 COBJS-y += compr_zlib.o
diff -uNr u-boot.org/include/jffs2/jffs2.h u-boot/include/jffs2/jffs2.h
--- u-boot.org/include/jffs2/jffs2.h	2009-07-27 06:57:58.000000000 +0200
+++ u-boot/include/jffs2/jffs2.h	2009-07-27 10:39:13.000000000 +0200
@@ -41,6 +41,10 @@
 #include <asm/types.h>
 #include <jffs2/load_kernel.h>
 
+#if defined(CONFIG_JFFS2_LZMA)
+#include <lzma/LzmaTypes.h>
+#endif
+
 #define JFFS2_SUPER_MAGIC 0x72b6
 
 /* Values we may expect to find in the 'magic' field */
@@ -68,12 +72,13 @@
 #define JFFS2_COMPR_COPY	0x04
 #define JFFS2_COMPR_DYNRUBIN	0x05
 #define JFFS2_COMPR_ZLIB	0x06
+#define JFFS2_COMPR_LZMA	0x15
 #if defined(CONFIG_JFFS2_LZO_LZARI)
 #define JFFS2_COMPR_LZO		0x07
 #define JFFS2_COMPR_LZARI	0x08
-#define JFFS2_NUM_COMPR		9
+#define JFFS2_NUM_COMPR		10
 #else
-#define JFFS2_NUM_COMPR		7
+#define JFFS2_NUM_COMPR		8
 #endif
 
 /* Compatibility flags. */
@@ -226,6 +231,10 @@
 		unsigned long sourcelen, unsigned long dstlen);
 long zlib_decompress(unsigned char *data_in, unsigned char *cpage_out,
 		__u32 srclen, __u32 destlen);
+#if defined(CONFIG_JFFS2_LZMA)
+int lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		SizeT srclen, SizeT destlen);
+#endif
 #if defined(CONFIG_JFFS2_LZO_LZARI)
 int lzo_decompress(unsigned char *data_in, unsigned char *cpage_out,
 		u32 srclen, u32 destlen);
