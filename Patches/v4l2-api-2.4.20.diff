add v4l2 API to the linux kernel
--- linux-2.4.20/drivers/media/video/Makefile	2002-12-11 10:59:20.000000000 +0100
+++ linux/drivers/media/video/Makefile	2002-12-11 11:04:12.000000000 +0100
@@ -25,13 +25,14 @@
 # All of the (potential) objects that export symbols.
 # This list comes from 'grep -l EXPORT_SYMBOL *.[hc]'.
 
-export-objs     :=	i2c-old.o videodev.o bttv-if.o cpia.o
+export-objs     :=	i2c-old.o videodev.o bttv-if.o cpia.o	\
+			v4l2-common.o v4l1-compat.o
 
 list-multi	:=	bttv.o zoran.o
 bttv-objs	:=	bttv-driver.o bttv-cards.o bttv-if.o
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 
-obj-$(CONFIG_VIDEO_DEV) += videodev.o
+obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
 obj-$(CONFIG_BUS_I2C) += i2c-old.o
 obj-$(CONFIG_VIDEO_BT848) += bttv.o msp3400.o tvaudio.o \
--- linux-2.4.20/drivers/media/video/v4l1-compat.c	2002-12-11 11:04:12.000000000 +0100
+++ linux/drivers/media/video/v4l1-compat.c	2002-12-18 14:58:41.000000000 +0100
@@ -0,0 +1,1042 @@
+/*
+ *	Video for Linux Two
+ *	Backward Compatibility Layer
+ *
+ *	Support subroutines for providing V4L2 drivers with backward
+ *	compatibility with applications using the old API.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Author:	Bill Dirks <bdirks@pacbell.net>
+ *		et al.
+ *
+ */
+
+#ifndef __KERNEL__
+#define __KERNEL__
+#endif
+
+#include <linux/config.h>
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/videodev.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+static unsigned int debug  = 0;
+MODULE_PARM(debug,"i");
+MODULE_PARM_DESC(debug,"enable debug messages");
+MODULE_AUTHOR("Bill Dirks");
+MODULE_DESCRIPTION("v4l(1) compatibility layer for v4l2 drivers.");
+MODULE_LICENSE("GPL");
+
+#define dprintk(fmt, arg...)	if (debug) \
+	printk(KERN_DEBUG "v4l1-compat: " fmt, ## arg)
+
+/*
+ *	I O C T L   T R A N S L A T I O N
+ *
+ *	From here on down is the code for translating the numerous
+ *	ioctl commands from the old API to the new API.
+ */
+
+static int
+get_v4l_control(struct inode            *inode,
+		struct file             *file,
+		int			cid,
+		v4l2_kioctl             drv)
+{
+	struct v4l2_queryctrl	qctrl2;
+	struct v4l2_control	ctrl2;
+	int			err;
+
+	qctrl2.id = cid;
+	err = drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2);
+	if (err < 0)
+		dprintk("VIDIOC_QUERYCTRL: %d\n",err);
+	if (err == 0 &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED))
+	{
+		ctrl2.id = qctrl2.id;
+		err = drv(inode, file, VIDIOC_G_CTRL, &ctrl2);
+		if (err < 0)
+			dprintk("VIDIOC_G_CTRL: %d\n",err);
+		return ((ctrl2.value - qctrl2.minimum) * 65535
+			 + (qctrl2.maximum - qctrl2.minimum) / 2)
+			/ (qctrl2.maximum - qctrl2.minimum);
+	}
+	return 0;
+}
+
+static int
+set_v4l_control(struct inode            *inode,
+		struct file             *file,
+		int			cid,
+		int			value,
+		v4l2_kioctl             drv)
+{
+	struct v4l2_queryctrl	qctrl2;
+	struct v4l2_control	ctrl2;
+	int			err;
+
+	qctrl2.id = cid;
+	err = drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2);
+	if (err < 0)
+		dprintk("VIDIOC_QUERYCTRL: %d\n",err);
+	if (err == 0 &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED) &&
+	    !(qctrl2.flags & V4L2_CTRL_FLAG_GRABBED))
+	{
+		if (value < 0)
+			value = 0;
+		if (value > 65535)
+			value = 65535;
+		if (value && qctrl2.type == V4L2_CTRL_TYPE_BOOLEAN)
+			value = 65535;
+		ctrl2.id = qctrl2.id;
+		ctrl2.value = 
+			(value * (qctrl2.maximum - qctrl2.minimum)
+			 + 32767)
+			/ 65535;
+		ctrl2.value += qctrl2.minimum;
+		err = drv(inode, file, VIDIOC_S_CTRL, &ctrl2);
+		if (err < 0)
+			dprintk("VIDIOC_S_CTRL: %d\n",err);
+	}
+	return 0;
+}
+
+static int palette2pixelformat[] = {
+	[VIDEO_PALETTE_GREY]    = V4L2_PIX_FMT_GREY,
+	[VIDEO_PALETTE_RGB555]  = V4L2_PIX_FMT_RGB555,
+	[VIDEO_PALETTE_RGB565]  = V4L2_PIX_FMT_RGB565,
+	[VIDEO_PALETTE_RGB24]   = V4L2_PIX_FMT_BGR24,
+	[VIDEO_PALETTE_RGB32]   = V4L2_PIX_FMT_BGR32,
+	/* yuv packed pixel */
+	[VIDEO_PALETTE_YUYV]    = V4L2_PIX_FMT_YUYV,
+	[VIDEO_PALETTE_YUV422]  = V4L2_PIX_FMT_YUYV,
+	[VIDEO_PALETTE_UYVY]    = V4L2_PIX_FMT_UYVY,
+	/* yuv planar */
+	[VIDEO_PALETTE_YUV410P] = V4L2_PIX_FMT_YUV410,
+	[VIDEO_PALETTE_YUV420]  = V4L2_PIX_FMT_YUV420,
+	[VIDEO_PALETTE_YUV420P] = V4L2_PIX_FMT_YUV420,
+	[VIDEO_PALETTE_YUV411P] = V4L2_PIX_FMT_YUV411P,
+	[VIDEO_PALETTE_YUV422P] = V4L2_PIX_FMT_YUV422P,
+};
+
+static int
+palette_to_pixelformat(int palette)
+{
+	if (palette < sizeof(palette2pixelformat)/sizeof(int))
+		return palette2pixelformat[palette];
+	else
+		return 0;
+}
+
+static int
+pixelformat_to_palette(int pixelformat)
+{
+	int	palette = 0;
+	switch (pixelformat)
+	{
+	case V4L2_PIX_FMT_GREY:
+		palette = VIDEO_PALETTE_GREY;
+		break;
+	case V4L2_PIX_FMT_RGB555:
+		palette = VIDEO_PALETTE_RGB555;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+		palette = VIDEO_PALETTE_RGB565;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		palette = VIDEO_PALETTE_RGB24;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		palette = VIDEO_PALETTE_RGB32;
+		break;
+	/* yuv packed pixel */
+	case V4L2_PIX_FMT_YUYV:
+		palette = VIDEO_PALETTE_YUYV;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		palette = VIDEO_PALETTE_UYVY;
+		break;
+	/* yuv planar */
+	case V4L2_PIX_FMT_YUV410:
+		palette = VIDEO_PALETTE_YUV420;
+		break;
+	case V4L2_PIX_FMT_YUV420:
+		palette = VIDEO_PALETTE_YUV420;
+		break;
+	case V4L2_PIX_FMT_YUV411P:
+		palette = VIDEO_PALETTE_YUV411P;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		palette = VIDEO_PALETTE_YUV422P;
+		break;
+	}
+	return palette;
+}
+
+/*  Do an 'in' (wait for input) select on a single file descriptor  */
+/*  This stuff plaigarized from linux/fs/select.c     */
+#define __FD_IN(fds, n)	(fds->in + n)
+#define BIT(i)		(1UL << ((i)&(__NFDBITS-1)))
+#define SET(i,m)	(*(m) |= (i))
+extern int do_select(int n, fd_set_bits *fds, long *timeout);
+
+
+static int
+simple_select(struct file *file)
+{
+	fd_set_bits fds;
+	char *bits;
+	long timeout;
+	int i, fd, n, ret, size;
+
+	for (i = 0; i < current->files->max_fds; ++i)
+		if (file == current->files->fd[i])
+			break;
+	if (i == current->files->max_fds)
+		return -EINVAL;
+	fd = i;
+	n = fd + 1;
+
+	timeout = MAX_SCHEDULE_TIMEOUT;
+	/*
+	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),
+	 * since we used fdset we need to allocate memory in units of
+	 * long-words. 
+	 */
+	ret = -ENOMEM;
+	size = FDS_BYTES(n);
+	bits = kmalloc(6 * size, GFP_KERNEL);
+	if (!bits)
+		goto out_nofds;
+	fds.in      = (unsigned long *)  bits;
+	fds.out     = (unsigned long *) (bits +   size);
+	fds.ex      = (unsigned long *) (bits + 2*size);
+	fds.res_in  = (unsigned long *) (bits + 3*size);
+	fds.res_out = (unsigned long *) (bits + 4*size);
+	fds.res_ex  = (unsigned long *) (bits + 5*size);
+
+	/*  All zero except our one file descriptor bit, for input  */
+	memset(bits, 0, 6 * size);
+	SET(BIT(fd), __FD_IN((&fds), fd / __NFDBITS));
+
+	ret = do_select(n, &fds, &timeout);
+
+	if (ret < 0)
+		goto out;
+	if (!ret) {
+		ret = -ERESTARTNOHAND;
+		if (signal_pending(current))
+			goto out;
+		ret = 0;
+	}
+out:
+	kfree(bits);
+out_nofds:
+	return ret;
+}
+
+static int count_inputs(struct inode         *inode,
+			struct file          *file,
+			v4l2_kioctl          drv)
+{
+	struct v4l2_input input2;
+	int i;
+
+	for (i = 0;; i++) {
+		memset(&input2,0,sizeof(input2));
+		input2.index = i;
+		if (0 != drv(inode,file,VIDIOC_ENUMINPUT, &input2))
+			break;
+	}
+	return i;
+}
+
+static int check_size(struct inode         *inode,
+		      struct file          *file,
+		      v4l2_kioctl          drv,
+		      int *maxw, int *maxh)
+{
+	struct v4l2_fmtdesc desc2;
+	struct v4l2_format  fmt2;
+
+	memset(&desc2,0,sizeof(desc2));
+	memset(&fmt2,0,sizeof(fmt2));
+	
+	desc2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (0 != drv(inode,file,VIDIOC_ENUM_FMT, &desc2))
+		goto done;
+
+	fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt2.fmt.pix.width       = 10000;
+	fmt2.fmt.pix.height      = 10000;
+	fmt2.fmt.pix.pixelformat = desc2.pixelformat;
+	if (0 != drv(inode,file,VIDIOC_TRY_FMT, &fmt2))
+		goto done;
+
+	*maxw = fmt2.fmt.pix.width;
+	*maxh = fmt2.fmt.pix.height;
+
+ done:
+	return 0;
+}
+
+
+/*
+ *	This function is exported.
+ */
+int
+v4l_compat_translate_ioctl(struct inode         *inode,
+			   struct file		*file,
+			   int			cmd,
+			   void			*arg,
+			   v4l2_kioctl          drv)
+{
+	int	             err = -ENOIOCTLCMD;
+
+	switch (cmd)
+	{
+	case VIDIOCGCAP:	/* capability */
+	{
+		struct video_capability *cap = arg;
+		struct v4l2_capability cap2;
+		struct v4l2_framebuffer fbuf2;
+		
+		memset(cap, 0, sizeof(*cap));
+		memset(&cap2, 0, sizeof(cap2));
+		memset(&fbuf2, 0, sizeof(fbuf2));
+
+		err = drv(inode, file, VIDIOC_QUERYCAP, &cap2);
+		if (err < 0) {
+			dprintk("VIDIOCGCAP / VIDIOC_QUERYCAP: %d\n",err);
+			break;
+		}
+		if (cap2.capabilities & V4L2_CAP_VIDEO_OVERLAY) {
+			err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+			if (err < 0) {
+				dprintk("VIDIOCGCAP / VIDIOC_G_FBUF: %d\n",err);
+				memset(&fbuf2, 0, sizeof(fbuf2));
+			}
+			err = 0;
+		}
+
+		memcpy(cap->name, cap2.card, 
+		       min(sizeof(cap->name), sizeof(cap2.card)));
+		cap->name[sizeof(cap->name) - 1] = 0;
+		if (cap2.capabilities & V4L2_CAP_VIDEO_CAPTURE)
+			cap->type |= VID_TYPE_CAPTURE;
+		if (cap2.capabilities & V4L2_CAP_TUNER)
+			cap->type |= VID_TYPE_TUNER;
+		if (cap2.capabilities & V4L2_CAP_VBI_CAPTURE)
+			cap->type |= VID_TYPE_TELETEXT;
+		if (cap2.capabilities & V4L2_CAP_VIDEO_OVERLAY)
+			cap->type |= VID_TYPE_OVERLAY;
+		if (fbuf2.capability & V4L2_FBUF_CAP_LIST_CLIPPING)
+			cap->type |= VID_TYPE_CLIPPING;
+
+		cap->channels  = count_inputs(inode,file,drv);
+		check_size(inode,file,drv,
+			   &cap->maxwidth,&cap->maxheight);
+		cap->audios    =  0; /* FIXME */
+		cap->minwidth  = 48; /* FIXME */
+		cap->minheight = 32; /* FIXME */
+		break;
+	}
+	case VIDIOCGFBUF: /*  get frame buffer  */
+	{
+		struct video_buffer	*buffer = arg;
+		struct v4l2_framebuffer	fbuf2;
+
+		err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+		if (err < 0) {
+			dprintk("VIDIOCGFBUF / VIDIOC_G_FBUF: %d\n",err);
+			break;
+		}
+		buffer->base   = fbuf2.base;
+		buffer->height = fbuf2.fmt.height;
+		buffer->width  = fbuf2.fmt.width;
+
+		switch (fbuf2.fmt.pixelformat) {
+		case V4L2_PIX_FMT_RGB332:
+			buffer->depth = 8;
+				break;
+		case V4L2_PIX_FMT_RGB555:
+			buffer->depth = 15;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+			buffer->depth = 16;
+			break;
+		case V4L2_PIX_FMT_BGR24:
+			buffer->depth = 24;
+			break;
+		case V4L2_PIX_FMT_BGR32:
+			buffer->depth = 32;
+			break;
+		default:
+			buffer->depth = 0;
+		}
+		if (0 != fbuf2.fmt.bytesperline)
+			buffer->bytesperline = fbuf2.fmt.bytesperline;
+		else {
+			buffer->bytesperline = 
+				(buffer->width * buffer->depth + 7) & 7;
+			buffer->bytesperline >>= 3;
+		}
+		break;
+	}
+	case VIDIOCSFBUF: /*  set frame buffer  */
+	{
+		struct video_buffer	*buffer = arg;
+		struct v4l2_framebuffer	fbuf2;
+
+		memset(&fbuf2, 0, sizeof(fbuf2));
+		fbuf2.base       = buffer->base;
+		fbuf2.fmt.height = buffer->height;
+		fbuf2.fmt.width  = buffer->width;
+		switch (buffer->depth) {
+		case 8:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB332;
+			break;
+		case 15:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB555;
+			break;
+		case 16:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_RGB565;
+			break;
+		case 24:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_BGR24;
+			break;
+		case 32:
+			fbuf2.fmt.pixelformat = V4L2_PIX_FMT_BGR32;
+			break;
+		}
+		fbuf2.fmt.bytesperline = buffer->bytesperline;
+		err = drv(inode, file, VIDIOC_S_FBUF, &fbuf2);
+		if (err < 0)
+			dprintk("VIDIOCSFBUF / VIDIOC_S_FBUF: %d\n",err);
+		break;
+	}
+	case VIDIOCGWIN: /*  get window or capture dimensions  */
+	{
+		struct video_window	*win = arg;
+		struct v4l2_format	fmt2;
+
+		memset(win,0,sizeof(*win));
+		memset(&fmt2,0,sizeof(fmt2));
+
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0)
+			dprintk("VIDIOCGWIN / VIDIOC_G_WIN: %d\n",err);
+		if (err == 0) {
+			win->x         = fmt2.fmt.win.w.left;
+			win->y         = fmt2.fmt.win.w.top;
+			win->width     = fmt2.fmt.win.w.width;
+			win->height    = fmt2.fmt.win.w.height;
+			win->chromakey = fmt2.fmt.win.chromakey;
+			win->clips     = NULL;
+			win->clipcount = 0;
+			break;
+		}
+
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCGWIN / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+		win->x         = 0;
+		win->y         = 0;
+		win->width     = fmt2.fmt.pix.width;
+		win->height    = fmt2.fmt.pix.height;
+		win->chromakey = 0;
+		win->clips     = NULL;
+		win->clipcount = 0;
+		break;
+	}
+	case VIDIOCSWIN: /*  set window and/or capture dimensions  */
+	{
+		struct video_window	*win = arg;
+		struct v4l2_format	fmt2;
+
+		memset(&fmt2,0,sizeof(fmt2));
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0)
+			dprintk("VIDIOCSWIN / VIDIOC_G_FMT: %d\n",err);
+		if (err == 0) {
+			fmt2.fmt.pix.width  = win->width;
+			fmt2.fmt.pix.height = win->height;
+			fmt2.fmt.pix.field  = V4L2_FIELD_ANY;
+			err = drv(inode, file, VIDIOC_S_FMT, &fmt2);
+			if (err < 0)
+				dprintk("VIDIOCSWIN / VIDIOC_S_FMT #1: %d\n",
+					err);
+			win->width  = fmt2.fmt.pix.width;
+			win->height = fmt2.fmt.pix.height;
+		}
+
+		memset(&fmt2,0,sizeof(fmt2));
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+		fmt2.fmt.win.w.left    = win->x;
+		fmt2.fmt.win.w.top     = win->y;
+		fmt2.fmt.win.w.width   = win->width;
+		fmt2.fmt.win.w.height  = win->height;
+		fmt2.fmt.win.chromakey = win->chromakey;
+		fmt2.fmt.win.clips     = (void *)win->clips;
+		fmt2.fmt.win.clipcount = win->clipcount;
+		err = drv(inode, file, VIDIOC_S_FMT, &fmt2);
+		if (err < 0)
+			dprintk("VIDIOCSWIN / VIDIOC_S_FMT #2: %d\n",err);
+		break;
+	}
+	case VIDIOCCAPTURE: /*  turn on/off preview  */
+	{
+		err = drv(inode, file, VIDIOC_OVERLAY, arg);
+		if (err < 0)
+			dprintk("VIDIOCCAPTURE / VIDIOC_PREVIEW: %d\n",err);
+		break;
+	}
+	case VIDIOCGCHAN: /*  get input information  */
+	{
+		struct video_channel	*chan = arg;
+		struct v4l2_input	input2;
+		v4l2_std_id    		sid;
+
+		memset(&input2,0,sizeof(input2));
+		input2.index = chan->channel;
+		err = drv(inode, file, VIDIOC_ENUMINPUT, &input2);
+		if (err < 0) {
+			dprintk("VIDIOCGCHAN / VIDIOC_ENUMINPUT: "
+				"channel=%d err=%d\n",chan->channel,err);
+			break;
+		}
+		chan->channel = input2.index;
+		memcpy(chan->name, input2.name,
+		       min(sizeof(chan->name), sizeof(input2.name)));
+		chan->name[sizeof(chan->name) - 1] = 0;
+		chan->tuners = (input2.type == V4L2_INPUT_TYPE_TUNER) ? 1 : 0;
+		chan->flags = (chan->tuners) ? VIDEO_VC_TUNER : 0;
+		switch (input2.type) {
+		case V4L2_INPUT_TYPE_TUNER:
+			chan->type = VIDEO_TYPE_TV;
+			break;
+		default:
+		case V4L2_INPUT_TYPE_CAMERA:
+			chan->type = VIDEO_TYPE_CAMERA;
+			break;
+		}
+		chan->norm = 0;
+		err = drv(inode, file, VIDIOC_G_STD, &sid);
+		if (err < 0)
+			dprintk("VIDIOCGCHAN / VIDIOC_G_STD: %d\n",err);
+		if (err == 0) {
+			if (sid & V4L2_STD_PAL)
+				chan->norm = VIDEO_MODE_PAL;
+			if (sid & V4L2_STD_NTSC)
+				chan->norm = VIDEO_MODE_NTSC;
+			if (sid & V4L2_STD_SECAM)
+				chan->norm = VIDEO_MODE_SECAM;
+		}
+		break;
+	}
+	case VIDIOCSCHAN: /*  set input  */
+	{
+		struct video_channel *chan = arg;
+		v4l2_std_id    	     sid = 0;
+		
+		err = drv(inode, file, VIDIOC_S_INPUT, &chan->channel);
+		if (err < 0)
+			dprintk("VIDIOCSCHAN / VIDIOC_S_INPUT: %d\n",err);
+		switch (chan->norm) {
+		case VIDEO_MODE_PAL:
+			sid = V4L2_STD_PAL;
+			break;
+		case VIDEO_MODE_NTSC:
+			sid = V4L2_STD_NTSC;
+			break;
+		case VIDEO_MODE_SECAM:
+			sid = V4L2_STD_SECAM;
+			break;
+		}
+		if (0 != sid) {
+			err = drv(inode, file, VIDIOC_S_STD, &sid);
+			if (err < 0)
+				dprintk("VIDIOCSCHAN / VIDIOC_S_STD: %d\n",err);
+		}
+		break;
+	}
+	case VIDIOCGPICT: /*  get tone controls & partial capture format  */
+	{
+		struct video_picture	*pict = arg;
+		struct v4l2_format	fmt2;
+
+		pict->brightness = get_v4l_control(inode, file,
+						   V4L2_CID_BRIGHTNESS,drv);
+		pict->hue = get_v4l_control(inode, file,
+					    V4L2_CID_HUE, drv);
+		pict->contrast = get_v4l_control(inode, file,
+						 V4L2_CID_CONTRAST, drv);
+		pict->colour = get_v4l_control(inode, file,
+					       V4L2_CID_SATURATION, drv);
+		pict->whiteness = get_v4l_control(inode, file,
+						  V4L2_CID_WHITENESS, drv);
+
+		memset(&fmt2,0,sizeof(fmt2));
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCGPICT / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+#if 0 /* FIXME */
+		pict->depth   = fmt2.fmt.pix.depth;
+#endif
+		pict->palette = pixelformat_to_palette(
+			fmt2.fmt.pix.pixelformat);
+		break;
+	}
+	case VIDIOCSPICT: /*  set tone controls & partial capture format  */
+	{
+		struct video_picture	*pict = arg;
+		struct v4l2_format	fmt2;
+		struct v4l2_framebuffer	fbuf2;
+
+		set_v4l_control(inode, file,
+				V4L2_CID_BRIGHTNESS, pict->brightness, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_HUE, pict->hue, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_CONTRAST, pict->contrast, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_SATURATION, pict->colour, drv);
+		set_v4l_control(inode, file,
+				V4L2_CID_WHITENESS, pict->whiteness, drv);
+
+		memset(&fmt2,0,sizeof(fmt2));
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0)
+			dprintk("VIDIOCSPICT / VIDIOC_G_FMT: %d\n",err);
+		if (fmt2.fmt.pix.pixelformat != 
+		    palette_to_pixelformat(pict->palette)) {
+			fmt2.fmt.pix.pixelformat = palette_to_pixelformat(
+				pict->palette);
+			err = drv(inode, file, VIDIOC_S_FMT, &fmt2);
+			if (err < 0)
+				dprintk("VIDIOCSPICT / VIDIOC_S_FMT: %d\n",err);
+		}
+
+		err = drv(inode, file, VIDIOC_G_FBUF, &fbuf2);
+		if (err < 0)
+			dprintk("VIDIOCSPICT / VIDIOC_G_FBUF: %d\n",err);
+		if (fbuf2.fmt.pixelformat !=
+		    palette_to_pixelformat(pict->palette)) {
+			fbuf2.fmt.pixelformat = palette_to_pixelformat(
+				pict->palette);
+			err = drv(inode, file, VIDIOC_S_FBUF, &fbuf2);
+			if (err < 0)
+				dprintk("VIDIOCSPICT / VIDIOC_S_FBUF: %d\n",err);
+			err = 0; /* likely fails for non-root */
+		}
+		break;
+	}
+	case VIDIOCGTUNER: /*  get tuner information  */
+	{
+		struct video_tuner	*tun = arg;
+		struct v4l2_tuner	tun2;
+		struct v4l2_standard	std2;
+		v4l2_std_id    		sid;
+		int i;
+
+		memset(&tun2,0,sizeof(tun2));
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0) {
+			dprintk("VIDIOCGTUNER / VIDIOC_G_TUNER: %d\n",err);
+			break;
+		}
+		memcpy(tun->name, tun2.name,
+		       min(sizeof(tun->name), sizeof(tun2.name)));
+		tun->name[sizeof(tun->name) - 1] = 0;
+		tun->rangelow = tun2.rangelow;
+		tun->rangehigh = tun2.rangehigh;
+		tun->flags = 0;
+		tun->mode = VIDEO_MODE_AUTO;
+
+		for (i = 0; i < 64; i++) {
+			memset(&std2,0,sizeof(std2));
+			std2.index = i;
+			if (0 != drv(inode, file, VIDIOC_ENUMSTD, &std2))
+				break;
+			if (std2.id & V4L2_STD_PAL)
+				tun->flags |= VIDEO_TUNER_PAL;
+			if (std2.id & V4L2_STD_NTSC)
+				tun->flags |= VIDEO_TUNER_NTSC;
+			if (std2.id & V4L2_STD_SECAM)
+				tun->flags |= VIDEO_TUNER_SECAM;
+		}
+
+		err = drv(inode, file, VIDIOC_G_STD, &sid);
+		if (err < 0)
+			dprintk("VIDIOCGTUNER / VIDIOC_G_STD: %d\n",err);
+		if (err == 0) {
+			if (sid & V4L2_STD_PAL)
+				tun->mode = VIDEO_MODE_PAL;
+			if (sid & V4L2_STD_NTSC)
+				tun->mode = VIDEO_MODE_NTSC;
+			if (sid & V4L2_STD_SECAM)
+				tun->mode = VIDEO_MODE_SECAM;
+		}
+
+		if (tun2.capability & V4L2_TUNER_CAP_LOW)
+			tun->flags |= VIDEO_TUNER_LOW;
+		if (tun2.rxsubchans & V4L2_TUNER_SUB_STEREO)
+			tun->flags |= VIDEO_TUNER_STEREO_ON;
+		tun->signal = tun2.signal;
+		break;
+	}
+#if 0 /* FIXME */
+	case VIDIOCSTUNER: /*  select a tuner input  */
+	{
+		int	i;
+
+		err = drv(inode, file, VIDIOC_S_INPUT, &i);
+		if (err < 0)
+			dprintk("VIDIOCSTUNER / VIDIOC_S_INPUT: %d\n",err);
+		break;
+	}
+#endif
+	case VIDIOCGFREQ: /*  get frequency  */
+	{
+		int *freq = arg;
+		struct v4l2_frequency freq2;
+		
+		err = drv(inode, file, VIDIOC_G_FREQUENCY, &freq2);
+		if (err < 0)
+			dprintk("VIDIOCGFREQ / VIDIOC_G_FREQUENCY: %d\n",err);
+		if (0 == err)
+			*freq = freq2.frequency;
+		break;
+	}
+	case VIDIOCSFREQ: /*  set frequency  */
+	{
+		int *freq = arg;
+		struct v4l2_frequency freq2;
+
+		drv(inode, file, VIDIOC_G_FREQUENCY, &freq2);
+		freq2.frequency = *freq;
+		err = drv(inode, file, VIDIOC_S_FREQUENCY, &freq2);
+		if (err < 0)
+			dprintk("VIDIOCSFREQ / VIDIOC_S_FREQUENCY: %d\n",err);
+		break;
+	}
+	case VIDIOCGAUDIO: /*  get audio properties/controls  */
+	{
+		struct video_audio	*aud = arg;
+		struct v4l2_audio	aud2;
+		struct v4l2_queryctrl	qctrl2;
+		struct v4l2_tuner	tun2;
+		int			v;
+
+		err = drv(inode, file, VIDIOC_G_AUDIO, &aud2);
+		if (err < 0) {
+			dprintk("VIDIOCGAUDIO / VIDIOC_G_AUDIO: %d\n",err);
+			break;
+		}
+		memcpy(aud->name, aud2.name,
+		       min(sizeof(aud->name), sizeof(aud2.name)));
+		aud->name[sizeof(aud->name) - 1] = 0;
+		aud->audio = aud2.index;
+		aud->flags = 0;
+		v = get_v4l_control(inode, file, V4L2_CID_AUDIO_VOLUME, drv);
+		if (v >= 0)
+		{
+			aud->volume = v;
+			aud->flags |= VIDEO_AUDIO_VOLUME;
+		}
+		v = get_v4l_control(inode, file, V4L2_CID_AUDIO_BASS, drv);
+		if (v >= 0)
+		{
+			aud->bass = v;
+			aud->flags |= VIDEO_AUDIO_BASS;
+		}
+		v = get_v4l_control(inode, file, V4L2_CID_AUDIO_TREBLE, drv);
+		if (v >= 0)
+		{
+			aud->treble = v;
+			aud->flags |= VIDEO_AUDIO_TREBLE;
+		}
+		v = get_v4l_control(inode, file, V4L2_CID_AUDIO_BALANCE, drv);
+		if (v >= 0)
+		{
+			aud->balance = v;
+			aud->flags |= VIDEO_AUDIO_BALANCE;
+		}
+		v = get_v4l_control(inode, file, V4L2_CID_AUDIO_MUTE, drv);
+		if (v >= 0)
+		{
+			if (v)
+				aud->flags |= VIDEO_AUDIO_MUTE;
+			aud->flags |= VIDEO_AUDIO_MUTABLE;
+		}
+		aud->step = 1;
+		qctrl2.id = V4L2_CID_AUDIO_VOLUME;
+		if (drv(inode, file, VIDIOC_QUERYCTRL, &qctrl2) == 0 &&
+		    !(qctrl2.flags & V4L2_CTRL_FLAG_DISABLED))
+			aud->step = qctrl2.step;
+		aud->mode = 0;
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0) {
+			dprintk("VIDIOCGAUDIO / VIDIOC_G_TUNER: %d\n",err);
+			err = 0;
+			break;
+		}
+		if (tun2.rxsubchans & V4L2_TUNER_SUB_LANG2)
+			aud->mode = VIDEO_SOUND_LANG1 | VIDEO_SOUND_LANG2;
+		else if (tun2.rxsubchans & V4L2_TUNER_SUB_STEREO)
+			aud->mode = VIDEO_SOUND_STEREO;
+		else if (tun2.rxsubchans & V4L2_TUNER_SUB_MONO)
+			aud->mode = VIDEO_SOUND_MONO;
+		break;
+	}
+	case VIDIOCSAUDIO: /*  set audio controls  */
+	{
+		struct video_audio	*aud = arg;
+		struct v4l2_audio	aud2;
+		struct v4l2_tuner	tun2;
+
+		memset(&aud2,0,sizeof(aud2));
+		memset(&tun2,0,sizeof(tun2));
+		
+		aud2.index = aud->audio;
+		err = drv(inode, file, VIDIOC_S_AUDIO, &aud2);
+		if (err < 0) {
+			dprintk("VIDIOCSAUDIO / VIDIOC_S_AUDIO: %d\n",err);
+			break;
+		}
+
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_VOLUME, 
+				aud->volume, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_BASS,
+				aud->bass, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_TREBLE,
+				aud->treble, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_BALANCE,
+				aud->balance, drv);
+		set_v4l_control(inode, file, V4L2_CID_AUDIO_MUTE,
+				!!(aud->flags & VIDEO_AUDIO_MUTE), drv);
+
+		err = drv(inode, file, VIDIOC_G_TUNER, &tun2);
+		if (err < 0)
+			dprintk("VIDIOCSAUDIO / VIDIOC_G_TUNER: %d\n",err);
+		if (err == 0) {
+			switch (aud->mode) {
+			default:
+			case VIDEO_SOUND_MONO:
+			case VIDEO_SOUND_LANG1:
+				tun2.audmode = V4L2_TUNER_MODE_MONO;
+				break;
+			case VIDEO_SOUND_STEREO:
+				tun2.audmode = V4L2_TUNER_MODE_STEREO;
+				break;
+			case VIDEO_SOUND_LANG2:
+				tun2.audmode = V4L2_TUNER_MODE_LANG2;
+				break;
+			}
+			err = drv(inode, file, VIDIOC_S_TUNER, &tun2);
+			if (err < 0)
+				dprintk("VIDIOCSAUDIO / VIDIOC_S_TUNER: %d\n",err);
+		}
+		err = 0;
+		break;
+	}
+#if 0
+	case VIDIOCGMBUF: /*  get mmap parameters  */
+	{
+		struct video_mbuf		*mbuf = arg;
+		struct v4l2_requestbuffers	reqbuf2;
+		struct v4l2_buffer		buf2;
+		struct v4l2_format		fmt2, fmt2o;
+		struct v4l2_capability		cap2;
+		int				i;
+
+		/*  Set the format to maximum dimensions  */
+		if ((err = drv(inode, file, VIDIOC_QUERYCAP, &cap2)) < 0)
+			break;
+		fmt2o.type = V4L2_BUF_TYPE_CAPTURE;
+		if ((err = drv(inode, file, VIDIOC_G_FMT, &fmt2o)) < 0)
+			break;
+		fmt2 = fmt2o;
+		fmt2.fmt.pix.width = cap2.maxwidth;
+		fmt2.fmt.pix.height = cap2.maxheight;
+		fmt2.fmt.pix.flags |= V4L2_FMT_FLAG_INTERLACED;
+		if ((err = drv(inode, file, VIDIOC_S_FMT, &fmt2)) < 0)
+			break;
+		reqbuf2.count = 2; /* v4l always used two buffers */
+		reqbuf2.type = V4L2_BUF_TYPE_CAPTURE | V4L2_BUF_REQ_CONTIG;
+		err = drv(inode, file, VIDIOC_REQBUFS, &reqbuf2);
+		if (err < 0 || reqbuf2.count < 2 || reqbuf2.type
+		    != (V4L2_BUF_TYPE_CAPTURE | V4L2_BUF_REQ_CONTIG))
+		{/*	Driver doesn't support v4l back-compatibility  */
+			fmt2o.fmt.pix.flags |= V4L2_FMT_FLAG_INTERLACED;
+			drv(inode, file, VIDIOC_S_FMT, &fmt2o);
+			reqbuf2.count = 1;
+			reqbuf2.type = V4L2_BUF_TYPE_CAPTURE;
+			err = drv(inode, file, VIDIOC_REQBUFS, &reqbuf2);
+			if (err < 0)
+			{
+				err = -EINVAL;
+				break;
+			}
+			printk(KERN_INFO"V4L2: Device \"%s\" doesn't support"
+			       " v4l memory mapping\n", vfl->name);
+		}
+		buf2.index = 0;
+		buf2.type = V4L2_BUF_TYPE_CAPTURE;
+		err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+		mbuf->size = buf2.length * reqbuf2.count;
+		mbuf->frames = reqbuf2.count;
+		memset(mbuf->offsets, 0, sizeof(mbuf->offsets));
+		for (i = 0; i < mbuf->frames; ++i)
+			mbuf->offsets[i] = i * buf2.length;
+		break;
+	}
+#endif
+	case VIDIOCMCAPTURE: /*  capture a frame  */
+	{
+		struct video_mmap	*mm = arg;
+		struct v4l2_buffer	buf2;
+		struct v4l2_format	fmt2;
+
+		memset(&buf2,0,sizeof(buf2));
+		memset(&fmt2,0,sizeof(fmt2));
+		
+		fmt2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_G_FMT, &fmt2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_G_FMT: %d\n",err);
+			break;
+		}
+		if (mm->width   != fmt2.fmt.pix.width || 
+		    mm->height != fmt2.fmt.pix.height ||
+		    palette_to_pixelformat(mm->format) != 
+		    fmt2.fmt.pix.pixelformat)
+		{/* New capture format...  */
+			fmt2.fmt.pix.width = mm->width;
+			fmt2.fmt.pix.height = mm->height;
+			fmt2.fmt.pix.pixelformat =
+				palette_to_pixelformat(mm->format);
+			fmt2.fmt.pix.field = V4L2_FIELD_ANY;
+			err = drv(inode, file, VIDIOC_S_FMT, &fmt2);
+			if (err < 0) {
+				dprintk("VIDIOCMCAPTURE / VIDIOC_S_FMT: %d\n",err);
+				break;
+			}
+		}
+		buf2.index = mm->frame;
+		buf2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_QUERYBUF: %d\n",err);
+			break;
+		}
+		err = drv(inode, file, VIDIOC_QBUF, &buf2);
+		if (err < 0) {
+			dprintk("VIDIOCMCAPTURE / VIDIOC_QBUF: %d\n",err);
+			break;
+		}
+		err = drv(inode, file, VIDIOC_STREAMON, &buf2.type);
+		if (err < 0)
+			dprintk("VIDIOCMCAPTURE / VIDIOC_STREAMON: %d\n",err);
+		break;
+	}
+	case VIDIOCSYNC: /*  wait for a frame  */
+	{
+		int			*i = arg;
+		struct v4l2_buffer	buf2;
+
+		buf2.index = *i;
+		buf2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+		if (err < 0) {
+			/*  No such buffer */
+			dprintk("VIDIOCSYNC / VIDIOC_QUERYBUF: %d\n",err);
+			break;
+		}
+		if (!(buf2.flags & V4L2_BUF_FLAG_MAPPED)) {
+			/* Buffer is not mapped  */
+			err = -EINVAL;
+			break;
+		}
+
+		/*  Loop as long as the buffer is queued, but not done  */
+		while ((buf2.flags &
+			(V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE))
+		       == V4L2_BUF_FLAG_QUEUED)
+		{
+			err = simple_select(file);
+			if (err < 0 ||	/* error or sleep was interrupted  */
+			    err == 0)	/* timeout? Shouldn't occur.  */
+				break;
+			err = drv(inode, file, VIDIOC_QUERYBUF, &buf2);
+			if (err < 0)
+				dprintk("VIDIOCSYNC / VIDIOC_QUERYBUF: %d\n",err);
+		}
+		if (!(buf2.flags & V4L2_BUF_FLAG_DONE)) /* not done */
+			break;
+		do {
+			err = drv(inode, file, VIDIOC_DQBUF, &buf2);
+			if (err < 0)
+				dprintk("VIDIOCSYNC / VIDIOC_DQBUF: %d\n",err);
+		} while (err == 0 && buf2.index != *i);
+		break;
+	}
+	case VIDIOCGUNIT: /*  get related device minors  */
+		/*  No translation  */
+		break;
+	case VIDIOCGCAPTURE: /*    */
+		/*  No translation, yet...  */
+		printk(KERN_INFO"v4l1-compat: VIDIOCGCAPTURE not implemented."
+		       " Send patches to bdirks@pacbell.net :-)\n");
+		break;
+	case VIDIOCSCAPTURE: /*    */
+		/*  No translation, yet...  */
+		printk(KERN_INFO"v4l1-compat: VIDIOCSCAPTURE not implemented."
+		       " Send patches to bdirks@pacbell.net :-)\n");
+		break;
+	}
+	return err;
+}
+
+EXPORT_SYMBOL(v4l_compat_translate_ioctl);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
--- linux-2.4.20/drivers/media/video/v4l2-common.c	2002-12-11 11:04:12.000000000 +0100
+++ linux/drivers/media/video/v4l2-common.c	2002-12-11 11:04:12.000000000 +0100
@@ -0,0 +1,211 @@
+/*
+ *	Video for Linux Two
+ *
+ *	A generic video device interface for the LINUX operating system
+ *	using a set of device structures/vectors for low level operations.
+ *
+ *	This file replaces the videodev.c file that comes with the
+ *	regular kernel distribution.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Author:	Bill Dirks <bdirks@pacbell.net>
+ *		based on code by Alan Cox, <alan@cymru.net>
+ *
+ */
+
+/*
+ * Video capture interface for Linux
+ *
+ *	A generic video device interface for the LINUX operating system
+ *	using a set of device structures/vectors for low level operations.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Author:	Alan Cox, <alan@redhat.com>
+ *
+ * Fixes:
+ */
+
+/*
+ * Video4linux 1/2 integration by Justin Schoeman
+ * <justin@suntiger.ee.up.ac.za>
+ * 2.4 PROCFS support ported from 2.4 kernels by 
+ *  Iñaki García Etxebarria <garetxe@euskalnet.net>
+ * Makefile fix by "W. Michael Petullo" <mike@flyn.org>
+ * 2.4 devfs support ported from 2.4 kernels by
+ *  Dan Merillat <dan@merillat.org>
+ * Added Gerd Knorrs v4l1 enhancements (Justin Schoeman)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+#if defined(CONFIG_UST) || defined(CONFIG_UST_MODULE)
+#include <linux/ust.h>
+#endif
+
+#include <linux/videodev.h>
+
+MODULE_AUTHOR("Bill Dirks, Justin Schoeman, Gerd Knorr");
+MODULE_DESCRIPTION("misc helper functions for v4l2 device drivers");
+MODULE_LICENSE("GPL");
+
+/*
+ *
+ *	V 4 L 2   D R I V E R   H E L P E R   A P I
+ *
+ */
+
+/*
+ *  Video Standard Operations (contributed by Michael Schimek)
+ */
+
+/* This is the recommended method to deal with the framerate fields. More 
+   sophisticated drivers will access the fields directly. */
+unsigned int
+v4l2_video_std_fps(struct v4l2_standard *vs)
+{ 
+	if (vs->frameperiod.numerator > 0)
+		return (((vs->frameperiod.denominator << 8) / 
+			 vs->frameperiod.numerator) + 
+			(1 << 7)) / (1 << 8);
+	return 0;
+}
+
+/* Fill in the fields of a v4l2_standard structure according to the
+   'id' and 'transmission' parameters.  Returns negative on error.  */
+int v4l2_video_std_construct(struct v4l2_standard *vs,
+			     int id, char *name)
+{
+	memset(vs, 0, sizeof(struct v4l2_standard));
+
+	vs->id = id;
+	if (id & (V4L2_STD_NTSC | V4L2_STD_PAL_M)) {
+		vs->frameperiod.numerator = 1001;
+		vs->frameperiod.denominator = 30000;
+		vs->framelines = 525;
+	} else {
+		vs->frameperiod.numerator = 1;
+		vs->frameperiod.denominator = 25;
+		vs->framelines = 625;
+	}
+	strncpy(vs->name,name,sizeof(vs->name));
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------- */
+
+char *v4l2_field_names[] = {
+	[V4L2_FIELD_ANY]        = "any",
+	[V4L2_FIELD_NONE]       = "none",
+	[V4L2_FIELD_TOP]        = "top",
+	[V4L2_FIELD_BOTTOM]     = "bottom",
+	[V4L2_FIELD_INTERLACED] = "interlaced",
+	[V4L2_FIELD_SEQ_TB]     = "seq-tb",
+	[V4L2_FIELD_SEQ_BT]     = "seq-bt",
+	[V4L2_FIELD_ALTERNATE]  = "alternate",
+};
+
+char *v4l2_type_names[] = {
+	[V4L2_BUF_TYPE_VIDEO_CAPTURE] = "video-cap",
+	[V4L2_BUF_TYPE_VIDEO_OVERLAY] = "video-over",
+	[V4L2_BUF_TYPE_VIDEO_OUTPUT]  = "video-out",
+	[V4L2_BUF_TYPE_VBI_CAPTURE]   = "vbi-cap",
+	[V4L2_BUF_TYPE_VBI_OUTPUT]    = "vbi-out",
+};
+
+char *v4l2_ioctl_names[256] = {
+#if __GNUC__ >= 3
+	[0 ... 255]                      = "UNKNOWN",
+#endif
+	[_IOC_NR(VIDIOC_QUERYCAP)]       = "VIDIOC_QUERYCAP",
+	[_IOC_NR(VIDIOC_RESERVED)]       = "VIDIOC_RESERVED",
+	[_IOC_NR(VIDIOC_ENUM_FMT)]       = "VIDIOC_ENUM_FMT",
+	[_IOC_NR(VIDIOC_G_FMT)]          = "VIDIOC_G_FMT",
+	[_IOC_NR(VIDIOC_S_FMT)]          = "VIDIOC_S_FMT",
+#if 0
+	[_IOC_NR(VIDIOC_G_COMP)]         = "VIDIOC_G_COMP",
+	[_IOC_NR(VIDIOC_S_COMP)]         = "VIDIOC_S_COMP",
+#endif
+	[_IOC_NR(VIDIOC_REQBUFS)]        = "VIDIOC_REQBUFS",
+	[_IOC_NR(VIDIOC_QUERYBUF)]       = "VIDIOC_QUERYBUF",
+	[_IOC_NR(VIDIOC_G_FBUF)]         = "VIDIOC_G_FBUF",
+	[_IOC_NR(VIDIOC_S_FBUF)]         = "VIDIOC_S_FBUF",
+	[_IOC_NR(VIDIOC_OVERLAY)]        = "VIDIOC_OVERLAY",
+	[_IOC_NR(VIDIOC_QBUF)]           = "VIDIOC_QBUF",
+	[_IOC_NR(VIDIOC_DQBUF)]          = "VIDIOC_DQBUF",
+	[_IOC_NR(VIDIOC_STREAMON)]       = "VIDIOC_STREAMON",
+	[_IOC_NR(VIDIOC_STREAMOFF)]      = "VIDIOC_STREAMOFF",
+	[_IOC_NR(VIDIOC_G_PARM)]         = "VIDIOC_G_PARM",
+	[_IOC_NR(VIDIOC_S_PARM)]         = "VIDIOC_S_PARM",
+	[_IOC_NR(VIDIOC_G_STD)]          = "VIDIOC_G_STD",
+	[_IOC_NR(VIDIOC_S_STD)]          = "VIDIOC_S_STD",
+	[_IOC_NR(VIDIOC_ENUMSTD)]        = "VIDIOC_ENUMSTD",
+	[_IOC_NR(VIDIOC_ENUMINPUT)]      = "VIDIOC_ENUMINPUT",
+	[_IOC_NR(VIDIOC_G_CTRL)]         = "VIDIOC_G_CTRL",
+	[_IOC_NR(VIDIOC_S_CTRL)]         = "VIDIOC_S_CTRL",
+	[_IOC_NR(VIDIOC_G_TUNER)]        = "VIDIOC_G_TUNER",
+	[_IOC_NR(VIDIOC_S_TUNER)]        = "VIDIOC_S_TUNER",
+	[_IOC_NR(VIDIOC_G_AUDIO)]        = "VIDIOC_G_AUDIO",
+	[_IOC_NR(VIDIOC_S_AUDIO)]        = "VIDIOC_S_AUDIO",
+	[_IOC_NR(VIDIOC_QUERYCTRL)]      = "VIDIOC_QUERYCTRL",
+	[_IOC_NR(VIDIOC_QUERYMENU)]      = "VIDIOC_QUERYMENU",
+	[_IOC_NR(VIDIOC_G_INPUT)]        = "VIDIOC_G_INPUT",
+	[_IOC_NR(VIDIOC_S_INPUT)]        = "VIDIOC_S_INPUT",
+	[_IOC_NR(VIDIOC_G_OUTPUT)]       = "VIDIOC_G_OUTPUT",
+	[_IOC_NR(VIDIOC_S_OUTPUT)]       = "VIDIOC_S_OUTPUT",
+	[_IOC_NR(VIDIOC_ENUMOUTPUT)]     = "VIDIOC_ENUMOUTPUT",
+	[_IOC_NR(VIDIOC_G_AUDOUT)]       = "VIDIOC_G_AUDOUT",
+	[_IOC_NR(VIDIOC_S_AUDOUT)]       = "VIDIOC_S_AUDOUT",
+	[_IOC_NR(VIDIOC_G_MODULATOR)]    = "VIDIOC_G_MODULATOR",
+	[_IOC_NR(VIDIOC_S_MODULATOR)]    = "VIDIOC_S_MODULATOR",
+	[_IOC_NR(VIDIOC_G_FREQUENCY)]    = "VIDIOC_G_FREQUENCY",
+	[_IOC_NR(VIDIOC_S_FREQUENCY)]    = "VIDIOC_S_FREQUENCY",
+	[_IOC_NR(VIDIOC_CROPCAP)]        = "VIDIOC_CROPCAP",
+	[_IOC_NR(VIDIOC_G_CROP)]         = "VIDIOC_G_CROP",
+	[_IOC_NR(VIDIOC_S_CROP)]         = "VIDIOC_S_CROP",
+	[_IOC_NR(VIDIOC_G_JPEGCOMP)]     = "VIDIOC_G_JPEGCOMP",
+	[_IOC_NR(VIDIOC_S_JPEGCOMP)]     = "VIDIOC_S_JPEGCOMP",
+	[_IOC_NR(VIDIOC_QUERYSTD)]       = "VIDIOC_QUERYSTD",
+	[_IOC_NR(VIDIOC_TRY_FMT)]        = "VIDIOC_TRY_FMT",
+};
+
+/* ----------------------------------------------------------------- */
+
+EXPORT_SYMBOL(v4l2_video_std_fps);
+EXPORT_SYMBOL(v4l2_video_std_construct);
+
+EXPORT_SYMBOL(v4l2_field_names);
+EXPORT_SYMBOL(v4l2_type_names);
+EXPORT_SYMBOL(v4l2_ioctl_names);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
--- linux-2.4.20/include/linux/videodev.h	2002-12-11 11:00:38.000000000 +0100
+++ linux/include/linux/videodev.h	2002-12-18 14:56:33.000000000 +0100
@@ -4,7 +4,7 @@
 #include <linux/types.h>
 #include <linux/version.h>
 
-#if 0
+#if 1
 /*
  * v4l2 is still work-in-progress, integration planed for 2.5.x
  *   v4l2 project homepage:   http://www.thedirks.org/v4l2/
@@ -20,6 +20,7 @@
 
 #include <linux/poll.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/mm.h>
 
 struct video_device
 {
@@ -30,6 +31,7 @@
 	int hardware;
 	int minor;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	/* old, obsolete interface -- dropped in 2.5.x, don't use it */
 	int (*open)(struct video_device *, int mode);
 	void (*close)(struct video_device *);
@@ -39,6 +41,7 @@
 	int (*ioctl)(struct video_device *, unsigned int , void *);
 	int (*mmap)(struct video_device *, const char *, unsigned long);
 	int (*initialize)(struct video_device *);       
+#endif
 
  	/* new interface -- we will use file_operations directly
  	 * like soundcore does. */
@@ -403,6 +406,7 @@
 #define VID_HARDWARE_PWC	31	/* Philips webcams */
 #define VID_HARDWARE_MEYE	32	/* Sony Vaio MotionEye cameras */
 #define VID_HARDWARE_CPIA2	33
+#define VID_HARDWARE_VICAM      34
 
 #endif /* __LINUX_VIDEODEV_H */
 
--- linux-2.4.20/include/linux/videodev2.h	2002-12-11 11:04:12.000000000 +0100
+++ linux/include/linux/videodev2.h	2002-12-18 14:56:33.000000000 +0100
@@ -0,0 +1,861 @@
+#ifndef __LINUX_VIDEODEV2_H
+#define __LINUX_VIDEODEV2_H
+/*
+ *	Video for Linux Two
+ *
+ *	Header file for v4l or V4L2 drivers and applications, for
+ *	Linux kernels 2.2.x or 2.4.x.
+ *
+ *	See http://www.thedirks.org/v4l2/ for API specs and other
+ *	v4l2 documentation.
+ *
+ *	Author: Bill Dirks <bdirks@pacbell.net>
+ *		Justin Schoeman
+ *		et al.
+ */
+#ifdef __KERNEL__
+#include <linux/time.h> /* need struct timeval */
+#endif
+
+/*
+ *	M I S C E L L A N E O U S
+ */
+
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*
+ *	E N U M S
+ */
+enum v4l2_field {
+	V4L2_FIELD_ANY        = 0, /* driver can choose from none,
+				      top, bottom, interlaced
+				      depending on whatever it thinks
+				      is approximate ... */
+	V4L2_FIELD_NONE       = 1, /* this device has no fields ... */
+	V4L2_FIELD_TOP        = 2, /* top field only */
+	V4L2_FIELD_BOTTOM     = 3, /* bottom field only */
+	V4L2_FIELD_INTERLACED = 4, /* both fields interlaced */
+	V4L2_FIELD_SEQ_TB     = 5, /* both fields sequential into one
+				      buffer, top-bottom order */
+	V4L2_FIELD_SEQ_BT     = 6, /* same as above + bottom-top order */
+	V4L2_FIELD_ALTERNATE  = 7, /* both fields alternating into
+				      separate buffers */
+};
+#define V4L2_FIELD_HAS_TOP(field)	\
+	((field) == V4L2_FIELD_TOP 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTTOM(field)	\
+	((field) == V4L2_FIELD_BOTTOM 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTH(field)	\
+	((field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+
+enum v4l2_buf_type {
+	V4L2_BUF_TYPE_VIDEO_CAPTURE  = 1,
+	V4L2_BUF_TYPE_VIDEO_OUTPUT   = 2,
+	V4L2_BUF_TYPE_VIDEO_OVERLAY  = 3,
+	V4L2_BUF_TYPE_VBI_CAPTURE    = 4,
+	V4L2_BUF_TYPE_VBI_OUTPUT     = 5,
+	V4L2_BUF_TYPE_PRIVATE        = 0x80,
+};
+
+enum v4l2_ctrl_type {
+	V4L2_CTRL_TYPE_INTEGER	     = 1,
+	V4L2_CTRL_TYPE_BOOLEAN	     = 2,
+	V4L2_CTRL_TYPE_MENU	     = 3,
+	V4L2_CTRL_TYPE_BUTTON	     = 4,
+};
+
+enum v4l2_tuner_type {
+	V4L2_TUNER_RADIO	     = 1,
+	V4L2_TUNER_ANALOG_TV	     = 2,
+};
+
+enum v4l2_memory {
+	V4L2_MEMORY_MMAP             = 1,
+	V4L2_MEMORY_USERPTR          = 2,
+	V4L2_MEMORY_OVERLAY          = 3,
+};
+
+/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
+enum v4l2_colorspace {
+	/* ITU-R 601 -- broadcast NTSC/PAL */
+	V4L2_COLORSPACE_SMPTE170M     = 1,
+
+	/* 1125-Line (US) HDTV */
+	V4L2_COLORSPACE_SMPTE240M     = 2,
+
+	/* HD and modern captures. */
+	V4L2_COLORSPACE_REC709        = 3,
+	
+	/* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
+	V4L2_COLORSPACE_BT878         = 4,
+	
+	/* These should be useful.  Assume 601 extents. */
+	V4L2_COLORSPACE_470_SYSTEM_M  = 5,
+	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
+	
+	/* I know there will be cameras that send this.  So, this is
+	 * unspecified chromaticities and full 0-255 on each of the
+	 * Y'CbCr components
+	 */
+	V4L2_COLORSPACE_JPEG          = 7,
+	
+	/* For RGB colourspaces, this is probably a good start. */
+	V4L2_COLORSPACE_SRGB          = 8,
+};
+
+struct v4l2_rect {
+	__s32   left;
+	__s32   top;
+	__s32   width;
+	__s32   height;
+};
+
+struct v4l2_fract {
+	__u32   numerator;
+	__u32   denominator;
+};
+
+/*
+ *	D R I V E R   C A P A B I L I T I E S
+ */
+struct v4l2_capability
+{
+	__u8	driver[16];	/* i.e. "bttv" */
+	__u8	card[32];	/* i.e. "Hauppauge WinTV" */
+	__u8	bus_info[32];	/* "PCI:" + pci_dev->slot_name */
+	__u32   version;        /* should use KERNEL_VERSION() */
+	__u32	capabilities;	/* Device capabilities */
+	__u32	reserved[4];
+};
+
+/* Values for 'capabilities' field */
+#define V4L2_CAP_VIDEO_CAPTURE	0x00000001  /* Is a video capture device */
+#define V4L2_CAP_VIDEO_OUTPUT	0x00000002  /* Is a video output device */
+#define V4L2_CAP_VIDEO_OVERLAY	0x00000004  /* Can do video overlay */
+#define V4L2_CAP_VBI_CAPTURE	0x00000010  /* Is a VBI capture device */
+#define V4L2_CAP_VBI_OUTPUT	0x00000020  /* Is a VBI output device */
+#define V4L2_CAP_RDS_CAPTURE	0x00000100  /* RDS data capture */
+
+#define V4L2_CAP_TUNER		0x00010000  /* Has a tuner */
+#define V4L2_CAP_AUDIO		0x00020000  /* has audio support */
+
+#define V4L2_CAP_READWRITE      0x01000000  /* read/write systemcalls */
+#define V4L2_CAP_ASYNCIO        0x02000000  /* async I/O */
+#define V4L2_CAP_STREAMING      0x04000000  /* streaming I/O ioctls */
+
+/*
+ *	V I D E O   I M A G E   F O R M A T
+ */
+
+struct v4l2_pix_format
+{
+	__u32         	 	width;
+	__u32	         	height;
+	__u32	         	pixelformat;
+	enum v4l2_field  	field;
+	__u32            	bytesperline;	/* for padding, zero if unused */
+	__u32          	 	sizeimage;
+        enum v4l2_colorspace	colorspace;
+	__u32			priv;		/* private data, depends on pixelformat */
+};
+
+/*           Pixel format    FOURCC                  depth  Description   */
+#define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R','G','B','1') /*  8  RGB-3-3-2     */
+#define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R','G','B','O') /* 16  RGB-5-5-5     */
+#define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R','G','B','P') /* 16  RGB-5-6-5     */
+#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R','G','B','Q') /* 16  RGB-5-5-5 BE  */
+#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R','G','B','R') /* 16  RGB-5-6-5 BE  */
+#define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B','G','R','3') /* 24  BGR-8-8-8     */
+#define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R','G','B','3') /* 24  RGB-8-8-8     */
+#define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B','G','R','4') /* 32  BGR-8-8-8-8   */
+#define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R','G','B','4') /* 32  RGB-8-8-8-8   */
+#define V4L2_PIX_FMT_GREY    v4l2_fourcc('G','R','E','Y') /*  8  Greyscale     */
+#define V4L2_PIX_FMT_YVU410  v4l2_fourcc('Y','V','U','9') /*  9  YVU 4:1:0     */
+#define V4L2_PIX_FMT_YVU420  v4l2_fourcc('Y','V','1','2') /* 12  YVU 4:2:0     */
+#define V4L2_PIX_FMT_YUYV    v4l2_fourcc('Y','U','Y','V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_UYVY    v4l2_fourcc('U','Y','V','Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4','2','2','P') /* 16  YVU422 planar */
+#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4','1','1','P') /* 16  YVU411 planar */
+#define V4L2_PIX_FMT_Y41P    v4l2_fourcc('Y','4','1','P') /* 12  YUV 4:1:1     */
+
+/* two planes -- one Y, one Cr + Cb interleaved  */
+#define V4L2_PIX_FMT_NV12    v4l2_fourcc('N','V','1','2') /* 12  Y/CbCr 4:2:0  */
+#define V4L2_PIX_FMT_NV21    v4l2_fourcc('N','V','2','1') /* 12  Y/CrCb 4:2:0  */
+
+/*  The following formats are not defined in the V4L2 specification */
+#define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y','U','V','9') /*  9  YUV 4:1:0     */
+#define V4L2_PIX_FMT_YUV420  v4l2_fourcc('Y','U','1','2') /* 12  YUV 4:2:0     */
+#define V4L2_PIX_FMT_YYUV    v4l2_fourcc('Y','Y','U','V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_HI240   v4l2_fourcc('H','I','2','4') /*  8  8-bit color   */
+
+/* compressed formats */
+#define V4L2_PIX_FMT_MJPEG    v4l2_fourcc('M','J','P','G') /* Motion-JPEG   */
+#define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J','P','E','G') /* JFIF JPEG     */
+#define V4L2_PIX_FMT_DV       v4l2_fourcc('d','v','s','d') /* 1394          */
+#define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M','P','E','G') /* MPEG          */
+
+/*  Vendor-specific formats   */
+#define V4L2_PIX_FMT_WNVA    v4l2_fourcc('W','N','V','A') /* Winnov hw compres */
+
+/*
+ *	F O R M A T   E N U M E R A T I O N
+ */
+struct v4l2_fmtdesc
+{
+	__u32	            index;             /* Format number      */
+	enum v4l2_buf_type  type;              /* buffer type        */
+	__u32               flags;
+	__u8	            description[32];   /* Description string */
+	__u32	            pixelformat;       /* Format fourcc      */
+	__u32	            reserved[4];
+};
+
+#define V4L2_FMT_FLAG_COMPRESSED 0x0001
+
+
+/*
+ *	T I M E C O D E
+ */
+struct v4l2_timecode
+{
+	__u32	type;
+	__u32	flags;
+	__u8	frames;
+	__u8	seconds;
+	__u8	minutes;
+	__u8	hours;
+	__u8	userbits[4];
+};
+
+/*  Type  */
+#define V4L2_TC_TYPE_24FPS		1
+#define V4L2_TC_TYPE_25FPS		2
+#define V4L2_TC_TYPE_30FPS		3
+#define V4L2_TC_TYPE_50FPS		4
+#define V4L2_TC_TYPE_60FPS		5
+
+/*  Flags  */
+#define V4L2_TC_FLAG_DROPFRAME		0x0001 /* "drop-frame" mode */
+#define V4L2_TC_FLAG_COLORFRAME		0x0002
+#define V4L2_TC_USERBITS_field		0x000C
+#define V4L2_TC_USERBITS_USERDEFINED	0x0000
+#define V4L2_TC_USERBITS_8BITCHARS	0x0008
+/* The above is based on SMPTE timecodes */
+
+
+/*
+ *	C O M P R E S S I O N   P A R A M E T E R S
+ */
+#if 0
+/* ### generic compression settings don't work, there is too much
+ * ### codec-specific stuff.  Maybe reuse that for MPEG codec settings
+ * ### later ... */
+struct v4l2_compression
+{
+	__u32	quality;
+	__u32	keyframerate;
+	__u32	pframerate;
+	__u32	reserved[5];
+};
+#endif
+
+struct v4l2_jpegcompression
+{
+	int quality;
+
+	int  APPn;              /* Number of APP segment to be written,
+				 * must be 0..15 */
+	int  APP_len;           /* Length of data in JPEG APPn segment */
+	char APP_data[60];      /* Data in the JPEG APPn segment. */
+	
+	int  COM_len;           /* Length of data in JPEG COM segment */
+	char COM_data[60];      /* Data in JPEG COM segment */
+	
+	__u32 jpeg_markers;     /* Which markers should go into the JPEG
+				 * output. Unless you exactly know what
+				 * you do, leave them untouched.
+				 * Inluding less markers will make the
+				 * resulting code smaller, but there will
+				 * be fewer aplications which can read it.
+				 * The presence of the APP and COM marker
+				 * is influenced by APP_len and COM_len
+				 * ONLY, not by this property! */
+	
+#define V4L2_JPEG_MARKER_DHT (1<<3)    /* Define Huffman Tables */
+#define V4L2_JPEG_MARKER_DQT (1<<4)    /* Define Quantization Tables */
+#define V4L2_JPEG_MARKER_DRI (1<<5)    /* Define Restart Interval */
+#define V4L2_JPEG_MARKER_COM (1<<6)    /* Comment segment */
+#define V4L2_JPEG_MARKER_APP (1<<7)    /* App segment, driver will
+                                        * allways use APP0 */
+};
+
+
+/*
+ *	M E M O R Y - M A P P I N G   B U F F E R S
+ */
+struct v4l2_requestbuffers
+{
+	__u32	                count;
+	enum v4l2_buf_type      type;
+	enum v4l2_memory        memory;
+	__u32	                reserved[2];
+};
+
+struct v4l2_buffer
+{
+	__u32			index;
+	enum v4l2_buf_type      type;
+	__u32			bytesused;
+	__u32			flags;
+	enum v4l2_field		field;
+	struct timeval		timestamp;
+	struct v4l2_timecode	timecode;
+	__u32			sequence;
+
+	/* memory location */
+	enum v4l2_memory        memory;
+	union {
+		__u32           offset;
+		unsigned long   userptr;
+	} m;
+	__u32			length;
+
+	__u32			reserved[2];
+};
+
+/*  Flags for 'flags' field */
+#define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
+#define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
+#define V4L2_BUF_FLAG_DONE	0x0004	/* Buffer is ready */
+#define V4L2_BUF_FLAG_KEYFRAME	0x0008	/* Image is a keyframe (I-frame) */
+#define V4L2_BUF_FLAG_PFRAME	0x0010	/* Image is a P-frame */
+#define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
+#define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
+
+/*
+ *	O V E R L A Y   P R E V I E W
+ */
+struct v4l2_framebuffer
+{
+	__u32			capability;
+	__u32			flags;
+/* FIXME: in theory we should pass something like PCI device + memory
+ * region + offset instead of some physical address */
+	void*                   base;
+	struct v4l2_pix_format	fmt;
+};
+/*  Flags for the 'capability' field. Read only */
+#define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
+#define V4L2_FBUF_CAP_CHROMAKEY		0x0002
+#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
+#define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
+/*  Flags for the 'flags' field. */
+#define V4L2_FBUF_FLAG_PRIMARY		0x0001
+#define V4L2_FBUF_FLAG_OVERLAY		0x0002
+#define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
+
+struct v4l2_clip
+{
+	struct v4l2_rect        c;
+	struct v4l2_clip	*next;
+};
+
+struct v4l2_window
+{
+	struct v4l2_rect        w;
+	enum v4l2_field  	field;
+	__u32			chromakey;
+	struct v4l2_clip	*clips;
+	__u32			clipcount;
+	void			*bitmap;
+};
+
+
+/*
+ *	C A P T U R E   P A R A M E T E R S
+ */
+struct v4l2_captureparm
+{
+	__u32		   capability;	  /*  Supported modes */
+	__u32		   capturemode;	  /*  Current mode */
+	struct v4l2_fract  timeperframe;  /*  Time per frame in .1us units */
+	__u32		   extendedmode;  /*  Driver-specific extensions */
+	__u32              readbuffers;   /*  # of buffers for read */
+	__u32		   reserved[4];
+};
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY	0x0001	/*  High quality imaging mode */
+#define V4L2_CAP_TIMEPERFRAME	0x1000	/*  timeperframe field is supported */
+
+struct v4l2_outputparm
+{
+	__u32		   capability;	 /*  Supported modes */
+	__u32		   outputmode;	 /*  Current mode */
+	struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
+	__u32		   extendedmode; /*  Driver-specific extensions */
+	__u32              writebuffers; /*  # of buffers for write */
+	__u32		   reserved[4];
+};
+
+/*
+ *	I N P U T   I M A G E   C R O P P I N G
+ */
+
+struct v4l2_cropcap {
+	enum v4l2_buf_type      type;	
+        struct v4l2_rect        bounds;
+        struct v4l2_rect        defrect;
+        struct v4l2_fract       pixelaspect;
+};
+
+struct v4l2_crop {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        c;
+};
+
+/*
+ *      A N A L O G   V I D E O   S T A N D A R D
+ */
+
+typedef __u64 v4l2_std_id;
+
+/* one bit for each */
+#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
+#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
+#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
+#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
+#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
+#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
+#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
+#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)
+
+#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
+#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
+#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
+#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
+
+#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
+#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
+
+#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
+#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
+#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
+#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
+#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
+#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
+#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
+
+/* ATSC/HDTV */
+#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
+#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
+
+/* some common needed stuff */
+#define V4L2_STD_PAL_BG		(V4L2_STD_PAL_B		|\
+				 V4L2_STD_PAL_B1	|\
+				 V4L2_STD_PAL_G)
+#define V4L2_STD_PAL_DK		(V4L2_STD_PAL_D		|\
+				 V4L2_STD_PAL_D1	|\
+				 V4L2_STD_PAL_K)
+#define V4L2_STD_PAL		(V4L2_STD_PAL_BG	|\
+				 V4L2_STD_PAL_DK	|\
+				 V4L2_STD_PAL_H		|\
+				 V4L2_STD_PAL_I)
+#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M	|\
+				 V4L2_STD_NTSC_M_JP)
+#define V4L2_STD_SECAM		(V4L2_STD_SECAM_B	|\
+				 V4L2_STD_SECAM_D	|\
+				 V4L2_STD_SECAM_G	|\
+				 V4L2_STD_SECAM_H	|\
+				 V4L2_STD_SECAM_K	|\
+				 V4L2_STD_SECAM_K1	|\
+				 V4L2_STD_SECAM_L)
+
+#define V4L2_STD_525_60		(V4L2_STD_PAL_M		|\
+				 V4L2_STD_PAL_60	|\
+				 V4L2_STD_NTSC)
+#define V4L2_STD_625_50		(V4L2_STD_PAL		|\
+				 V4L2_STD_PAL_N		|\
+				 V4L2_STD_PAL_Nc	|\
+				 V4L2_STD_SECAM)
+
+#define V4L2_STD_UNKNOWN        0
+#define V4L2_STD_ALL            (V4L2_STD_525_60	|\
+				 V4L2_STD_625_50)
+
+struct v4l2_standard
+{
+	__u32	       	     index;
+	v4l2_std_id          id;
+	__u8		     name[24];
+	struct v4l2_fract    frameperiod; /* Frames, not fields */
+	__u32		     framelines;
+	__u32		     reserved[4];
+};
+
+
+/*
+ *	V I D E O   I N P U T S
+ */
+struct v4l2_input
+{
+	__u32	     index;		/*  Which input */
+	__u8	     name[32];	        /*  Label */
+	__u32	     type;		/*  Type of input */
+	__u32	     audioset;	        /*  Associated audios (bitfield) */
+	__u32        tuner;             /*  Associated tuner */
+	v4l2_std_id  std;
+	__u32	     status;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_INPUT_TYPE_TUNER		1
+#define V4L2_INPUT_TYPE_CAMERA		2
+
+/* field 'status' - general */
+#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
+#define V4L2_IN_ST_NO_SIGNAL   0x00000002
+#define V4L2_IN_ST_NO_COLOR    0x00000004
+
+/* field 'status' - analog */
+#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
+#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */
+
+/* field 'status' - digital */
+#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
+#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
+#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */
+
+/* field 'status' - VCR and set-top box */
+#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
+#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
+#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */
+
+/*
+ *	V I D E O   O U T P U T S
+ */
+struct v4l2_output
+{
+	__u32	     index;		/*  Which output */
+	__u8	     name[32];	        /*  Label */
+	__u32	     type;		/*  Type of output */
+	__u32	     audioset;	        /*  Associated audios (bitfield) */
+	__u32	     modulator;         /*  Associated modulator */
+	v4l2_std_id  std;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_OUTPUT_TYPE_MODULATOR		1
+#define V4L2_OUTPUT_TYPE_ANALOG			2
+#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
+
+/*
+ *	C O N T R O L S
+ */
+struct v4l2_control
+{
+	__u32		     id;
+	__s32		     value;
+};
+
+/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
+struct v4l2_queryctrl
+{
+	__u32	             id;
+	enum v4l2_ctrl_type  type;
+	__u8		     name[32];	/* Whatever */
+	__s32		     minimum;	/* Note signedness */
+	__s32		     maximum;
+	__s32	             step;
+	__s32		     default_value;
+	__u32                flags;
+	__u32		     reserved[2];
+};
+
+/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
+struct v4l2_querymenu
+{
+	__u32		id;
+	__u32		index;
+	__u8		name[32];	/* Whatever */
+	__u32		reserved;
+};
+
+/*  Control flags  */
+#define V4L2_CTRL_FLAG_DISABLED		0x0001
+#define V4L2_CTRL_FLAG_GRABBED		0x0002
+
+/*  Control IDs defined by V4L2 */
+#define V4L2_CID_BASE			0x00980900
+/*  IDs reserved for driver specific controls */
+#define V4L2_CID_PRIVATE_BASE		0x08000000
+
+#define V4L2_CID_BRIGHTNESS		(V4L2_CID_BASE+0)
+#define V4L2_CID_CONTRAST		(V4L2_CID_BASE+1)
+#define V4L2_CID_SATURATION		(V4L2_CID_BASE+2)
+#define V4L2_CID_HUE			(V4L2_CID_BASE+3)
+#define V4L2_CID_AUDIO_VOLUME		(V4L2_CID_BASE+5)
+#define V4L2_CID_AUDIO_BALANCE		(V4L2_CID_BASE+6)
+#define V4L2_CID_AUDIO_BASS		(V4L2_CID_BASE+7)
+#define V4L2_CID_AUDIO_TREBLE		(V4L2_CID_BASE+8)
+#define V4L2_CID_AUDIO_MUTE		(V4L2_CID_BASE+9)
+#define V4L2_CID_AUDIO_LOUDNESS		(V4L2_CID_BASE+10)
+#define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11)
+#define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
+#define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+#define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
+#define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
+#define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
+#define V4L2_CID_WHITENESS		(V4L2_CID_GAMMA) /* ? Not sure */
+#define V4L2_CID_EXPOSURE		(V4L2_CID_BASE+17)
+#define V4L2_CID_AUTOGAIN		(V4L2_CID_BASE+18)
+#define V4L2_CID_GAIN			(V4L2_CID_BASE+19)
+#define V4L2_CID_HFLIP			(V4L2_CID_BASE+20)
+#define V4L2_CID_VFLIP			(V4L2_CID_BASE+21)
+#define V4L2_CID_HCENTER		(V4L2_CID_BASE+22)
+#define V4L2_CID_VCENTER		(V4L2_CID_BASE+23)
+#define V4L2_CID_LASTP1			(V4L2_CID_BASE+24) /* last CID + 1 */
+
+/*
+ *	T U N I N G
+ */
+struct v4l2_tuner
+{
+	__u32                   index;
+	__u8			name[32];
+	enum v4l2_tuner_type    type;
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			rxsubchans;
+	__u32			audmode;
+	__s32			signal;
+	__s32			afc;
+	__u32			reserved[4];
+};
+
+struct v4l2_modulator
+{
+	__u32			index;
+	__u8			name[32];
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			txsubchans;
+	__u32			reserved[4];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_TUNER_CAP_LOW		0x0001
+#define V4L2_TUNER_CAP_NORM		0x0002
+#define V4L2_TUNER_CAP_STEREO		0x0010
+#define V4L2_TUNER_CAP_LANG2		0x0020
+#define V4L2_TUNER_CAP_SAP		0x0020
+#define V4L2_TUNER_CAP_LANG1		0x0040
+
+/*  Flags for the 'rxsubchans' field */
+#define V4L2_TUNER_SUB_MONO		0x0001
+#define V4L2_TUNER_SUB_STEREO		0x0002
+#define V4L2_TUNER_SUB_LANG2		0x0004
+#define V4L2_TUNER_SUB_SAP		0x0004
+#define V4L2_TUNER_SUB_LANG1		0x0008
+
+/*  Values for the 'audmode' field */
+#define V4L2_TUNER_MODE_MONO		0x0000
+#define V4L2_TUNER_MODE_STEREO		0x0001
+#define V4L2_TUNER_MODE_LANG2		0x0002
+#define V4L2_TUNER_MODE_SAP		0x0002
+#define V4L2_TUNER_MODE_LANG1		0x0003
+
+struct v4l2_frequency
+{
+	__u32	              tuner;
+	enum v4l2_tuner_type  type;
+        __u32	              frequency;
+	__u32	              reserved[8];
+};
+
+/*
+ *	A U D I O
+ */
+struct v4l2_audio
+{
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+/*  Flags for the 'capability' field */
+#define V4L2_AUDCAP_STEREO		0x00001
+#define V4L2_AUDCAP_AVL			0x00002
+
+/*  Flags for the 'mode' field */
+#define V4L2_AUDMODE_AVL		0x00001
+
+struct v4l2_audioout
+{
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*
+ *	D A T A   S E R V I C E S   ( V B I )
+ *
+ *	Data services API by Michael Schimek
+ */
+
+struct v4l2_vbi_format
+{
+	__u32	sampling_rate;		/* in 1 Hz */
+	__u32	offset;
+	__u32	samples_per_line;
+	__u32	sample_format;		/* V4L2_PIX_FMT_* */
+	__s32	start[2];
+	__u32	count[2];
+	__u32	flags;			/* V4L2_VBI_* */
+	__u32	reserved[2];		/* must be zero */
+};
+
+/*  VBI flags  */
+#define V4L2_VBI_UNSYNC		(1<< 0)
+#define V4L2_VBI_INTERLACED	(1<< 1)
+
+
+/*
+ *	A G G R E G A T E   S T R U C T U R E S
+ */
+
+/*	Stream data format
+ */
+struct v4l2_format
+{
+	enum v4l2_buf_type type;
+	union
+	{
+		struct v4l2_pix_format	pix;  // V4L2_BUF_TYPE_VIDEO_CAPTURE
+		struct v4l2_window	win;  // V4L2_BUF_TYPE_VIDEO_OVERLAY
+		struct v4l2_vbi_format	vbi;  // V4L2_BUF_TYPE_VBI_CAPTURE
+		__u8	raw_data[200];        // user-defined
+	} fmt;
+};
+
+
+/*	Stream type-dependent parameters
+ */
+struct v4l2_streamparm
+{
+	enum v4l2_buf_type type;
+	union
+	{
+		struct v4l2_captureparm	capture;
+		struct v4l2_outputparm	output;
+		__u8	raw_data[200];  /* user-defined */
+	} parm;
+};
+
+
+
+/*
+ *	I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
+ *
+ */
+#define VIDIOC_QUERYCAP		_IOR  ('V',  0, struct v4l2_capability)
+#define VIDIOC_RESERVED		_IO   ('V',  1)
+#define VIDIOC_ENUM_FMT         _IOWR ('V',  2, struct v4l2_fmtdesc)
+#define VIDIOC_G_FMT		_IOWR ('V',  4, struct v4l2_format)
+#define VIDIOC_S_FMT		_IOWR ('V',  5, struct v4l2_format)
+#if 0
+#define VIDIOC_G_COMP		_IOR  ('V',  6, struct v4l2_compression)
+#define VIDIOC_S_COMP		_IOW  ('V',  7, struct v4l2_compression)
+#endif
+#define VIDIOC_REQBUFS		_IOWR ('V',  8, struct v4l2_requestbuffers)
+#define VIDIOC_QUERYBUF		_IOWR ('V',  9, struct v4l2_buffer)
+#define VIDIOC_G_FBUF		_IOR  ('V', 10, struct v4l2_framebuffer)
+#define VIDIOC_S_FBUF		_IOW  ('V', 11, struct v4l2_framebuffer)
+#define VIDIOC_OVERLAY		_IOWR ('V', 14, int)
+#define VIDIOC_QBUF		_IOWR ('V', 15, struct v4l2_buffer)
+#define VIDIOC_DQBUF		_IOWR ('V', 17, struct v4l2_buffer)
+#define VIDIOC_STREAMON		_IOW  ('V', 18, int)
+#define VIDIOC_STREAMOFF	_IOW  ('V', 19, int)
+#define VIDIOC_G_PARM		_IOWR ('V', 21, struct v4l2_streamparm)
+#define VIDIOC_S_PARM		_IOW  ('V', 22, struct v4l2_streamparm)
+#define VIDIOC_G_STD		_IOR  ('V', 23, v4l2_std_id)
+#define VIDIOC_S_STD		_IOW  ('V', 24, v4l2_std_id)
+#define VIDIOC_ENUMSTD		_IOWR ('V', 25, struct v4l2_standard)
+#define VIDIOC_ENUMINPUT	_IOWR ('V', 26, struct v4l2_input)
+#define VIDIOC_G_CTRL		_IOWR ('V', 27, struct v4l2_control)
+#define VIDIOC_S_CTRL		_IOW  ('V', 28, struct v4l2_control)
+#define VIDIOC_G_TUNER		_IOWR ('V', 29, struct v4l2_tuner)
+#define VIDIOC_S_TUNER		_IOW  ('V', 30, struct v4l2_tuner)
+#define VIDIOC_G_AUDIO		_IOWR ('V', 33, struct v4l2_audio)
+#define VIDIOC_S_AUDIO		_IOW  ('V', 34, struct v4l2_audio)
+#define VIDIOC_QUERYCTRL	_IOWR ('V', 36, struct v4l2_queryctrl)
+#define VIDIOC_QUERYMENU	_IOWR ('V', 37, struct v4l2_querymenu)
+#define VIDIOC_G_INPUT		_IOR  ('V', 38, int)
+#define VIDIOC_S_INPUT		_IOWR ('V', 39, int)
+#define VIDIOC_G_OUTPUT		_IOR  ('V', 46, int)
+#define VIDIOC_S_OUTPUT		_IOWR ('V', 47, int)
+#define VIDIOC_ENUMOUTPUT	_IOWR ('V', 48, struct v4l2_output)
+#define VIDIOC_G_AUDOUT		_IOWR ('V', 49, struct v4l2_audioout)
+#define VIDIOC_S_AUDOUT		_IOW  ('V', 50, struct v4l2_audioout)
+#define VIDIOC_G_MODULATOR	_IOWR ('V', 54, struct v4l2_modulator)
+#define VIDIOC_S_MODULATOR	_IOW  ('V', 55, struct v4l2_modulator)
+#define VIDIOC_G_FREQUENCY	_IOWR ('V', 56, struct v4l2_frequency)
+#define VIDIOC_S_FREQUENCY	_IOW  ('V', 57, struct v4l2_frequency)
+#define VIDIOC_CROPCAP		_IOR  ('V', 58, struct v4l2_cropcap)
+#define VIDIOC_G_CROP		_IOWR ('V', 59, struct v4l2_crop)
+#define VIDIOC_S_CROP		_IOW  ('V', 60, struct v4l2_crop)
+#define VIDIOC_G_JPEGCOMP	_IOR  ('V', 61, struct v4l2_jpegcompression)
+#define VIDIOC_S_JPEGCOMP	_IOW  ('V', 62, struct v4l2_jpegcompression)
+#define VIDIOC_QUERYSTD      	_IOR  ('V', 63, v4l2_std_id)
+#define VIDIOC_TRY_FMT      	_IOWR ('V', 64, struct v4l2_format)
+
+#define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
+
+
+#ifdef __KERNEL__
+/*
+ *
+ *	V 4 L 2   D R I V E R   H E L P E R   A P I
+ *
+ *	Some commonly needed functions for drivers (v4l2-common.o module)
+ */
+#include <linux/fs.h>
+
+/*  Video standard functions  */
+extern unsigned int v4l2_video_std_fps(struct v4l2_standard *vs);
+extern int v4l2_video_std_construct(struct v4l2_standard *vs,
+				    int id, char *name);
+
+/*  Compatibility layer interface  */
+typedef int (*v4l2_kioctl)(struct inode *inode, struct file *file,
+			   unsigned int cmd, void *arg);
+int v4l_compat_translate_ioctl(struct inode *inode, struct file *file,
+			       int cmd, void *arg, v4l2_kioctl driver_ioctl);
+
+/* names for fancy debug output */
+extern char *v4l2_field_names[];
+extern char *v4l2_type_names[];
+extern char *v4l2_ioctl_names[];
+
+#endif /* __KERNEL__ */
+#endif /* __LINUX_VIDEODEV2_H */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
--- linux-2.4.20/kernel/ksyms.c	2002-12-11 10:56:55.000000000 +0100
+++ linux/kernel/ksyms.c	2002-12-11 11:04:13.000000000 +0100
@@ -283,6 +283,7 @@
 EXPORT_SYMBOL(dcache_dir_fsync);
 EXPORT_SYMBOL(dcache_readdir);
 EXPORT_SYMBOL(dcache_dir_ops);
+EXPORT_SYMBOL(do_select);
 
 /* for stackable file systems (lofs, wrapfs, cryptfs, etc.) */
 EXPORT_SYMBOL(default_llseek);
