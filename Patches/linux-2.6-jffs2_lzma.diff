diff -uNr linux-2.6.26.8.org/fs/jffs2/compr.c linux-2.6.26.8/fs/jffs2/compr.c
--- linux-2.6.26.8.org/fs/jffs2/compr.c	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/fs/jffs2/compr.c	2009-08-03 10:28:59.000000000 +0200
@@ -319,6 +319,9 @@
 #ifdef CONFIG_JFFS2_LZO
 	jffs2_lzo_init();
 #endif
+#ifdef CONFIG_JFFS2_LZMA
+	jffs2_lzma_init();
+#endif
 /* Setting default compression mode */
 #ifdef CONFIG_JFFS2_CMODE_NONE
 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
@@ -345,6 +348,9 @@
 #ifdef CONFIG_JFFS2_LZO
 	jffs2_lzo_exit();
 #endif
+#ifdef CONFIG_JFFS2_LZMA
+	jffs2_lzma_exit();
+#endif
 #ifdef CONFIG_JFFS2_RUBIN
 	jffs2_dynrubin_exit();
 	jffs2_rubinmips_exit();
diff -uNr linux-2.6.26.8.org/fs/jffs2/compr.h linux-2.6.26.8/fs/jffs2/compr.h
--- linux-2.6.26.8.org/fs/jffs2/compr.h	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/fs/jffs2/compr.h	2009-08-03 10:28:59.000000000 +0200
@@ -30,6 +30,7 @@
 #define JFFS2_RTIME_PRIORITY     50
 #define JFFS2_ZLIB_PRIORITY      60
 #define JFFS2_LZO_PRIORITY       80
+#define JFFS2_LZMA_PRIORITY      90
 
 
 #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
@@ -98,5 +99,9 @@
 int jffs2_lzo_init(void);
 void jffs2_lzo_exit(void);
 #endif
+#ifdef CONFIG_JFFS2_LZMA
+int jffs2_lzma_init(void);
+void jffs2_lzma_exit(void);
+#endif
 
 #endif /* __JFFS2_COMPR_H__ */
diff -uNr linux-2.6.26.8.org/fs/jffs2/compr_lzma.c linux-2.6.26.8/fs/jffs2/compr_lzma.c
--- linux-2.6.26.8.org/fs/jffs2/compr_lzma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.26.8/fs/jffs2/compr_lzma.c	2009-08-03 10:28:59.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2008 Nikos Mavrogiannopoulos.
+ *
+ * compr_lzma is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *               
+ * compr_lzma is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *                               
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/jffs2.h>
+#include <linux/lzma/LzmaDec.h>
+#include <linux/lzma/LzmaEnc.h>
+#include "compr.h"
+
+#ifndef JFFS2_COMPR_LZMA
+# define JFFS2_COMPR_LZMA 0x15
+#endif
+
+static void* my_alloc( void* p, size_t size)
+{
+  return kmalloc(size, GFP_KERNEL);
+}
+
+static void my_free( void* p, void* addr)
+{
+  kfree(addr);
+}
+
+static void* my_bigalloc( void* p, size_t size)
+{
+  return vmalloc(size);
+}
+
+static void my_bigfree( void* p, void* addr)
+{
+  vfree(addr);
+}
+
+const CLzmaEncProps lzma_props = {
+  .level = 1, /* unused */
+  .lc = 3,
+  .lp = 0,
+  .pb = 2,
+  .algo = 1,
+  .fb = 32,
+  .btMode = 1,
+  .mc = 32,
+  .writeEndMark = 0,
+  .numThreads = 1,
+  .numHashBytes = 4,
+  /* something more than this doesn't seem to offer anything
+   * practical and increases memory size.
+   */
+  .dictSize = 1 << 13,
+};
+
+ISzAlloc xalloc = { my_alloc, my_free };
+ISzAlloc xbigalloc = { my_bigalloc, my_bigfree };
+
+int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
+		uint32_t *sourcelen, uint32_t *dstlen, void *model)
+{
+	int ret;
+	size_t props_size = LZMA_PROPS_SIZE;
+	size_t data_out_size = (*dstlen)-LZMA_PROPS_SIZE;
+
+	if (*dstlen < LZMA_PROPS_SIZE)
+		return -1;
+
+        ret = LzmaEncode_2008( cpage_out+LZMA_PROPS_SIZE, &data_out_size, 
+        	data_in, *sourcelen, &lzma_props, 
+        	cpage_out, &props_size, 0, NULL, &xalloc, &xbigalloc);
+        	
+	if (ret != SZ_OK)
+		return -1;
+
+	*dstlen = data_out_size + LZMA_PROPS_SIZE;
+	
+	return 0;
+}
+
+int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		uint32_t srclen, uint32_t destlen, void *model)
+{
+	int ret;
+	size_t data_out_size = destlen;
+	size_t data_in_size = srclen - LZMA_PROPS_SIZE;
+	ELzmaStatus status;
+	
+	if (srclen < LZMA_PROPS_SIZE)
+		return -1;
+	
+	ret = LzmaDecode_2008( cpage_out, &data_out_size, data_in+LZMA_PROPS_SIZE, &data_in_size, 
+		data_in, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &status, &xalloc);
+	
+	if (ret != SZ_OK)
+		return -1;
+
+	return 0;
+}
+
+static struct jffs2_compressor jffs2_lzma_comp = {
+	.priority = JFFS2_LZMA_PRIORITY,
+	.name = "lzma",
+	.disabled = 0,
+	.compr = JFFS2_COMPR_LZMA,
+	.compress = &jffs2_lzma_compress,
+	.decompress = &jffs2_lzma_decompress,
+};
+
+int jffs2_lzma_init(void)
+{
+	return jffs2_register_compressor(&jffs2_lzma_comp);
+}
+
+void jffs2_lzma_exit(void)
+{
+	jffs2_unregister_compressor(&jffs2_lzma_comp);
+}
diff -uNr linux-2.6.26.8.org/fs/jffs2/Makefile linux-2.6.26.8/fs/jffs2/Makefile
--- linux-2.6.26.8.org/fs/jffs2/Makefile	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/fs/jffs2/Makefile	2009-08-03 10:28:59.000000000 +0200
@@ -18,4 +18,5 @@
 jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
 jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
 jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
+jffs2-$(CONFIG_JFFS2_LZMA)	+= compr_lzma.o
 jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
diff -uNr linux-2.6.26.8.org/fs/Kconfig linux-2.6.26.8/fs/Kconfig
--- linux-2.6.26.8.org/fs/Kconfig	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/fs/Kconfig	2009-08-03 10:28:59.000000000 +0200
@@ -1327,6 +1327,17 @@
 	  This feature was added in July, 2007. Say 'N' if you need
 	  compatibility with older bootloaders or kernels.
 
+config JFFS2_LZMA
+	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
+	select LZMA_COMPRESS
+	depends on JFFS2_FS
+	default n
+	help
+	  lzma compression. Generally compresses about 10% more than zlib.
+
+	  This feature was added in June, 2008. Say 'N' if you need
+	  compatibility with older bootloaders or kernels.
+
 config JFFS2_RTIME
 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
 	depends on JFFS2_FS
diff -uNr linux-2.6.26.8.org/include/linux/jffs2.h linux-2.6.26.8/include/linux/jffs2.h
--- linux-2.6.26.8.org/include/linux/jffs2.h	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/include/linux/jffs2.h	2009-08-03 10:28:59.000000000 +0200
@@ -47,6 +47,7 @@
 #define JFFS2_COMPR_DYNRUBIN	0x05
 #define JFFS2_COMPR_ZLIB	0x06
 #define JFFS2_COMPR_LZO		0x07
+#define JFFS2_COMPR_LZMA	0x15
 /* Compatibility flags. */
 #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
 #define JFFS2_NODE_ACCURATE 0x2000
diff -uNr linux-2.6.26.8.org/include/linux/lzma/LzmaDec.h linux-2.6.26.8/include/linux/lzma/LzmaDec.h
--- linux-2.6.26.8.org/include/linux/lzma/LzmaDec.h	2009-08-03 10:29:31.000000000 +0200
+++ linux-2.6.26.8/include/linux/lzma/LzmaDec.h	2009-08-03 10:29:55.000000000 +0200
@@ -4,7 +4,7 @@
 #ifndef __LZMADEC_H
 #define __LZMADEC_H
 
-#include "Types.h"
+#include <linux/lzma/Types.h>
 
 /* #define _LZMA_PROB32 */
 /* _LZMA_PROB32 can increase the speed on some CPUs,
@@ -197,7 +197,7 @@
 
 /* ---------- One Call Interface ---------- */
 
-/* LzmaDecode
+/* LzmaDecode_2008
 
 finishMode:
   It has meaning only if the decoding reaches output limit (*destLen).
@@ -216,7 +216,7 @@
   SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
 */
 
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+SRes LzmaDecode_2008(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
     ELzmaStatus *status, ISzAlloc *alloc);
 
diff -uNr linux-2.6.26.8.org/include/linux/lzma/LzmaEnc.h linux-2.6.26.8/include/linux/lzma/LzmaEnc.h
--- linux-2.6.26.8.org/include/linux/lzma/LzmaEnc.h	2009-08-03 10:29:31.000000000 +0200
+++ linux-2.6.26.8/include/linux/lzma/LzmaEnc.h	2009-08-03 10:29:55.000000000 +0200
@@ -4,7 +4,7 @@
 #ifndef __LZMAENC_H
 #define __LZMAENC_H
 
-#include "Types.h"
+#include <linux/lzma/Types.h>
 
 #define LZMA_PROPS_SIZE 5
 
@@ -56,7 +56,7 @@
 
 /* ---------- One Call Interface ---------- */
 
-/* LzmaEncode
+/* LzmaEncode_2008
 Return code:
   SZ_OK               - OK
   SZ_ERROR_MEM        - Memory allocation error
@@ -65,7 +65,7 @@
   SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
 */
 
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+SRes LzmaEncode_2008(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
     const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
     ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
 
diff -uNr linux-2.6.26.8.org/include/linux/lzma/Types.h linux-2.6.26.8/include/linux/lzma/Types.h
--- linux-2.6.26.8.org/include/linux/lzma/Types.h	2009-08-03 10:29:31.000000000 +0200
+++ linux-2.6.26.8/include/linux/lzma/Types.h	2009-08-03 10:29:55.000000000 +0200
@@ -4,12 +4,6 @@
 #ifndef __7Z_TYPES_H
 #define __7Z_TYPES_H
 
-#include <stddef.h>
-
-#ifdef _WIN32
-#include <windows.h>
-#endif
-
 #define SZ_OK 0
 
 #define SZ_ERROR_DATA 1
@@ -30,12 +24,6 @@
 
 typedef int SRes;
 
-#ifdef _WIN32
-typedef DWORD WRes;
-#else
-typedef int WRes;
-#endif
-
 #ifndef RINOK
 #define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
 #endif
@@ -75,6 +63,7 @@
 #ifdef _LZMA_NO_SYSTEM_SIZE_T
 typedef UInt32 SizeT;
 #else
+#include <stddef.h>
 typedef size_t SizeT;
 #endif
 
@@ -113,11 +102,6 @@
        (output(*size) < input(*size)) is allowed */
 } ISeqInStream;
 
-/* it can return SZ_ERROR_INPUT_EOF */
-SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-
 typedef struct
 {
   size_t (*Write)(void *p, const void *buf, size_t size);
@@ -125,70 +109,6 @@
        (result < size) means error */
 } ISeqOutStream;
 
-typedef enum
-{
-  SZ_SEEK_SET = 0,
-  SZ_SEEK_CUR = 1,
-  SZ_SEEK_END = 2
-} ESzSeek;
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ISeekInStream;
-
-typedef struct
-{
-  SRes (*Look)(void *p, void **buf, size_t *size);
-    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-       (output(*size) > input(*size)) is not allowed
-       (output(*size) < input(*size)) is allowed */
-  SRes (*Skip)(void *p, size_t offset);
-    /* offset must be <= output(*size) of Look */
-
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ILookInStream;
-
-SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-
-/* reads via ILookInStream::Read */
-SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-
-#define LookToRead_BUF_SIZE (1 << 14)
-
-typedef struct
-{
-  ILookInStream s;
-  ISeekInStream *realStream;
-  size_t pos;
-  size_t size;
-  Byte buf[LookToRead_BUF_SIZE];
-} CLookToRead;
-
-void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-void LookToRead_Init(CLookToRead *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToLook;
-
-void SecToLook_CreateVTable(CSecToLook *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToRead;
-
-void SecToRead_CreateVTable(CSecToRead *p);
-
 typedef struct
 {
   SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
diff -uNr linux-2.6.26.8.org/lib/Kconfig linux-2.6.26.8/lib/Kconfig
--- linux-2.6.26.8.org/lib/Kconfig	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/lib/Kconfig	2009-08-03 10:28:59.000000000 +0200
@@ -84,6 +84,9 @@
 config LZO_DECOMPRESS
 	tristate
 
+config LZMA_COMPRESS
+	tristate
+
 #
 # Generic allocator support is selected if needed
 #
diff -uNr linux-2.6.26.8.org/lib/lzma/LzFind.c linux-2.6.26.8/lib/lzma/LzFind.c
--- linux-2.6.26.8.org/lib/lzma/LzFind.c	2009-08-03 10:29:23.000000000 +0200
+++ linux-2.6.26.8/lib/lzma/LzFind.c	2009-08-03 10:29:46.000000000 +0200
@@ -1,10 +1,10 @@
 /* LzFind.c -- Match finder for LZ algorithms
 2008-10-04 : Igor Pavlov : Public domain */
 
-#include <string.h>
+#include <linux/string.h>
 
-#include "LzFind.h"
-#include "LzHash.h"
+#include <linux/lzma/LzFind.h>
+#include <linux/lzma/LzHash.h>
 
 #define kEmptyHashValue 0
 #define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
diff -uNr linux-2.6.26.8.org/lib/lzma/LzmaDec.c linux-2.6.26.8/lib/lzma/LzmaDec.c
--- linux-2.6.26.8.org/lib/lzma/LzmaDec.c	2009-08-03 10:29:23.000000000 +0200
+++ linux-2.6.26.8/lib/lzma/LzmaDec.c	2009-08-03 10:29:46.000000000 +0200
@@ -1,9 +1,9 @@
 /* LzmaDec.c -- LZMA Decoder
 2008-11-06 : Igor Pavlov : Public domain */
 
-#include "LzmaDec.h"
+#include <linux/lzma/LzmaDec.h>
 
-#include <string.h>
+#include <linux/string.h>
 
 #define kNumTopBits 24
 #define kTopValue ((UInt32)1 << kNumTopBits)
@@ -113,6 +113,11 @@
 StopCompilingDueBUG
 #endif
 
+/*
+#define LZMA_STREAM_WAS_FINISHED_ID (-1)
+#define LZMA_SPEC_LEN_OFFSET (-3)
+*/
+
 static const Byte kLiteralNextStates[kNumStates * 2] =
 {
   0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
@@ -125,8 +130,8 @@
 And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
 Out:
   Result:
-    SZ_OK - OK
-    SZ_ERROR_DATA - Error
+    0 - OK
+    1 - Error
   p->remainLen:
     < kMatchSpecLenStart : normal remain
     = kMatchSpecLenStart : finished
@@ -383,8 +388,6 @@
 
       len += kMatchMinLen;
 
-      if (limit == dicPos)
-        return SZ_ERROR_DATA;
       {
         SizeT rem = limit - dicPos;
         unsigned curLen = ((rem < len) ? (unsigned)rem : len);
@@ -459,6 +462,8 @@
   }
 }
 
+/* LzmaDec_DecodeReal2 decodes LZMA-symbols and sets p->needFlush and p->needInit, if required. */
+
 static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
 {
   do
@@ -690,7 +695,7 @@
   p->needFlush = 0;
 }
 
-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState) 
 {
   p->needFlush = 1;
   p->remainLen = 0;
@@ -804,7 +809,7 @@
         p->buf = src;
         if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
           return SZ_ERROR_DATA;
-        processed = (SizeT)(p->buf - src);
+        processed = p->buf - src;
         (*srcLen) += processed;
         src += processed;
         inSize -= processed;
@@ -974,7 +979,7 @@
   return SZ_OK;
 }
 
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+SRes LzmaDecode_2008(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
     ELzmaStatus *status, ISzAlloc *alloc)
 {
diff -uNr linux-2.6.26.8.org/lib/lzma/LzmaEnc.c linux-2.6.26.8/lib/lzma/LzmaEnc.c
--- linux-2.6.26.8.org/lib/lzma/LzmaEnc.c	2009-08-03 10:29:23.000000000 +0200
+++ linux-2.6.26.8/lib/lzma/LzmaEnc.c	2009-08-03 10:29:46.000000000 +0200
@@ -1,18 +1,14 @@
 /* LzmaEnc.c -- LZMA Encoder
 2009-02-02 : Igor Pavlov : Public domain */
 
-#include <string.h>
+#include <linux/string.h>
 
 /* #define SHOW_STAT */
 /* #define SHOW_STAT2 */
 
-#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-#include <stdio.h>
-#endif
-
-#include "LzmaEnc.h"
+#include <linux/lzma/LzmaEnc.h>
 
-#include "LzFind.h"
+#include <linux/lzma/LzFind.h>
 #ifdef COMPRESS_MF_MT
 #include "LzFindMt.h"
 #endif
@@ -64,13 +60,7 @@
   if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
   if (p->numHashBytes < 0) p->numHashBytes = 4;
   if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
-  if (p->numThreads < 0)
-    p->numThreads =
-      #ifdef COMPRESS_MF_MT
-      ((p->btMode && p->algo) ? 2 : 1);
-      #else
-      1;
-      #endif
+  if (p->numThreads < 0) p->numThreads = ((p->btMode && p->algo) ? 2 : 1);
 }
 
 UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
@@ -293,9 +283,10 @@
   UInt32 optimumEndIndex;
   UInt32 optimumCurrentIndex;
 
+  Bool longestMatchWasFound;
   UInt32 longestMatchLength;
-  UInt32 numPairs;
-  UInt32 numAvail;
+  UInt32 numDistancePairs;
+
   COptimal opt[kNumOpts];
   
   #ifndef LZMA_LOG_BSR
@@ -303,7 +294,7 @@
   #endif
 
   UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
-  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
+  UInt32 matchDistances[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
   UInt32 numFastBytes;
   UInt32 additionalOffset;
   UInt32 reps[LZMA_NUM_REPS];
@@ -836,28 +827,31 @@
 
 static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
 {
-  UInt32 lenRes = 0, numPairs;
-  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
+  UInt32 lenRes = 0, numDistancePairs;
+  numDistancePairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matchDistances);
   #ifdef SHOW_STAT
-  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
+  printf("\n i = %d numPairs = %d    ", ttt, numDistancePairs / 2);
+  if (ttt >= 61994)
+    ttt = ttt;
+
   ttt++;
   {
     UInt32 i;
-    for (i = 0; i < numPairs; i += 2)
-      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
+  for (i = 0; i < numDistancePairs; i += 2)
+    printf("%2d %6d   | ", p->matchDistances[i], p->matchDistances[i + 1]);
   }
   #endif
-  if (numPairs > 0)
+  if (numDistancePairs > 0)
   {
-    lenRes = p->matches[numPairs - 2];
+    lenRes = p->matchDistances[numDistancePairs - 2];
     if (lenRes == p->numFastBytes)
     {
+      UInt32 numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) + 1;
       const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-      UInt32 distance = p->matches[numPairs - 1] + 1;
-      UInt32 numAvail = p->numAvail;
+      UInt32 distance = p->matchDistances[numDistancePairs - 1] + 1;
       if (numAvail > LZMA_MATCH_LEN_MAX)
         numAvail = LZMA_MATCH_LEN_MAX;
+
       {
         const Byte *pby2 = pby - distance;
         for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
@@ -865,7 +859,7 @@
     }
   }
   p->additionalOffset++;
-  *numDistancePairsRes = numPairs;
+  *numDistancePairsRes = numDistancePairs;
   return lenRes;
 }
 
@@ -949,12 +943,19 @@
 
 static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
 {
-  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
-  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-  UInt32 *matches;
+  UInt32 numAvailableBytes, lenMain, numDistancePairs;
   const Byte *data;
-  Byte curByte, matchByte;
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 repLens[LZMA_NUM_REPS];
+  UInt32 repMaxIndex, i;
+  UInt32 *matchDistances;
+  Byte currentByte, matchByte; 
+  UInt32 posState;
+  UInt32 matchPrice, repMatchPrice;
+  UInt32 lenEnd;
+  UInt32 len;
+  UInt32 normalMatchPrice;
+  UInt32 cur;
   if (p->optimumEndIndex != p->optimumCurrentIndex)
   {
     const COptimal *opt = &p->opt[p->optimumCurrentIndex];
@@ -965,24 +966,28 @@
   }
   p->optimumCurrentIndex = p->optimumEndIndex = 0;
   
-  if (p->additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &numPairs);
+  numAvailableBytes = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+
+  if (!p->longestMatchWasFound)
+  {
+    lenMain = ReadMatchDistances(p, &numDistancePairs);
+  }
   else
   {
-    mainLen = p->longestMatchLength;
-    numPairs = p->numPairs;
+    lenMain = p->longestMatchLength;
+    numDistancePairs = p->numDistancePairs;
+    p->longestMatchWasFound = False;
   }
 
-  numAvail = p->numAvail;
-  if (numAvail < 2)
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  if (numAvailableBytes < 2)
   {
     *backRes = (UInt32)(-1);
     return 1;
   }
-  if (numAvail > LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
+  if (numAvailableBytes > LZMA_MATCH_LEN_MAX)
+    numAvailableBytes = LZMA_MATCH_LEN_MAX;
 
-  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
   repMaxIndex = 0;
   for (i = 0; i < LZMA_NUM_REPS; i++)
   {
@@ -995,7 +1000,7 @@
       repLens[i] = 0;
       continue;
     }
-    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+    for (lenTest = 2; lenTest < numAvailableBytes && data[lenTest] == data2[lenTest]; lenTest++);
     repLens[i] = lenTest;
     if (lenTest > repLens[repMaxIndex])
       repMaxIndex = i;
@@ -1009,17 +1014,17 @@
     return lenRes;
   }
 
-  matches = p->matches;
-  if (mainLen >= p->numFastBytes)
+  matchDistances = p->matchDistances;
+  if (lenMain >= p->numFastBytes)
   {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
+    *backRes = matchDistances[numDistancePairs - 1] + LZMA_NUM_REPS; 
+    MovePos(p, lenMain - 1);
+    return lenMain;
   }
-  curByte = *data;
+  currentByte = *data;
   matchByte = *(data - (reps[0] + 1));
 
-  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
+  if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)
   {
     *backRes = (UInt32)-1;
     return 1;
@@ -1033,8 +1038,8 @@
     const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
     p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
         (!IsCharState(p->state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+          LitEnc_GetPriceMatched(probs, currentByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, currentByte, p->ProbPrices));
   }
 
   MakeAsChar(&p->opt[1]);
@@ -1042,7 +1047,7 @@
   matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
   repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
 
-  if (matchByte == curByte)
+  if (matchByte == currentByte)
   {
     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
     if (shortRepPrice < p->opt[1].price)
@@ -1051,7 +1056,7 @@
       MakeAsShortRep(&p->opt[1]);
     }
   }
-  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
+  lenEnd = ((lenMain >= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);
 
   if (lenEnd < 2)
   {
@@ -1093,15 +1098,15 @@
   normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
 
   len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-  if (len <= mainLen)
+  if (len <= lenMain)
   {
     UInt32 offs = 0;
-    while (len > matches[offs])
+    while (len > matchDistances[offs])
       offs += 2;
     for (; ; len++)
     {
       COptimal *opt;
-      UInt32 distance = matches[offs + 1];
+      UInt32 distance = matchDistances[offs + 1];
 
       UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
       UInt32 lenToPosState = GetLenToPosState(len);
@@ -1121,10 +1126,10 @@
         opt->backPrev = distance + LZMA_NUM_REPS;
         opt->prev1IsChar = False;
       }
-      if (len == matches[offs])
+      if (len == matchDistances[offs])
       {
         offs += 2;
-        if (offs == numPairs)
+        if (offs == numDistancePairs)
           break;
       }
     }
@@ -1144,23 +1149,32 @@
 
   for (;;)
   {
-    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
+    UInt32 numAvailableBytesFull, newLen, numDistancePairs;
+    COptimal *curOpt;
+    UInt32 posPrev;
+    UInt32 state;
+    UInt32 curPrice;
     Bool nextIsChar;
-    Byte curByte, matchByte;
     const Byte *data;
-    COptimal *curOpt;
+    Byte currentByte, matchByte;
+    UInt32 posState;
+    UInt32 curAnd1Price;
     COptimal *nextOpt;
+    UInt32 matchPrice, repMatchPrice;  
+    UInt32 numAvailableBytes;
+    UInt32 startLen;
 
     cur++;
     if (cur == lenEnd)
       return Backward(p, backRes, cur);
 
-    newLen = ReadMatchDistances(p, &numPairs);
+    numAvailableBytesFull = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+    newLen = ReadMatchDistances(p, &numDistancePairs);
     if (newLen >= p->numFastBytes)
     {
-      p->numPairs = numPairs;
+      p->numDistancePairs = numDistancePairs;
       p->longestMatchLength = newLen;
+      p->longestMatchWasFound = True;
       return Backward(p, backRes, cur);
     }
     position++;
@@ -1236,7 +1250,7 @@
     curPrice = curOpt->price;
     nextIsChar = False;
     data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-    curByte = *data;
+    currentByte = *data;
     matchByte = *(data - (reps[0] + 1));
 
     posState = (position & p->pbMask);
@@ -1246,8 +1260,8 @@
       const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
       curAnd1Price +=
         (!IsCharState(state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+          LitEnc_GetPriceMatched(probs, currentByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, currentByte, p->ProbPrices));
     }
 
     nextOpt = &p->opt[cur + 1];
@@ -1263,7 +1277,7 @@
     matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
     repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
     
-    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
+    if (matchByte == currentByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
     {
       UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
       if (shortRepPrice <= nextOpt->price)
@@ -1274,26 +1288,27 @@
         nextIsChar = True;
       }
     }
-    numAvailFull = p->numAvail;
+
     {
       UInt32 temp = kNumOpts - 1 - cur;
-      if (temp < numAvailFull)
-        numAvailFull = temp;
+      if (temp <  numAvailableBytesFull)
+        numAvailableBytesFull = temp;
     }
+    numAvailableBytes = numAvailableBytesFull;
 
-    if (numAvailFull < 2)
+    if (numAvailableBytes < 2)
       continue;
-    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
-
-    if (!nextIsChar && matchByte != curByte) /* speed optimization */
+    if (numAvailableBytes > p->numFastBytes)
+      numAvailableBytes = p->numFastBytes;
+    if (!nextIsChar && matchByte != currentByte) /* speed optimization */
     {
       /* try Literal + rep0 */
       UInt32 temp;
       UInt32 lenTest2;
       const Byte *data2 = data - (reps[0] + 1);
       UInt32 limit = p->numFastBytes + 1;
-      if (limit > numAvailFull)
-        limit = numAvailFull;
+      if (limit > numAvailableBytesFull)
+        limit = numAvailableBytesFull;
 
       for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
       lenTest2 = temp - 1;
@@ -1336,7 +1351,7 @@
       const Byte *data2 = data - (reps[repIndex] + 1);
       if (data[0] != data2[0] || data[1] != data2[1])
         continue;
-      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+      for (lenTest = 2; lenTest < numAvailableBytes && data[lenTest] == data2[lenTest]; lenTest++);
       while (lenEnd < cur + lenTest)
         p->opt[++lenEnd].price = kInfinityPrice;
       lenTestTemp = lenTest;
@@ -1364,8 +1379,8 @@
           UInt32 lenTest2 = lenTest + 1;
           UInt32 limit = lenTest2 + p->numFastBytes;
           UInt32 nextRepMatchPrice;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
+          if (limit > numAvailableBytesFull)
+            limit = numAvailableBytesFull;
           for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
           lenTest2 -= lenTest + 1;
           if (lenTest2 >= 2)
@@ -1408,12 +1423,12 @@
     }
     }
     /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
-    if (newLen > numAvail)
+    if (newLen > numAvailableBytes)
     {
-      newLen = numAvail;
-      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-      matches[numPairs] = newLen;
-      numPairs += 2;
+      newLen = numAvailableBytes;
+      for (numDistancePairs = 0; newLen > matchDistances[numDistancePairs]; numDistancePairs += 2);
+      matchDistances[numDistancePairs] = newLen;
+      numDistancePairs += 2;
     }
     if (newLen >= startLen)
     {
@@ -1424,9 +1439,9 @@
         p->opt[++lenEnd].price = kInfinityPrice;
 
       offs = 0;
-      while (startLen > matches[offs])
+      while (startLen > matchDistances[offs])
         offs += 2;
-      curBack = matches[offs + 1];
+      curBack = matchDistances[offs + 1];
       GetPosSlot2(curBack, posSlot);
       for (lenTest = /*2*/ startLen; ; lenTest++)
       {
@@ -1447,15 +1462,15 @@
           opt->prev1IsChar = False;
         }
 
-        if (/*_maxMode && */lenTest == matches[offs])
+        if (/*_maxMode && */lenTest == matchDistances[offs])
         {
           /* Try Match + Literal + Rep0 */
           const Byte *data2 = data - (curBack + 1);
           UInt32 lenTest2 = lenTest + 1;
           UInt32 limit = lenTest2 + p->numFastBytes;
           UInt32 nextRepMatchPrice;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
+          if (limit > numAvailableBytesFull)
+            limit = numAvailableBytesFull;
           for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
           lenTest2 -= lenTest + 1;
           if (lenTest2 >= 2)
@@ -1494,9 +1509,9 @@
             }
           }
           offs += 2;
-          if (offs == numPairs)
+          if (offs == numDistancePairs)
             break;
-          curBack = matches[offs + 1];
+          curBack = matchDistances[offs + 1];
           if (curBack >= kNumFullDistances)
             GetPosSlot2(curBack, posSlot);
         }
@@ -1509,110 +1524,136 @@
 
 static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
 {
-  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  UInt32 numAvailableBytes = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+  UInt32 lenMain, numDistancePairs;
   const Byte *data;
-  const UInt32 *matches;
+  UInt32 repLens[LZMA_NUM_REPS];
+  UInt32 repMaxIndex, i;
+  UInt32 *matchDistances;
+  UInt32 backMain;
 
-  if (p->additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &numPairs);
+  if (!p->longestMatchWasFound)
+  {
+    lenMain = ReadMatchDistances(p, &numDistancePairs);
+  }
   else
   {
-    mainLen = p->longestMatchLength;
-    numPairs = p->numPairs;
+    lenMain = p->longestMatchLength;
+    numDistancePairs = p->numDistancePairs;
+    p->longestMatchWasFound = False;
   }
 
-  numAvail = p->numAvail;
-  *backRes = (UInt32)-1;
-  if (numAvail < 2)
-    return 1;
-  if (numAvail > LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
   data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  if (numAvailableBytes > LZMA_MATCH_LEN_MAX)
+    numAvailableBytes = LZMA_MATCH_LEN_MAX;
+  if (numAvailableBytes < 2)
+  {
+    *backRes = (UInt32)(-1);
+    return 1;
+  }
+
+  repMaxIndex = 0;
 
-  repLen = repIndex = 0;
   for (i = 0; i < LZMA_NUM_REPS; i++)
   {
-    UInt32 len;
     const Byte *data2 = data - (p->reps[i] + 1);
+    UInt32 len;
     if (data[0] != data2[0] || data[1] != data2[1])
+    {
+      repLens[i] = 0;
       continue;
-    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
+    }
+    for (len = 2; len < numAvailableBytes && data[len] == data2[len]; len++);
     if (len >= p->numFastBytes)
     {
       *backRes = i;
       MovePos(p, len - 1);
       return len;
     }
-    if (len > repLen)
-    {
-      repIndex = i;
-      repLen = len;
-    }
+    repLens[i] = len;
+    if (len > repLens[repMaxIndex])
+      repMaxIndex = i;
   }
-
-  matches = p->matches;
-  if (mainLen >= p->numFastBytes)
+  matchDistances = p->matchDistances;
+  if (lenMain >= p->numFastBytes)
   {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
+    *backRes = matchDistances[numDistancePairs - 1] + LZMA_NUM_REPS; 
+    MovePos(p, lenMain - 1);
+    return lenMain;
   }
 
-  mainDist = 0; /* for GCC */
-  if (mainLen >= 2)
+  backMain = 0; /* for GCC */
+  if (lenMain >= 2)
   {
-    mainDist = matches[numPairs - 1];
-    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
+    backMain = matchDistances[numDistancePairs - 1];
+    while (numDistancePairs > 2 && lenMain == matchDistances[numDistancePairs - 4] + 1)
     {
-      if (!ChangePair(matches[numPairs - 3], mainDist))
+      if (!ChangePair(matchDistances[numDistancePairs - 3], backMain))
         break;
-      numPairs -= 2;
-      mainLen = matches[numPairs - 2];
-      mainDist = matches[numPairs - 1];
-    }
-    if (mainLen == 2 && mainDist >= 0x80)
-      mainLen = 1;
-  }
-
-  if (repLen >= 2 && (
-        (repLen + 1 >= mainLen) ||
-        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
-        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
-  {
-    *backRes = repIndex;
-    MovePos(p, repLen - 1);
-    return repLen;
+      numDistancePairs -= 2;
+      lenMain = matchDistances[numDistancePairs - 2];
+      backMain = matchDistances[numDistancePairs - 1];
+    }
+    if (lenMain == 2 && backMain >= 0x80)
+      lenMain = 1;
   }
-  
-  if (mainLen < 2 || numAvail <= 2)
-    return 1;
 
-  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
+  if (repLens[repMaxIndex] >= 2)
+  {
+    if (repLens[repMaxIndex] + 1 >= lenMain || 
+        (repLens[repMaxIndex] + 2 >= lenMain && (backMain > (1 << 9))) ||
+        (repLens[repMaxIndex] + 3 >= lenMain && (backMain > (1 << 15))))
+  {
+      UInt32 lenRes;
+      *backRes = repMaxIndex;
+      lenRes = repLens[repMaxIndex];
+      MovePos(p, lenRes - 1);
+      return lenRes;
+    }
+  }
+  
+  if (lenMain >= 2 && numAvailableBytes > 2)
+  {
+    UInt32 i;
+    numAvailableBytes = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+    p->longestMatchLength = ReadMatchDistances(p, &p->numDistancePairs);
   if (p->longestMatchLength >= 2)
   {
-    UInt32 newDistance = matches[p->numPairs - 1];
-    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
-        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
-        (p->longestMatchLength > mainLen + 1) ||
-        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
+      UInt32 newDistance = matchDistances[p->numDistancePairs - 1];
+      if ((p->longestMatchLength >= lenMain && newDistance < backMain) || 
+          (p->longestMatchLength == lenMain + 1 && !ChangePair(backMain, newDistance)) ||
+          (p->longestMatchLength > lenMain + 1) ||
+          (p->longestMatchLength + 1 >= lenMain && lenMain >= 3 && ChangePair(newDistance, backMain)))
+      {
+        p->longestMatchWasFound = True;
+        *backRes = (UInt32)(-1);
       return 1;
   }
-  
+    }
   data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
   for (i = 0; i < LZMA_NUM_REPS; i++)
   {
-    UInt32 len, limit;
+      UInt32 len;
     const Byte *data2 = data - (p->reps[i] + 1);
-    if (data[0] != data2[0] || data[1] != data2[1])
+      if (data[1] != data2[1] || data[2] != data2[2])
+      {
+        repLens[i] = 0;
       continue;
-    limit = mainLen - 1;
-    for (len = 2; len < limit && data[len] == data2[len]; len++);
-    if (len >= limit)
+      }
+      for (len = 2; len < numAvailableBytes && data[len] == data2[len]; len++);
+      if (len + 1 >= lenMain)
+      {
+        p->longestMatchWasFound = True;
+        *backRes = (UInt32)(-1);
       return 1;
   }
-  *backRes = mainDist + LZMA_NUM_REPS;
-  MovePos(p, mainLen - 2);
-  return mainLen;
+    }
+    *backRes = backMain + LZMA_NUM_REPS; 
+    MovePos(p, lenMain - 2);
+    return lenMain;
+  }
+  *backRes = (UInt32)(-1);
+  return 1;
 }
 
 static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
@@ -1770,11 +1811,11 @@
 
   if (p->nowPos64 == 0)
   {
-    UInt32 numPairs;
+    UInt32 numDistancePairs;
     Byte curByte;
     if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
       return Flush(p, nowPos32);
-    ReadMatchDistances(p, &numPairs);
+    ReadMatchDistances(p, &numDistancePairs);
     RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
     p->state = kLiteralNextStates[p->state];
     curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
@@ -1798,7 +1839,7 @@
     #endif
 
     posState = nowPos32 & p->pbMask;
-    if (len == 1 && pos == (UInt32)-1)
+    if (len == 1 && pos == 0xFFFFFFFF)
     {
       Byte curByte;
       CLzmaProb *probs;
@@ -2016,6 +2057,7 @@
   for (i = 0; i < (1 << kNumAlignBits); i++)
     p->posAlignEncoder[i] = kProbInitValue;
 
+  p->longestMatchWasFound = False;
   p->optimumEndIndex = 0;
   p->optimumCurrentIndex = 0;
   p->additionalOffset = 0;
@@ -2096,8 +2138,6 @@
   CLzmaEnc *p = (CLzmaEnc *)pp;
   if (p->mtMode)
     MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-  #else
-  pp = pp;
   #endif
 }
 
@@ -2160,7 +2200,7 @@
   RangeEnc_Init(&p->rc);
   p->rc.outStream = &outStream.funcTable;
 
-  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+  res = LzmaEnc_CodeOneBlock(pp, True, desiredPackSize, *unpackSize);
   
   *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
   *destLen -= outStream.rem;
@@ -2187,7 +2227,7 @@
 
   for (;;)
   {
-    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
+    res = LzmaEnc_CodeOneBlock(pp, False, 0, 0);
     if (res != SZ_OK || p->finished != 0)
       break;
     if (progress != 0)
@@ -2258,7 +2298,7 @@
   return res;
 }
 
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+SRes LzmaEncode_2008(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
     const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
     ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
 {
diff -uNr linux-2.6.26.8.org/lib/lzma/Makefile linux-2.6.26.8/lib/lzma/Makefile
--- linux-2.6.26.8.org/lib/lzma/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.26.8/lib/lzma/Makefile	2009-08-03 10:28:59.000000000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_LZMA_COMPRESS) += LzFind.o LzmaDec.o LzmaEnc.o
diff -uNr linux-2.6.26.8.org/lib/Makefile linux-2.6.26.8/lib/Makefile
--- linux-2.6.26.8.org/lib/Makefile	2008-11-10 20:18:24.000000000 +0100
+++ linux-2.6.26.8/lib/Makefile	2009-08-03 10:28:59.000000000 +0200
@@ -56,6 +56,7 @@
 obj-$(CONFIG_REED_SOLOMON) += reed_solomon/
 obj-$(CONFIG_LZO_COMPRESS) += lzo/
 obj-$(CONFIG_LZO_DECOMPRESS) += lzo/
+obj-$(CONFIG_LZMA_COMPRESS) += lzma/
 
 obj-$(CONFIG_TEXTSEARCH) += textsearch.o
 obj-$(CONFIG_TEXTSEARCH_KMP) += ts_kmp.o
