? diff
? diff-old
Index: include/libbb.h
===================================================================
RCS file: /var/cvs/busybox/include/libbb.h,v
retrieving revision 1.91
diff -u -r1.91 libbb.h
--- include/libbb.h	13 Jan 2003 22:09:47 -0000	1.91
+++ include/libbb.h	19 Jan 2003 20:26:11 -0000
@@ -86,11 +86,11 @@
 extern void show_usage(void) __attribute__ ((noreturn));
 extern void error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
 extern void error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
-extern void perror_msg(const char *s, ...);
-extern void perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn));
+extern void perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+extern void perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
 extern void vherror_msg(const char *s, va_list p);
-extern void herror_msg(const char *s, ...);
-extern void herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn));
+extern void herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+extern void herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
 
 /* These two are used internally -- you shouldn't need to use them */
 extern void verror_msg(const char *s, va_list p);
@@ -277,7 +277,6 @@
 extern const char * const group_file;
 extern const char * const securetty_file;
 extern const char * const motd_file;
-extern const char * const issue_file;
 extern const char * const _path_login;
 
 #ifdef CONFIG_FEATURE_DEVFS
@@ -364,5 +363,8 @@
 	struct llist_s *link;
 } llist_t;
 extern llist_t *llist_add_to(llist_t *old_head, char *new_item);
+
+void print_login_issue(const char *issue_file, const char *tty);
+void print_login_prompt(void);
 
 #endif /* __LIBCONFIG_H__ */
Index: libbb/Makefile.in
===================================================================
RCS file: /var/cvs/busybox/libbb/Makefile.in,v
retrieving revision 1.15
diff -u -r1.15 Makefile.in
--- libbb/Makefile.in	14 Dec 2002 01:58:58 -0000	1.15
+++ libbb/Makefile.in	19 Jan 2003 20:26:11 -0000
@@ -33,7 +33,7 @@
 	get_last_path_component.c get_line_from_file.c herror_msg.c \
 	herror_msg_and_die.c human_readable.c inet_common.c inode_hash.c \
 	interface.c isdirectory.c kernel_version.c last_char_is.c libc5.c \
-	llist_add_to.c loop.c make_directory.c mode_string.c \
+	llist_add_to.c login.c loop.c make_directory.c mode_string.c \
 	module_syscalls.c mtab.c mtab_file.c my_getgrgid.c my_getgrnam.c \
 	my_getpwnam.c my_getpwnamegid.c my_getpwuid.c obscure.c parse_mode.c \
 	parse_number.c perror_msg.c perror_msg_and_die.c print_file.c \
Index: libbb/login.c
===================================================================
RCS file: libbb/login.c
diff -N libbb/login.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ libbb/login.c	19 Jan 2003 20:26:11 -0000
@@ -0,0 +1,124 @@
+/*
+ * issue.c: issue printing code
+ *
+ * Copyright (C) 2003 Bastian Blank <waldi@tuxbox.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * $Id$
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include "busybox.h"
+
+#include <sys/utsname.h>
+#include <time.h>
+
+#define LOGIN " login: "
+
+static char fmtstr_d[] = { "%A, %d %B %Y" };
+static char fmtstr_t[] = { "%H:%M:%S" };
+
+void print_login_issue(const char *issue_file, const char *tty)
+{
+	FILE *fd;
+	int c;
+	char buf[256];
+	char *ret;
+	time_t t;
+	struct utsname uts;
+
+	time(&t);
+	uname(&uts);
+
+	puts("");	/* start a new line */
+
+	if ((fd = fopen(issue_file, "r"))) {
+		while ((c = fgetc(fd)) != EOF) {
+			if (c == '\\' || c == '%') {
+				c = fgetc(fd);
+
+				switch (c) {
+					case 's':
+						fputs(uts.sysname, stdout);
+						break;
+
+					case 'n':
+						fputs(uts.nodename, stdout);
+						break;
+
+					case 'r':
+						fputs(uts.release, stdout);
+						break;
+
+					case 'v':
+						fputs(uts.version, stdout);
+						break;
+
+					case 'm':
+						fputs(uts.machine, stdout);
+						break;
+
+					case 'D':
+					case 'o':
+						getdomainname(buf, sizeof(buf));
+						buf[sizeof(buf) - 1] = '\0';
+						fputs(buf, stdout);
+						break;
+
+					case 'd':
+						strftime(buf, sizeof(buf), fmtstr_d, localtime(&t));
+						fputs(buf, stdout);
+						break;
+
+					case 't':
+						strftime(buf, sizeof(buf), fmtstr_t, localtime(&t));
+						fputs(buf, stdout);
+						break;
+
+					case 'h':
+						gethostname(buf, sizeof(buf));
+						fputs(buf, stdout);
+						break;
+
+					case 'l':
+						printf("%s", tty);
+
+					default:
+						putchar(c);
+				}
+			} else
+				putchar(c);
+		}
+
+		puts("");	/* start a new line */
+		fflush(stdout);
+
+		fclose(fd);
+	}
+}
+
+void print_login_prompt(void)
+{
+	char buf[MAXHOSTNAMELEN];
+
+	gethostname(buf, MAXHOSTNAMELEN);
+	fputs(buf, stdout);
+
+	fputs(LOGIN, stdout);
+	fflush(stdout);
+}
+
Index: libbb/run_parts.c
===================================================================
RCS file: /var/cvs/busybox/libbb/run_parts.c,v
retrieving revision 1.3
diff -u -r1.3 run_parts.c
--- libbb/run_parts.c	21 Nov 2002 22:17:11 -0000	1.3
+++ libbb/run_parts.c	19 Jan 2003 20:26:11 -0000
@@ -64,6 +64,8 @@
 	entries = scandir(arg0, &namelist, valid_name, alphasort);
 
 	if (entries == -1) {
+		if (test_mode & 2)
+			return 2;
 		perror_msg_and_die("failed to open directory %s", arg0);
 	}
 
@@ -75,7 +77,7 @@
 			perror_msg_and_die("failed to stat component %s", filename);
 		}
 		if (S_ISREG(st.st_mode) && !access(filename, X_OK)) {
-			if (test_mode)
+			if (test_mode & 1)
 				printf("run-parts would run %s\n", filename);
 			else {
 				/* exec_errno is common vfork variable */
Index: loginutils/Config.in
===================================================================
RCS file: /var/cvs/busybox/loginutils/Config.in,v
retrieving revision 1.1
diff -u -r1.1 Config.in
--- loginutils/Config.in	5 Dec 2002 08:40:47 -0000	1.1
+++ loginutils/Config.in	19 Jan 2003 20:26:12 -0000
@@ -54,7 +54,6 @@
 	help
 	  Please submit a patch to add help text for this item.
 
-
 config CONFIG_PASSWD
 	bool "passwd"
 	default n
@@ -67,29 +66,32 @@
 	help
 	  Please submit a patch to add help text for this item.
 
-config CONFIG_FEATURE_SHADOWPASSWDS
-	bool "Support for shadow passwords"
-	default y
-	depends on CONFIG_ADDUSER || CONFIG_DELUSER || CONFIG_LOGIN || CONFIG_SU
+config CONFIG_SULOGIN
+	bool "sulogin"
+	default n
 	help
 	  Please submit a patch to add help text for this item.
 
-config CONFIG_USE_BB_SHADOW
-	bool "  Use busybox shadow password functions"
+config CONFIG_VLOCK
+	bool "vlock"
 	default n
-	depends on CONFIG_USE_BB_PWD_GRP && CONFIG_FEATURE_SHADOWPASSWDS
 	help
 	  Please submit a patch to add help text for this item.
 
-config CONFIG_SULOGIN
-	bool "sulogin"
+comment "Common options for adduser, deluser, login, su"
+	depends on CONFIG_ADDUSER || CONFIG_DELUSER || CONFIG_LOGIN || CONFIG_SU
+
+config CONFIG_FEATURE_SHADOWPASSWDS
+	bool "Support for shadow passwords"
 	default n
+	depends on CONFIG_ADDUSER || CONFIG_DELUSER || CONFIG_LOGIN || CONFIG_SU
 	help
 	  Please submit a patch to add help text for this item.
 
-config CONFIG_VLOCK
-	bool "vlock"
+config CONFIG_USE_BB_SHADOW
+	bool "  Use busybox shadow password functions"
 	default n
+	depends on CONFIG_USE_BB_PWD_GRP && CONFIG_FEATURE_SHADOWPASSWDS
 	help
 	  Please submit a patch to add help text for this item.
 
Index: loginutils/getty.c
===================================================================
RCS file: /var/cvs/busybox/loginutils/getty.c,v
retrieving revision 1.5
diff -u -r1.5 getty.c
--- loginutils/getty.c	10 Oct 2002 04:20:17 -0000	1.5
+++ loginutils/getty.c	19 Jan 2003 20:26:12 -0000
@@ -73,8 +73,6 @@
 #include <time.h>
 #endif
 
-#define LOGIN " login: "		/* login prompt */
-
 /* Some shorthands for control characters. */
 
 #define CTL(x)		(x ^ 0100)	/* Assumes ASCII dialect */
@@ -752,142 +750,10 @@
 /* do_prompt - show login prompt, optionally preceded by /etc/issue contents */
 static void do_prompt(struct options *op, struct termio *tp)
 {
-#ifdef	ISSUE
-	FILE *fd;
-	int oflag;
-	int c;
-	struct utsname uts;
-
-	(void) uname(&uts);
-#endif
-
-	(void) write(1, "\r\n", 2);	/* start a new line */
 #ifdef	ISSUE					/* optional: show /etc/issue */
-	if ((op->flags & F_ISSUE) && (fd = fopen(op->issue, "r"))) {
-		oflag = tp->c_oflag;	/* save current setting */
-		tp->c_oflag |= (ONLCR | OPOST);	/* map NL in output to CR-NL */
-		(void) ioctl(0, TCSETAW, tp);
-
-
-		while ((c = getc(fd)) != EOF) {
-			if (c == '\\') {
-				c = getc(fd);
-
-				switch (c) {
-				case 's':
-					(void) printf("%s", uts.sysname);
-					break;
-
-				case 'n':
-					(void) printf("%s", uts.nodename);
-					break;
-
-				case 'r':
-					(void) printf("%s", uts.release);
-					break;
-
-				case 'v':
-					(void) printf("%s", uts.version);
-					break;
-
-				case 'm':
-					(void) printf("%s", uts.machine);
-					break;
-
-				case 'o':
-				{
-					char domainname[256];
-
-					getdomainname(domainname, sizeof(domainname));
-					domainname[sizeof(domainname) - 1] = '\0';
-					printf("%s", domainname);
-				}
-					break;
-
-				case 'd':
-				case 't':
-				{
-					char *weekday[] = { "Sun", "Mon", "Tue", "Wed", "Thu",
-						"Fri", "Sat"
-					};
-					char *month[] = { "Jan", "Feb", "Mar", "Apr", "May",
-						"Jun", "Jul", "Aug", "Sep", "Oct",
-						"Nov", "Dec"
-					};
-					time_t now;
-					struct tm *tm;
-
-					(void) time(&now);
-					tm = localtime(&now);
-
-					if (c == 'd')
-						(void) printf("%s %s %d  %d",
-									  weekday[tm->tm_wday],
-									  month[tm->tm_mon], tm->tm_mday,
-									  tm->tm_year <
-									  70 ? tm->tm_year +
-									  2000 : tm->tm_year + 1900);
-					else
-						(void) printf("%02d:%02d:%02d", tm->tm_hour,
-									  tm->tm_min, tm->tm_sec);
-
-					break;
-				}
-
-				case 'l':
-					(void) printf("%s", op->tty);
-					break;
-
-				case 'b':
-				{
-					int i;
-
-					for (i = 0; speedtab[i].speed; i++) {
-						if (speedtab[i].code == (tp->c_cflag & CBAUD)) {
-							printf("%ld", speedtab[i].speed);
-							break;
-						}
-					}
-					break;
-				}
-				case 'u':
-				case 'U':
-				{
-					int users = 0;
-					struct utmp *ut;
-
-					setutent();
-					while ((ut = getutent()))
-						if (ut->ut_type == USER_PROCESS)
-							users++;
-					endutent();
-					printf("%d ", users);
-					if (c == 'U')
-						printf((users == 1) ? "user" : "users");
-					break;
-				}
-				default:
-					(void) putchar(c);
-				}
-			} else
-				(void) putchar(c);
-		}
-		fflush(stdout);
-
-		tp->c_oflag = oflag;	/* restore settings */
-		(void) ioctl(0, TCSETAW, tp);	/* wait till output is gone */
-		(void) fclose(fd);
-	}
-#endif
-#ifdef __linux__
-	{
-		char hn[MAXHOSTNAMELEN + 1];
-
-		(void) gethostname(hn, MAXHOSTNAMELEN);
-		write(1, hn, strlen(hn));
-	}
+	print_login_issue(op->issue, op->tty);
 #endif
-	(void) write(1, LOGIN, sizeof(LOGIN) - 1);	/* always show login prompt */
+	print_login_prompt();
 }
 
 /* next_speed - select next baud rate */
Index: loginutils/login.c
===================================================================
RCS file: /var/cvs/busybox/loginutils/login.c,v
retrieving revision 1.8
diff -u -r1.8 login.c
--- loginutils/login.c	3 Dec 2002 19:54:12 -0000	1.8
+++ loginutils/login.c	19 Jan 2003 20:26:13 -0000
@@ -253,20 +253,18 @@
 	int i;
 
 	for(i=0; i<EMPTY_USERNAME_COUNT; i++) {
-	gethostname ( buf, sizeof( buf ));
-	printf ( "\n%s login: ", buf );
-	fflush ( stdout );
+		print_login_prompt();
+
+		if ( !fgets ( buf, sizeof( buf ) - 1, stdin ))
+			return 0;
 
-	if ( !fgets ( buf, sizeof( buf ) - 1, stdin ))
-		return 0;
-		
 		if ( !strchr ( buf, '\n' ))
-		return 0;
-	
-	for ( sp = buf; isspace ( *sp ); sp++ ) { }
-	for ( ep = sp; isgraph ( *ep ); ep++ ) { }
+			return 0;
+
+		for ( sp = buf; isspace ( *sp ); sp++ ) { }
+		for ( ep = sp; isgraph ( *ep ); ep++ ) { }
 
-	*ep = 0;		
+		*ep = 0;		
 		safe_strncpy(buf_name, sp, USERNAME_SIZE);
 		if(buf_name[0])
 			return 1;
Index: networking/Config.in
===================================================================
RCS file: /var/cvs/busybox/networking/Config.in,v
retrieving revision 1.8
diff -u -r1.8 Config.in
--- networking/Config.in	13 Jan 2003 21:40:37 -0000	1.8
+++ networking/Config.in	19 Jan 2003 20:26:13 -0000
@@ -315,6 +315,13 @@
 	help
 	  Please submit a patch to add help text for this item.
 
+config CONFIG_FEATURE_TELNETD_INETD
+	bool "  Use inetd"
+	default n
+	depends on CONFIG_TELNETD
+	help
+	  Please submit a patch to add help text for this item.
+
 config CONFIG_TFTP
 	bool "tftp"
 	default n
Index: networking/ifupdown.c
===================================================================
RCS file: /var/cvs/busybox/networking/ifupdown.c,v
retrieving revision 1.16
retrieving revision 1.18
diff -u -r1.16 -r1.18
--- networking/ifupdown.c	13 Jan 2003 21:40:37 -0000	1.16
+++ networking/ifupdown.c	20 Jan 2003 23:50:59 -0000	1.18
@@ -604,27 +604,28 @@
 
 #endif	/* ifdef CONFIG_FEATURE_IFUPDOWN_IPV4 */
 
-static char *next_word(char *buf, char *word, int maxlen)
+static char *next_word(char **buf)
 {
-	if (!buf)
-		return NULL;
-	if (!*buf)
-		return NULL;
+	unsigned short length;
+	char *word;
 
-	while (!isspace(*buf) && *buf) {
-		if (maxlen-- > 1)
-			*word++ = *buf;
-		buf++;
-	}
-	if (maxlen > 0) {
-		*word = '\0';
+	if ((buf == NULL) || (*buf == NULL) || (**buf == '\0')) {
+		return NULL;
 	}
 
-	while (isspace(*buf) && *buf) {
-		buf++;
-	}
+	/* Skip over leading whitespace */
+	word = *buf + strspn(*buf, " \t\n");
 
-	return buf;
+	/* Find the length of this word */
+	length = strcspn(word, " \t\n");
+	if (length == 0) {
+		return(NULL);
+	}
+	*buf = word + length;
+	**buf = '\0';
+	(*buf)++;
+
+	return word;
 }
 
 static address_family_t *get_address_family(address_family_t *af[], char *name)
@@ -675,44 +676,34 @@
 
 static interfaces_file_t *read_interfaces(char *filename)
 {
-	interface_defn_t *currif = NULL;
-	interfaces_file_t *defn;
 #ifdef CONFIG_FEATURE_IFUPDOWN_MAPPING
 	mapping_defn_t *currmap = NULL;
 #endif
+	interface_defn_t *currif = NULL;
+	interfaces_file_t *defn;
 	FILE *f;
-	char firstword[80];
-	char *buf = NULL;
-	char *rest;
-//	int line;
+	char *firstword;
+	char *buf;
 
 	enum { NONE, IFACE, MAPPING } currently_processing = NONE;
 
 	defn = xmalloc(sizeof(interfaces_file_t));
-//	defn->max_autointerfaces = defn->n_autointerfaces = 0;
 	defn->autointerfaces = NULL;
 	defn->mappings = NULL;
 	defn->ifaces = NULL;
-	f = fopen(filename, "r");
-	if (f == NULL) {
-		return NULL;
-	}
+
+	f = xfopen(filename, "r");
 
 	while ((buf = get_line_from_file(f)) != NULL) {
-		char *end;
+		char *buf_ptr = buf;
 
+		/* Ignore comments */
 		if (buf[0] == '#') {
 			continue;
 		}
-		end = last_char_is(buf, '\n');
-		if (end) {
-			*end = '\0';
-		}
-		while ((end = last_char_is(buf, ' ')) != NULL) {
-			*end = '\0';
-		}
-		rest = next_word(buf, firstword, 80);
-		if (rest == NULL) {
+
+		firstword = next_word(&buf_ptr);
+		if (firstword == NULL) {
 			continue;	/* blank line */
 		}
 
@@ -723,7 +714,7 @@
 			currmap->n_matches = 0;
 			currmap->match = NULL;
 
-			while ((rest = next_word(rest, firstword, 80))) {
+			while ((firstword = next_word(&buf_ptr)) != NULL) {
 				if (currmap->max_matches == currmap->n_matches) {
 					currmap->max_matches = currmap->max_matches * 2 + 1;
 					currmap->match = xrealloc(currmap->match, sizeof(currmap->match) * currmap->max_matches);
@@ -747,9 +738,9 @@
 			currently_processing = MAPPING;
 		} else if (strcmp(firstword, "iface") == 0) {
 			{
-				char iface_name[80];
-				char address_family_name[80];
-				char method_name[80];
+				char *iface_name;
+				char *address_family_name;
+				char *method_name;
 				address_family_t *addr_fams[] = {
 #ifdef CONFIG_FEATURE_IFUPDOWN_IPV4
 					&addr_inet,
@@ -764,17 +755,16 @@
 				};
 
 				currif = xmalloc(sizeof(interface_defn_t));
+				iface_name = next_word(&buf_ptr);
+				address_family_name = next_word(&buf_ptr);
+				method_name = next_word(&buf_ptr);
 
-				rest = next_word(rest, iface_name, 80);
-				rest = next_word(rest, address_family_name, 80);
-				rest = next_word(rest, method_name, 80);
-
-				if (rest == NULL) {
+				if (buf_ptr == NULL) {
 					error_msg("too few parameters for line \"%s\"", buf);
 					return NULL;
 				}
 
-				if (rest[0] != '\0') {
+				if (buf_ptr[0] != '\0') {
 					error_msg("too many parameters \"%s\"", buf);
 					return NULL;
 				}
@@ -816,7 +806,7 @@
 			}
 			currently_processing = IFACE;
 		} else if (strcmp(firstword, "auto") == 0) {
-			while ((rest = next_word(rest, firstword, 80))) {
+			while ((firstword = next_word(&buf_ptr)) != NULL) {
 
 				/* Check the interface isnt already listed */
 				if (find_list_string(defn->autointerfaces, firstword)) {
@@ -833,7 +823,7 @@
 			{
 				int i;
 
-				if (xstrlen(rest) == 0) {
+				if (xstrlen(buf_ptr) == 0) {
 					error_msg("option with empty value \"%s\"", buf);
 					return NULL;
 				}
@@ -858,7 +848,7 @@
 					currif->option = opt;
 				}
 				currif->option[currif->n_options].name = xstrdup(firstword);
-				currif->option[currif->n_options].value = xstrdup(rest);
+				currif->option[currif->n_options].value = xstrdup(next_word(&buf_ptr));
 				if (!currif->option[currif->n_options].name) {
 					perror(filename);
 					return NULL;
@@ -876,14 +866,14 @@
 						error_msg("duplicate script in mapping \"%s\"", buf);
 						return NULL;
 					} else {
-						currmap->script = xstrdup(rest);
+						currmap->script = xstrdup(next_word(&buf_ptr));
 					}
 				} else if (strcmp(firstword, "map") == 0) {
 					if (currmap->max_mappings == currmap->n_mappings) {
 						currmap->max_mappings = currmap->max_mappings * 2 + 1;
 						currmap->mapping = xrealloc(currmap->mapping, sizeof(char *) * currmap->max_mappings);
 					}
-					currmap->mapping[currmap->n_mappings] = xstrdup(rest);
+					currmap->mapping[currmap->n_mappings] = xstrdup(next_word(&buf_ptr));
 					currmap->n_mappings++;
 				} else {
 					error_msg("misplaced option \"%s\"", buf);
@@ -897,10 +887,10 @@
 				return NULL;
 			}
 		}
+		free(buf);
 	}
 	if (ferror(f) != 0) {
-		perror_msg("%s", filename);
-		return NULL;
+		perror_msg_and_die("%s", filename);
 	}
 	fclose(f);
 
@@ -1020,7 +1010,7 @@
 
 	buf = xmalloc(xstrlen(opt) + 19);
 	sprintf(buf, "/etc/network/if-%s.d", opt);
-	run_parts(&buf, 0);
+	run_parts(&buf, 2);
 	free(buf);
 	return (1);
 }
@@ -1230,9 +1220,6 @@
 	}			
 
 	defn = read_interfaces(interfaces);
-	if (!defn) {
-		error_msg_and_die("couldn't read interfaces file \"%s\"", interfaces);
-	}
 
 	if (no_act) {
 		state_fp = fopen(statefile, "r");
Index: networking/telnetd.c
===================================================================
RCS file: /var/cvs/busybox/networking/telnetd.c,v
retrieving revision 1.2
diff -u -r1.2 telnetd.c
--- networking/telnetd.c	10 Nov 2002 22:26:19 -0000	1.2
+++ networking/telnetd.c	19 Jan 2003 20:26:14 -0000
@@ -48,7 +48,13 @@
 
 #define BUFSIZE 4000
 
-static const char *loginpath = "/bin/sh";
+static const char *loginpath = 
+#ifdef CONFIG_LOGIN
+"/bin/login";
+#else
+"/bin/sh";
+#endif
+static const char *issuefile = "/etc/issue.net";
 
 /* shell name and arguments */
 
@@ -57,8 +63,12 @@
 /* structure that describes a session */
 
 struct tsession {
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+	int sockfd_read, sockfd_write, ptyfd;
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 	struct tsession *next;
 	int sockfd, ptyfd;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 	int shell_pid;
 	/* two circular buffers */
 	char *buf1, *buf2;
@@ -204,7 +214,11 @@
 
 
 static struct tsession *
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+make_new_session(void)
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 make_new_session(int sockfd)
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 {
 	struct termios termbuf;
 	int pty, pid;
@@ -214,7 +228,12 @@
 	ts->buf1 = (char *)(&ts[1]);
 	ts->buf2 = ts->buf1 + BUFSIZE;
 
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+	ts->sockfd_read = 0;
+	ts->sockfd_write = 1;
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 	ts->sockfd = sockfd;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 	ts->rdidx1 = ts->wridx1 = ts->size1 = 0;
 	ts->rdidx2 = ts->wridx2 = ts->size2 = 0;
@@ -278,6 +297,8 @@
 		/*termbuf.c_lflag &= ~ICANON;*/
 		tcsetattr(0, TCSANOW, &termbuf);
 
+		print_login_issue(issuefile, NULL);
+
 		/* exec shell, with correct argv and env */
 		execv(loginpath, (char *const *)argv_init);
 
@@ -291,6 +312,7 @@
 	return ts;
 }
 
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 static void
 free_session(struct tsession *ts)
 {
@@ -319,30 +341,44 @@
 
 	free(ts);
 }
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 int
 telnetd_main(int argc, char **argv)
 {
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 	struct sockaddr_in sa;
 	int master_fd;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 	fd_set rdfdset, wrfdset;
 	int selret;
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 	int on = 1;
 	int portnbr = 23;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 	int c;
-
-	/* check if user supplied a port number */
+	static const char options[] =
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+		"f:l:";
+#else /* CONFIG_EATURE_TELNETD_INETD */
+		"f:l:p:";
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 	for (;;) {
-		c = getopt( argc, argv, "p:l:");
+		c = getopt( argc, argv, options);
 		if (c == EOF) break;
 		switch (c) {
-			case 'p':
-				portnbr = atoi(optarg);
+			case 'f':
+				issuefile = strdup (optarg);
 				break;
 			case 'l':
 				loginpath = strdup (optarg);
 				break;
+#ifndef CONFIG_FEATURE_TELNETD_INETD
+			case 'p':
+				portnbr = atoi(optarg);
+				break;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 			default:
 				show_usage();
 		}
@@ -353,6 +389,12 @@
 	}
 
 	argv_init[0] = loginpath;
+
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+	maxfd = 1;
+
+	sessions = make_new_session();
+#else /* CONFIG_EATURE_TELNETD_INETD */
 	sessions = 0;
 
 	/* Grab a TCP socket.  */
@@ -382,6 +424,7 @@
 
 
 	maxfd = master_fd;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 	do {
 		struct tsession *ts;
@@ -393,10 +436,14 @@
 		 * ptys if there is room in their respective session buffers.
 		 */
 
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 		FD_SET(master_fd, &rdfdset);
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 		ts = sessions;
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 		while (ts) {
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 			/* buf1 is used from socket to pty
 			 * buf2 is used from pty to socket
 			 */
@@ -404,22 +451,33 @@
 				FD_SET(ts->ptyfd, &wrfdset);  /* can write to pty */
 			}
 			if (ts->size1 < BUFSIZE) {
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+				FD_SET(ts->sockfd_read, &rdfdset); /* can read from socket */
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 				FD_SET(ts->sockfd, &rdfdset); /* can read from socket */
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 			}
 			if (ts->size2 > 0) {
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+				FD_SET(ts->sockfd_write, &wrfdset); /* can write to socket */
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 				FD_SET(ts->sockfd, &wrfdset); /* can write to socket */
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 			}
 			if (ts->size2 < BUFSIZE) {
 				FD_SET(ts->ptyfd, &rdfdset);  /* can read from pty */
 			}
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 			ts = ts->next;
 		}
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 		selret = select(maxfd + 1, &rdfdset, &wrfdset, 0, 0);
 
 		if (!selret)
 			break;
 
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 		/* First check for and accept new sessions.  */
 		if (FD_ISSET(master_fd, &rdfdset)) {
 			int fd, salen;
@@ -447,9 +505,12 @@
 
 		ts = sessions;
 		while (ts) { /* For all sessions...  */
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 			int maxlen, w, r;
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 			struct tsession *next = ts->next; /* in case we free ts. */
-
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
+			
 			if (ts->size1 && FD_ISSET(ts->ptyfd, &wrfdset)) {
 				int num_totty;
 				char *ptr;
@@ -459,9 +520,13 @@
 
 				w = write(ts->ptyfd, ptr, num_totty);
 				if (w < 0) {
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+					exit(0);
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 					free_session(ts);
 					ts = next;
 					continue;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				}
 				ts->wridx1 += w;
 				ts->size1 -= w;
@@ -469,31 +534,51 @@
 					ts->wridx1 = 0;
 			}
 
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+			if (ts->size2 && FD_ISSET(ts->sockfd_write, &wrfdset)) {
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 			if (ts->size2 && FD_ISSET(ts->sockfd, &wrfdset)) {
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				/* Write to socket from buffer 2.  */
 				maxlen = MIN(BUFSIZE - ts->wridx2, ts->size2);
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+				w = write(ts->sockfd_write, ts->buf2 + ts->wridx2, maxlen);
+				if (w < 0)
+					exit(0);
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 				w = write(ts->sockfd, ts->buf2 + ts->wridx2, maxlen);
 				if (w < 0) {
 					free_session(ts);
 					ts = next;
 					continue;
 				}
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				ts->wridx2 += w;
 				ts->size2 -= w;
 				if (ts->wridx2 == BUFSIZE)
 					ts->wridx2 = 0;
 			}
 
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+			if (ts->size1 < BUFSIZE && FD_ISSET(ts->sockfd_read, &rdfdset)) {
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 			if (ts->size1 < BUFSIZE && FD_ISSET(ts->sockfd, &rdfdset)) {
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				/* Read from socket to buffer 1. */
 				maxlen = MIN(BUFSIZE - ts->rdidx1,
 						BUFSIZE - ts->size1);
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+				r = read(ts->sockfd_read, ts->buf1 + ts->rdidx1, maxlen);
+				if (!r || (r < 0 && errno != EINTR))
+					exit(0);
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 				r = read(ts->sockfd, ts->buf1 + ts->rdidx1, maxlen);
 				if (!r || (r < 0 && errno != EINTR)) {
 					free_session(ts);
 					ts = next;
 					continue;
 				}
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				if(!*(ts->buf1 + ts->rdidx1 + r - 1)) {
 					r--;
 					if(!r)
@@ -511,9 +596,13 @@
 						BUFSIZE - ts->size2);
 				r = read(ts->ptyfd, ts->buf2 + ts->rdidx2, maxlen);
 				if (!r || (r < 0 && errno != EINTR)) {
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+					exit(0);
+#else /* CONFIG_FEATURE_TELNETD_INETD */
 					free_session(ts);
 					ts = next;
 					continue;
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 				}
 				ts->rdidx2 += r;
 				ts->size2 += r;
@@ -529,8 +618,10 @@
 				ts->rdidx2 = 0;
 				ts->wridx2 = 0;
 			}
+#ifndef CONFIG_FEATURE_TELNETD_INETD
 			ts = next;
 		}
+#endif /* CONFIG_FEATURE_TELNETD_INETD */
 
 	} while (1);
 
Index: networking/libiproute/ip_common.h
===================================================================
RCS file: /var/cvs/busybox/networking/libiproute/ip_common.h,v
retrieving revision 1.4
diff -u -r1.4 ip_common.h
--- networking/libiproute/ip_common.h	2 Dec 2002 01:40:05 -0000	1.4
+++ networking/libiproute/ip_common.h	19 Jan 2003 20:26:14 -0000
@@ -3,7 +3,7 @@
 
 extern void ip_parse_common_args(int *argcp, char ***argvp);
 extern int print_neigh(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
-extern int ipaddr_list(int argc, char **argv);
+extern int ipaddr_list_or_flush(int argc, char **argv, int flush);
 extern int iproute_monitor(int argc, char **argv);
 extern void iplink_usage(void) __attribute__((noreturn));
 extern void ipneigh_reset_filter(void);
Index: sysdeps/linux/Config.in
===================================================================
RCS file: /var/cvs/busybox/sysdeps/linux/Config.in,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- sysdeps/linux/Config.in	13 Dec 2002 22:53:27 -0000	1.4
+++ sysdeps/linux/Config.in	19 Jan 2003 12:55:13 -0000	1.5
@@ -157,6 +157,17 @@
 
 endmenu
 
+menu 'Installation Options'
+
+config CONFIG_INSTALL_NO_USR
+	bool "Don't use /usr"
+	default n
+	help
+	  Disable use of /usr. Don't activate this option if you don't know,
+	  that you really want this behaviour.
+
+endmenu
+
 source archival/Config.in
 source console-tools/Config.in
 source debianutils/Config.in
Index: include/applets.h
===================================================================
RCS file: /var/cvs/busybox/include/applets.h,v
retrieving revision 1.87
retrieving revision 1.90
diff -u -r1.87 -r1.90
--- include/applets.h	9 Jan 2003 10:06:00 -0000	1.87
+++ include/applets.h	23 Jan 2003 05:59:31 -0000	1.90
@@ -41,6 +41,11 @@
   #define APPLET_ODDNAME(a,b,c,d,e) {a,b,c,d},
 #endif
 
+#ifdef CONFIG_INSTALL_NO_USR
+#define _BB_DIR_USR_BIN _BB_DIR_BIN
+#define _BB_DIR_USR_SBIN _BB_DIR_SBIN
+#endif
+
 
 
 #ifdef CONFIG_TEST
@@ -267,22 +272,22 @@
 	APPLET(insmod, insmod_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IP
-	APPLET(ip, ip_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+	APPLET(ip, ip_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IPCALC
 	APPLET(ipcalc, ipcalc_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IPADDRESS
-	APPLET(ipaddr, ipaddr_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+	APPLET(ipaddr, ipaddr_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IPLINK
-	APPLET(iplink, iplink_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+	APPLET(iplink, iplink_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IPROUTE
-	APPLET(iproute, iproute_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+	APPLET(iproute, iproute_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_IPTUNNEL
-	APPLET(iptunnel, iptunnel_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+	APPLET(iptunnel, iptunnel_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_KILL
 	APPLET(kill, kill_main, _BB_DIR_BIN, _BB_SUID_NEVER)
@@ -592,6 +597,9 @@
 #endif
 #ifdef CONFIG_UUENCODE
 	APPLET(uuencode, uuencode_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_VCONFIG
+	APPLET(vconfig, vconfig_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
 #ifdef CONFIG_VI
 	APPLET(vi, vi_main, _BB_DIR_BIN, _BB_SUID_NEVER)
Index: include/usage.h
===================================================================
RCS file: /var/cvs/busybox/include/usage.h,v
retrieving revision 1.142
diff -u -r1.142 usage.h
--- include/usage.h	23 Jan 2003 05:59:31 -0000	1.142
+++ include/usage.h	24 Jan 2003 19:23:09 -0000
@@ -2076,6 +2076,14 @@
 	"Telnet is used to establish interactive communication with another\n"\
 	"computer over a network using the TELNET protocol."
 
+#ifdef CONFIG_FEATURE_TELNETD_INETD
+#define telnetd_trivial_usage \
+	"(inetd mode) [OPTION]"
+#define telnetd_full_usage \
+	"Telnetd uses incoming TELNET connections via inetd.\n"\
+	"Options:\n" \
+	"\t-l LOGIN\texec LOGIN on connect (default /bin/sh)"
+#else
 #define telnetd_trivial_usage \
 	"[OPTION]"
 #define telnetd_full_usage \
@@ -2083,6 +2091,7 @@
 	"Options:\n" \
 	"\t-p PORT\tlisten for connections on PORT (default 23)\n"\
 	"\t-l LOGIN\texec LOGIN on connect (default /bin/sh)"
+#endif
 
 #define test_trivial_usage \
 	"EXPRESSION\n  or   [ EXPRESSION ]"
Index: networking/Config.in
===================================================================
RCS file: /var/cvs/busybox/networking/Config.in,v
retrieving revision 1.10
diff -u -r1.10 Config.in
--- networking/Config.in	23 Jan 2003 05:59:32 -0000	1.10
+++ networking/Config.in	24 Jan 2003 19:23:10 -0000
@@ -146,7 +146,7 @@
 if ! (CONFIG_IP && CONFIG_IPADDR)
 	config CONFIG_FEATURE_IP_ADDRESS
 		bool "  address"
-		default n
+		default y
 		depends on CONFIG_IP
 		help
 		  Please submit a patch to add help text for this item.
@@ -188,7 +188,7 @@
 if !(CONFIG_IP && CONFIG_IPTUNNEL)
 	config CONFIG_FEATURE_IP_TUNNEL
 		bool "  tunnel"
-		default y
+		default n
 		depends on CONFIG_IP
 		help
 		  Please submit a patch to add help text for this item.
Index: networking/libiproute/iproute.c
===================================================================
RCS file: /var/cvs/busybox/networking/libiproute/iproute.c,v
retrieving revision 1.8
diff -u -r1.8 iproute.c
--- networking/libiproute/iproute.c	16 Dec 2002 07:37:20 -0000	1.8
+++ networking/libiproute/iproute.c	24 Jan 2003 19:23:12 -0000
@@ -19,6 +19,8 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
 
 #include "rt_names.h"
 #include "utils.h"
@@ -33,6 +35,8 @@
 static struct
 {
 	int tb;
+	int flushed;
+	char *flushb;
 	int flushp;
 	int flushe;
 	struct rtnl_handle *rth;
@@ -51,6 +55,16 @@
 	inet_prefix msrc;
 } filter;
 
+static int flush_update(void)
+{
+	if (rtnl_send(filter.rth, filter.flushb, filter.flushp) < 0) {
+		perror("Failed to send flush request\n");
+		return -1;
+	}
+	filter.flushp = 0;
+	return 0;
+}
+
 static int print_route(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
 {
 	FILE *fp = (FILE*)arg;
@@ -67,6 +81,8 @@
 			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
 		return 0;
 	}
+	if (filter.flushb && n->nlmsg_type != RTM_NEWROUTE)
+		return 0;
 	len -= NLMSG_LENGTH(sizeof(*r));
 	if (len < 0) {
 		error_msg("wrong nlmsg len %d", len);
@@ -128,6 +144,30 @@
 	memset(tb, 0, sizeof(tb));
 	parse_rtattr(tb, RTA_MAX, RTM_RTA(r), len);
 
+	if (filter.flushb &&
+	    r->rtm_family == AF_INET6 &&
+	    r->rtm_dst_len == 0 &&
+	    r->rtm_type == RTN_UNREACHABLE &&
+	    tb[RTA_PRIORITY] &&
+	    *(int*)RTA_DATA(tb[RTA_PRIORITY]) == -1)
+		return 0;
+
+	if (filter.flushb) {
+		struct nlmsghdr *fn;
+		if (NLMSG_ALIGN(filter.flushp) + n->nlmsg_len > filter.flushe) {
+			if (flush_update())
+				return -1;
+		}
+		fn = (struct nlmsghdr*)(filter.flushb + NLMSG_ALIGN(filter.flushp));
+		memcpy(fn, n, n->nlmsg_len);
+		fn->nlmsg_type = RTM_DELROUTE;
+		fn->nlmsg_flags = NLM_F_REQUEST;
+		fn->nlmsg_seq = ++filter.rth->seq;
+		filter.flushp = (((char*)fn) + n->nlmsg_len) - filter.flushb;
+		filter.flushed++;
+		return 0;
+	}
+
 	if (n->nlmsg_type == RTM_DELROUTE) {
 		fprintf(fp, "Deleted ");
 	}
@@ -393,6 +433,29 @@
 	return sendto(rth->fd, (void*)&req, sizeof(req), 0, (struct sockaddr*)&nladdr, sizeof(nladdr));
 }
 
+static int iproute_flush_cache(void)
+{
+#define ROUTE_FLUSH_PATH "/proc/sys/net/ipv4/route/flush"
+
+	int len;
+	int flush_fd = open (ROUTE_FLUSH_PATH, O_WRONLY);
+	char *buffer = "-1";
+
+	if (flush_fd < 0) {
+		fprintf (stderr, "Cannot open \"%s\"\n", ROUTE_FLUSH_PATH);
+		return -1;
+	}
+
+	len = strlen (buffer);
+
+	if ((write (flush_fd, (void *)buffer, len)) < len) {
+		fprintf (stderr, "Cannot flush routing cache\n");
+		return -1;
+	}
+	close(flush_fd);
+	return 0;
+}
+
 static void iproute_reset_filter(void)
 {
 	memset(&filter, 0, sizeof(filter));
@@ -400,7 +463,7 @@
 	filter.msrc.bitlen = -1;
 }
 
-static int iproute_list(int argc, char **argv)
+static int iproute_list_or_flush(int argc, char **argv, int flush)
 {
 	int do_ipv6 = preferred_family;
 	struct rtnl_handle rth;
@@ -410,6 +473,11 @@
 	iproute_reset_filter();
 	filter.tb = RT_TABLE_MAIN;
 
+	if (flush && argc <= 0) {
+		fprintf(stderr, "\"ip route flush\" requires arguments.\n");
+		return -1;
+	}
+
 	while (argc > 0) {
 		if (matches(*argv, "protocol") == 0) {
 			int prot = 0;
@@ -496,6 +564,46 @@
 		}
 	}
 
+	if (flush) {
+		int round = 0;
+		char flushb[4096-512];
+
+		if (filter.tb == -1) {
+			if (do_ipv6 != AF_INET6)
+				iproute_flush_cache();
+			if (do_ipv6 == AF_INET)
+				return 0;
+		}
+
+		filter.flushb = flushb;
+		filter.flushp = 0;
+		filter.flushe = sizeof(flushb);
+		filter.rth = &rth;
+
+		for (;;) {
+			if (rtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE) < 0) {
+				perror("Cannot send dump request");
+				return -1;
+			}
+			filter.flushed = 0;
+			if (rtnl_dump_filter(&rth, print_route, stdout, NULL, NULL) < 0) {
+				error_msg("Flush terminated\n");
+				return -1;
+			}
+			if (filter.flushed == 0) {
+				if (round == 0) {
+					if (filter.tb != -1 || do_ipv6 == AF_INET6)
+						fprintf(stderr, "Nothing to flush.\n");
+				}
+				fflush(stdout);
+				return 0;
+			}
+			round++;
+			if (flush_update() < 0)
+				exit(1);
+		}
+	}
+
 	if (filter.tb != -1) {
 		if (rtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE) < 0) {
 			perror_msg_and_die("Cannot send dump request");
@@ -686,7 +794,7 @@
 int do_iproute(int argc, char **argv)
 {
 	const char *ip_route_commands[] = { "add", "append", "change", "chg",
-		"delete", "get", "list", "show", "prepend", "replace", "test", 0 };
+		"delete", "get", "list", "show", "prepend", "replace", "test", "flush", 0 };
 	unsigned short command_num = 6;
 	unsigned int flags = 0;
 	int cmd = RTM_NEWROUTE;
@@ -712,13 +820,15 @@
 			return iproute_get(argc-1, argv+1);
 		case 6: /* list */
 		case 7: /* show */
-			return iproute_list(argc-1, argv+1);
+			return iproute_list_or_flush(argc-1, argv+1, 0);
 		case 8: /* prepend */
 			flags = NLM_F_CREATE;
 		case 9: /* replace */
 			flags = NLM_F_CREATE|NLM_F_REPLACE;
 		case 10: /* test */
 			flags = NLM_F_EXCL;
+		case 11: /* flush */
+			return iproute_list_or_flush(argc-1, argv+1, 1);
 		default:
 			error_msg_and_die("Unknown command %s", *argv);
 	}
Index: networking/udhcp/dhcpc.c
===================================================================
RCS file: /var/cvs/busybox/networking/udhcp/dhcpc.c,v
retrieving revision 1.7
diff -u -r1.7 dhcpc.c
--- networking/udhcp/dhcpc.c	21 Jan 2003 22:39:34 -0000	1.7
+++ networking/udhcp/dhcpc.c	24 Jan 2003 19:23:12 -0000
@@ -59,7 +59,11 @@
 #define LISTEN_RAW 2
 static int listen_mode;
 
+#ifdef CONFIG_INSTALL_NO_USR
+#define DEFAULT_SCRIPT	"/share/udhcpc/default.script"
+#else
 #define DEFAULT_SCRIPT	"/usr/share/udhcpc/default.script"
+#endif
 
 struct client_config_t client_config = {
 	/* Default options. */
