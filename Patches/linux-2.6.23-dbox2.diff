diff --git a/Makefile b/Makefile
index 4635a64..16fe88d 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 23
-EXTRAVERSION =
+EXTRAVERSION = -dbox2
 NAME = Arr Matey! A Hairy Bilge Rat!
 
 # *DOCUMENTATION*
diff --git a/arch/ppc/8xx_io/enet.c b/arch/ppc/8xx_io/enet.c
index 703d47e..eace3bc 100644
--- a/arch/ppc/8xx_io/enet.c
+++ b/arch/ppc/8xx_io/enet.c
@@ -44,6 +44,7 @@
 #include <asm/mpc8xx.h>
 #include <asm/uaccess.h>
 #include <asm/commproc.h>
+#include <asm/cacheflush.h>
 
 /*
  *				Theory of Operation
diff --git a/arch/ppc/Kconfig b/arch/ppc/Kconfig
index 6bdeeb7..9340190 100644
--- a/arch/ppc/Kconfig
+++ b/arch/ppc/Kconfig
@@ -502,6 +502,9 @@ config WINCEPT
 	  MPC821 PowerPC, introduced in 1998 and designed to be used in
 	  thin-client machines.  Say Y to support it directly.
 
+config DBOX2
+	bool "dbox2"
+
 endchoice
 
 menu "Freescale Ethernet driver platform-specific options"
diff --git a/arch/ppc/platforms/Makefile b/arch/ppc/platforms/Makefile
index e17fad4..1cff7e6 100644
--- a/arch/ppc/platforms/Makefile
+++ b/arch/ppc/platforms/Makefile
@@ -31,3 +31,4 @@ obj-$(CONFIG_EV64360)		+= ev64360.o
 obj-$(CONFIG_MPC86XADS)		+= mpc866ads_setup.o
 obj-$(CONFIG_MPC885ADS)		+= mpc885ads_setup.o
 obj-$(CONFIG_ADS8272)		+= mpc8272ads_setup.o
+obj-$(CONFIG_DBOX2)			+= dbox2.o
diff --git a/arch/ppc/platforms/dbox2.c b/arch/ppc/platforms/dbox2.c
new file mode 100644
index 0000000..684b032
--- /dev/null
+++ b/arch/ppc/platforms/dbox2.c
@@ -0,0 +1,221 @@
+/*
+ * arch/ppc/platforms/dbox2.c
+ *
+ * setup routines for the dbox2 board
+ *
+ * Copyright (C) 2004 Andreas Oberritter <obi@linuxtv.org>
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/commproc.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+enum dbox2_mid {
+	MID_NOKIA	= 1,
+	MID_PHILIPS	= 2,
+	MID_SAGEM	= 3,
+};
+
+const char *manuf_name[3] = {
+	"Nokia",
+	"Philips",
+	"Sagem",
+};
+
+static unsigned int manuf_id;
+
+static struct resource enx_resources[] = {
+	[0] = {
+		.start	= 0x08000000,
+		.end	= 0x080033ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0x09000000,
+		.end	= 0x091fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= SIU_IRQ1,
+		.end	= SIU_IRQ1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device enx_device = {
+	.name		= "enx",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(enx_resources),
+	.resource	= enx_resources,
+};
+
+static struct resource gtx_resources[] = {
+	[0] = {
+		.start	= 0x08400000,
+		.end	= 0x08402fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0x08000000,
+		.end	= 0x081fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= SIU_IRQ1,
+		.end	= SIU_IRQ1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gtx_device = {
+	.name		= "gtx",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(gtx_resources),
+	.resource	= gtx_resources,
+};
+
+static struct resource fp_resources[] = {
+	[0] = {
+		.start	= SIU_IRQ2,
+		.end	= SIU_IRQ2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device fp_device = {
+	.name		= "fp",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(fp_resources),
+	.resource	= fp_resources,
+};
+
+static struct resource fe_resources[] = {
+	[0] = {
+		.start	= SIU_IRQ7,
+		.end	= SIU_IRQ7,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device fe_device = {
+	.name		= "fe",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(fe_resources),
+	.resource	= fe_resources,
+};
+
+static struct resource cam_resources[] = {
+	[0] = {
+		.start	= 0x0c000000,
+		.end	= 0x0c01ffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SIU_IRQ3,
+		.end	= SIU_IRQ3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cam_device = {
+	.name		= "cam",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(cam_resources),
+	.resource	= cam_resources,
+};
+
+static struct resource avia_resources[] = {
+	[0] = {
+		.start	= 0x0a000000,
+		.end	= 0x0a0001ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SIU_IRQ4,
+		.end	= SIU_IRQ4,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device avia_device = {
+	.name		= "avia",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(avia_resources),
+	.resource	= avia_resources,
+};
+
+static ssize_t dbox2_manufacturer_node(struct bus_type *bus, char *buf)
+{
+	return sprintf(buf, "%s\n", manuf_name[manuf_id - 1]);
+}
+static BUS_ATTR(manufacturer, S_IRUGO, dbox2_manufacturer_node, NULL);
+
+static ssize_t dbox2_mID_node(struct bus_type *bus, char *buf)
+{
+	return sprintf(buf, "%d\n", manuf_id);
+}
+static BUS_ATTR(mID, S_IRUGO, dbox2_mID_node, NULL);
+
+static struct bus_attribute *const platform_bus_attrs[] = {
+	&bus_attr_manufacturer,
+	&bus_attr_mID,
+	NULL
+};
+
+static struct platform_device *dbox2_devs[] __initdata = {
+	&enx_device,
+	&fp_device,
+	&fe_device,
+	&cam_device,
+	&avia_device,
+};
+
+static int __init dbox2_add_devices(void)
+{
+	u8 *config_area;
+	int i;
+
+	config_area = ioremap(0x1001ffe0, 0x20);
+	if (!config_area) {
+		printk(KERN_ERR "dbox2: could not map config area!\n");
+		return -EIO;
+	}
+	manuf_id = config_area[0];
+	iounmap(config_area);
+
+	if ((manuf_id < MID_NOKIA) || (manuf_id > MID_SAGEM)) {
+		printk(KERN_ERR "dbox2: invalid config area!\n");
+		return -EIO;
+	}
+
+	printk(KERN_INFO "dbox2: %s board detected.\n", manuf_name[manuf_id - 1]);
+
+	if (manuf_id == MID_NOKIA) {
+		dbox2_devs[0] = &gtx_device;
+	} else if (manuf_id == MID_PHILIPS) {
+		cam_resources[0].start += 0x40000;
+		cam_resources[0].end += 0x40000;
+	}
+	fe_device.dev.platform_data = (void*)manuf_id;
+	
+	for (i=0; platform_bus_attrs[i]; i++){
+		int ret = bus_create_file(&platform_bus_type, platform_bus_attrs[i]);
+		if (ret<0){
+			while (--i>=0){
+				bus_remove_file(&platform_bus_type, platform_bus_attrs[i]);
+			}
+			printk(KERN_ERR "dbox2: error creating platform bus attributes: errno: %d\n",ret);
+		}
+	}
+	
+	return platform_add_devices(dbox2_devs, ARRAY_SIZE(dbox2_devs));
+}
+
+void __init board_init(void)
+{
+	device_initcall(dbox2_add_devices);
+}
diff --git a/arch/ppc/platforms/dbox2.h b/arch/ppc/platforms/dbox2.h
new file mode 100644
index 0000000..170c2c3
--- /dev/null
+++ b/arch/ppc/platforms/dbox2.h
@@ -0,0 +1,29 @@
+/*
+ * arch/ppc/platforms/dbox2.h
+ *
+ * Copyright (c) 2001-2002 Florian Schirmer <jolt@tuxbox.org>
+ *
+ */
+
+#ifndef _PPC_PLATFORMS_DBOX2_H
+#define _PPC_PLATFORMS_DBOX2_H
+
+#include <asm/ppcboot.h>
+
+/* physical base address of IMMR area */
+#define IMAP_ADDR	0xFF000000
+/* mapped size of IMMR area */
+#define IMAP_SIZE	(64 * 1024)
+
+#define PA_ENET_RXD	((u16)0x0004)
+#define PA_ENET_TXD	((u16)0x0008)
+#define PA_ENET_RCLK	((u16)0x0200)
+#define PA_ENET_TCLK	((u16)0x0800)
+#define PC_ENET_TENA	((u16)0x0002)
+#define PC_ENET_CLSN	((u16)0x0040)
+#define PC_ENET_RENA	((u16)0x0080)
+
+#define SICR_ENET_MASK	((u32)0x0000ff00)
+#define SICR_ENET_CLKRT	((u32)0x00003d00)
+
+#endif /* _PPC_PLATFORMS_DBOX2_H */
diff --git a/arch/ppc/syslib/m8xx_setup.c b/arch/ppc/syslib/m8xx_setup.c
index 9caf850..ba006fc 100644
--- a/arch/ppc/syslib/m8xx_setup.c
+++ b/arch/ppc/syslib/m8xx_setup.c
@@ -60,7 +60,7 @@
 #define MPC8xxADS_U_BOOT_SIZE          0x80000
 #define MPC8xxADS_FREE_AREA_OFFSET     MPC8xxADS_U_BOOT_SIZE
 
-#if defined(CONFIG_MTD_PARTITIONS)
+#if defined(CONFIG_MTD_PARTITIONS) && !defined(CONFIG_DBOX2)
  /*
    NOTE: bank width and interleave relative to the installed flash
    should have been chosen within MTD_CFI_GEOMETRY options.
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index cc6c734..d4c355f 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -614,5 +614,8 @@ config MTD_PLATRAM
 
 	  This selection automatically selects the map_ram driver.
 
-endmenu
+config MTD_DBOX2
+	tristate "Map driver for the dbox2"
+	depends on DBOX2
 
+endmenu
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 5216c11..c907e8e 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -459,6 +459,16 @@ config FB_OF
 	  Say Y if you want support with Open Firmware for your graphics
 	  board.
 
+config FB_DBOX2
+	bool "Framebuffer generic functions (for dbox2)"
+	depends on FB && PPC
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Say Y here to include the generic functions necessary for
+	  building the (external) dbox2 driver
+
 config FB_CONTROL
 	bool "Apple \"control\" display support"
 	depends on (FB = y) && PPC_PMAC && PPC32
diff --git a/include/asm-ppc/mpc8xx.h b/include/asm-ppc/mpc8xx.h
index d3a2f2f..a3e0e2c 100644
--- a/include/asm-ppc/mpc8xx.h
+++ b/include/asm-ppc/mpc8xx.h
@@ -31,6 +31,10 @@
 #include <platforms/rpxclassic.h>
 #endif
 
+#ifdef CONFIG_DBOX2
+#include <platforms/dbox2.h>
+#endif
+
 #if defined(CONFIG_TQM8xxL)
 #include <platforms/tqm8xx.h>
 #endif
diff --git a/include/asm-ppc/pgtable.h b/include/asm-ppc/pgtable.h
index c159315..baf4942 100644
--- a/include/asm-ppc/pgtable.h
+++ b/include/asm-ppc/pgtable.h
@@ -754,11 +754,23 @@ extern void paging_init(void);
  * must not include the _PAGE_PRESENT bit, the _PAGE_FILE bit, or the
  *_PAGE_HASHPTE bit (if used).  -- paulus
  */
+#if (CONFIG_8xx)
+/* usually:
+   24 bits offset, 5 bits type, 3 bits flags 
+      so enough for 64 GiByte
+   as a quick and dirty workaround we reduce this to:
+   19 bits offset, 5 bits type, 8 bits flags
+      so enough for 2 GiByte
+*/
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 8 })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val << 8 })
+#else
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 3 })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val << 3 })
+#endif
 #define __swp_type(entry)		((entry).val & 0x1f)
 #define __swp_offset(entry)		((entry).val >> 5)
 #define __swp_entry(type, offset)	((swp_entry_t) { (type) | ((offset) << 5) })
-#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 3 })
-#define __swp_entry_to_pte(x)		((pte_t) { (x).val << 3 })
 
 /* Encode and decode a nonlinear file mapping entry */
 #define PTE_FILE_MAX_BITS	29
