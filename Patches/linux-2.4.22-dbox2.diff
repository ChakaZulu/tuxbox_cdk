diff -Naur linux-2.4.22.orig/Makefile linux-2.4.22.patched/Makefile
--- linux-2.4.22.orig/Makefile	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22.patched/Makefile	2004-02-15 16:40:28.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 22
-EXTRAVERSION =
+EXTRAVERSION = -dbox2
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -Naur linux-2.4.22.orig/arch/ppc/8xx_io/enet.c linux-2.4.22.patched/arch/ppc/8xx_io/enet.c
--- linux-2.4.22.orig/arch/ppc/8xx_io/enet.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/8xx_io/enet.c	2004-02-15 16:40:50.000000000 +0100
@@ -14,13 +14,6 @@
  * Buffer descriptors are kept in the CPM dual port RAM, and the frame
  * buffers are in the host memory.
  *
- * Right now, I am very watseful with the buffers.  I allocate memory
- * pages and then divide them into 2K frame buffers.  This way I know I
- * have buffers large enough to hold one frame within one buffer descriptor.
- * Once I get this working, I will use 64 or 128 byte CPM buffers, which
- * will be much more memory efficient and will easily handle lots of
- * small packets.
- *
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -56,11 +49,7 @@
  *
  * The buffer descriptors are allocated from the CPM dual port memory
  * with the data buffers allocated from host memory, just like all other
- * serial communication protocols.  The host memory buffers are allocated
- * from the free page pool, and then divided into smaller receive and
- * transmit buffers.  The size of the buffers should be a power of two,
- * since that nicely divides the page.  This creates a ring buffer
- * structure similar to the LANCE and other controllers.
+ * serial communication protocols.
  *
  * Like the LANCE driver:
  * The driver runs as two independent, single-threaded flows of control.  One
@@ -92,22 +81,17 @@
  * pool.  The code may assume these are power of two, so it is best
  * to keep them that size.
  * We don't need to allocate pages for the transmitter.  We just use
- * the skbuffer directly.
+ * the skbuffer directly. Receiving data works by swapping skbuffers.
  */
 #ifdef CONFIG_ENET_BIG_BUFFERS
-#define CPM_ENET_RX_PAGES	32
-#define CPM_ENET_RX_FRSIZE	2048
-#define CPM_ENET_RX_FRPPG	(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
+#define RX_RING_SIZE		64
 #define TX_RING_SIZE		64	/* Must be power of two */
 #define TX_RING_MOD_MASK	63	/*   for this to work */
 #else
-#define CPM_ENET_RX_PAGES	4
-#define CPM_ENET_RX_FRSIZE	2048
-#define CPM_ENET_RX_FRPPG	(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
-#define TX_RING_SIZE		8	/* Must be power of two */
-#define TX_RING_MOD_MASK	7	/*   for this to work */
+#define RX_RING_SIZE		8	/* Must be power of two */
+#define RX_RING_MOD_MASK	7	/*   for this to work */
+#define TX_RING_SIZE		32	/* Must be power of two */
+#define TX_RING_MOD_MASK	31	/*   for this to work */
 #endif
 
 /* The CPM stores dest/src/type, data, and checksum for receive packets.
@@ -129,6 +113,8 @@
 	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
 	ushort	skb_cur;
 	ushort	skb_dirty;
+	struct	sk_buff* rx_skbuff[RX_RING_SIZE];
+	ushort	skb_cur_rx;
 
 	/* CPM dual port RAM relative addresses.
 	*/
@@ -148,6 +134,9 @@
 static int scc_enet_close(struct net_device *dev);
 static struct net_device_stats *scc_enet_get_stats(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
+int scc_enet_multiple_xmit(struct net_device *dev,unsigned count, unsigned first,
+	unsigned first_len, unsigned second, unsigned second_len, unsigned third,
+	unsigned third_len);
 
 /* Get this from various configuration locations (depends on board).
 */
@@ -194,18 +183,21 @@
 	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
 	volatile cbd_t	*bdp;
 
+	/* Push the data cache so the CPM does not get stale memory
+	 * data.
+	 */
+	flush_dcache_range((unsigned long)(skb->data),
+					(unsigned long)(skb->data + skb->len));
+
+	spin_lock_irq(&cep->lock);
+
 	/* Fill in a Tx ring entry */
 	bdp = cep->cur_tx;
 
-#ifndef final_version
 	if (!cep->tx_free || (bdp->cbd_sc & BD_ENET_TX_READY)) {
-		/* Ooops.  All transmit buffers are full.  Bail out.
-		 * This should not happen, since the tx queue should be stopped.
-		 */
-		printk("%s: tx queue full!.\n", dev->name);
+		spin_unlock_irq(&cep->lock);
 		return 1;
 	}
-#endif
 
 	/* Clear all of the status flags.
 	 */
@@ -230,14 +222,6 @@
 	cep->stats.tx_bytes += skb->len;
 	cep->skb_cur = (cep->skb_cur+1) & TX_RING_MOD_MASK;
 
-	/* Push the data cache so the CPM does not get stale memory
-	 * data.
-	 */
-	flush_dcache_range((unsigned long)(skb->data),
-					(unsigned long)(skb->data + skb->len));
-
-	spin_lock_irq(&cep->lock);
-
 	/* Send it on its way.  Tell CPM its ready, interrupt when done,
 	 * its the last BD of the frame, and to put the CRC on the end.
 	 */
@@ -262,29 +246,133 @@
 	return 0;
 }
 
+/*
+ * Transmits up to 3 memory locations. This 3 locations must be cache-flushed
+ * before this function is invoked. The memory won't be freed after
+ * transmission. The function takes physical addresses!
+ */
+
+int scc_enet_multiple_xmit(struct net_device *dev,unsigned count, unsigned first,
+	unsigned first_len, unsigned second, unsigned second_len, unsigned third,
+	unsigned third_len)
+{
+	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
+	volatile cbd_t	*bdp,*first_bdp;
+	unsigned pad = 0;
+
+	/* nothing to send ? */
+	if (!count)
+		return 0;
+
+	spin_lock_irq(&cep->lock);
+
+	/* not enough free descriptors? */
+	if (cep->tx_free < count)
+	{
+		spin_unlock_irq(&cep->lock);
+		return 1;
+	}
+
+	bdp = cep->cur_tx;
+	first_bdp = bdp;
+
+	if (first_len + second_len + third_len < ETH_ZLEN)
+	{
+		pad = BD_ENET_TX_PAD;
+	}
+
+	/* setup first descriptor */
+
+	cep->tx_skbuff[cep->skb_cur] = NULL;
+	bdp->cbd_datlen = first_len;
+	bdp->cbd_bufaddr = first;
+	cep->tx_free--;
+	cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+
+	/* setup second descriptor */
+	if (count > 1)
+	{
+		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+		{
+			bdp = cep->tx_bd_base;
+		}
+		else
+		{
+			bdp++;
+		}
+		cep->tx_skbuff[cep->skb_cur] = NULL;
+		bdp->cbd_datlen = second_len;
+		bdp->cbd_bufaddr = second;
+		cep->tx_free--;
+		cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+
+		if (count > 2)
+		{
+			bdp->cbd_sc = (bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY;
+			if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+			{
+				bdp = cep->tx_bd_base;
+			}
+			else
+			{
+				bdp++;
+			}
+			cep->tx_skbuff[cep->skb_cur] = NULL;
+			bdp->cbd_datlen = third_len;
+			bdp->cbd_bufaddr = third;
+			cep->tx_free--;
+			cep->skb_cur = (cep->skb_cur + 1) & TX_RING_MOD_MASK;
+		}
+	}
+	bdp->cbd_sc = (bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY |
+	BD_ENET_TX_INTR | BD_ENET_TX_LAST | BD_ENET_TX_TC | pad;
+	if (count > 1)
+	{
+		first_bdp->cbd_sc = (first_bdp->cbd_sc & BD_ENET_TX_WRAP) | BD_ENET_TX_READY;
+	}
+
+	if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+	{
+		bdp = cep->tx_bd_base;
+	}
+	else
+	{
+		bdp++;
+	}
+
+	if (!cep->tx_free)
+		netif_stop_queue(dev);
+
+	cep->cur_tx = (cbd_t *) bdp;
+
+	spin_unlock_irq(&cep->lock);
+
+	return 0;
+}
+
 static void
 scc_enet_timeout(struct net_device *dev)
 {
 	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
 
-	printk("%s: transmit timed out.\n", dev->name);
+	printk(KERN_ERR "%s: transmit timed out.\n", dev->name);
 	cep->stats.tx_errors++;
 #ifndef final_version
 	{
 		int	i;
 		cbd_t	*bdp;
-		printk(" Ring data dump: cur_tx %p tx_free %d cur_rx %p.\n",
+		printk(KERN_DEBUG " Ring data dump: cur_tx %p tx_free %d cur_rx %p.\n",
 		       cep->cur_tx, cep->tx_free,
 		       cep->cur_rx);
 		bdp = cep->tx_bd_base;
 		for (i = 0 ; i < TX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
+			printk(KERN_DEBUG "%04x %04x %08x\n",
 			       bdp->cbd_sc,
 			       bdp->cbd_datlen,
 			       bdp->cbd_bufaddr);
 		bdp = cep->rx_bd_base;
 		for (i = 0 ; i < RX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
+			printk(KERN_DEBUG "%04x %04x %08x\n",
 			       bdp->cbd_sc,
 			       bdp->cbd_datlen,
 			       bdp->cbd_bufaddr);
@@ -368,7 +456,9 @@
 
 		/* Free the sk buffer associated with this last transmit.
 		*/
-		dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+		if (cep->tx_skbuff[cep->skb_dirty])
+			dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+
 		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
 
 		/* Update pointer to next buffer descriptor to be transmitted.
@@ -434,8 +524,9 @@
 {
 	struct	scc_enet_private *cep;
 	volatile cbd_t	*bdp;
-	struct	sk_buff *skb;
+	struct	sk_buff *skb,*rx_skb;
 	ushort	pkt_len;
+	ushort	skb_cur_rx;
 
 	cep = (struct scc_enet_private *)dev->priv;
 
@@ -443,6 +534,7 @@
 	 * These get messed up if we get called due to a busy condition.
 	 */
 	bdp = cep->cur_rx;
+	skb_cur_rx = cep->skb_cur_rx;
 
 for (;;) {
 	if (bdp->cbd_sc & BD_ENET_RX_EMPTY)
@@ -454,7 +546,7 @@
 	 */
 	if ((bdp->cbd_sc & (BD_ENET_RX_FIRST | BD_ENET_RX_LAST)) !=
 		(BD_ENET_RX_FIRST | BD_ENET_RX_LAST))
-			printk("CPM ENET: rcv is not first+last\n");
+			printk(KERN_CRIT "CPM ENET: rcv is not first+last\n");
 #endif
 
 	/* Frame too long or too short.
@@ -481,47 +573,55 @@
 		*/
 		cep->stats.rx_packets++;
 		pkt_len = bdp->cbd_datlen;
-		cep->stats.rx_bytes += pkt_len;
+		cep->stats.rx_bytes += pkt_len - 4;
 
-		/* This does 16 byte alignment, much more than we need.
-		 * The packet length includes FCS, but we don't want to
-		 * include that when passing upstream as it messes up
-		 * bridging applications.
-		 */
-		skb = dev_alloc_skb(pkt_len-4);
+		/* Allocate a new skb
+		*/
 
-		if (skb == NULL) {
-			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+		if ( (skb = dev_alloc_skb(PKT_MAXBLR_SIZE)) == NULL)
+		{
+			printk(KERN_ERR "%s: Memory squeeze, dropping packet.\n",dev->name);
 			cep->stats.rx_dropped++;
 		}
-		else {
+		else
+		{
+		/* swap new and filled skb
+		*/
 			skb->dev = dev;
-			skb_put(skb,pkt_len-4);	/* Make room */
-			eth_copy_and_sum(skb,
-				(unsigned char *)__va(bdp->cbd_bufaddr),
-				pkt_len-4, 0);
-			skb->protocol=eth_type_trans(skb,dev);
-			netif_rx(skb);
+			/* invalidate data cache to prevent memory-modification in
+			 * write-back-mode and to get the real data on the next read
+			 */
+			invalidate_dcache_range((unsigned long) skb->data,(unsigned long) skb->data + PKT_MAXBLR_SIZE - 1);
+			rx_skb = cep->rx_skbuff[skb_cur_rx];
+			cep->rx_skbuff[skb_cur_rx] = skb;
+			bdp->cbd_bufaddr = __pa(skb->data);
+
+			/* Don't include FCS as it messes up bridging applications */
+			skb_put(rx_skb,pkt_len-4);
+			rx_skb->protocol=eth_type_trans(rx_skb,dev);
+			netif_rx(rx_skb);
 		}
 	}
 
-	/* Clear the status flags for this buffer.
-	*/
-	bdp->cbd_sc &= ~BD_ENET_RX_STATS;
-
-	/* Mark the buffer empty.
+	/* Clear the status flags for this buffer and mark the buffer empty.
 	*/
-	bdp->cbd_sc |= BD_ENET_RX_EMPTY;
+	bdp->cbd_sc = (bdp->cbd_sc & ~BD_ENET_RX_STATS) | BD_ENET_RX_EMPTY;
 
 	/* Update BD pointer to next entry.
 	*/
-	if (bdp->cbd_sc & BD_ENET_RX_WRAP)
+	if (bdp->cbd_sc & BD_ENET_RX_WRAP) {
 		bdp = cep->rx_bd_base;
+		skb_cur_rx = 0;
+	}
 	else
+	{
 		bdp++;
+		skb_cur_rx++;
+	}
 
    }
 	cep->cur_rx = (cbd_t *)bdp;
+	cep->skb_cur_rx = skb_cur_rx;
 
 	return 0;
 }
@@ -569,7 +669,7 @@
 	if (dev->flags&IFF_PROMISC) {
 
 		/* Log any net taps. */
-		printk("%s: Promiscuous mode enabled.\n", dev->name);
+		printk(KERN_INFO "%s: Promiscuous mode enabled.\n", dev->name);
 		cep->sccp->scc_pmsr |= SCC_PMSR_PRO;
 	} else {
 
@@ -632,10 +732,8 @@
 {
 	struct net_device *dev;
 	struct scc_enet_private *cep;
-	int i, j;
+	int i;
 	unsigned char	*eap;
-	unsigned long	mem_addr;
-	pte_t		*pte;
 	bd_t		*bd;
 	volatile	cbd_t		*bdp;
 	volatile	cpm8xx_t	*cp;
@@ -745,6 +843,7 @@
 	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
 	cep->tx_free = TX_RING_SIZE;
 	cep->cur_rx = cep->rx_bd_base;
+	cep->skb_cur_rx = 0;
 
 	/* Issue init Rx BD command for SCC.
 	 * Manual says to perform an Init Rx parameters here.  We have
@@ -825,27 +924,21 @@
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
-	bdp = cep->rx_bd_base;
-	for (i=0; i<CPM_ENET_RX_PAGES; i++) {
-
-		/* Allocate a page.
-		*/
-		mem_addr = __get_free_page(GFP_KERNEL);
+	/* Allocate skbs for receive-buffers */
 
-		/* Make it uncached.
-		*/
-		pte = va_to_pte(mem_addr);
-		pte_val(*pte) |= _PAGE_NO_CACHE;
-		flush_tlb_page(init_mm.mmap, mem_addr);
+	bdp = cep->rx_bd_base;
 
-		/* Initialize the BD for every fragment in the page.
-		*/
-		for (j=0; j<CPM_ENET_RX_FRPPG; j++) {
-			bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
-			bdp->cbd_bufaddr = __pa(mem_addr);
-			mem_addr += CPM_ENET_RX_FRSIZE;
-			bdp++;
-		}
+	for (i=0; i<RX_RING_SIZE; i++) {
+		cep->rx_skbuff[i] = dev_alloc_skb(PKT_MAXBLR_SIZE);
+		cep->rx_skbuff[i]->dev = dev;
+		/* invalidate data cache to prevent memory-modification in
+		 * write-back-mode and to get the real data on the next read
+		 */
+		invalidate_dcache_range((unsigned long) cep->rx_skbuff[i]->data,
+			(unsigned long) cep->rx_skbuff[i]->data + PKT_MAXBLR_SIZE - 1);
+		bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
+		bdp->cbd_bufaddr = __pa(cep->rx_skbuff[i]->data);
+		bdp++;
 	}
 
 	/* Set the last buffer to wrap.
@@ -953,7 +1046,7 @@
 	*/
 	sccp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
 
-	printk("%s: CPM ENET Version 0.2 on SCC%d, ", dev->name, SCC_ENET+1);
+	printk(KERN_INFO "%s: CPM ENET Version 0.2.dbox2 on SCC%d at %p, ", dev->name, SCC_ENET+1,dev);
 	for (i=0; i<5; i++)
 		printk("%02x:", dev->dev_addr[i]);
 	printk("%02x\n", dev->dev_addr[5]);
diff -Naur linux-2.4.22.orig/arch/ppc/Makefile linux-2.4.22.patched/arch/ppc/Makefile
--- linux-2.4.22.orig/arch/ppc/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/Makefile	2004-02-15 16:40:28.000000000 +0100
@@ -30,7 +30,11 @@
 endif
 
 ifdef CONFIG_8xx
-CFLAGS := $(CFLAGS) -mcpu=860
+  ifdef CONFIG_DBOX2
+    CFLAGS := $(CFLAGS) -mcpu=823
+  else
+    CFLAGS := $(CFLAGS) -mcpu=860
+  endif
 endif
 
 ifdef CONFIG_PPC64BRIDGE
diff -Naur linux-2.4.22.orig/arch/ppc/boot/simple/embed_config.c linux-2.4.22.patched/arch/ppc/boot/simple/embed_config.c
--- linux-2.4.22.orig/arch/ppc/boot/simple/embed_config.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/boot/simple/embed_config.c	2004-02-15 16:40:28.000000000 +0100
@@ -755,3 +755,11 @@
 }
 #endif
 
+#ifdef CONFIG_DBOX2
+/* dbox2
+ * doesn't do anything right now */
+void
+embed_config(bd_t **bdp)
+{
+}
+#endif
diff -Naur linux-2.4.22.orig/arch/ppc/config.in linux-2.4.22.patched/arch/ppc/config.in
--- linux-2.4.22.orig/arch/ppc/config.in	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/config.in	2004-02-15 16:40:28.000000000 +0100
@@ -73,6 +73,7 @@
 	 RPX-Classic	CONFIG_RPXCLASSIC	\
 	 BSE-IP		CONFIG_BSEIP		\
 	 FADS		CONFIG_FADS		\
+	 D-BOX2		CONFIG_DBOX2		\
 	 TQM823L	CONFIG_TQM823L		\
 	 TQM850L	CONFIG_TQM850L		\
 	 TQM855L	CONFIG_TQM855L		\
diff -Naur linux-2.4.22.orig/arch/ppc/kernel/irq.c linux-2.4.22.patched/arch/ppc/kernel/irq.c
--- linux-2.4.22.orig/arch/ppc/kernel/irq.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/kernel/irq.c	2004-02-15 16:40:28.000000000 +0100
@@ -507,6 +507,14 @@
 		else if (irq_desc[irq].handler->enable)
 			irq_desc[irq].handler->enable(irq);
 	}
+	
+#ifdef CONFIG_DBOX2
+	if (action) {
+	    if (action->flags & SA_ONESHOT)
+		disable_irq_nosync(irq);
+	}
+#endif
+
 	spin_unlock(&desc->lock);
 }
 
diff -Naur linux-2.4.22.orig/arch/ppc/kernel/m8xx_setup.c linux-2.4.22.patched/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.22.orig/arch/ppc/kernel/m8xx_setup.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/kernel/m8xx_setup.c	2004-02-15 16:40:28.000000000 +0100
@@ -117,6 +117,22 @@
 	printk ("timebase_interrupt()\n");
 }
 
+#ifdef CONFIG_DBOX2
+void m8xx_reset_watchdog(void)
+{
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0x556c;             /* write magic1 */
+	((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_swsr = 0xaa39;             /* write magic2 */
+}
+
+void pit_interrupt(int irq, void * dev, struct pt_regs * regs)
+{
+	m8xx_reset_watchdog();
+
+	// Clear irq
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr |= PISCR_PS;
+}
+#endif
+
 /* The decrementer counts at the system (internal) clock frequency divided by
  * sixteen, or external oscillator divided by four.  We force the processor
  * to use system clock divided by sixteen.
@@ -126,6 +142,11 @@
 	bd_t	*binfo = (bd_t *)__res;
 	int freq, fp, divisor;
 
+#ifdef CONFIG_DBOX2
+	unsigned long sypcr;
+	unsigned short pitc, swtc, swp;
+#endif	
+
 	/* Unlock the SCCR. */
 	((volatile immap_t *)IMAP_ADDR)->im_clkrstk.cark_sccrk = ~KAPWR_KEY;
 	((volatile immap_t *)IMAP_ADDR)->im_clkrstk.cark_sccrk = KAPWR_KEY;
@@ -133,6 +154,18 @@
 	/* Force all 8xx processors to use divide by 16 processor clock. */
 	((volatile immap_t *)IMAP_ADDR)->im_clkrst.car_sccr |= 0x02000000;
 
+#ifdef CONFIG_DBOX2
+	if ((binfo->bi_intfreq < 1000000) || (binfo->bi_busfreq < 1000000)) {
+	    printk("WARNING: Frequency is not in HZ. Please consider using a newer bootloader!\n");
+	    printk("WARNING: OLD intfreq = %d busfreq = %d\n", binfo->bi_intfreq, binfo->bi_busfreq);
+
+	    binfo->bi_intfreq *= 1000000;
+	    binfo->bi_busfreq *= 1000000;
+
+	    printk("WARNING: NEW intfreq = %d busfreq = %d\n", binfo->bi_intfreq, binfo->bi_busfreq);
+	}
+#endif
+
 	/* Processor frequency is MHz.
 	 * The value 'fp' is the number of decrementer ticks per second.
 	 */
@@ -184,6 +217,41 @@
 	if (request_irq(DEC_INTERRUPT, timebase_interrupt, 0, "tbint",
 				NULL) != 0)
 		panic("Could not allocate timer IRQ!");
+
+#ifdef CONFIG_DBOX2
+	sypcr = ((volatile immap_t *)IMAP_ADDR)->im_siu_conf.sc_sypcr;
+
+	if ((sypcr >> 2) & 0x1) {
+	    m8xx_reset_watchdog();
+	
+	    if (sypcr >> 16)
+		swtc = sypcr >> 16;
+	    else	
+		swtc = 0xFFFF;
+
+	    if (sypcr & 0x1)
+		swp = 2048;
+	    else
+		swp = 1;
+
+#define PITRTCLK 8192
+
+	    // Fire trigger if half of the wdt ticked down		
+	    if ((swp * swtc) > (UINT_MAX / PITRTCLK))
+		pitc = swtc * swp / binfo->bi_intfreq * PITRTCLK / 2;
+	    else
+		pitc = PITRTCLK * swtc * swp / binfo->bi_intfreq / 2;
+	    
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_pitc = pitc << 16;
+	    ((volatile immap_t *)IMAP_ADDR)->im_sit.sit_piscr = (mk_int_int_mask(PIT_INTERRUPT) << 8) | PISCR_PIE | PISCR_PTE;
+	
+	    if (request_8xxirq(PIT_INTERRUPT, pit_interrupt, 0, "pit", NULL) != 0)
+		    panic("mpc8xx-wdt: could not allocate pit irq!");
+
+	    printk(KERN_INFO "mpc8xx-wdt: active wdt found (SWTC: 0x%04X, SWP: 0x%01X)\n", sypcr >> 16, sypcr & 0x1);
+	    printk(KERN_INFO "mpc8xx-wdt: keep-alive trigger activated (PITC: 0x%04X)\n", pitc);
+	}
+#endif
 }
 
 /* The RTC on the MPC8xx is an internal register.
diff -Naur linux-2.4.22.orig/arch/ppc/kernel/ppc_ksyms.c linux-2.4.22.patched/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.4.22.orig/arch/ppc/kernel/ppc_ksyms.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/kernel/ppc_ksyms.c	2004-02-15 16:41:06.000000000 +0100
@@ -343,6 +343,13 @@
 EXPORT_SYMBOL(cpm_install_handler);
 EXPORT_SYMBOL(cpm_free_handler);
 EXPORT_SYMBOL(m8xx_cpm_hostalloc);
+#ifdef CONFIG_DBOX2
+EXPORT_SYMBOL(m8xx_cpm_setbrg);
+EXPORT_SYMBOL(m8xx_cpm_dpalloc);
+extern int scc_enet_multiple_xmit(struct net_device *, unsigned, unsigned, 
+	unsigned, unsigned, unsigned, unsigned, unsigned);
+EXPORT_SYMBOL(scc_enet_multiple_xmit);
+#endif /* CONFIG_DBOX2 */
 #endif /* CONFIG_8xx */
 
 /* Those should really be inline */
diff -Naur linux-2.4.22.orig/arch/ppc/kernel/time.c linux-2.4.22.patched/arch/ppc/kernel/time.c
--- linux-2.4.22.orig/arch/ppc/kernel/time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22.patched/arch/ppc/kernel/time.c	2004-02-15 16:40:28.000000000 +0100
@@ -71,6 +71,10 @@
 
 extern int do_sys_settimeofday(struct timeval *tv, struct timezone *tz);
 
+#ifdef CONFIG_DBOX2
+extern void m8xx_reset_watchdog(void);
+#endif
+
 /* keep track of when we need to update the rtc */
 time_t last_rtc_update;
 extern rwlock_t xtime_lock;
@@ -320,6 +324,9 @@
 		sec = ppc_md.get_rtc_time();
 		elapsed = 0;
 		do {
+#ifdef CONFIG_DBOX2
+			m8xx_reset_watchdog();
+#endif
 			old_stamp = stamp;
 			old_sec = sec;
 			stamp = get_native_tbl();
diff -Naur linux-2.4.22.orig/arch/ppc/platforms/dbox2.h linux-2.4.22.patched/arch/ppc/platforms/dbox2.h
--- linux-2.4.22.orig/arch/ppc/platforms/dbox2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22.patched/arch/ppc/platforms/dbox2.h	2004-02-15 16:40:28.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * D-BOX2 board specific definitions
+ * 
+ * Copyright (c) 2001-2002 Florian Schirmer (jolt@tuxbox.org)
+ */
+
+#ifndef __MACH_DBOX2_H
+#define __MACH_DBOX2_H
+
+#include <linux/config.h>
+ 
+#include <asm/ppcboot.h>
+
+#define	DBOX2_IMMR_BASE	0xFF000000	/* phys. addr of IMMR */
+#define	DBOX2_IMAP_SIZE	(64 * 1024)	/* size of mapped area */
+
+#define	IMAP_ADDR	DBOX2_IMMR_BASE	/* physical base address of IMMR area */
+#define IMAP_SIZE	DBOX2_IMAP_SIZE	/* mapped size of IMMR area */
+
+/* We don't use the 8259.
+*/
+#define NR_8259_INTS	0
+
+#endif	/* __MACH_DBOX2_H */
diff -Naur linux-2.4.22.orig/drivers/char/console.c linux-2.4.22.patched/drivers/char/console.c
--- linux-2.4.22.orig/drivers/char/console.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.22.patched/drivers/char/console.c	2004-02-15 16:40:28.000000000 +0100
@@ -110,7 +110,11 @@
 #include "console_macros.h"
 
 
-const struct consw *conswitchp;
+#ifdef CONFIG_DUMMY_CONSOLE
+const struct consw *conswitchp = &dummy_con;
+#else
+const struct consw *conswitchp = 0;
+#endif
 
 /* A bitmap for codes <32. A bit of 1 indicates that the code
  * corresponding to that bit number invokes some special action
diff -Naur linux-2.4.22.orig/drivers/char/vt.c linux-2.4.22.patched/drivers/char/vt.c
--- linux-2.4.22.orig/drivers/char/vt.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.22.patched/drivers/char/vt.c	2004-02-15 16:40:28.000000000 +0100
@@ -93,7 +93,8 @@
 #if defined(__i386__) || defined(__alpha__) || defined(CONFIG_PPC_ISATIMER) \
     || (defined(__mips__) && defined(CONFIG_ISA)) \
     || (defined(__arm__) && defined(CONFIG_HOST_FOOTBRIDGE)) \
-    || defined(__x86_64__)
+    || defined(__x86_64__) \
+    || (defined(__powerpc__) && !defined(CONFIG_DBOX2))
 
 static void
 kd_nosound(unsigned long ignored)
diff -Naur linux-2.4.22.orig/drivers/input/keybdev.c linux-2.4.22.patched/drivers/input/keybdev.c
--- linux-2.4.22.orig/drivers/input/keybdev.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22.patched/drivers/input/keybdev.c	2004-02-15 16:40:28.000000000 +0100
@@ -108,7 +108,11 @@
 #endif	/* CONFIG_MAC_ADBKEYCODES || CONFIG_ADB_KEYBOARD */
 
 	if (keycode > 255 || !x86_keycodes[keycode])
+#ifdef CONFIG_DBOX2
+		return 0; 
+#else
 		return -1; 
+#endif
 
 	if (keycode == KEY_PAUSE) {
 		handle_scancode(0xe1, 1);
diff -Naur linux-2.4.22.orig/drivers/video/Config.in linux-2.4.22.patched/drivers/video/Config.in
--- linux-2.4.22.orig/drivers/video/Config.in	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22.patched/drivers/video/Config.in	2004-02-15 16:40:28.000000000 +0100
@@ -248,6 +248,7 @@
       tristate '    VGA 16-color planar support' CONFIG_FBCON_VGA_PLANES
       tristate '    VGA characters/attributes support' CONFIG_FBCON_VGA
       tristate '    HGA monochrome support (EXPERIMENTAL)' CONFIG_FBCON_HGA
+      bool '    console shift' CONFIG_FBCON_SHIFT 0
    else
       # Guess what we need
       if [ "$CONFIG_FB_ACORN" = "y" -o "$CONFIG_FB_AMIGA" = "y" -o \
diff -Naur linux-2.4.22.orig/drivers/video/fbcon-cfb16.c linux-2.4.22.patched/drivers/video/fbcon-cfb16.c
--- linux-2.4.22.orig/drivers/video/fbcon-cfb16.c	2001-10-15 22:47:13.000000000 +0200
+++ linux-2.4.22.patched/drivers/video/fbcon-cfb16.c	2004-02-15 16:40:28.000000000 +0100
@@ -46,6 +46,12 @@
     int bytes = p->next_line, linesize = bytes * fontheight(p), rows;
     u8 *src, *dst;
 
+#ifdef CONFIG_FBCON_SHIFT
+    width += p->shift_x;
+    dy += p->shift_y;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     if (sx == 0 && dx == 0 && width * fontwidth(p) * 2 == bytes) {
 	fb_memmove(p->screen_base + dy * linesize,
 		  p->screen_base + sy * linesize,
@@ -108,6 +114,11 @@
     int bytes = p->next_line, lines = height * fontheight(p);
     u32 bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    sx += p->shift_x;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + sy * fontheight(p) * bytes + sx * fontwidth(p) * 2;
 
     bgx = ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
@@ -126,6 +137,11 @@
     int bytes = p->next_line, rows;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p) * 2;
 
     fgx = ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
@@ -177,6 +193,11 @@
     int rows, bytes = p->next_line;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest0 = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p) * 2;
     c = scr_readw(s);
     fgx = ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
@@ -233,6 +254,11 @@
     u8 *dest;
     int bytes = p->next_line, rows;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p)*2;
     for (rows = fontheight(p); rows--; dest += bytes) {
 	switch (fontwidth(p)) {
@@ -261,18 +287,31 @@
     int bytes = p->next_line;
     u32 bgx;
 
+#ifndef CONFIG_FBCON_SHIFT
     unsigned int right_start = conp->vc_cols*fontwidth(p);
     unsigned int bottom_start = conp->vc_rows*fontheight(p);
     unsigned int right_width, bottom_width;
+#endif /* CONFIG_FBCON_SHIFT */
 
     bgx = ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
 
+#ifndef CONFIG_FBCON_SHIFT
     if (!bottom_only && (right_width = p->var.xres-right_start))
 	rectfill(p->screen_base+right_start*2, right_width,
 		 p->var.yres_virtual, bgx, bytes);
     if ((bottom_width = p->var.yres-bottom_start))
 	rectfill(p->screen_base+(p->var.yoffset+bottom_start)*bytes,
 		 right_start, bottom_width, bgx, bytes);
+#else /* CONFIG_FBCON_SHIFT */
+    rectfill(p->screen_base, p->var.xres_virtual,
+	     p->shift_y*fontheight(p), bgx, bytes);
+    rectfill(p->screen_base, p->shift_x*fontwidth(p),
+	     p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_cols+p->shift_x)*fontwidth(p)*2, p->shift_x*fontwidth(p),
+	     p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_rows+p->shift_y)*fontheight(p)*bytes, p->var.xres_virtual,
+	     p->shift_y*fontheight(p), bgx, bytes);
+#endif /* CONFIG_FBCON_SHIFT */
 }
 
 
diff -Naur linux-2.4.22.orig/drivers/video/fbcon-cfb8.c linux-2.4.22.patched/drivers/video/fbcon-cfb8.c
--- linux-2.4.22.orig/drivers/video/fbcon-cfb8.c	2001-10-15 22:47:13.000000000 +0200
+++ linux-2.4.22.patched/drivers/video/fbcon-cfb8.c	2004-02-15 16:40:28.000000000 +0100
@@ -51,6 +51,12 @@
     int bytes = p->next_line, linesize = bytes * fontheight(p), rows;
     u8 *src,*dst;
 
+#ifdef CONFIG_FBCON_SHIFT
+    width += p->shift_x;
+    dy += p->shift_y;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     if (sx == 0 && dx == 0 && width * fontwidth(p) == bytes) {
 	fb_memmove(p->screen_base + dy * linesize,
 		  p->screen_base + sy * linesize,
@@ -97,6 +103,11 @@
     int bytes=p->next_line,lines=height * fontheight(p);
     u8 bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    sx += p->shift_x;
+    sy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + sy * fontheight(p) * bytes + sx * fontwidth(p);
 
     bgx=attr_bgcol_ec(p,conp);
@@ -115,6 +126,11 @@
     int bytes=p->next_line,rows;
     u32 eorx,fgx,bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     if (fontwidth(p) <= 8)
 	cdat = p->fontdata + (c & p->charmask) * fontheight(p);
@@ -162,6 +178,11 @@
     int rows,bytes=p->next_line;
     u32 eorx, fgx, bgx;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest0 = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     c = scr_readw(s);
     fgx = attr_fgcol(p, c);
@@ -219,6 +240,11 @@
     u8 *dest;
     int bytes=p->next_line, rows;
 
+#ifdef CONFIG_FBCON_SHIFT
+    xx += p->shift_x;
+    yy += p->shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
+
     dest = p->screen_base + yy * fontheight(p) * bytes + xx * fontwidth(p);
     for (rows = fontheight(p) ; rows-- ; dest += bytes) {
     	switch (fontwidth(p)) {
@@ -237,18 +263,31 @@
     int bytes=p->next_line;
     u8 bgx;
 
+#ifndef CONFIG_FBCON_SHIFT
     unsigned int right_start = conp->vc_cols*fontwidth(p);
     unsigned int bottom_start = conp->vc_rows*fontheight(p);
     unsigned int right_width, bottom_width;
+#endif /* CONFIG_FBCON_SHIFT */
 
     bgx=attr_bgcol_ec(p,conp);
 
+#ifndef CONFIG_FBCON_SHIFT
     if (!bottom_only && (right_width = p->var.xres-right_start))
 	rectfill(p->screen_base+right_start, right_width, p->var.yres_virtual,
 		 bgx, bytes);
     if ((bottom_width = p->var.yres-bottom_start))
 	rectfill(p->screen_base+(p->var.yoffset+bottom_start)*bytes,
 		 right_start, bottom_width, bgx, bytes);
+#else /* CONFIG_FBCON_SHIFT */
+    rectfill(p->screen_base, p->var.xres_virtual,
+             p->shift_y*fontheight(p), bgx, bytes);
+    rectfill(p->screen_base, p->shift_x*fontwidth(p),
+             p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_cols+p->shift_x)*fontwidth(p), p->shift_x*fontwidth(p),
+             p->var.yres_virtual, bgx, bytes);
+    rectfill(p->screen_base+(conp->vc_rows+p->shift_y)*fontheight(p)*bytes, p->var.xres_virtual,
+             p->shift_y*fontheight(p), bgx, bytes);
+#endif /* CONFIG_FBCON_SHIFT */
 }
 
 
diff -Naur linux-2.4.22.orig/drivers/video/fbcon.c linux-2.4.22.patched/drivers/video/fbcon.c
--- linux-2.4.22.orig/drivers/video/fbcon.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22.patched/drivers/video/fbcon.c	2004-02-15 16:40:28.000000000 +0100
@@ -655,8 +655,13 @@
     old_cols = conp->vc_cols;
     old_rows = conp->vc_rows;
     
+#ifdef CONFIG_FBCON_SHIFT
+    nr_cols = p->var.xres/fontwidth(p) - 2*p->shift_x;
+    nr_rows = p->var.yres/fontheight(p) - 2*p->shift_y;
+#else /* CONFIG_FBCON_SHIFT */
     nr_cols = p->var.xres/fontwidth(p);
     nr_rows = p->var.yres/fontheight(p);
+#endif /* CONFIG_FBCON_SHIFT */
     
     if (logo) {
     	/* Need to make room for the logo */
diff -Naur linux-2.4.22.orig/include/asm-ppc/commproc.h linux-2.4.22.patched/include/asm-ppc/commproc.h
--- linux-2.4.22.orig/include/asm-ppc/commproc.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22.patched/include/asm-ppc/commproc.h	2004-02-15 16:40:28.000000000 +0100
@@ -466,6 +466,24 @@
 #define SICR_ENET_CLKRT	((uint)0x0000003d)
 #endif	/* CONFIG_RPXCLASSIC */
 
+/***  D-BOX2  ***********************************************/
+
+#ifdef CONFIG_DBOX2
+
+#define PA_ENET_RXD	((ushort)0x0004)	
+#define PA_ENET_TXD	((ushort)0x0008)	
+#define PA_ENET_RCLK	((ushort)0x0200)	
+#define PA_ENET_TCLK	((ushort)0x0800)	
+
+#define PC_ENET_TENA	((ushort)0x0002)
+
+#define PC_ENET_CLSN	((ushort)0x0040)	
+#define PC_ENET_RENA	((ushort)0x0080)	
+
+#define SICR_ENET_MASK	((uint)0x0000ff00)
+#define SICR_ENET_CLKRT	((uint)0x00003d00)
+#endif	/* CONFIG_DBOX2 */
+
 /***  TQM823L, TQM850L  ***********************************************/
 
 #if defined(CONFIG_TQM823L) || defined(CONFIG_TQM850L)
diff -Naur linux-2.4.22.orig/include/asm-ppc/mpc8xx.h linux-2.4.22.patched/include/asm-ppc/mpc8xx.h
--- linux-2.4.22.orig/include/asm-ppc/mpc8xx.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22.patched/include/asm-ppc/mpc8xx.h	2004-02-15 16:40:28.000000000 +0100
@@ -32,6 +32,10 @@
 #include <platforms/rpxclassic.h>
 #endif
 
+#ifdef CONFIG_DBOX2
+#include <platforms/dbox2.h>
+#endif
+
 #if defined(CONFIG_TQM8xxL)
 #include <platforms/tqm8xx.h>
 #endif
diff -Naur linux-2.4.22.orig/include/linux/fb.h linux-2.4.22.patched/include/linux/fb.h
--- linux-2.4.22.orig/include/linux/fb.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22.patched/include/linux/fb.h	2004-02-15 16:40:28.000000000 +0100
@@ -108,6 +108,9 @@
 #define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
 #define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
 
+#define FB_ACCEL_CCUBE_AVIA_GTX	120	/* C-Cube AViA GTX		*/
+#define FB_ACCEL_CCUBE_AVIA_ENX	121	/* C-Cube AViA eNX		*/
+
 
 struct fb_fix_screeninfo {
 	char id[16];			/* identification string eg "TT Builtin" */
diff -Naur linux-2.4.22.orig/include/linux/input.h linux-2.4.22.patched/include/linux/input.h
--- linux-2.4.22.orig/include/linux/input.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22.patched/include/linux/input.h	2004-02-15 16:40:28.000000000 +0100
@@ -310,6 +310,77 @@
 #define KEY_BRIGHTNESSDOWN	224
 #define KEY_BRIGHTNESSUP	225
 
+#define KEY_OK           0x160
+#define KEY_SELECT       0x161
+#define KEY_GOTO         0x162
+#define KEY_CLEAR        0x163
+#define KEY_POWER2       0x164
+#define KEY_OPTION       0x165
+#define KEY_INFO         0x166
+#define KEY_TIME         0x167
+#define KEY_VENDOR       0x168
+#define KEY_ARCHIVE      0x169
+#define KEY_PROGRAM      0x16a
+#define KEY_CHANNEL      0x16b
+#define KEY_FAVORITES    0x16c
+#define KEY_EPG          0x16d
+#define KEY_PVR          0x16e
+#define KEY_MHP          0x16f
+#define KEY_LANGUAGE     0x170
+#define KEY_TITLE        0x171
+#define KEY_SUBTITLE     0x172
+#define KEY_ANGLE        0x173
+#define KEY_ZOOM         0x174
+#define KEY_MODE         0x175
+#define KEY_KEYBOARD     0x176
+#define KEY_SCREEN       0x177
+#define KEY_PC           0x178
+#define KEY_TV           0x179
+#define KEY_TV2          0x17a
+#define KEY_VCR          0x17b
+#define KEY_VCR2         0x17c
+#define KEY_SAT          0x17d
+#define KEY_SAT2         0x17e
+#define KEY_CD           0x17f
+#define KEY_TAPE         0x180
+#define KEY_RADIO        0x181
+#define KEY_TUNER        0x182
+#define KEY_PLAYER       0x183
+#define KEY_TEXT         0x184
+#define KEY_DVD          0x185
+#define KEY_AUX          0x186
+#define KEY_MP3          0x187
+#define KEY_AUDIO        0x188
+#define KEY_VIDEO        0x189
+#define KEY_DIRECTORY    0x18a
+#define KEY_LIST         0x18b
+#define KEY_MEMO         0x18c
+#define KEY_CALENDAR     0x18d
+#define KEY_RED          0x18e
+#define KEY_GREEN        0x18f
+#define KEY_YELLOW       0x190
+#define KEY_BLUE         0x191
+#define KEY_CHANNELUP    0x192
+#define KEY_CHANNELDOWN  0x193
+#define KEY_FIRST        0x194
+#define KEY_LAST         0x195
+#define KEY_AB           0x196
+#define KEY_PLAY         0x197
+#define KEY_RESTART      0x198
+#define KEY_SLOW         0x199
+#define KEY_SHUFFLE      0x19a
+#define KEY_FASTFORWARD  0x19b
+#define KEY_PREVIOUS     0x19c
+#define KEY_NEXT         0x19d
+#define KEY_DIGITS       0x19e
+#define KEY_TEEN         0x19f
+#define KEY_TWEN         0x1a0
+#define KEY_BREAK        0x1a1
+#define KEY_TOPLEFT      0x1a2
+#define KEY_TOPRIGHT     0x1a3
+#define KEY_BOTTOMLEFT   0x1a4
+#define KEY_BOTTOMRIGHT  0x1a5
+
 #define BTN_MISC		0x100
 #define BTN_0			0x100
 #define BTN_1			0x101
diff -Naur linux-2.4.22.orig/include/video/fbcon.h linux-2.4.22.patched/include/video/fbcon.h
--- linux-2.4.22.orig/include/video/fbcon.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22.patched/include/video/fbcon.h	2004-02-15 16:40:28.000000000 +0100
@@ -95,6 +95,11 @@
     short yscroll;                  /* Hardware scrolling */
     unsigned char fgshift, bgshift;
     unsigned short charmask;        /* 0xff or 0x1ff */
+
+#ifdef CONFIG_FBCON_SHIFT
+    int shift_x;
+    int shift_y;
+#endif /* CONFIG_FBCON_SHIFT */
 };
 
 /* drivers/video/fbcon.c */
